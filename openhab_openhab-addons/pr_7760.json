{"pr_number": 7760, "pr_title": "[mqtt.homie] Improve Homie discovery time", "pr_author": "bodiroga", "pr_createdAt": "2020-05-24T01:31:54Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7760", "timeline": [{"oid": "ad39c5a88b4022e88f84860b6942254f95605d31", "url": "https://github.com/openhab/openhab-addons/commit/ad39c5a88b4022e88f84860b6942254f95605d31", "message": "Improve Homie discovery time\n\nSigned-off-by: Aitor Iturrioz <riturrioz@gmail.com>", "committedDate": "2020-05-24T00:53:04Z", "type": "commit"}, {"oid": "448fabecb685244507c50f6682d168a6022088cc", "url": "https://github.com/openhab/openhab-addons/commit/448fabecb685244507c50f6682d168a6022088cc", "message": "Fix javadoc\n\nSigned-off-by: Aitor Iturrioz <riturrioz@gmail.com>", "committedDate": "2020-05-24T01:36:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU5MzE0MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r429593141", "body": "Do you expect this method to be called concurrently?", "bodyText": "Do you expect this method to be called concurrently?", "bodyHTML": "<p dir=\"auto\">Do you expect this method to be called concurrently?</p>", "author": "cpmeister", "createdAt": "2020-05-24T02:25:48Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -56,18 +56,19 @@ public DelayedBatchProcessing(int delay, Consumer<List<T>> consumer, ScheduledEx\n     }\n \n     /**\n-     * Add new object to the batch process list. If the list was empty, the delay timer\n-     * is armed and all successive objects are accumulated from here on.\n+     * Add new object to the batch process list. Every time a new object is received,\n+     * the delay timer is rescheduled.\n      *\n      * @param t An object\n      */\n     @Override\n-    public void accept(T t) {\n+    synchronized public void accept(T t) {", "originalCommit": "448fabecb685244507c50f6682d168a6022088cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYyNDA2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r429624061", "bodyText": "Yes, sir, I have seen more than on scheduler been created with a single Homie device and I can't synchronize on the future field because it is nullable \ud83d\ude09", "author": "bodiroga", "createdAt": "2020-05-24T10:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU5MzE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTYyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r429671624", "body": "I can see a lot of potential concurrency issues around reassigning the future which mostly has to do with how this interacts with the other methods that cancel the future. I'm going to suggest a couple of changes which will make all of this thread-safe.\r\n\r\nFirst, create a utility method for cancelling the future:\r\n```\r\nprivate static void cancel(@Nullable Future<?> future){\r\n    Future<?> future = this.future;\r\n    if(future != null){\r\n        future.cancel(false);\r\n    }\r\n}\r\n```\r\nYou will notice I don't bother checking if it is done or not since nothing bad will happen if you try to cancel an already finished future.\r\n\r\nThen you will want to change \r\n`protected @Nullable ScheduledFuture<?> future;` \r\nto \r\n`protected final AtomicReference<@Nullable Future<?>> futureRef = new AtomicReference<>()`.\r\n\r\nThen when you just want to cancel the future you call `cancel(futureRef.getAndSet(null))`\r\nAnd when you want to schedule the future while canceling the old one you call `cancel(futureRef.getAndSet(executor.schedule(this::run, delay, TimeUnit.MILLISECONDS)));`\r\n\r\nA few of the other methods would also change slightly.\r\n```\r\n    /**\r\n     * Return true if there is a delayed processing going on.\r\n     */\r\n    public boolean isArmed() {\r\n        ScheduledFuture<?> scheduledFuture = this.futureRef.get();\r\n        return scheduledFuture != null && !scheduledFuture.isDone();\r\n    }\r\n```\r\n\r\nDoing all this will allow you to safely remove the `synchronized` you added to `accept` as well as making all sure all of your other code is interacting with your future in an atomic way. I think using an AtomicReference here is more performant and less error prone than trying to basically synchronize every method in this class. \r\n", "bodyText": "I can see a lot of potential concurrency issues around reassigning the future which mostly has to do with how this interacts with the other methods that cancel the future. I'm going to suggest a couple of changes which will make all of this thread-safe.\nFirst, create a utility method for cancelling the future:\nprivate static void cancel(@Nullable Future<?> future){\n    Future<?> future = this.future;\n    if(future != null){\n        future.cancel(false);\n    }\n}\n\nYou will notice I don't bother checking if it is done or not since nothing bad will happen if you try to cancel an already finished future.\nThen you will want to change\nprotected @Nullable ScheduledFuture<?> future;\nto\nprotected final AtomicReference<@Nullable Future<?>> futureRef = new AtomicReference<>().\nThen when you just want to cancel the future you call cancel(futureRef.getAndSet(null))\nAnd when you want to schedule the future while canceling the old one you call cancel(futureRef.getAndSet(executor.schedule(this::run, delay, TimeUnit.MILLISECONDS)));\nA few of the other methods would also change slightly.\n    /**\n     * Return true if there is a delayed processing going on.\n     */\n    public boolean isArmed() {\n        ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n        return scheduledFuture != null && !scheduledFuture.isDone();\n    }\n\nDoing all this will allow you to safely remove the synchronized you added to accept as well as making all sure all of your other code is interacting with your future in an atomic way. I think using an AtomicReference here is more performant and less error prone than trying to basically synchronize every method in this class.", "bodyHTML": "<p dir=\"auto\">I can see a lot of potential concurrency issues around reassigning the future which mostly has to do with how this interacts with the other methods that cancel the future. I'm going to suggest a couple of changes which will make all of this thread-safe.</p>\n<p dir=\"auto\">First, create a utility method for cancelling the future:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private static void cancel(@Nullable Future&lt;?&gt; future){\n    Future&lt;?&gt; future = this.future;\n    if(future != null){\n        future.cancel(false);\n    }\n}\"><pre><code>private static void cancel(@Nullable Future&lt;?&gt; future){\n    Future&lt;?&gt; future = this.future;\n    if(future != null){\n        future.cancel(false);\n    }\n}\n</code></pre></div>\n<p dir=\"auto\">You will notice I don't bother checking if it is done or not since nothing bad will happen if you try to cancel an already finished future.</p>\n<p dir=\"auto\">Then you will want to change<br>\n<code>protected @Nullable ScheduledFuture&lt;?&gt; future;</code><br>\nto<br>\n<code>protected final AtomicReference&lt;@Nullable Future&lt;?&gt;&gt; futureRef = new AtomicReference&lt;&gt;()</code>.</p>\n<p dir=\"auto\">Then when you just want to cancel the future you call <code>cancel(futureRef.getAndSet(null))</code><br>\nAnd when you want to schedule the future while canceling the old one you call <code>cancel(futureRef.getAndSet(executor.schedule(this::run, delay, TimeUnit.MILLISECONDS)));</code></p>\n<p dir=\"auto\">A few of the other methods would also change slightly.</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    /**\n     * Return true if there is a delayed processing going on.\n     */\n    public boolean isArmed() {\n        ScheduledFuture&lt;?&gt; scheduledFuture = this.futureRef.get();\n        return scheduledFuture != null &amp;&amp; !scheduledFuture.isDone();\n    }\"><pre><code>    /**\n     * Return true if there is a delayed processing going on.\n     */\n    public boolean isArmed() {\n        ScheduledFuture&lt;?&gt; scheduledFuture = this.futureRef.get();\n        return scheduledFuture != null &amp;&amp; !scheduledFuture.isDone();\n    }\n</code></pre></div>\n<p dir=\"auto\">Doing all this will allow you to safely remove the <code>synchronized</code> you added to <code>accept</code> as well as making all sure all of your other code is interacting with your future in an atomic way. I think using an AtomicReference here is more performant and less error prone than trying to basically synchronize every method in this class.</p>", "author": "cpmeister", "createdAt": "2020-05-24T20:22:58Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -56,18 +56,19 @@ public DelayedBatchProcessing(int delay, Consumer<List<T>> consumer, ScheduledEx\n     }\n \n     /**\n-     * Add new object to the batch process list. If the list was empty, the delay timer\n-     * is armed and all successive objects are accumulated from here on.\n+     * Add new object to the batch process list. Every time a new object is received,\n+     * the delay timer is rescheduled.\n      *\n      * @param t An object\n      */\n     @Override\n-    public void accept(T t) {\n+    synchronized public void accept(T t) {\n         queue.add(t);\n         final ScheduledFuture<?> scheduledFuture = this.future;\n-        if (scheduledFuture == null || scheduledFuture.isDone()) {\n-            this.future = executor.schedule(this::run, delay, TimeUnit.MILLISECONDS);\n+        if (scheduledFuture != null && !scheduledFuture.isDone()) {\n+            scheduledFuture.cancel(true);\n         }", "originalCommit": "448fabecb685244507c50f6682d168a6022088cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAwNTQ4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430005487", "bodyText": "Wow, thanks for the detailed instructions @cpmeister, I will add them \ud83d\udc4d  @jochen314, do you have anything to add? Do you agree with the proposed solution? I don't want to touch the DelayedBatchProccesing class without your approval \ud83d\ude09", "author": "bodiroga", "createdAt": "2020-05-25T16:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2MzI2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430063261", "bodyText": "I am 100% with @cpmeister here.\nPersonally I would even try a method like\nprivate boolean setNewFuture(ScheduledFuture<?> newFuture) {\n    Future<?> oldFuture = this.future.getAndSet(newFuture);\n    boolean result = true;\n    if(future != null){\n        result = future.isDone();\n        future.cancel(false);\n    }\n    return result;\n}\n\nAnd just one more thing:\nThere is the possibility that:\n\nThe future times out\nWe receive a new call to accept()\n\nDoes your caode then schedule another timeout-future?\nI think, this should not be done. That's why my proposed method returns, if the old future was already done, so we could use that, not to trigger a new timeout, once a timeout occured.", "author": "jochen314", "createdAt": "2020-05-25T20:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA5MDQxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430090413", "bodyText": "Hi @jochen314!\nFirst of all, many thanks for your message, it's good to see you here \ud83d\ude09 But... I don't understand what you mean with your last concerns.\n\nIf the future times out, that means that no new messages have arrived in X seconds, so the run method is called.\nA new call to accept() just reschedules the future, resetting the process.\n\nTo make things more clear, the current DelayedBatchProccesing class behavior is:\n\nThe first time the accept() method is called, the future timer is set and new objects are collected when accept() is triggered. After the delay time has passed, the run method is called.\n\nWith the proposed changes, the new behavior will be:\n\nThe first time the accept() method is called, the future timer is set, but it is rescheduled when a new object is accepted. The run method will be called only after delay seconds have passed since the last message.\n\nThe new logic ensures that discovery processes that take longer than initially anticipated can be completed successfully, as it was suggested in #5963 (comment). Perhaps I'm explaining something that is obvious, but I just wanted to avoid any misunderstanding.\nAnyway, tomorrow I will update the PR with the changes proposed by @cpmeister. Stay tuned!", "author": "bodiroga", "createdAt": "2020-05-25T22:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3MTYyNA=="}], "type": "inlineReview"}, {"oid": "448fabecb685244507c50f6682d168a6022088cc", "url": "https://github.com/openhab/openhab-addons/commit/448fabecb685244507c50f6682d168a6022088cc", "message": "Fix javadoc\n\nSigned-off-by: Aitor Iturrioz <riturrioz@gmail.com>", "committedDate": "2020-05-24T01:36:29Z", "type": "forcePushed"}, {"oid": "9bf26c28ed49750d6738fe1a122e9f2119b2227f", "url": "https://github.com/openhab/openhab-addons/commit/9bf26c28ed49750d6738fe1a122e9f2119b2227f", "message": "Replace 'synchronized' with AtomicReference\n\nSigned-off-by: Aitor Iturrioz <riturrioz@gmail.com>", "committedDate": "2020-05-26T17:30:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MDk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430640940", "body": "The AtomicReference handles your synchronization so you can remove the `synchronized` here\r\n```suggestion\r\n    public void accept(T t) {\r\n```", "bodyText": "The AtomicReference handles your synchronization so you can remove the synchronized here\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                synchronized public void accept(T t) {\n          \n          \n            \n                public void accept(T t) {", "bodyHTML": "<p dir=\"auto\">The AtomicReference handles your synchronization so you can remove the <code>synchronized</code> here</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k x x-first\">synchronized</span><span class=\"x x-last\"> </span><span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> accept(<span class=\"pl-smi\">T</span> t) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> accept(<span class=\"pl-smi\">T</span> t) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "cpmeister", "createdAt": "2020-05-26T19:04:00Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -56,18 +57,19 @@ public DelayedBatchProcessing(int delay, Consumer<List<T>> consumer, ScheduledEx\n     }\n \n     /**\n-     * Add new object to the batch process list. If the list was empty, the delay timer\n-     * is armed and all successive objects are accumulated from here on.\n+     * Add new object to the batch process list. Every time a new object is received,\n+     * the delay timer is rescheduled.\n      *\n      * @param t An object\n      */\n     @Override\n-    public void accept(T t) {\n+    synchronized public void accept(T t) {", "originalCommit": "9bf26c28ed49750d6738fe1a122e9f2119b2227f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY1MjAxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430652014", "bodyText": "In my defense, I can say that in the first push it was removed... \ud83e\udd26", "author": "bodiroga", "createdAt": "2020-05-26T19:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MTQ1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430641454", "body": "The cancel is already handled in the next statement. So you can remove this logic.\r\n```suggestion\r\n```", "bodyText": "The cancel is already handled in the next statement. So you can remove this logic.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n          \n          \n            \n                    if (scheduledFuture != null && !scheduledFuture.isDone()) {\n          \n          \n            \n                        cancel(futureRef.getAndSet(null));\n          \n          \n            \n                    }", "bodyHTML": "<p dir=\"auto\">The cancel is already handled in the next statement. So you can remove this logic.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">final</span> <span class=\"pl-k\">ScheduledFuture&lt;?&gt;</span> scheduledFuture <span class=\"pl-k\">=</span> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>futureRef<span class=\"pl-k\">.</span>get();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (scheduledFuture <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>scheduledFuture<span class=\"pl-k\">.</span>isDone()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            cancel(futureRef<span class=\"pl-k\">.</span>getAndSet(<span class=\"pl-c1\">null</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "cpmeister", "createdAt": "2020-05-26T19:05:02Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -56,18 +57,19 @@ public DelayedBatchProcessing(int delay, Consumer<List<T>> consumer, ScheduledEx\n     }\n \n     /**\n-     * Add new object to the batch process list. If the list was empty, the delay timer\n-     * is armed and all successive objects are accumulated from here on.\n+     * Add new object to the batch process list. Every time a new object is received,\n+     * the delay timer is rescheduled.\n      *\n      * @param t An object\n      */\n     @Override\n-    public void accept(T t) {\n+    synchronized public void accept(T t) {\n         queue.add(t);\n-        final ScheduledFuture<?> scheduledFuture = this.future;\n-        if (scheduledFuture == null || scheduledFuture.isDone()) {\n-            this.future = executor.schedule(this::run, delay, TimeUnit.MILLISECONDS);\n+        final ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n+        if (scheduledFuture != null && !scheduledFuture.isDone()) {\n+            cancel(futureRef.getAndSet(null));\n         }", "originalCommit": "9bf26c28ed49750d6738fe1a122e9f2119b2227f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MjQ0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430642440", "body": "You can replace all this with just `cancel(futureRef.getAndSet(null));`", "bodyText": "You can replace all this with just cancel(futureRef.getAndSet(null));", "bodyHTML": "<p dir=\"auto\">You can replace all this with just <code>cancel(futureRef.getAndSet(null));</code></p>", "author": "cpmeister", "createdAt": "2020-05-26T19:06:49Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -76,9 +78,9 @@ public void accept(T t) {\n      * @return A list of accumulated objects\n      */\n     public List<T> join() {\n-        ScheduledFuture<?> scheduledFuture = this.future;\n+        ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n         if (scheduledFuture != null && !scheduledFuture.isDone()) {\n-            scheduledFuture.cancel(false);\n+            cancel(futureRef.getAndSet(null));\n         }", "originalCommit": "9bf26c28ed49750d6738fe1a122e9f2119b2227f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MzAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7760#discussion_r430643013", "body": "Same here, just replace all this with `cancel(futureRef.getAndSet(null));`.", "bodyText": "Same here, just replace all this with cancel(futureRef.getAndSet(null));.", "bodyHTML": "<p dir=\"auto\">Same here, just replace all this with <code>cancel(futureRef.getAndSet(null));</code>.</p>", "author": "cpmeister", "createdAt": "2020-05-26T19:07:51Z", "path": "bundles/org.openhab.binding.mqtt.generic/src/main/java/org/openhab/binding/mqtt/generic/tools/DelayedBatchProcessing.java", "diffHunk": "@@ -92,17 +94,17 @@ public void accept(T t) {\n      * Return true if there is a delayed processing going on.\n      */\n     public boolean isArmed() {\n-        ScheduledFuture<?> scheduledFuture = this.future;\n+        ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n         return scheduledFuture != null && !scheduledFuture.isDone();\n     }\n \n     /**\n      * Deliver queued items now to the target consumer.\n      */\n     public void forceProcessNow() {\n-        ScheduledFuture<?> scheduledFuture = this.future;\n+        ScheduledFuture<?> scheduledFuture = this.futureRef.get();\n         if (scheduledFuture != null && !scheduledFuture.isDone()) {\n-            scheduledFuture.cancel(false);\n+            cancel(futureRef.getAndSet(null));\n         }", "originalCommit": "9bf26c28ed49750d6738fe1a122e9f2119b2227f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59f4f160a4edbd364a69fdb380399eba0a31642a", "url": "https://github.com/openhab/openhab-addons/commit/59f4f160a4edbd364a69fdb380399eba0a31642a", "message": "Address review comments\n\nSigned-off-by: Aitor Iturrioz <riturrioz@gmail.com>", "committedDate": "2020-05-26T19:42:01Z", "type": "commit"}]}