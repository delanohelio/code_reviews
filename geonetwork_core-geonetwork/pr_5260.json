{"pr_number": 5260, "pr_title": "Review ServiceContext resource leak", "pr_createdAt": "2020-12-14T06:21:44Z", "pr_url": "https://github.com/geonetwork/core-geonetwork/pull/5260", "merge_commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "timeline": [{"oid": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "url": "https://github.com/geonetwork/core-geonetwork/commit/a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2020-12-14T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE5NjY0Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r542196646", "body": "This is pretty ugly coding, keeping a throwable in order to report back who called setAsThreadLocal() in case of future conflict (the approach may confuse debuggers configured to stop when a Throwable is created).", "bodyText": "This is pretty ugly coding, keeping a throwable in order to report back who called setAsThreadLocal() in case of future conflict (the approach may confuse debuggers configured to stop when a Throwable is created).", "bodyHTML": "<p dir=\"auto\">This is pretty ugly coding, keeping a throwable in order to report back who called setAsThreadLocal() in case of future conflict (the approach may confuse debuggers configured to stop when a Throwable is created).</p>", "author": "jodygarnett", "createdAt": "2020-12-14T08:31:35Z", "path": "core/src/main/java/jeeves/server/context/ServiceContext.java", "diffHunk": "@@ -115,10 +160,168 @@ public static ServiceContext get() {\n \n     /**\n      * Called to set the Service context for this thread and inherited threads.\n+     *\n+     * If you call this method you are responsible for thread context management and {@link #clearAsThreadLocal()}.\n+     * <pre>\n+     * try {\n+     *     context.setAsThreadLocal();\n+     * }\n+     * finally {\n+     *     context.clearAsThreadLocal();\n+     * }\n+     * </pre>\n      */\n     public void setAsThreadLocal() {\n+        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n+\n+        if( POLICY == ThreadLocalPolicy.DIRECT || check == null){\n+            // step one set thread local\n+            THREAD_LOCAL_INSTANCE.set(this);\n+            // step two ensure ApplicationContextHolder thread local kept in sync\n+            ApplicationContextHolder.set(this.getApplicationContext());\n+            // step three details on allocation\n+            allocation = new Throwable(\"ServiceContext allocated to thread\");", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/server/context/ServiceContext.java b/core/src/main/java/jeeves/server/context/ServiceContext.java\nindex f19bbe9db2..a64c2c7fb1 100644\n--- a/core/src/main/java/jeeves/server/context/ServiceContext.java\n+++ b/core/src/main/java/jeeves/server/context/ServiceContext.java\n", "chunk": "@@ -160,168 +115,10 @@ public class ServiceContext extends BasicContext {\n \n     /**\n      * Called to set the Service context for this thread and inherited threads.\n-     *\n-     * If you call this method you are responsible for thread context management and {@link #clearAsThreadLocal()}.\n-     * <pre>\n-     * try {\n-     *     context.setAsThreadLocal();\n-     * }\n-     * finally {\n-     *     context.clearAsThreadLocal();\n-     * }\n-     * </pre>\n      */\n     public void setAsThreadLocal() {\n-        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n-\n-        if( POLICY == ThreadLocalPolicy.DIRECT || check == null){\n-            // step one set thread local\n-            THREAD_LOCAL_INSTANCE.set(this);\n-            // step two ensure ApplicationContextHolder thread local kept in sync\n-            ApplicationContextHolder.set(this.getApplicationContext());\n-            // step three details on allocation\n-            allocation = new Throwable(\"ServiceContext allocated to thread\");\n-\n-            return;\n-        }\n-\n-        if (this == check) {\n-            String unexpected = \"Service \" + _service + \" Context: already in use for this thread\";\n-            if( allocation != null ){\n-                // details on prior allocation\n-                unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n-            }\n-            // step one set thread local\n-            // (already done)\n-            // step two ensure ApplicationContextHolder thread local kept in sync\n-            if( ApplicationContextHolder.get() != null ){\n-                ApplicationContextHolder.clear();\n-            }\n-            ApplicationContextHolder.set(this.getApplicationContext());\n-            // step three detail on re-allocation\n-            allocation = new Throwable(\"ServiceContext allocated to thread\");\n-\n-            unexpected += \"\\n\\tService '\"+_service+\"' allocate: \" + allocation.getStackTrace()[1];\n-            checkUnexpectedState( unexpected );\n-            return;\n-        }\n-\n-        // thread being recycled or reused for new service context\n-        //\n-        THREAD_LOCAL_INSTANCE.remove();\n-\n-        String unexpected = \"Service \" + _service + \" Context: Clearing prior service context \" + check._service;\n-        if( check.allocation != null ){\n-            // details on prior allocation\n-            unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n-        }\n-\n-        // step one set thread local\n         THREAD_LOCAL_INSTANCE.set(this);\n-        // step two ensure ApplicationContextHolder thread local kept in sync\n-        if( ApplicationContextHolder.get() != null ){\n-            ApplicationContextHolder.clear();\n-        }\n         ApplicationContextHolder.set(this.getApplicationContext());\n-        // step three detail on present re-allocation\n-        allocation = new Throwable(\"ServiceContext allocated to thread\");\n-\n-        unexpected += \"\\n\\tService '\"+_service+\"' allocate: \" + allocation.getStackTrace()[1];\n-        checkUnexpectedState( unexpected );\n-    }\n-\n-    /** Log or raise exception based on {@link POLICY} */\n-    public void checkUnexpectedState( String unexpected ){\n-        if( unexpected == null ){\n-            return; // nothing unexpected to report\n-        }\n-        switch( POLICY ){\n-            case DIRECT:\n-                break; // ignore\n-            case TRACE:\n-                debug(unexpected);\n-                break;\n-            case STRICT:\n-                throw new IllegalStateException(unexpected);\n-        }\n-    }\n-\n-    /**\n-     * Called to clear the Service context for this thread and inherited threads.\n-     *\n-     * In general code that creates ServiceContext is responsible thread management and any cleanup:\n-     * <pre>\n-     * try {\n-     *     context.setAsThreadLocal();\n-     * }\n-     * finally {\n-     *     context.clearAsThreadLocal();\n-     * }\n-     * </pre>\n-     */\n-    public void clearAsThreadLocal() {\n-        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n-\n-        // clean up thread local\n-        if( POLICY == ThreadLocalPolicy.DIRECT){\n-            if( check != null ){\n-                check.allocation = null;\n-                check = null;\n-            }\n-            THREAD_LOCAL_INSTANCE.remove();\n-            allocation = null;\n-            // ApplicationContextHolder.clear();\n-            return;\n-        }\n-        if( check == null ){\n-            String unexpected = \"ServiceContext \"+_service+\" clearAsThreadLocal: '\"+_service+\"' unexpected state, thread local already cleared\";\n-            if( allocation != null ){\n-                unexpected += \"\\n\\tContext '\"+_service+\"' allocation: \" + allocation.getStackTrace()[1];\n-            }\n-            allocation = null;\n-            // ApplicationContextHolder.clear();\n-            checkUnexpectedState( unexpected );\n-            return;\n-        }\n-        if (check == this){\n-            THREAD_LOCAL_INSTANCE.remove();\n-            allocation = null;\n-            // ApplicationContextHolder.clear();\n-            return;\n-        }\n-\n-        String unexpected = \"ServiceContext clearAsThreadLocal: \\\"+_service+\\\" unexpected state, thread local presently used by service context '\"+check._service+\"'\";\n-        if( check.allocation != null ){\n-            unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n-        }\n-        if( allocation != null ){\n-            unexpected += \"\\n\\tContext '\"+_service+\"' allocation: \" + allocation.getStackTrace()[1];\n-        }\n-        THREAD_LOCAL_INSTANCE.remove();\n-        allocation = null;\n-        // ApplicationContextHolder.clear();\n-        if( ApplicationContextHolder.get() != null && ApplicationContextHolder.get() != getApplicationContext() ){\n-            unexpected += \"\\n\\tApplicationContext '\"+ApplicationContextHolder.get().getApplicationName()+\"' conflict detected\";\n-            unexpected += \"\\n\\tApplicationContext '\"+getApplicationContext().getApplicationName()+\"' expected\";\n-            ApplicationContextHolder.clear();\n-        }\n-        checkUnexpectedState( unexpected );\n-    }\n-\n-    /**\n-     * Release any resources tied up by this service context.\n-     */\n-    public void clear(){\n-        if( this._service != null) {\n-            this._service = null;\n-            this._headers = null;\n-            this._responseHeaders = null;\n-            this._servlet = null;\n-            this._userSession = null;\n-        }\n-        else {\n-            debug(\"Service unexpectedly cleared twice\");\n-        }\n     }\n \n     //--------------------------------------------------------------------------\n", "next_change": {"commit": "b8103a85dd637545b8ab5ef75f0c4b17bf745622", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/server/context/ServiceContext.java b/core/src/main/java/jeeves/server/context/ServiceContext.java\nindex a64c2c7fb1..f19bbe9db2 100644\n--- a/core/src/main/java/jeeves/server/context/ServiceContext.java\n+++ b/core/src/main/java/jeeves/server/context/ServiceContext.java\n", "chunk": "@@ -115,10 +160,168 @@ public class ServiceContext extends BasicContext {\n \n     /**\n      * Called to set the Service context for this thread and inherited threads.\n+     *\n+     * If you call this method you are responsible for thread context management and {@link #clearAsThreadLocal()}.\n+     * <pre>\n+     * try {\n+     *     context.setAsThreadLocal();\n+     * }\n+     * finally {\n+     *     context.clearAsThreadLocal();\n+     * }\n+     * </pre>\n      */\n     public void setAsThreadLocal() {\n+        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n+\n+        if( POLICY == ThreadLocalPolicy.DIRECT || check == null){\n+            // step one set thread local\n+            THREAD_LOCAL_INSTANCE.set(this);\n+            // step two ensure ApplicationContextHolder thread local kept in sync\n+            ApplicationContextHolder.set(this.getApplicationContext());\n+            // step three details on allocation\n+            allocation = new Throwable(\"ServiceContext allocated to thread\");\n+\n+            return;\n+        }\n+\n+        if (this == check) {\n+            String unexpected = \"Service \" + _service + \" Context: already in use for this thread\";\n+            if( allocation != null ){\n+                // details on prior allocation\n+                unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n+            }\n+            // step one set thread local\n+            // (already done)\n+            // step two ensure ApplicationContextHolder thread local kept in sync\n+            if( ApplicationContextHolder.get() != null ){\n+                ApplicationContextHolder.clear();\n+            }\n+            ApplicationContextHolder.set(this.getApplicationContext());\n+            // step three detail on re-allocation\n+            allocation = new Throwable(\"ServiceContext allocated to thread\");\n+\n+            unexpected += \"\\n\\tService '\"+_service+\"' allocate: \" + allocation.getStackTrace()[1];\n+            checkUnexpectedState( unexpected );\n+            return;\n+        }\n+\n+        // thread being recycled or reused for new service context\n+        //\n+        THREAD_LOCAL_INSTANCE.remove();\n+\n+        String unexpected = \"Service \" + _service + \" Context: Clearing prior service context \" + check._service;\n+        if( check.allocation != null ){\n+            // details on prior allocation\n+            unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n+        }\n+\n+        // step one set thread local\n         THREAD_LOCAL_INSTANCE.set(this);\n+        // step two ensure ApplicationContextHolder thread local kept in sync\n+        if( ApplicationContextHolder.get() != null ){\n+            ApplicationContextHolder.clear();\n+        }\n         ApplicationContextHolder.set(this.getApplicationContext());\n+        // step three detail on present re-allocation\n+        allocation = new Throwable(\"ServiceContext allocated to thread\");\n+\n+        unexpected += \"\\n\\tService '\"+_service+\"' allocate: \" + allocation.getStackTrace()[1];\n+        checkUnexpectedState( unexpected );\n+    }\n+\n+    /** Log or raise exception based on {@link POLICY} */\n+    public void checkUnexpectedState( String unexpected ){\n+        if( unexpected == null ){\n+            return; // nothing unexpected to report\n+        }\n+        switch( POLICY ){\n+            case DIRECT:\n+                break; // ignore\n+            case TRACE:\n+                debug(unexpected);\n+                break;\n+            case STRICT:\n+                throw new IllegalStateException(unexpected);\n+        }\n+    }\n+\n+    /**\n+     * Called to clear the Service context for this thread and inherited threads.\n+     *\n+     * In general code that creates ServiceContext is responsible thread management and any cleanup:\n+     * <pre>\n+     * try {\n+     *     context.setAsThreadLocal();\n+     * }\n+     * finally {\n+     *     context.clearAsThreadLocal();\n+     * }\n+     * </pre>\n+     */\n+    public void clearAsThreadLocal() {\n+        ServiceContext check = THREAD_LOCAL_INSTANCE.get();\n+\n+        // clean up thread local\n+        if( POLICY == ThreadLocalPolicy.DIRECT){\n+            if( check != null ){\n+                check.allocation = null;\n+                check = null;\n+            }\n+            THREAD_LOCAL_INSTANCE.remove();\n+            allocation = null;\n+            // ApplicationContextHolder.clear();\n+            return;\n+        }\n+        if( check == null ){\n+            String unexpected = \"ServiceContext \"+_service+\" clearAsThreadLocal: '\"+_service+\"' unexpected state, thread local already cleared\";\n+            if( allocation != null ){\n+                unexpected += \"\\n\\tContext '\"+_service+\"' allocation: \" + allocation.getStackTrace()[1];\n+            }\n+            allocation = null;\n+            // ApplicationContextHolder.clear();\n+            checkUnexpectedState( unexpected );\n+            return;\n+        }\n+        if (check == this){\n+            THREAD_LOCAL_INSTANCE.remove();\n+            allocation = null;\n+            // ApplicationContextHolder.clear();\n+            return;\n+        }\n+\n+        String unexpected = \"ServiceContext clearAsThreadLocal: \\\"+_service+\\\" unexpected state, thread local presently used by service context '\"+check._service+\"'\";\n+        if( check.allocation != null ){\n+            unexpected += \"\\n\\tContext '\"+check._service+\"' conflict: \" + check.allocation.getStackTrace()[1];\n+        }\n+        if( allocation != null ){\n+            unexpected += \"\\n\\tContext '\"+_service+\"' allocation: \" + allocation.getStackTrace()[1];\n+        }\n+        THREAD_LOCAL_INSTANCE.remove();\n+        allocation = null;\n+        // ApplicationContextHolder.clear();\n+        if( ApplicationContextHolder.get() != null && ApplicationContextHolder.get() != getApplicationContext() ){\n+            unexpected += \"\\n\\tApplicationContext '\"+ApplicationContextHolder.get().getApplicationName()+\"' conflict detected\";\n+            unexpected += \"\\n\\tApplicationContext '\"+getApplicationContext().getApplicationName()+\"' expected\";\n+            ApplicationContextHolder.clear();\n+        }\n+        checkUnexpectedState( unexpected );\n+    }\n+\n+    /**\n+     * Release any resources tied up by this service context.\n+     */\n+    public void clear(){\n+        if( this._service != null) {\n+            this._service = null;\n+            this._headers = null;\n+            this._responseHeaders = null;\n+            this._servlet = null;\n+            this._userSession = null;\n+        }\n+        else {\n+            debug(\"Service unexpectedly cleared twice\");\n+        }\n     }\n \n     //--------------------------------------------------------------------------\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701753", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:20:59Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NzQzNQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547047435", "bodyText": "I did not change any logic here, however I can can see how would be used ... if an exception is thrown during doRollback then the catch Throwable t on line 126 would wish to check this flag.", "author": "jodygarnett", "createdAt": "2020-12-22T03:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDE0Nw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090147", "bodyText": "Added debug messages to mimic the kind of checks I was performing with the debugger.", "author": "jodygarnett", "createdAt": "2020-12-22T06:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701858", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:21:13Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                if (!rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTA0OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051049", "bodyText": "You are correct, this I think is the last one. I would leave it as written:\na) To be be clear of rollBack state (setting with try/finally after each call to doRollback\nb) This way you can put a breakpoint in a debugger, or add more logic after this catch and be clear what is going on....\nA more interesting question, if you look at the previous logic, should I set rolledBack = true before calling the doRollback method?", "author": "jodygarnett", "createdAt": "2020-12-22T03:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -73,93 +85,93 @@ public class TransactionManager {\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n-\n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n-            }\n+            return action.doInTransaction(status);\n \n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                if (readOnly) {\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n             }\n-        }\n-\n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n-        return result;\n+\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n \n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n         try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n+            fireBeforeCommit(context, transactionManager, status);\n         }\n         catch( Throwable t ){\n             Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n         }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n         try {\n-            transactionManager.commit(transaction);\n+            transactionManager.commit(status);\n         }\n         finally {\n             try {\n-                fireAfterCommit(context, transactionManager, transaction);\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n             }\n             catch( Throwable t) {\n                 Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701959", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:21:27Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MDQ4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547050484", "bodyText": "See line 126, we are trying to prevent duplicate rollback.\nAside: Trying for minimal change the previous tested logic. With more time I would refactor into multiple methods to clearly document what each branch of logic is trying to do etc...", "author": "jodygarnett", "createdAt": "2020-12-22T03:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546702884", "body": "Is the intention that the code continues?", "bodyText": "Is the intention that the code continues?", "bodyHTML": "<p dir=\"auto\">Is the intention that the code continues?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:23:32Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n+        if ( transaction == null || transaction.isCompleted()){\n+            // nothing to do", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTQ2NQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051465", "bodyText": "no, reading the previous logic I should have a return. Idea was to change the check to be postive, general principle to improve legibility.", "author": "jodygarnett", "createdAt": "2020-12-22T03:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -148,157 +113,42 @@ public class TransactionManager {\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-        try {\n-            transactionManager.commit(transaction);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, transaction);\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    private static void fireNewTransaction(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n-            }\n-        }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n-    }\n-\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                    PlatformTransactionManager transactionManager,\n-                                    @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n-\n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n-        }\n-    }\n-\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n-\n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n-        }\n-    }\n-\n-\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n-        if ( transaction == null || transaction.isCompleted()){\n-            // nothing to do\n-        }\n         try {\n-            fireBeforeRollback( context, transactionManager, transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, transaction);\n-            }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n+                }\n             }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546704372", "body": "In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.", "bodyText": "In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.", "bodyHTML": "<p dir=\"auto\">In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:26:26Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0OTc1Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547049756", "bodyText": "Yes that was my intension, trying to read the code and check the listener api contracts and make the application more predictable.\nThere was nothing explicit in the api about allowing listeners to halt the notification process (sometimes in core java api listeners are allowed to return \"true\" if they have addressed an event to prevent further processing).", "author": "jodygarnett", "createdAt": "2020-12-22T03:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -148,157 +113,42 @@ public class TransactionManager {\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-        try {\n-            transactionManager.commit(transaction);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, transaction);\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    private static void fireNewTransaction(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n-            }\n-        }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n-    }\n-\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                    PlatformTransactionManager transactionManager,\n-                                    @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n-\n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n-        }\n-    }\n-\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n-\n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n-        }\n-    }\n-\n-\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n-        if ( transaction == null || transaction.isCompleted()){\n-            // nothing to do\n-        }\n         try {\n-            fireBeforeRollback( context, transactionManager, transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, transaction);\n-            }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n+                }\n             }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546707394", "body": "To confirm no need to call `_context.clear()` as this code runs in a custom thread?", "bodyText": "To confirm no need to call _context.clear() as this code runs in a custom thread?", "bodyHTML": "<p dir=\"auto\">To confirm no need to call <code>_context.clear()</code> as this code runs in a custom thread?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:32:47Z", "path": "core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java", "diffHunk": "@@ -125,6 +125,7 @@ public void run() {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n+            _context.clearAsThreadLocal();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1OTM3NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547059374", "bodyText": "This may be a case where a task is sharing a context, so calling clear() breaks another task.\nLong term it may be smart to implement reference counting, or a context wrapper, when providing the same context to more than one thread.", "author": "jodygarnett", "createdAt": "2020-12-22T04:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex df51151304..5cbcf19bc2 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -125,7 +125,6 @@ public final class IndexMetadataTask implements Runnable {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n-            _context.clearAsThreadLocal();\n         }\n     }\n }\n", "next_change": {"commit": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex 5cbcf19bc2..df51151304 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -125,6 +125,7 @@ public final class IndexMetadataTask implements Runnable {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n+            _context.clearAsThreadLocal();\n         }\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546708616", "body": "I see some code in the API package creating a `ServiceContext`, but not calling the `clear` method at the end (for example: https://github.com/geonetwork/core-geonetwork/blob/23910ced1b727319d099960b02020e789c226d5c/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java#L189-L258)\r\n\r\nIs this due to the way of creating the `ServiceContext` (`serviceManager.createServiceContext` vs `ApiUtils.createServiceContext`)?", "bodyText": "I see some code in the API package creating a ServiceContext, but not calling the clear method at the end (for example: \n  \n    \n      core-geonetwork/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java\n    \n    \n        Lines 189 to 258\n      in\n      23910ce\n    \n    \n    \n    \n\n        \n          \n           public void getGroupLogo( \n        \n\n        \n          \n               @ApiParam(value = \"Group identifier\", required = true) @PathVariable(value = \"groupId\") final Integer groupId, \n        \n\n        \n          \n               @ApiIgnore final WebRequest webRequest, \n        \n\n        \n          \n               HttpServletRequest request, \n        \n\n        \n          \n               HttpServletResponse response) throws ResourceNotFoundException { \n        \n\n        \n          \n            \n        \n\n        \n          \n               Locale locale = languageUtils.parseAcceptLanguage(request.getLocales()); \n        \n\n        \n          \n            \n        \n\n        \n          \n               ApplicationContext context = ApplicationContextHolder.get(); \n        \n\n        \n          \n               ServiceContext serviceContext = ApiUtils.createServiceContext(request, locale.getISO3Country()); \n        \n\n        \n          \n               if (context == null) { \n        \n\n        \n          \n                   throw new RuntimeException(\"ServiceContext not available\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               Group group = groupRepository.findOne(groupId); \n        \n\n        \n          \n               if (group == null) { \n        \n\n        \n          \n                   throw new ResourceNotFoundException(messages.getMessage(\"api.groups.group_not_found\", new \n        \n\n        \n          \n                       Object[]{groupId}, locale)); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                   final Resources resources = context.getBean(Resources.class); \n        \n\n        \n          \n                   final String logoUUID = group.getLogo(); \n        \n\n        \n          \n                   if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                       try (Resources.ResourceHolder image = getImage(resources, serviceContext, group)){ \n        \n\n        \n          \n                           if (image != null) { \n        \n\n        \n          \n                               FileTime lastModifiedTime = image.getLastModifiedTime(); \n        \n\n        \n          \n                               response.setDateHeader(\"Expires\", System.currentTimeMillis() + SIX_HOURS * 1000L); \n        \n\n        \n          \n                               if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                                   // webRequest.checkNotModified sets the right HTTP headers \n        \n\n        \n          \n                                   return; \n        \n\n        \n          \n                               } \n        \n\n        \n          \n                               response.setContentType(AttachmentsApi.getFileContentType(image.getPath())); \n        \n\n        \n          \n                               response.setContentLength((int) Files.size(image.getPath())); \n        \n\n        \n          \n                               response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                               FileUtils.copyFile(image.getPath().toFile(), response.getOutputStream()); \n        \n\n        \n          \n                               return; \n        \n\n        \n          \n                           } \n        \n\n        \n          \n                       } \n        \n\n        \n          \n                   } \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // no logo image found. Return a transparent 1x1 png \n        \n\n        \n          \n                   FileTime lastModifiedTime = FileTime.fromMillis(0); \n        \n\n        \n          \n                   if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                       return; \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   response.setContentType(\"image/png\"); \n        \n\n        \n          \n                   response.setContentLength(TRANSPARENT_1_X_1_PNG.length); \n        \n\n        \n          \n                   response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                   response.getOutputStream().write(TRANSPARENT_1_X_1_PNG); \n        \n\n        \n          \n            \n        \n\n        \n          \n               } catch (IOException e) { \n        \n\n        \n          \n                   Log.error(LOGGER, String.format(\"There was an error accessing the logo of the group with id '%d'\", \n        \n\n        \n          \n                       groupId)); \n        \n\n        \n          \n                   throw new RuntimeException(e); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           private static Resources.ResourceHolder getImage(Resources resources, ServiceContext serviceContext, Group group) throws IOException { \n        \n\n        \n          \n               final Path logosDir = resources.locateLogosDir(serviceContext); \n        \n\n        \n          \n               final Path harvesterLogosDir = resources.locateHarvesterLogosDir(serviceContext); \n        \n\n        \n          \n               final String logoUUID = group.getLogo(); \n        \n\n        \n          \n               Resources.ResourceHolder image = null; \n        \n\n        \n          \n               if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                   image = resources.getImage(serviceContext, logoUUID, logosDir); \n        \n\n        \n          \n                   if (image == null) { \n        \n\n        \n          \n                       image = resources.getImage(serviceContext, logoUUID, harvesterLogosDir); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return image; \n        \n\n        \n          \n           } \n        \n    \n  \n\n)\nIs this due to the way of creating the ServiceContext (serviceManager.createServiceContext vs ApiUtils.createServiceContext)?", "bodyHTML": "<p dir=\"auto\">I see some code in the API package creating a <code>ServiceContext</code>, but not calling the <code>clear</code> method at the end (for example: <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/geonetwork/core-geonetwork/blob/23910ced1b727319d099960b02020e789c226d5c/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java#L189-L258\">core-geonetwork/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 189 to 258\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/geonetwork/core-geonetwork/commit/23910ced1b727319d099960b02020e789c226d5c\">23910ce</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L189\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"189\"></td>\n          <td id=\"LC189\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">getGroupLogo</span>( </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L190\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"190\"></td>\n          <td id=\"LC190\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">@ApiParam</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Group identifier<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">required</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>) <span class=\"pl-k\">@PathVariable</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>groupId<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-v\">groupId</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L191\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"191\"></td>\n          <td id=\"LC191\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">@ApiIgnore</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">WebRequest</span> <span class=\"pl-v\">webRequest</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L192\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"192\"></td>\n          <td id=\"LC192\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">HttpServletRequest</span> <span class=\"pl-v\">request</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L193\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"193\"></td>\n          <td id=\"LC193\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">HttpServletResponse</span> <span class=\"pl-v\">response</span>) <span class=\"pl-k\">throws</span> <span class=\"pl-smi\">ResourceNotFoundException</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L194\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"194\"></td>\n          <td id=\"LC194\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L195\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"195\"></td>\n          <td id=\"LC195\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Locale</span> locale <span class=\"pl-k\">=</span> languageUtils<span class=\"pl-k\">.</span>parseAcceptLanguage(request<span class=\"pl-k\">.</span>getLocales()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L196\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"196\"></td>\n          <td id=\"LC196\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L197\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"197\"></td>\n          <td id=\"LC197\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">ApplicationContext</span> context <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ApplicationContextHolder</span><span class=\"pl-k\">.</span>get(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L198\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"198\"></td>\n          <td id=\"LC198\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">ServiceContext</span> serviceContext <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ApiUtils</span><span class=\"pl-k\">.</span>createServiceContext(request, locale<span class=\"pl-k\">.</span>getISO3Country()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L199\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"199\"></td>\n          <td id=\"LC199\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (context <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L200\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"200\"></td>\n          <td id=\"LC200\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RuntimeException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ServiceContext not available<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L201\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"201\"></td>\n          <td id=\"LC201\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L202\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"202\"></td>\n          <td id=\"LC202\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L203\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"203\"></td>\n          <td id=\"LC203\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Group</span> group <span class=\"pl-k\">=</span> groupRepository<span class=\"pl-k\">.</span>findOne(groupId); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L204\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"204\"></td>\n          <td id=\"LC204\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (group <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L205\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"205\"></td>\n          <td id=\"LC205\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ResourceNotFoundException</span>(messages<span class=\"pl-k\">.</span>getMessage(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>api.groups.group_not_found<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-k\">new</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L206\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"206\"></td>\n          <td id=\"LC206\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-smi\">Object</span>[]{groupId}, locale)); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L207\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"207\"></td>\n          <td id=\"LC207\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L208\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"208\"></td>\n          <td id=\"LC208\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">try</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L209\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"209\"></td>\n          <td id=\"LC209\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Resources</span> resources <span class=\"pl-k\">=</span> context<span class=\"pl-k\">.</span>getBean(<span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span>class); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L210\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"210\"></td>\n          <td id=\"LC210\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> logoUUID <span class=\"pl-k\">=</span> group<span class=\"pl-k\">.</span>getLogo(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L211\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"211\"></td>\n          <td id=\"LC211\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>isNotBlank(logoUUID) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>http://<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>https//<span class=\"pl-pds\">\"</span></span>)) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L212\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"212\"></td>\n          <td id=\"LC212\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">ResourceHolder</span> image <span class=\"pl-k\">=</span> getImage(resources, serviceContext, group)){ </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L213\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"213\"></td>\n          <td id=\"LC213\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                 <span class=\"pl-k\">if</span> (image <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L214\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"214\"></td>\n          <td id=\"LC214\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-smi\">FileTime</span> lastModifiedTime <span class=\"pl-k\">=</span> image<span class=\"pl-k\">.</span>getLastModifiedTime(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L215\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"215\"></td>\n          <td id=\"LC215\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setDateHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Expires<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>currentTimeMillis() <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">1000L</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L216\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"216\"></td>\n          <td id=\"LC216\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-k\">if</span> (webRequest<span class=\"pl-k\">.</span>checkNotModified(lastModifiedTime<span class=\"pl-k\">.</span>toMillis())) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L217\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"217\"></td>\n          <td id=\"LC217\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                         <span class=\"pl-c\"><span class=\"pl-c\">//</span> webRequest.checkNotModified sets the right HTTP headers</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L218\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"218\"></td>\n          <td id=\"LC218\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                         <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L219\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"219\"></td>\n          <td id=\"LC219\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L220\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"220\"></td>\n          <td id=\"LC220\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setContentType(<span class=\"pl-smi\">AttachmentsApi</span><span class=\"pl-k\">.</span>getFileContentType(image<span class=\"pl-k\">.</span>getPath())); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L221\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"221\"></td>\n          <td id=\"LC221\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setContentLength((<span class=\"pl-k\">int</span>) <span class=\"pl-smi\">Files</span><span class=\"pl-k\">.</span>size(image<span class=\"pl-k\">.</span>getPath())); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L222\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"222\"></td>\n          <td id=\"LC222\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>addHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cache-Control<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>max-age=<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, public<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L223\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"223\"></td>\n          <td id=\"LC223\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-smi\">FileUtils</span><span class=\"pl-k\">.</span>copyFile(image<span class=\"pl-k\">.</span>getPath()<span class=\"pl-k\">.</span>toFile(), response<span class=\"pl-k\">.</span>getOutputStream()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L224\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"224\"></td>\n          <td id=\"LC224\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L225\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"225\"></td>\n          <td id=\"LC225\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                 } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L226\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"226\"></td>\n          <td id=\"LC226\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L227\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"227\"></td>\n          <td id=\"LC227\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L228\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"228\"></td>\n          <td id=\"LC228\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L229\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"229\"></td>\n          <td id=\"LC229\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-c\"><span class=\"pl-c\">//</span> no logo image found. Return a transparent 1x1 png</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L230\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"230\"></td>\n          <td id=\"LC230\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-smi\">FileTime</span> lastModifiedTime <span class=\"pl-k\">=</span> <span class=\"pl-smi\">FileTime</span><span class=\"pl-k\">.</span>fromMillis(<span class=\"pl-c1\">0</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L231\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"231\"></td>\n          <td id=\"LC231\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (webRequest<span class=\"pl-k\">.</span>checkNotModified(lastModifiedTime<span class=\"pl-k\">.</span>toMillis())) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L232\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"232\"></td>\n          <td id=\"LC232\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L233\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"233\"></td>\n          <td id=\"LC233\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L234\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"234\"></td>\n          <td id=\"LC234\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>setContentType(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>image/png<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L235\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"235\"></td>\n          <td id=\"LC235\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>setContentLength(<span class=\"pl-c1\">TRANSPARENT_1_X_1_PNG</span><span class=\"pl-k\">.</span>length); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L236\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"236\"></td>\n          <td id=\"LC236\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>addHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cache-Control<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>max-age=<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, public<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L237\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"237\"></td>\n          <td id=\"LC237\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>getOutputStream()<span class=\"pl-k\">.</span>write(<span class=\"pl-c1\">TRANSPARENT_1_X_1_PNG</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L238\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"238\"></td>\n          <td id=\"LC238\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L239\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"239\"></td>\n          <td id=\"LC239\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">IOException</span> e) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L240\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"240\"></td>\n          <td id=\"LC240\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-smi\">Log</span><span class=\"pl-k\">.</span>error(<span class=\"pl-c1\">LOGGER</span>, <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>There was an error accessing the logo of the group with id '%d'<span class=\"pl-pds\">\"</span></span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L241\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"241\"></td>\n          <td id=\"LC241\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             groupId)); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L242\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"242\"></td>\n          <td id=\"LC242\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RuntimeException</span>(e); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L243\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"243\"></td>\n          <td id=\"LC243\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L244\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"244\"></td>\n          <td id=\"LC244\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L245\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"245\"></td>\n          <td id=\"LC245\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L246\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"246\"></td>\n          <td id=\"LC246\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">Resources</span>.<span class=\"pl-smi\">ResourceHolder</span> <span class=\"pl-en\">getImage</span>(<span class=\"pl-smi\">Resources</span> <span class=\"pl-v\">resources</span>, <span class=\"pl-smi\">ServiceContext</span> <span class=\"pl-v\">serviceContext</span>, <span class=\"pl-smi\">Group</span> <span class=\"pl-v\">group</span>) <span class=\"pl-k\">throws</span> <span class=\"pl-smi\">IOException</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L247\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"247\"></td>\n          <td id=\"LC247\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Path</span> logosDir <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>locateLogosDir(serviceContext); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L248\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"248\"></td>\n          <td id=\"LC248\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Path</span> harvesterLogosDir <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>locateHarvesterLogosDir(serviceContext); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L249\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"249\"></td>\n          <td id=\"LC249\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> logoUUID <span class=\"pl-k\">=</span> group<span class=\"pl-k\">.</span>getLogo(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L250\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"250\"></td>\n          <td id=\"LC250\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">ResourceHolder</span> image <span class=\"pl-k\">=</span> <span class=\"pl-c1\">null</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L251\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"251\"></td>\n          <td id=\"LC251\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>isNotBlank(logoUUID) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>http://<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>https//<span class=\"pl-pds\">\"</span></span>)) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L252\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"252\"></td>\n          <td id=\"LC252\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         image <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>getImage(serviceContext, logoUUID, logosDir); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L253\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"253\"></td>\n          <td id=\"LC253\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (image <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L254\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"254\"></td>\n          <td id=\"LC254\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             image <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>getImage(serviceContext, logoUUID, harvesterLogosDir); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L255\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"255\"></td>\n          <td id=\"LC255\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L256\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"256\"></td>\n          <td id=\"LC256\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L257\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"257\"></td>\n          <td id=\"LC257\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> image; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L258\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"258\"></td>\n          <td id=\"LC258\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n)</p>\n<p dir=\"auto\">Is this due to the way of creating the <code>ServiceContext</code> (<code>serviceManager.createServiceContext</code> vs <code>ApiUtils.createServiceContext</code>)?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:35:13Z", "path": "services/src/main/java/org/fao/geonet/api/records/formatters/Register.java", "diffHunk": "@@ -145,6 +145,7 @@ public JSONObject serviceSpecificExec(HttpServletRequest request,\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n+            context.clear();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5NDk0MA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547094940", "bodyText": "I expect more instances of clear() can be added over time, especially if you can confirm how it is used.", "author": "jodygarnett", "createdAt": "2020-12-22T06:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 8dfc52b306..26bdbb31ec 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -145,7 +145,6 @@ public class Register extends AbstractFormatService {\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n-            context.clear();\n         }\n     }\n \n", "next_change": {"commit": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 26bdbb31ec..510923b4ee 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -146,6 +147,9 @@ public class Register extends AbstractFormatService {\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n         }\n+      } finally {\n+        context.clear();\n+      }\n     }\n \n     private Path findViewXslContainerDir(Path dir) throws IOException {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546709358", "body": "This code seem more for testing?", "bodyText": "This code seem more for testing?", "bodyHTML": "<p dir=\"auto\">This code seem more for testing?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:36:42Z", "path": "web/src/main/java/org/fao/geonet/GeonetworkHttpSessionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+//=============================================================================\n+//===\tCopyright (C) 2001-2007 Food and Agriculture Organization of the\n+//===\tUnited Nations (FAO-UN), United Nations World Food Programme (WFP)\n+//===\tand United Nations Environment Programme (UNEP)\n+//===\n+//===\tThis program is free software; you can redistribute it and/or modify\n+//===\tit under the terms of the GNU General Public License as published by\n+//===\tthe Free Software Foundation; either version 2 of the License, or (at\n+//===\tyour option) any later version.\n+//===\n+//===\tThis program is distributed in the hope that it will be useful, but\n+//===\tWITHOUT ANY WARRANTY; without even the implied warranty of\n+//===\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+//===\tGeneral Public License for more details.\n+//===\n+//===\tYou should have received a copy of the GNU General Public License\n+//===\talong with this program; if not, write to the Free Software\n+//===\tFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+//===\n+//===\tContact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+//===\tRome - Italy. email: geonetwork@osgeo.org\n+//==============================================================================\n+package org.fao.geonet;\n+\n+import jeeves.config.springutil.JeevesApplicationContext;\n+import jeeves.constants.Jeeves;\n+import jeeves.server.UserSession;\n+import org.fao.geonet.utils.Log;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpSessionEvent;\n+import javax.servlet.http.HttpSessionListener;\n+import java.util.Enumeration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Used to keep track of the number of active sessions.\\\n+ */\n+public class GeonetworkHttpSessionListener implements HttpSessionListener {", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDQyMw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090423", "bodyText": "It produces debug log messages that can be enabled in the field if needed", "author": "jodygarnett", "createdAt": "2020-12-22T06:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "9cebf79164064053563624e367a26a52a109c387", "url": "https://github.com/geonetwork/core-geonetwork/commit/9cebf79164064053563624e367a26a52a109c387", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-01-05T20:20:07Z", "type": "forcePushed"}, {"oid": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "url": "https://github.com/geonetwork/core-geonetwork/commit/a908c404ad2563809a67a9ebe71a3ce507531ef7", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-01-08T15:35:37Z", "type": "forcePushed"}, {"oid": "28605f0b877e44ea7fe5c31661b094e160382973", "url": "https://github.com/geonetwork/core-geonetwork/commit/28605f0b877e44ea7fe5c31661b094e160382973", "message": "Add debug logging for HTTP session created / destroyed\n\nUsed to track potential service context leaks.", "committedDate": "2021-02-23T22:17:37Z", "type": "commit"}, {"oid": "b8103a85dd637545b8ab5ef75f0c4b17bf745622", "url": "https://github.com/geonetwork/core-geonetwork/commit/b8103a85dd637545b8ab5ef75f0c4b17bf745622", "message": "ServiceLocator API contract for setAsThreadLocal() / clearAsThreadLocal() / clear()\n\nDocument api contract with respect to clearing up thread local use.", "committedDate": "2021-02-23T22:17:55Z", "type": "commit"}, {"oid": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "url": "https://github.com/geonetwork/core-geonetwork/commit/fad3719aea04704cd7fee77b5d6333bc033a5f62", "message": "Introduce try / finally managmeent of ServiceContext", "committedDate": "2021-02-24T00:05:18Z", "type": "commit"}, {"oid": "210b97b3d149bc504475f0de966060190d3e1a42", "url": "https://github.com/geonetwork/core-geonetwork/commit/210b97b3d149bc504475f0de966060190d3e1a42", "message": "Clear XFrameOptionsFilter cache", "committedDate": "2021-02-24T00:08:28Z", "type": "commit"}, {"oid": "e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "url": "https://github.com/geonetwork/core-geonetwork/commit/e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T00:22:48Z", "type": "forcePushed"}, {"oid": "f98fb566bc604e5eb609a389b65889cd062b946b", "url": "https://github.com/geonetwork/core-geonetwork/commit/f98fb566bc604e5eb609a389b65889cd062b946b", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-02-24T05:14:25Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "forcePushed"}]}