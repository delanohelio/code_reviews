{"pr_number": 5260, "pr_title": "Review ServiceContext resource leak", "pr_author": "jodygarnett", "pr_createdAt": "2020-12-14T06:21:44Z", "pr_url": "https://github.com/geonetwork/core-geonetwork/pull/5260", "merge_commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "timeline": [{"oid": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "url": "https://github.com/geonetwork/core-geonetwork/commit/a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2020-12-14T06:57:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701753", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:20:59Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NzQzNQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547047435", "bodyText": "I did not change any logic here, however I can can see how would be used ... if an exception is thrown during doRollback then the catch Throwable t on line 126 would wish to check this flag.", "author": "jodygarnett", "createdAt": "2020-12-22T03:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDE0Nw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090147", "bodyText": "Added debug messages to mimic the kind of checks I was performing with the debugger.", "author": "jodygarnett", "createdAt": "2020-12-22T06:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -73,93 +85,93 @@ public class TransactionManager {\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n-\n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n-            }\n+            return action.doInTransaction(status);\n \n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                if (readOnly) {\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n             }\n-        }\n-\n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n-        return result;\n+\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n \n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n         try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n+            fireBeforeCommit(context, transactionManager, status);\n         }\n         catch( Throwable t ){\n             Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n         }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n         try {\n-            transactionManager.commit(transaction);\n+            transactionManager.commit(status);\n         }\n         finally {\n             try {\n-                fireAfterCommit(context, transactionManager, transaction);\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n             }\n             catch( Throwable t) {\n                 Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701858", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:21:13Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;\n+                        }\n+                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                if (!rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTA0OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051049", "bodyText": "You are correct, this I think is the last one. I would leave it as written:\na) To be be clear of rollBack state (setting with try/finally after each call to doRollback\nb) This way you can put a breakpoint in a debugger, or add more logic after this catch and be clear what is going on....\nA more interesting question, if you look at the previous logic, should I set rolledBack = true before calling the doRollback method?", "author": "jodygarnett", "createdAt": "2020-12-22T03:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -73,93 +85,93 @@ public class TransactionManager {\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n-\n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n-            }\n+            return action.doInTransaction(status);\n \n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                if (readOnly) {\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n             }\n-        }\n-\n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n-        return result;\n+\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n \n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n         try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n+            fireBeforeCommit(context, transactionManager, status);\n         }\n         catch( Throwable t ){\n             Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n         }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n         try {\n-            transactionManager.commit(transaction);\n+            transactionManager.commit(status);\n         }\n         finally {\n             try {\n-                fireAfterCommit(context, transactionManager, transaction);\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n             }\n             catch( Throwable t) {\n                 Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546701959", "body": "This seem not used later.", "bodyText": "This seem not used later.", "bodyHTML": "<p dir=\"auto\">This seem not used later.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:21:27Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -77,25 +80,57 @@\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n+\n+            try {\n+                doRollback(context, transactionManager, transaction);\n+            }\n+            finally {\n+                rolledBack = true;\n+            }\n         } finally {\n             try {\n-                if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n+                if (readOnly && !rolledBack) {\n+                    try {\n+                        doRollback(context, transactionManager, transaction);\n+                    }\n+                    finally {\n+                        rolledBack = true;\n+                    }\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    if (!rolledBack) {\n+                        try {\n+                            doRollback(context, transactionManager, transaction);\n+                        }\n+                        finally {\n+                            rolledBack = true;", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MDQ4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547050484", "bodyText": "See line 126, we are trying to prevent duplicate rollback.\nAside: Trying for minimal change the previous tested logic. With more time I would refactor into multiple methods to clearly document what each branch of logic is trying to do etc...", "author": "jodygarnett", "createdAt": "2020-12-22T03:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMTk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -80,57 +77,25 @@ public class TransactionManager {\n             if (exception[0] == null) {\n                 exception[0] = e;\n             }\n-\n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n-            }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n+                if (readOnly) {\n+                    doRollback(context, transactionManager, transaction);\n                 } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n                     doCommit(context, transactionManager, transaction);\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n                     Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n                     Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n                 }\n             } catch (Throwable t) {\n                 Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -73,93 +85,93 @@ public class TransactionManager {\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n-\n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n-            }\n+            return action.doInTransaction(status);\n \n-            try {\n-                doRollback(context, transactionManager, transaction);\n-            }\n-            finally {\n-                rolledBack = true;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n         } finally {\n             try {\n-                if (readOnly && !rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                if (readOnly) {\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    if (!rolledBack) {\n-                        try {\n-                            doRollback(context, transactionManager, transaction);\n-                        }\n-                        finally {\n-                            rolledBack = true;\n-                        }\n-                    }\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                if (!rolledBack) {\n-                    try {\n-                        doRollback(context, transactionManager, transaction);\n-                    }\n-                    finally {\n-                        rolledBack = true;\n-                    }\n-                }\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n             }\n-        }\n-\n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n-        return result;\n+\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n \n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n         try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n+            fireBeforeCommit(context, transactionManager, status);\n         }\n         catch( Throwable t ){\n             Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n         }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n         try {\n-            transactionManager.commit(transaction);\n+            transactionManager.commit(status);\n         }\n         finally {\n             try {\n-                fireAfterCommit(context, transactionManager, transaction);\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n             }\n             catch( Throwable t) {\n                 Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546702884", "body": "Is the intention that the code continues?", "bodyText": "Is the intention that the code continues?", "bodyHTML": "<p dir=\"auto\">Is the intention that the code continues?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:23:32Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n+        if ( transaction == null || transaction.isCompleted()){\n+            // nothing to do", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1MTQ2NQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547051465", "bodyText": "no, reading the previous logic I should have a return. Idea was to change the check to be postive, general principle to improve legibility.", "author": "jodygarnett", "createdAt": "2020-12-22T03:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwMjg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -148,157 +113,42 @@ public class TransactionManager {\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-        try {\n-            transactionManager.commit(transaction);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, transaction);\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    private static void fireNewTransaction(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n-            }\n-        }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n-    }\n-\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                    PlatformTransactionManager transactionManager,\n-                                    @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n-\n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n-        }\n-    }\n-\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n-\n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n-        }\n-    }\n-\n-\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n-        if ( transaction == null || transaction.isCompleted()){\n-            // nothing to do\n-        }\n         try {\n-            fireBeforeRollback( context, transactionManager, transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, transaction);\n-            }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n+                }\n             }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -272,29 +331,40 @@ public class TransactionManager {\n         }\n     }\n \n-\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n-        if ( transaction == null || transaction.isCompleted()){\n-            // nothing to do\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n         }\n         try {\n-            fireBeforeRollback( context, transactionManager, transaction);\n+            fireBeforeRollback( context, transactionManager, status);\n         }\n         catch (Throwable t) {\n             Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n         }\n \n         try {\n-            transactionManager.rollback(transaction);\n+            transactionManager.rollback(status);\n         }\n         catch (Throwable t) {\n             Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n         finally {\n             try {\n-                fireAfterRollback(context, transactionManager, transaction);\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                }\n             }\n             catch (Throwable t) {\n                 Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546704372", "body": "In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.", "bodyText": "In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.", "bodyHTML": "<p dir=\"auto\">In previous code when a listener failed, seem no further processing, now all are processed and thrown the exception of the last one that fails. It can be fine, but want to confirm that is the intention.</p>", "author": "josegar74", "createdAt": "2020-12-21T13:26:26Z", "path": "core/src/main/java/jeeves/transaction/TransactionManager.java", "diffHunk": "@@ -113,43 +148,158 @@\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        try {\n+            fireBeforeCommit(context, transactionManager, transaction);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+        try {\n+            transactionManager.commit(transaction);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, transaction);\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n+            }\n+        }\n+    }\n+\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterCommitFailure = null;\n+\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n+        }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n         }\n+    }\n \n-        transactionManager.commit(transaction);\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    private static void fireNewTransaction(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(transaction);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                    PlatformTransactionManager transactionManager,\n+                                    @Nullable TransactionStatus transaction) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(transaction);\n+            }\n+            catch (Throwable t){", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0OTc1Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547049756", "bodyText": "Yes that was my intension, trying to read the code and check the listener api contracts and make the application more predictable.\nThere was nothing explicit in the api about allowing listeners to halt the notification process (sometimes in core java api listeners are allowed to return \"true\" if they have addressed an event to prevent further processing).", "author": "jodygarnett", "createdAt": "2020-12-22T03:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNDM3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..7071822937 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -148,157 +113,42 @@ public class TransactionManager {\n \n     protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        try {\n-            fireBeforeCommit(context, transactionManager, transaction);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-        try {\n-            transactionManager.commit(transaction);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, transaction);\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    private static void fireNewTransaction(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n-            }\n-        }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n-    }\n-\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                    PlatformTransactionManager transactionManager,\n-                                    @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n-\n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n-        }\n-    }\n-\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus transaction) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n-\n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(transaction);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n-        }\n-    }\n-\n-\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n                                    @Nullable TransactionStatus transaction) {\n-        if ( transaction == null || transaction.isCompleted()){\n-            // nothing to do\n-        }\n         try {\n-            fireBeforeRollback( context, transactionManager, transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(transaction);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, transaction);\n-            }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n+                }\n             }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n", "next_change": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 7071822937..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -51,111 +64,328 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        final Throwable[] exception = new Throwable[1];\n-        TransactionStatus transaction = null;\n+        TransactionStatus status = null;\n         boolean isNewTransaction = false;\n-        boolean rolledBack = false;\n-        V result = null;\n+        boolean isRolledBack = false;\n+        boolean isCommitted = false;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            transaction = transactionManager.getTransaction(definition);\n-            isNewTransaction = transaction.isNewTransaction();\n+            status = transactionManager.getTransaction(definition);\n+            isNewTransaction = status.isNewTransaction();\n \n             if (isNewTransaction) {\n-                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n-                for (NewTransactionListener listener : listeners) {\n-                    listener.newTransaction(transaction);\n+                try {\n+                    fireNewTransaction(context, transactionManager, status);\n+                }\n+                catch(Throwable t) {\n+                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n+                    // warning as we continue with action below\n                 }\n             }\n \n-            result = action.doInTransaction(transaction);\n+            return action.doInTransaction(status);\n \n-        } catch (Throwable e) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n-            if (exception[0] == null) {\n-                exception[0] = e;\n+        } catch (Throwable exception) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n+            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            if (exception instanceof RuntimeException) {\n+                throw (RuntimeException) exception;\n+            } else if (exception instanceof Error) {\n+                throw (Error) exception;\n+            } else {\n+                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n             }\n-            rolledBack = true;\n-            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n                 if (readOnly) {\n-                    doRollback(context, transactionManager, transaction);\n-                } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, transaction);\n+                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                    doCommit(context, transactionManager, status);\n+                    isCommitted = true;\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n-                    doRollback(context, transactionManager, transaction);\n+                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n                 }\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n-                doRollback(context, transactionManager, transaction);\n+                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n+                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n+            }\n+            Log.debug(\n+                Log.JEEVES,\n+                \"Run in transaction completed:\" +\n+                    (isRolledBack?\" rolled back\":\"\") +\n+                    (isCommitted?\" committed\":\"\")\n+            );\n+            if( !isRolledBack && !isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n+            }\n+            if( isRolledBack && isCommitted ){\n+                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n             }\n         }\n \n-        if (exception[0] != null) {\n-            if (exception[0] instanceof RuntimeException) {\n-                throw (RuntimeException) exception[0];\n-            } else if (exception[0] instanceof Error) {\n-                throw (Error) exception[0];\n-            } else {\n-                throw new RuntimeException(exception[0]);\n+    }\n+\n+    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n+        if (!isRolledBack) {\n+            doRollback(context, transactionManager, status);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n+        try {\n+            fireBeforeCommit(context, transactionManager, status);\n+        }\n+        catch( Throwable t ){\n+            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n+        }\n+\n+        if ( status == null || status.isCompleted()){\n+            // not calling return here to preserve previous logic\n+            // we can check if the following log messages are seen before taking defensive action\n+            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n+        }\n+\n+        try {\n+            transactionManager.commit(status);\n+        }\n+        finally {\n+            try {\n+                fireAfterCommit(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n+                }\n+            }\n+            catch( Throwable t) {\n+                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n             }\n         }\n-        return result;\n     }\n \n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n+    /**\n+     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n+     * <p>\n+     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n+     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n+     * </p>\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterCommit(ApplicationContext context,\n+                                        PlatformTransactionManager transactionManager,\n+                                        @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterCommitFailure = null;\n \n-        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n-            listener.beforeCommit(transaction);\n+        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n+            (AfterCommitTransactionListener.class).values();\n+        for (AfterCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.afterCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                afterCommitFailure = t;\n+            }\n         }\n+        if (afterCommitFailure != null){\n+            throw afterCommitFailure;\n+        }\n+    }\n \n-        transactionManager.commit(transaction);\n+    /**\n+     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeCommit(ApplicationContext context,\n+                                         PlatformTransactionManager transactionManager,\n+                                         @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeCommitFailure = null;\n \n-        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n-            listener.afterCommit(transaction);\n+        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n+            (BeforeCommitTransactionListener.class).values();\n+        for (BeforeCommitTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeCommit(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                beforeCommitFailure = t;\n+            }\n+        }\n+        if (beforeCommitFailure != null){\n+            throw beforeCommitFailure;\n         }\n     }\n \n+    /**\n+     * Notify context NewTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireNewTransaction(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable newTransactionFailure = null;\n+\n+        Collection<NewTransactionListener> listeners = context.getBeansOfType\n+            (NewTransactionListener.class).values();\n+        for (NewTransactionListener listener : listeners) {\n+            try {\n+                listener.newTransaction(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n+                newTransactionFailure = t;\n+            }\n+        }\n+        if (newTransactionFailure != null){\n+            throw newTransactionFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireAfterRollback(ApplicationContext context,\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n+        Throwable afterRollbackFailure = null;\n+\n+        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n+            (AfterRollbackTransactionListener.class).values();\n+        for (AfterRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.afterRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n+                afterRollbackFailure = t;\n+            }\n+        }\n+        if (afterRollbackFailure != null){\n+            throw afterRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n+    private static void fireBeforeRollback(ApplicationContext context,\n+                                           PlatformTransactionManager transactionManager,\n+                                           @Nullable TransactionStatus status) throws Throwable {\n+        Throwable beforeRollbackFailure = null;\n+\n+        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+            (BeforeRollbackTransactionListener.class).values();\n+        for (BeforeRollbackTransactionListener listener : listeners) {\n+            try {\n+                listener.beforeRollback(status);\n+            }\n+            catch (Throwable t){\n+                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n+                beforeRollbackFailure = t;\n+            }\n+        }\n+        if (beforeRollbackFailure != null){\n+            throw beforeRollbackFailure;\n+        }\n+    }\n+\n+    /**\n+     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n+     *\n+     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n+     *\n+     * @param context context used to obtain listeners to notify\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus transaction) {\n+                                   @Nullable TransactionStatus status) {\n+        if ( status == null || status.isCompleted()){\n+            return; // nothing to do transaction already completed\n+        }\n         try {\n-            if (transaction != null && !transaction.isCompleted()) {\n+            fireBeforeRollback( context, transactionManager, status);\n+        }\n+        catch (Throwable t) {\n+            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n+        }\n \n-                try {\n-                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-                        (BeforeRollbackTransactionListener.class).values();\n-                    for (BeforeRollbackTransactionListener listener : listeners) {\n-                        listener.beforeRollback(transaction);\n-                    }\n-                } finally {\n-                    transactionManager.rollback(transaction);\n-                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n-                        AfterRollbackTransactionListener.class).values();\n-                    for (AfterRollbackTransactionListener listener : listeners) {\n-                        listener.afterRollback(transaction);\n-                    }\n+        try {\n+            transactionManager.rollback(status);\n+        }\n+        catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+        }\n+        finally {\n+            try {\n+                fireAfterRollback(context, transactionManager, status);\n+                if(! status.isCompleted() ) {\n+                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n                 }\n             }\n-            //what if the transaction is completed?\n-            //maybe then we shouldn't be here\n-        } catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n+            catch (Throwable t) {\n+                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n+            }\n         }\n     }\n \n+    /**\n+     * Approach used for transaction execution.\n+     */\n     public static enum TransactionRequirement {\n+        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n+\n+        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n+\n+        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n+\n+        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex 576367c093..f430ef2649 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -230,16 +269,28 @@ public class TransactionManager {\n         }\n     }\n \n+    /**\n+     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n+     * <p>\n+     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n+     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n+     * </p>\n+     *\n+     * @param context context used to obtain listeners\n+     * @param transactionManager manager responsible for execution\n+     * @param status transaction status\n+     * @throws Throwable\n+     */\n     private static void fireAfterRollback(ApplicationContext context,\n-                                    PlatformTransactionManager transactionManager,\n-                                    @Nullable TransactionStatus transaction) throws Throwable {\n+                                          PlatformTransactionManager transactionManager,\n+                                          @Nullable TransactionStatus status) throws Throwable {\n         Throwable afterRollbackFailure = null;\n \n         Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n             (AfterRollbackTransactionListener.class).values();\n         for (AfterRollbackTransactionListener listener : listeners) {\n             try {\n-                listener.afterRollback(transaction);\n+                listener.afterRollback(status);\n             }\n             catch (Throwable t){\n                 Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n", "next_change": {"commit": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "changed_code": [{"header": "diff --git a/core/src/main/java/jeeves/transaction/TransactionManager.java b/core/src/main/java/jeeves/transaction/TransactionManager.java\nindex f430ef2649..4f81a54d4b 100644\n--- a/core/src/main/java/jeeves/transaction/TransactionManager.java\n+++ b/core/src/main/java/jeeves/transaction/TransactionManager.java\n", "chunk": "@@ -64,328 +53,127 @@ public class TransactionManager {\n                                          boolean readOnly,\n                                          final TransactionTask<V> action) {\n         final PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);\n-        TransactionStatus status = null;\n+        final Throwable[] exception = new Throwable[1];\n+        TransactionStatus transaction = null;\n         boolean isNewTransaction = false;\n-        boolean isRolledBack = false;\n-        boolean isCommitted = false;\n+        boolean rolledBack = false;\n+        V result = null;\n         try {\n             DefaultTransactionDefinition definition = new DefaultTransactionDefinition(transactionRequirement.propagationId);\n             definition.setName(name);\n             definition.setReadOnly(readOnly);\n-            status = transactionManager.getTransaction(definition);\n-            isNewTransaction = status.isNewTransaction();\n+            transaction = transactionManager.getTransaction(definition);\n+            isNewTransaction = transaction.isNewTransaction();\n \n             if (isNewTransaction) {\n-                try {\n-                    fireNewTransaction(context, transactionManager, status);\n-                }\n-                catch(Throwable t) {\n-                    Log.warning(Log.JEEVES, \"New transaction:\", t);\n-                    // warning as we continue with action below\n+                Collection<NewTransactionListener> listeners = context.getBeansOfType(NewTransactionListener.class).values();\n+                for (NewTransactionListener listener : listeners) {\n+                    listener.newTransaction(transaction);\n                 }\n             }\n \n-            return action.doInTransaction(status);\n+            result = action.doInTransaction(transaction);\n \n-        } catch (Throwable exception) {\n-            Log.error(Log.JEEVES, \"Error occurred within a transaction\", exception);\n-            isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            if (exception instanceof RuntimeException) {\n-                throw (RuntimeException) exception;\n-            } else if (exception instanceof Error) {\n-                throw (Error) exception;\n-            } else {\n-                throw new RuntimeException(\"Run in transaction '\"+action+\"': \"+exception.getLocalizedMessage(), exception);\n+\n+\n+        } catch (Throwable e) {\n+            Log.error(Log.JEEVES, \"Error occurred within a transaction\", e);\n+            if (exception[0] == null) {\n+                exception[0] = e;\n             }\n+            rolledBack = true;\n+            doRollback(context, transactionManager, transaction);\n         } finally {\n             try {\n-                if (readOnly) {\n-                    isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-                } else if (!isRolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n-                    doCommit(context, transactionManager, status);\n-                    isCommitted = true;\n+                // GlobalExceptionManager stores the exception in a request attribute, to be processed to rollback the transaction\n+                // as otherwise GlobalExceptionManager processes the exception and the code doesn't enter in the catch block\n+                // to rollback the transaction\n+                Throwable requestException = null;\n+                try {\n+                    requestException = (Throwable) RequestContextHolder.currentRequestAttributes().getAttribute(\"exception\", RequestAttributes.SCOPE_REQUEST);\n+                } catch (IllegalStateException ex) {\n+                    // Ignore: transaction non-related to a web request\n+                }\n+\n+                if (requestException != null) {\n+                    doRollback(context, transactionManager, transaction);\n+                } else {\n+                    if (readOnly) {\n+                        doRollback(context, transactionManager, transaction);\n+                    } else if (!rolledBack && (isNewTransaction || commitBehavior == CommitBehavior.ALWAYS_COMMIT)) {\n+                        doCommit(context, transactionManager, transaction);\n+                    }\n                 }\n             } catch (TransactionSystemException e) {\n                 if (!(e.getOriginalException() instanceof RollbackException)) {\n-                    Log.error(Log.JEEVES, \"Exception completing transaction rollback, will try to rollback\", e);\n+                    Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n+                    doRollback(context, transactionManager, transaction);\n                 } else {\n-                    Log.debug(Log.JEEVES, \"Exception completing transaction, will try to rollback\", e);\n+                    Log.debug(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", e);\n                 }\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-\n             } catch (Throwable t) {\n-                Log.error(Log.JEEVES, \"Unexpected problem completing transaction, will try to rollback\", t);\n-                isRolledBack = rollbackIfNotRolledBack(context, transactionManager, status, isRolledBack);\n-            }\n-            Log.debug(\n-                Log.JEEVES,\n-                \"Run in transaction completed:\" +\n-                    (isRolledBack?\" rolled back\":\"\") +\n-                    (isCommitted?\" committed\":\"\")\n-            );\n-            if( !isRolledBack && !isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction not committed or rolledback\");\n-            }\n-            if( isRolledBack && isCommitted ){\n-                Log.warning(  Log.JEEVES, \"Run in transaction did not complete cleanly, transaction both committed and rolledback\");\n+                Log.error(Log.JEEVES, \"ERROR committing transaction, will try to rollback\", t);\n+                doRollback(context, transactionManager, transaction);\n             }\n         }\n \n-    }\n-\n-    private static Boolean rollbackIfNotRolledBack(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status, Boolean isRolledBack) {\n-        if (!isRolledBack) {\n-            doRollback(context, transactionManager, status);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Safely perform {@link PlatformTransactionManager#commit(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n-    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus status) {\n-        try {\n-            fireBeforeCommit(context, transactionManager, status);\n-        }\n-        catch( Throwable t ){\n-            Log.warning(Log.JEEVES, \"Commit transaction - before:\", t);\n-        }\n-\n-        if ( status == null || status.isCompleted()){\n-            // not calling return here to preserve previous logic\n-            // we can check if the following log messages are seen before taking defensive action\n-            Log.debug( Log.JEEVES,\"transactionManager.commit called unexpectedly when transaction is already completed \");\n-        }\n-\n-        try {\n-            transactionManager.commit(status);\n-        }\n-        finally {\n-            try {\n-                fireAfterCommit(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.commit failed to complete\");\n-                }\n-            }\n-            catch( Throwable t) {\n-                Log.warning(Log.JEEVES, \"Commit transaction - after:\", t);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Notify context AfterCommitTransactionListener instances of transaction status after commit.\n-     * <p>\n-     * Transaction commit listeners can check {@link TransactionStatus#isCompleted()} {@code true} if commit was successful,\n-     * or {@code false} if the commmit failed and the code is in an inconsistent state.\n-     * </p>\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterCommit(ApplicationContext context,\n-                                        PlatformTransactionManager transactionManager,\n-                                        @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterCommitFailure = null;\n-\n-        Collection<AfterCommitTransactionListener> listeners = context.getBeansOfType\n-            (AfterCommitTransactionListener.class).values();\n-        for (AfterCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.afterCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                afterCommitFailure = t;\n-            }\n-        }\n-        if (afterCommitFailure != null){\n-            throw afterCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context BeforeCommitTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeCommit(ApplicationContext context,\n-                                         PlatformTransactionManager transactionManager,\n-                                         @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeCommitFailure = null;\n-\n-        Collection<BeforeCommitTransactionListener> listeners = context.getBeansOfType\n-            (BeforeCommitTransactionListener.class).values();\n-        for (BeforeCommitTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeCommit(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                beforeCommitFailure = t;\n-            }\n-        }\n-        if (beforeCommitFailure != null){\n-            throw beforeCommitFailure;\n-        }\n-    }\n-\n-    /**\n-     * Notify context NewTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireNewTransaction(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable newTransactionFailure = null;\n-\n-        Collection<NewTransactionListener> listeners = context.getBeansOfType\n-            (NewTransactionListener.class).values();\n-        for (NewTransactionListener listener : listeners) {\n-            try {\n-                listener.newTransaction(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" newTransaction callback failed: \"+ t);\n-                newTransactionFailure = t;\n+        if (exception[0] != null) {\n+            if (exception[0] instanceof RuntimeException) {\n+                throw (RuntimeException) exception[0];\n+            } else if (exception[0] instanceof Error) {\n+                throw (Error) exception[0];\n+            } else {\n+                throw new RuntimeException(exception[0]);\n             }\n         }\n-        if (newTransactionFailure != null){\n-            throw newTransactionFailure;\n-        }\n+        return result;\n     }\n \n-    /**\n-     * Notify context AfterRollbackTransactionListener instances of transaction status change.\n-     * <p>\n-     * Transaction rollback listeners can check {@link TransactionStatus#isCompleted()} {@code true} if rollback was successful,\n-     * or {@code false} if the rollback failed and the code is in an inconsistent state.\n-     * </p>\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireAfterRollback(ApplicationContext context,\n-                                          PlatformTransactionManager transactionManager,\n-                                          @Nullable TransactionStatus status) throws Throwable {\n-        Throwable afterRollbackFailure = null;\n+    protected static void doCommit(ApplicationContext context, PlatformTransactionManager transactionManager, TransactionStatus transaction) {\n \n-        Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType\n-            (AfterRollbackTransactionListener.class).values();\n-        for (AfterRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.afterRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" afterRollback callback failed: \"+ t);\n-                afterRollbackFailure = t;\n-            }\n-        }\n-        if (afterRollbackFailure != null){\n-            throw afterRollbackFailure;\n+        for (BeforeCommitTransactionListener listener : context.getBeansOfType(BeforeCommitTransactionListener.class).values()) {\n+            listener.beforeCommit(transaction);\n         }\n-    }\n \n-    /**\n-     * Notify context BeforeRollbackTransactionListener instances of transaction status change.\n-     *\n-     * @param context context used to obtain listeners\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     * @throws Throwable\n-     */\n-    private static void fireBeforeRollback(ApplicationContext context,\n-                                           PlatformTransactionManager transactionManager,\n-                                           @Nullable TransactionStatus status) throws Throwable {\n-        Throwable beforeRollbackFailure = null;\n+        transactionManager.commit(transaction);\n \n-        Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n-            (BeforeRollbackTransactionListener.class).values();\n-        for (BeforeRollbackTransactionListener listener : listeners) {\n-            try {\n-                listener.beforeRollback(status);\n-            }\n-            catch (Throwable t){\n-                Log.debug(Log.JEEVES, \"Listener \"+listener.toString()+\" beforeRollback callback failed: \"+ t);\n-                beforeRollbackFailure = t;\n-            }\n-        }\n-        if (beforeRollbackFailure != null){\n-            throw beforeRollbackFailure;\n+        for (AfterCommitTransactionListener listener : context.getBeansOfType(AfterCommitTransactionListener.class).values()) {\n+            listener.afterCommit(transaction);\n         }\n     }\n \n-    /**\n-     * Safely perform {@link PlatformTransactionManager#rollback(TransactionStatus)}.\n-     *\n-     * This method is responsible for safely logging any notification failures as warnings, rather than failing outright.\n-     *\n-     * @param context context used to obtain listeners to notify\n-     * @param transactionManager manager responsible for execution\n-     * @param status transaction status\n-     */\n     private static void doRollback(ApplicationContext context,\n                                    PlatformTransactionManager transactionManager,\n-                                   @Nullable TransactionStatus status) {\n-        if ( status == null || status.isCompleted()){\n-            return; // nothing to do transaction already completed\n-        }\n+                                   @Nullable TransactionStatus transaction) {\n         try {\n-            fireBeforeRollback( context, transactionManager, status);\n-        }\n-        catch (Throwable t) {\n-            Log.warning(Log.JEEVES, \"Rolling back transaction - before:\", t);\n-        }\n+            if (transaction != null && !transaction.isCompleted()) {\n \n-        try {\n-            transactionManager.rollback(status);\n-        }\n-        catch (Throwable t) {\n-            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n-        }\n-        finally {\n-            try {\n-                fireAfterRollback(context, transactionManager, status);\n-                if(! status.isCompleted() ) {\n-                    Log.warning( Log.JEEVES, \"transactionManager.rollback incomplete\");\n+                try {\n+                    Collection<BeforeRollbackTransactionListener> listeners = context.getBeansOfType\n+                        (BeforeRollbackTransactionListener.class).values();\n+                    for (BeforeRollbackTransactionListener listener : listeners) {\n+                        listener.beforeRollback(transaction);\n+                    }\n+                } finally {\n+                    transactionManager.rollback(transaction);\n+                    Collection<AfterRollbackTransactionListener> listeners = context.getBeansOfType(\n+                        AfterRollbackTransactionListener.class).values();\n+                    for (AfterRollbackTransactionListener listener : listeners) {\n+                        listener.afterRollback(transaction);\n+                    }\n                 }\n             }\n-            catch (Throwable t) {\n-                Log.warning(Log.JEEVES, \"Rolling back transaction - after:\", t);\n-            }\n+            //what if the transaction is completed?\n+            //maybe then we shouldn't be here\n+        } catch (Throwable t) {\n+            Log.error(Log.JEEVES, \"ERROR rolling back transaction\", t);\n         }\n     }\n \n-    /**\n-     * Approach used for transaction execution.\n-     */\n     public static enum TransactionRequirement {\n-        /** Support a current transaction; create a new one if none exists. */\n         CREATE_ONLY_WHEN_NEEDED(TransactionDefinition.PROPAGATION_REQUIRED),\n-\n-        /** Support a current transaction; throw an exception if no current transaction exists. */\n         THROW_EXCEPTION_IF_NOT_PRESENT(TransactionDefinition.PROPAGATION_MANDATORY),\n-\n-        /** Create a new transaction, suspending the current transaction if one exists. */\n         CREATE_NEW(TransactionDefinition.PROPAGATION_REQUIRES_NEW);\n-\n-        /** Propagation id defined by {@link org.springframework.transaction.TransactionDefinition} */\n         private final int propagationId;\n \n         TransactionRequirement(int propagation) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "8a2e2688ec355a1d83403a56c3eb7f7356c413b2", "committedDate": "2021-09-08 16:41:00 +0200", "message": "Rollback exceptions handled in GlobalExceptionController. Fixes #5944 (#5948)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546707394", "body": "To confirm no need to call `_context.clear()` as this code runs in a custom thread?", "bodyText": "To confirm no need to call _context.clear() as this code runs in a custom thread?", "bodyHTML": "<p dir=\"auto\">To confirm no need to call <code>_context.clear()</code> as this code runs in a custom thread?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:32:47Z", "path": "core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java", "diffHunk": "@@ -125,6 +125,7 @@ public void run() {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n+            _context.clearAsThreadLocal();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1OTM3NA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547059374", "bodyText": "This may be a case where a task is sharing a context, so calling clear() breaks another task.\nLong term it may be smart to implement reference counting, or a context wrapper, when providing the same context to more than one thread.", "author": "jodygarnett", "createdAt": "2020-12-22T04:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwNzM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex df51151304..5cbcf19bc2 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -125,7 +125,6 @@ public final class IndexMetadataTask implements Runnable {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n-            _context.clearAsThreadLocal();\n         }\n     }\n }\n", "next_change": {"commit": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex 5cbcf19bc2..df51151304 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -125,6 +125,7 @@ public final class IndexMetadataTask implements Runnable {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n+            _context.clearAsThreadLocal();\n         }\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "c6c9ba4e041dcf98005f59f5a0f20efd02cbfdff", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex df51151304..a5048c8409 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -125,7 +126,6 @@ public final class IndexMetadataTask implements Runnable {\n             Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n-            _context.clearAsThreadLocal();\n         }\n     }\n }\n", "next_change": {"commit": "bfd1e33c61d19fbda85e2af9075d0db487dd87af", "changed_code": [{"header": "diff --git a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\nindex a5048c8409..ac7db5535f 100644\n--- a/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n+++ b/core/src/main/java/org/fao/geonet/kernel/IndexMetadataTask.java\n", "chunk": "@@ -122,8 +117,6 @@ final class IndexMetadataTask implements Runnable {\n                 _context.getUserSession().loginAs(_user);\n             }\n             searchManager.forceIndexChanges();\n-        } catch (IOException e) {\n-            Log.error(Geonet.INDEX_ENGINE, \"Error occurred indexing metadata\", e);\n         } finally {\n             _batchIndex.remove(this);\n         }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "c6c9ba4e041dcf98005f59f5a0f20efd02cbfdff", "committedDate": "2018-06-11 22:34:12 +0200", "message": "Update to JEST 5.3.3 and make rebuild index works with ES."}, {"oid": "7374b5c7f147eadd9d4798ca86174ed507d6130e", "committedDate": "2018-06-11 22:37:14 +0200", "message": "Remove Lucene dependency and start removing old Jeeves services."}, {"oid": "9fe05c19f4765edbc1fefd36b75edce1238e0dbb", "committedDate": "2018-06-18 14:19:42 +0200", "message": "Merge remote-tracking branch 'origin/master' into es"}, {"oid": "536251f509d1bdfbc4892023144963af2e1adf19", "committedDate": "2019-06-21 16:01:44 +0200", "message": "ES / Record view is now displaying all record properties."}, {"oid": "bfd1e33c61d19fbda85e2af9075d0db487dd87af", "committedDate": "2020-10-02 16:52:05 +0200", "message": "Indexing / Improvements (#5064)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546708616", "body": "I see some code in the API package creating a `ServiceContext`, but not calling the `clear` method at the end (for example: https://github.com/geonetwork/core-geonetwork/blob/23910ced1b727319d099960b02020e789c226d5c/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java#L189-L258)\r\n\r\nIs this due to the way of creating the `ServiceContext` (`serviceManager.createServiceContext` vs `ApiUtils.createServiceContext`)?", "bodyText": "I see some code in the API package creating a ServiceContext, but not calling the clear method at the end (for example: \n  \n    \n      core-geonetwork/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java\n    \n    \n        Lines 189 to 258\n      in\n      23910ce\n    \n    \n    \n    \n\n        \n          \n           public void getGroupLogo( \n        \n\n        \n          \n               @ApiParam(value = \"Group identifier\", required = true) @PathVariable(value = \"groupId\") final Integer groupId, \n        \n\n        \n          \n               @ApiIgnore final WebRequest webRequest, \n        \n\n        \n          \n               HttpServletRequest request, \n        \n\n        \n          \n               HttpServletResponse response) throws ResourceNotFoundException { \n        \n\n        \n          \n            \n        \n\n        \n          \n               Locale locale = languageUtils.parseAcceptLanguage(request.getLocales()); \n        \n\n        \n          \n            \n        \n\n        \n          \n               ApplicationContext context = ApplicationContextHolder.get(); \n        \n\n        \n          \n               ServiceContext serviceContext = ApiUtils.createServiceContext(request, locale.getISO3Country()); \n        \n\n        \n          \n               if (context == null) { \n        \n\n        \n          \n                   throw new RuntimeException(\"ServiceContext not available\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n            \n        \n\n        \n          \n               Group group = groupRepository.findOne(groupId); \n        \n\n        \n          \n               if (group == null) { \n        \n\n        \n          \n                   throw new ResourceNotFoundException(messages.getMessage(\"api.groups.group_not_found\", new \n        \n\n        \n          \n                       Object[]{groupId}, locale)); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               try { \n        \n\n        \n          \n                   final Resources resources = context.getBean(Resources.class); \n        \n\n        \n          \n                   final String logoUUID = group.getLogo(); \n        \n\n        \n          \n                   if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                       try (Resources.ResourceHolder image = getImage(resources, serviceContext, group)){ \n        \n\n        \n          \n                           if (image != null) { \n        \n\n        \n          \n                               FileTime lastModifiedTime = image.getLastModifiedTime(); \n        \n\n        \n          \n                               response.setDateHeader(\"Expires\", System.currentTimeMillis() + SIX_HOURS * 1000L); \n        \n\n        \n          \n                               if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                                   // webRequest.checkNotModified sets the right HTTP headers \n        \n\n        \n          \n                                   return; \n        \n\n        \n          \n                               } \n        \n\n        \n          \n                               response.setContentType(AttachmentsApi.getFileContentType(image.getPath())); \n        \n\n        \n          \n                               response.setContentLength((int) Files.size(image.getPath())); \n        \n\n        \n          \n                               response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                               FileUtils.copyFile(image.getPath().toFile(), response.getOutputStream()); \n        \n\n        \n          \n                               return; \n        \n\n        \n          \n                           } \n        \n\n        \n          \n                       } \n        \n\n        \n          \n                   } \n        \n\n        \n          \n            \n        \n\n        \n          \n                   // no logo image found. Return a transparent 1x1 png \n        \n\n        \n          \n                   FileTime lastModifiedTime = FileTime.fromMillis(0); \n        \n\n        \n          \n                   if (webRequest.checkNotModified(lastModifiedTime.toMillis())) { \n        \n\n        \n          \n                       return; \n        \n\n        \n          \n                   } \n        \n\n        \n          \n                   response.setContentType(\"image/png\"); \n        \n\n        \n          \n                   response.setContentLength(TRANSPARENT_1_X_1_PNG.length); \n        \n\n        \n          \n                   response.addHeader(\"Cache-Control\", \"max-age=\" + SIX_HOURS + \", public\"); \n        \n\n        \n          \n                   response.getOutputStream().write(TRANSPARENT_1_X_1_PNG); \n        \n\n        \n          \n            \n        \n\n        \n          \n               } catch (IOException e) { \n        \n\n        \n          \n                   Log.error(LOGGER, String.format(\"There was an error accessing the logo of the group with id '%d'\", \n        \n\n        \n          \n                       groupId)); \n        \n\n        \n          \n                   throw new RuntimeException(e); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           private static Resources.ResourceHolder getImage(Resources resources, ServiceContext serviceContext, Group group) throws IOException { \n        \n\n        \n          \n               final Path logosDir = resources.locateLogosDir(serviceContext); \n        \n\n        \n          \n               final Path harvesterLogosDir = resources.locateHarvesterLogosDir(serviceContext); \n        \n\n        \n          \n               final String logoUUID = group.getLogo(); \n        \n\n        \n          \n               Resources.ResourceHolder image = null; \n        \n\n        \n          \n               if (StringUtils.isNotBlank(logoUUID) && !logoUUID.startsWith(\"http://\") && !logoUUID.startsWith(\"https//\")) { \n        \n\n        \n          \n                   image = resources.getImage(serviceContext, logoUUID, logosDir); \n        \n\n        \n          \n                   if (image == null) { \n        \n\n        \n          \n                       image = resources.getImage(serviceContext, logoUUID, harvesterLogosDir); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return image; \n        \n\n        \n          \n           } \n        \n    \n  \n\n)\nIs this due to the way of creating the ServiceContext (serviceManager.createServiceContext vs ApiUtils.createServiceContext)?", "bodyHTML": "<p dir=\"auto\">I see some code in the API package creating a <code>ServiceContext</code>, but not calling the <code>clear</code> method at the end (for example: <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/geonetwork/core-geonetwork/blob/23910ced1b727319d099960b02020e789c226d5c/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java#L189-L258\">core-geonetwork/services/src/main/java/org/fao/geonet/api/groups/GroupsApi.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 189 to 258\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/geonetwork/core-geonetwork/commit/23910ced1b727319d099960b02020e789c226d5c\">23910ce</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L189\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"189\"></td>\n          <td id=\"LC189\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">public</span> <span class=\"pl-k\">void</span> <span class=\"pl-en\">getGroupLogo</span>( </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L190\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"190\"></td>\n          <td id=\"LC190\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">@ApiParam</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Group identifier<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">required</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">true</span>) <span class=\"pl-k\">@PathVariable</span>(<span class=\"pl-c1\">value</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>groupId<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Integer</span> <span class=\"pl-v\">groupId</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L191\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"191\"></td>\n          <td id=\"LC191\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">@ApiIgnore</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">WebRequest</span> <span class=\"pl-v\">webRequest</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L192\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"192\"></td>\n          <td id=\"LC192\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">HttpServletRequest</span> <span class=\"pl-v\">request</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L193\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"193\"></td>\n          <td id=\"LC193\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">HttpServletResponse</span> <span class=\"pl-v\">response</span>) <span class=\"pl-k\">throws</span> <span class=\"pl-smi\">ResourceNotFoundException</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L194\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"194\"></td>\n          <td id=\"LC194\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L195\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"195\"></td>\n          <td id=\"LC195\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Locale</span> locale <span class=\"pl-k\">=</span> languageUtils<span class=\"pl-k\">.</span>parseAcceptLanguage(request<span class=\"pl-k\">.</span>getLocales()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L196\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"196\"></td>\n          <td id=\"LC196\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L197\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"197\"></td>\n          <td id=\"LC197\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">ApplicationContext</span> context <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ApplicationContextHolder</span><span class=\"pl-k\">.</span>get(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L198\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"198\"></td>\n          <td id=\"LC198\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">ServiceContext</span> serviceContext <span class=\"pl-k\">=</span> <span class=\"pl-smi\">ApiUtils</span><span class=\"pl-k\">.</span>createServiceContext(request, locale<span class=\"pl-k\">.</span>getISO3Country()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L199\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"199\"></td>\n          <td id=\"LC199\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (context <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L200\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"200\"></td>\n          <td id=\"LC200\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RuntimeException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>ServiceContext not available<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L201\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"201\"></td>\n          <td id=\"LC201\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L202\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"202\"></td>\n          <td id=\"LC202\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L203\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"203\"></td>\n          <td id=\"LC203\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Group</span> group <span class=\"pl-k\">=</span> groupRepository<span class=\"pl-k\">.</span>findOne(groupId); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L204\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"204\"></td>\n          <td id=\"LC204\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (group <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L205\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"205\"></td>\n          <td id=\"LC205\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ResourceNotFoundException</span>(messages<span class=\"pl-k\">.</span>getMessage(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>api.groups.group_not_found<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-k\">new</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L206\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"206\"></td>\n          <td id=\"LC206\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-smi\">Object</span>[]{groupId}, locale)); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L207\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"207\"></td>\n          <td id=\"LC207\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L208\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"208\"></td>\n          <td id=\"LC208\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">try</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L209\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"209\"></td>\n          <td id=\"LC209\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Resources</span> resources <span class=\"pl-k\">=</span> context<span class=\"pl-k\">.</span>getBean(<span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span>class); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L210\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"210\"></td>\n          <td id=\"LC210\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> logoUUID <span class=\"pl-k\">=</span> group<span class=\"pl-k\">.</span>getLogo(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L211\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"211\"></td>\n          <td id=\"LC211\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>isNotBlank(logoUUID) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>http://<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>https//<span class=\"pl-pds\">\"</span></span>)) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L212\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"212\"></td>\n          <td id=\"LC212\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">ResourceHolder</span> image <span class=\"pl-k\">=</span> getImage(resources, serviceContext, group)){ </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L213\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"213\"></td>\n          <td id=\"LC213\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                 <span class=\"pl-k\">if</span> (image <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L214\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"214\"></td>\n          <td id=\"LC214\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-smi\">FileTime</span> lastModifiedTime <span class=\"pl-k\">=</span> image<span class=\"pl-k\">.</span>getLastModifiedTime(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L215\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"215\"></td>\n          <td id=\"LC215\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setDateHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Expires<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-smi\">System</span><span class=\"pl-k\">.</span>currentTimeMillis() <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">*</span> <span class=\"pl-c1\">1000L</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L216\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"216\"></td>\n          <td id=\"LC216\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-k\">if</span> (webRequest<span class=\"pl-k\">.</span>checkNotModified(lastModifiedTime<span class=\"pl-k\">.</span>toMillis())) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L217\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"217\"></td>\n          <td id=\"LC217\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                         <span class=\"pl-c\"><span class=\"pl-c\">//</span> webRequest.checkNotModified sets the right HTTP headers</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L218\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"218\"></td>\n          <td id=\"LC218\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                         <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L219\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"219\"></td>\n          <td id=\"LC219\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L220\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"220\"></td>\n          <td id=\"LC220\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setContentType(<span class=\"pl-smi\">AttachmentsApi</span><span class=\"pl-k\">.</span>getFileContentType(image<span class=\"pl-k\">.</span>getPath())); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L221\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"221\"></td>\n          <td id=\"LC221\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>setContentLength((<span class=\"pl-k\">int</span>) <span class=\"pl-smi\">Files</span><span class=\"pl-k\">.</span>size(image<span class=\"pl-k\">.</span>getPath())); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L222\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"222\"></td>\n          <td id=\"LC222\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     response<span class=\"pl-k\">.</span>addHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cache-Control<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>max-age=<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, public<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L223\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"223\"></td>\n          <td id=\"LC223\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-smi\">FileUtils</span><span class=\"pl-k\">.</span>copyFile(image<span class=\"pl-k\">.</span>getPath()<span class=\"pl-k\">.</span>toFile(), response<span class=\"pl-k\">.</span>getOutputStream()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L224\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"224\"></td>\n          <td id=\"LC224\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                     <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L225\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"225\"></td>\n          <td id=\"LC225\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                 } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L226\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"226\"></td>\n          <td id=\"LC226\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L227\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"227\"></td>\n          <td id=\"LC227\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L228\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"228\"></td>\n          <td id=\"LC228\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L229\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"229\"></td>\n          <td id=\"LC229\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-c\"><span class=\"pl-c\">//</span> no logo image found. Return a transparent 1x1 png</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L230\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"230\"></td>\n          <td id=\"LC230\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-smi\">FileTime</span> lastModifiedTime <span class=\"pl-k\">=</span> <span class=\"pl-smi\">FileTime</span><span class=\"pl-k\">.</span>fromMillis(<span class=\"pl-c1\">0</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L231\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"231\"></td>\n          <td id=\"LC231\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (webRequest<span class=\"pl-k\">.</span>checkNotModified(lastModifiedTime<span class=\"pl-k\">.</span>toMillis())) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L232\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"232\"></td>\n          <td id=\"LC232\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             <span class=\"pl-k\">return</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L233\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"233\"></td>\n          <td id=\"LC233\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L234\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"234\"></td>\n          <td id=\"LC234\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>setContentType(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>image/png<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L235\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"235\"></td>\n          <td id=\"LC235\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>setContentLength(<span class=\"pl-c1\">TRANSPARENT_1_X_1_PNG</span><span class=\"pl-k\">.</span>length); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L236\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"236\"></td>\n          <td id=\"LC236\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>addHeader(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Cache-Control<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>max-age=<span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> <span class=\"pl-c1\">SIX_HOURS</span> <span class=\"pl-k\">+</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>, public<span class=\"pl-pds\">\"</span></span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L237\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"237\"></td>\n          <td id=\"LC237\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         response<span class=\"pl-k\">.</span>getOutputStream()<span class=\"pl-k\">.</span>write(<span class=\"pl-c1\">TRANSPARENT_1_X_1_PNG</span>); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L238\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"238\"></td>\n          <td id=\"LC238\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L239\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"239\"></td>\n          <td id=\"LC239\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } <span class=\"pl-k\">catch</span> (<span class=\"pl-smi\">IOException</span> e) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L240\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"240\"></td>\n          <td id=\"LC240\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-smi\">Log</span><span class=\"pl-k\">.</span>error(<span class=\"pl-c1\">LOGGER</span>, <span class=\"pl-smi\">String</span><span class=\"pl-k\">.</span>format(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>There was an error accessing the logo of the group with id '%d'<span class=\"pl-pds\">\"</span></span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L241\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"241\"></td>\n          <td id=\"LC241\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             groupId)); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L242\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"242\"></td>\n          <td id=\"LC242\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RuntimeException</span>(e); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L243\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"243\"></td>\n          <td id=\"LC243\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L244\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"244\"></td>\n          <td id=\"LC244\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L245\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"245\"></td>\n          <td id=\"LC245\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">  </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L246\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"246\"></td>\n          <td id=\"LC246\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">Resources</span>.<span class=\"pl-smi\">ResourceHolder</span> <span class=\"pl-en\">getImage</span>(<span class=\"pl-smi\">Resources</span> <span class=\"pl-v\">resources</span>, <span class=\"pl-smi\">ServiceContext</span> <span class=\"pl-v\">serviceContext</span>, <span class=\"pl-smi\">Group</span> <span class=\"pl-v\">group</span>) <span class=\"pl-k\">throws</span> <span class=\"pl-smi\">IOException</span> { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L247\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"247\"></td>\n          <td id=\"LC247\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Path</span> logosDir <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>locateLogosDir(serviceContext); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L248\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"248\"></td>\n          <td id=\"LC248\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Path</span> harvesterLogosDir <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>locateHarvesterLogosDir(serviceContext); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L249\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"249\"></td>\n          <td id=\"LC249\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">String</span> logoUUID <span class=\"pl-k\">=</span> group<span class=\"pl-k\">.</span>getLogo(); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L250\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"250\"></td>\n          <td id=\"LC250\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">Resources</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">ResourceHolder</span> image <span class=\"pl-k\">=</span> <span class=\"pl-c1\">null</span>; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L251\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"251\"></td>\n          <td id=\"LC251\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">StringUtils</span><span class=\"pl-k\">.</span>isNotBlank(logoUUID) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>http://<span class=\"pl-pds\">\"</span></span>) <span class=\"pl-k\">&amp;&amp;</span> <span class=\"pl-k\">!</span>logoUUID<span class=\"pl-k\">.</span>startsWith(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>https//<span class=\"pl-pds\">\"</span></span>)) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L252\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"252\"></td>\n          <td id=\"LC252\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         image <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>getImage(serviceContext, logoUUID, logosDir); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L253\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"253\"></td>\n          <td id=\"LC253\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">if</span> (image <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L254\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"254\"></td>\n          <td id=\"LC254\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">             image <span class=\"pl-k\">=</span> resources<span class=\"pl-k\">.</span>getImage(serviceContext, logoUUID, harvesterLogosDir); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L255\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"255\"></td>\n          <td id=\"LC255\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L256\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"256\"></td>\n          <td id=\"LC256\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     } </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L257\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"257\"></td>\n          <td id=\"LC257\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> image; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L258\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"258\"></td>\n          <td id=\"LC258\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n)</p>\n<p dir=\"auto\">Is this due to the way of creating the <code>ServiceContext</code> (<code>serviceManager.createServiceContext</code> vs <code>ApiUtils.createServiceContext</code>)?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:35:13Z", "path": "services/src/main/java/org/fao/geonet/api/records/formatters/Register.java", "diffHunk": "@@ -145,6 +145,7 @@ public JSONObject serviceSpecificExec(HttpServletRequest request,\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n+            context.clear();", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5NDk0MA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547094940", "bodyText": "I expect more instances of clear() can be added over time, especially if you can confirm how it is used.", "author": "jodygarnett", "createdAt": "2020-12-22T06:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwODYxNg=="}], "type": "inlineReview", "revised_code": {"commit": "28605f0b877e44ea7fe5c31661b094e160382973", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 8dfc52b306..26bdbb31ec 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -145,7 +145,6 @@ public class Register extends AbstractFormatService {\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n-            context.clear();\n         }\n     }\n \n", "next_change": {"commit": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 26bdbb31ec..510923b4ee 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -146,6 +147,9 @@ public class Register extends AbstractFormatService {\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n         }\n+      } finally {\n+        context.clear();\n+      }\n     }\n \n     private Path findViewXslContainerDir(Path dir) throws IOException {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 8dfc52b306..510923b4ee 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -145,8 +146,10 @@ public class Register extends AbstractFormatService {\n             return response;\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n-            context.clear();\n         }\n+      } finally {\n+        context.clear();\n+      }\n     }\n \n     private Path findViewXslContainerDir(Path dir) throws IOException {\n", "next_change": {"commit": "721f0b78604fbaa698c29dafc5f961ef47c710f3", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\nindex 510923b4ee..729ce1a4e3 100644\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n", "chunk": "@@ -147,9 +146,6 @@ public class Register extends AbstractFormatService {\n         } finally {\n             IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n         }\n-      } finally {\n-        context.clear();\n-      }\n     }\n \n     private Path findViewXslContainerDir(Path dir) throws IOException {\n", "next_change": {"commit": "64a59a6936ed7400c34dfe0b56fdeaf1826462cc", "changed_code": [{"header": "diff --git a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java b/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\ndeleted file mode 100644\nindex 729ce1a4e3..0000000000\n--- a/services/src/main/java/org/fao/geonet/api/records/formatters/Register.java\n+++ /dev/null\n", "chunk": "@@ -1,226 +0,0 @@\n-//==============================================================================\n-//===\tCopyright (C) 2001-2008 Food and Agriculture Organization of the\n-//===\tUnited Nations (FAO-UN), United Nations World Food Programme (WFP)\n-//===\tand United Nations Environment Programme (UNEP)\n-//===\n-//===\tThis program is free software; you can redistribute it and/or modify\n-//===\tit under the terms of the GNU General Public License as published by\n-//===\tthe Free Software Foundation; either version 2 of the License, or (at\n-//===\tyour option) any later version.\n-//===\n-//===\tThis program is distributed in the hope that it will be useful, but\n-//===\tWITHOUT ANY WARRANTY; without even the implied warranty of\n-//===\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n-//===\tGeneral Public License for more details.\n-//===\n-//===\tYou should have received a copy of the GNU General Public License\n-//===\talong with this program; if not, write to the Free Software\n-//===\tFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n-//===\n-//===\tContact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n-//===\tRome - Italy. email: geonetwork@osgeo.org\n-//==============================================================================\n-\n-package org.fao.geonet.api.records.formatters;\n-\n-import com.google.common.io.ByteStreams;\n-\n-import com.vividsolutions.jts.util.Assert;\n-\n-import net.sf.json.JSONObject;\n-\n-import org.fao.geonet.ApplicationContextHolder;\n-import org.fao.geonet.Constants;\n-import org.fao.geonet.ZipUtil;\n-import org.fao.geonet.constants.Geonet;\n-import org.fao.geonet.constants.Params;\n-import org.fao.geonet.kernel.GeonetworkDataDirectory;\n-import org.fao.geonet.utils.FilePathChecker;\n-import org.fao.geonet.utils.IO;\n-import org.fao.oaipmh.exceptions.BadArgumentException;\n-import org.springframework.http.MediaType;\n-import org.springframework.stereotype.Controller;\n-import org.springframework.web.bind.annotation.PathVariable;\n-import org.springframework.web.bind.annotation.RequestMapping;\n-import org.springframework.web.bind.annotation.RequestParam;\n-import org.springframework.web.bind.annotation.ResponseBody;\n-import org.springframework.web.multipart.MultipartFile;\n-\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.FileSystem;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Iterator;\n-\n-import javax.servlet.http.HttpServletRequest;\n-\n-import jeeves.server.context.ServiceContext;\n-import jeeves.server.dispatchers.ServiceManager;\n-import jeeves.services.ReadWriteController;\n-\n-import static org.fao.geonet.api.records.formatters.FormatterConstants.VIEW_XSL_FILENAME;\n-\n-/**\n- * Upload a formatter bundle.  Uploaded file can be a single xsl or a zip file containing resources\n- * as well as the xsl file.  If a zip the zip must contain view.xsl which is the root xsl file.\n- *\n- * The  zip file can be flat or contain a single directory.\n- *\n- * @author jeichar\n- */\n-@Controller\n-@ReadWriteController\n-public class Register extends AbstractFormatService {\n-\n-\n-    @RequestMapping(value = {\"/{portal}/{lang}/md.formatter.register\"}, produces = {MediaType.APPLICATION_JSON_VALUE})\n-    @ResponseBody\n-    public JSONObject serviceSpecificExec(HttpServletRequest request,\n-                                          @PathVariable String lang,\n-                                          @RequestParam(value = Params.ID, required = false) String xslid,\n-                                          @RequestParam(Params.FNAME) MultipartFile file\n-    ) throws Exception {\n-\n-        ServiceManager serviceManager = ApplicationContextHolder.get().getBean(ServiceManager.class);\n-        ServiceContext context = serviceManager.createServiceContext(\"md.formatter.register\", lang, request);\n-\n-        if (xslid == null) {\n-            xslid = file.getOriginalFilename();\n-            int extentionIdx = xslid.lastIndexOf('.');\n-            if (extentionIdx != -1) {\n-                xslid = xslid.substring(0, extentionIdx);\n-            }\n-        }\n-\n-        FilePathChecker.verify(xslid);\n-        FilePathChecker.verify(file.getOriginalFilename());\n-\n-        checkLegalId(Params.ID, xslid);\n-        Path userXslDir = context.getBean(GeonetworkDataDirectory.class).getFormatterDir();\n-        Path newBundle = userXslDir.resolve(xslid);\n-\n-        Path uploadedFile = context.getUploadDir().resolve(file.getOriginalFilename());\n-        byte[] data = ByteStreams.toByteArray(file.getInputStream());\n-        Files.write(uploadedFile, data);\n-\n-        try {\n-            Files.createDirectories(newBundle);\n-\n-            try (FileSystem zipFs = ZipUtil.openZipFs(uploadedFile)) {\n-                Path viewFile = findViewFile(zipFs);\n-                if (viewFile == null) {\n-                    throw new BadArgumentException(\n-                        \"A formatter zip file must contain a \" + VIEW_XSL_FILENAME + \" file as one of its root files\");\n-                }\n-\n-                Path viewXslContainerDir = null;\n-                for (Path root : zipFs.getRootDirectories()) {\n-                    viewXslContainerDir = findViewXslContainerDir(root);\n-                    if (viewXslContainerDir != null) {\n-                        break;\n-                    }\n-                }\n-\n-                if (viewXslContainerDir == null) {\n-                    throw new IllegalArgumentException(uploadedFile + \" does not have a view.xsl file within it\");\n-                }\n-\n-                IO.copyDirectoryOrFile(viewXslContainerDir, newBundle, false);\n-\n-            } catch (IllegalArgumentException | UnsupportedOperationException e) {\n-                handleRawXsl(uploadedFile, newBundle);\n-            } catch (Exception e) {\n-                IO.deleteFileOrDirectory(newBundle);\n-                throw e;\n-            }\n-\n-            addOptionalFiles(newBundle);\n-\n-            JSONObject response = new JSONObject();\n-            response.put(\"success\", true);\n-            response.put(\"id\", xslid);\n-\n-            return response;\n-        } finally {\n-            IO.deleteFile(uploadedFile, false, Geonet.FORMATTER);\n-        }\n-    }\n-\n-    private Path findViewXslContainerDir(Path dir) throws IOException {\n-        if (Files.exists(dir.resolve(FormatterConstants.VIEW_XSL_FILENAME))) {\n-            return dir;\n-        }\n-\n-        try (DirectoryStream<Path> paths = Files.newDirectoryStream(dir, IO.DIRECTORIES_FILTER)) {\n-            for (Path childDir : paths) {\n-                Path container = findViewXslContainerDir(childDir);\n-                if (container != null) {\n-                    return container;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private Path findViewFile(FileSystem zipFs) throws IOException {\n-        Path rootView = zipFs.getPath(VIEW_XSL_FILENAME);\n-        if (Files.exists(rootView)) {\n-            return rootView;\n-        }\n-        final String groovyView = \"view.groovy\";\n-        rootView = zipFs.getPath(groovyView);\n-        if (Files.exists(rootView)) {\n-            return rootView;\n-        }\n-        final Path rootDir = zipFs.getRootDirectories().iterator().next();\n-        try (DirectoryStream<Path> dirs = Files.newDirectoryStream(rootDir, IO.DIRECTORIES_FILTER)) {\n-            Iterator<Path> dirIter = dirs.iterator();\n-            if (dirIter.hasNext()) {\n-                Path next = dirIter.next();\n-                Assert.isTrue(!dirIter.hasNext(),\n-                    \"The formatter/view zip file must either have a single root directory which contains the view file or \" +\n-                        \"it must have all formatter resources at the root of the directory\");\n-                rootView = next.resolve(VIEW_XSL_FILENAME);\n-                if (Files.exists(rootView)) {\n-                    return rootView;\n-                }\n-                rootView = next.resolve(groovyView);\n-                if (Files.exists(rootView)) {\n-                    return rootView;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private void addOptionalFiles(Path file) throws IOException {\n-        ConfigFile.generateDefault(file);\n-\n-        final Path locDir = file.resolve(\"loc\");\n-        if (!Files.exists(locDir)) {\n-            Files.createDirectories(locDir);\n-            try (PrintStream out = new PrintStream(Files.newOutputStream(locDir.resolve(\"README\")), true, Constants.ENCODING)) {\n-                out.println(\"If a formatter requires localization that cannot be found in strings or schema \");\n-                out.println(\"localization the format bundle can have a loc subfolder containing translations.\");\n-                out.println(\"\");\n-                out.println(\"The xml document created will have the xml files from loc/<currentLoc>/ added to\");\n-                out.println(\"xml documentation under the /root/resources tag.\");\n-                out.println(\"\");\n-                out.println(\"If a localization folder is not found then the default language will be used.  \");\n-                out.println(\"if the default language also does not exist then the first localization will be used\");\n-                out.println(\"but it is recommended to always have the default language localization\");\n-                out.println(\"(unless language is fixed in the config.properties)\");\n-            }\n-        }\n-    }\n-\n-    private void handleRawXsl(Path uploadedFile, Path dir) throws IOException {\n-        Files.createDirectories(dir);\n-        IO.moveDirectoryOrFile(uploadedFile, dir.resolve(VIEW_XSL_FILENAME), false);\n-    }\n-\n-}\n-\n-\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}, {"oid": "721f0b78604fbaa698c29dafc5f961ef47c710f3", "committedDate": "2019-11-01 12:17:58 +0100", "message": "Merge remote-tracking branch 'origin/master' into es"}, {"oid": "b76bd72db042baf7093475bf4a2b2eece8fcbbd6", "committedDate": "2020-05-05 16:24:25 +0200", "message": "Merge remote-tracking branch 'origin/master' into 4.0.x"}, {"oid": "3fa8fd9d486bc4927abc183caa019afa61f8455e", "committedDate": "2020-06-10 18:01:21 +0200", "message": "Open API migration."}, {"oid": "d965b201480b658ff243e171aab6365d85293cb1", "committedDate": "2020-06-10 18:02:57 +0200", "message": "Open API doc + Swagger UI."}, {"oid": "64a59a6936ed7400c34dfe0b56fdeaf1826462cc", "committedDate": "2021-08-10 11:55:33 +0200", "message": "Formatter / Admin API / Migrate to Spring. (#5905)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r546709358", "body": "This code seem more for testing?", "bodyText": "This code seem more for testing?", "bodyHTML": "<p dir=\"auto\">This code seem more for testing?</p>", "author": "josegar74", "createdAt": "2020-12-21T13:36:42Z", "path": "web/src/main/java/org/fao/geonet/GeonetworkHttpSessionListener.java", "diffHunk": "@@ -0,0 +1,111 @@\n+//=============================================================================\n+//===\tCopyright (C) 2001-2007 Food and Agriculture Organization of the\n+//===\tUnited Nations (FAO-UN), United Nations World Food Programme (WFP)\n+//===\tand United Nations Environment Programme (UNEP)\n+//===\n+//===\tThis program is free software; you can redistribute it and/or modify\n+//===\tit under the terms of the GNU General Public License as published by\n+//===\tthe Free Software Foundation; either version 2 of the License, or (at\n+//===\tyour option) any later version.\n+//===\n+//===\tThis program is distributed in the hope that it will be useful, but\n+//===\tWITHOUT ANY WARRANTY; without even the implied warranty of\n+//===\tMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+//===\tGeneral Public License for more details.\n+//===\n+//===\tYou should have received a copy of the GNU General Public License\n+//===\talong with this program; if not, write to the Free Software\n+//===\tFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+//===\n+//===\tContact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+//===\tRome - Italy. email: geonetwork@osgeo.org\n+//==============================================================================\n+package org.fao.geonet;\n+\n+import jeeves.config.springutil.JeevesApplicationContext;\n+import jeeves.constants.Jeeves;\n+import jeeves.server.UserSession;\n+import org.fao.geonet.utils.Log;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.http.HttpSession;\n+import javax.servlet.http.HttpSessionEvent;\n+import javax.servlet.http.HttpSessionListener;\n+import java.util.Enumeration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Used to keep track of the number of active sessions.\\\n+ */\n+public class GeonetworkHttpSessionListener implements HttpSessionListener {", "originalCommit": "a3d4cdbe4c1b12da622a503a9be91f352ebba15c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA5MDQyMw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5260#discussion_r547090423", "bodyText": "It produces debug log messages that can be enabled in the field if needed", "author": "jodygarnett", "createdAt": "2020-12-22T06:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjcwOTM1OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "2c125906a3ac04a43abd5a83118b00d333ce0e98", "message": "Merge commit", "committedDate": null}]}, {"oid": "9cebf79164064053563624e367a26a52a109c387", "url": "https://github.com/geonetwork/core-geonetwork/commit/9cebf79164064053563624e367a26a52a109c387", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-01-05T20:20:07Z", "type": "forcePushed"}, {"oid": "a908c404ad2563809a67a9ebe71a3ce507531ef7", "url": "https://github.com/geonetwork/core-geonetwork/commit/a908c404ad2563809a67a9ebe71a3ce507531ef7", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-01-08T15:35:37Z", "type": "forcePushed"}, {"oid": "28605f0b877e44ea7fe5c31661b094e160382973", "url": "https://github.com/geonetwork/core-geonetwork/commit/28605f0b877e44ea7fe5c31661b094e160382973", "message": "Add debug logging for HTTP session created / destroyed\n\nUsed to track potential service context leaks.", "committedDate": "2021-02-23T22:17:37Z", "type": "commit"}, {"oid": "b8103a85dd637545b8ab5ef75f0c4b17bf745622", "url": "https://github.com/geonetwork/core-geonetwork/commit/b8103a85dd637545b8ab5ef75f0c4b17bf745622", "message": "ServiceLocator API contract for setAsThreadLocal() / clearAsThreadLocal() / clear()\n\nDocument api contract with respect to clearing up thread local use.", "committedDate": "2021-02-23T22:17:55Z", "type": "commit"}, {"oid": "fad3719aea04704cd7fee77b5d6333bc033a5f62", "url": "https://github.com/geonetwork/core-geonetwork/commit/fad3719aea04704cd7fee77b5d6333bc033a5f62", "message": "Introduce try / finally managmeent of ServiceContext", "committedDate": "2021-02-24T00:05:18Z", "type": "commit"}, {"oid": "210b97b3d149bc504475f0de966060190d3e1a42", "url": "https://github.com/geonetwork/core-geonetwork/commit/210b97b3d149bc504475f0de966060190d3e1a42", "message": "Clear XFrameOptionsFilter cache", "committedDate": "2021-02-24T00:08:28Z", "type": "commit"}, {"oid": "e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "url": "https://github.com/geonetwork/core-geonetwork/commit/e3fc0b3310f9a4d8889005c968a7c90ebfb8d66e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T00:22:48Z", "type": "forcePushed"}, {"oid": "f98fb566bc604e5eb609a389b65889cd062b946b", "url": "https://github.com/geonetwork/core-geonetwork/commit/f98fb566bc604e5eb609a389b65889cd062b946b", "message": "Introduce try / finally service context cleanup to tests", "committedDate": "2021-02-24T05:14:25Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "commit"}, {"oid": "9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "url": "https://github.com/geonetwork/core-geonetwork/commit/9acb3fb8264b56bd8db3ecc546c6221f9dbe115e", "message": "Default to TRACE logging unusual service context use\n\nFor backport use of DIRECT is recommended.", "committedDate": "2021-02-24T05:14:41Z", "type": "forcePushed"}]}