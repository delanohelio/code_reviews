{"pr_number": 1111, "pr_title": "Optimize: add dedicated BeaconSate cache container, add active validators cache", "pr_author": "Nashatyrev", "pr_createdAt": "2020-01-23T10:47:55Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1111", "merge_commit": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "timeline": [{"oid": "bcc60315ad654d49d500f7c8d8301cba935d6426", "url": "https://github.com/ConsenSys/teku/commit/bcc60315ad654d49d500f7c8d8301cba935d6426", "message": "Add activeValidatorsCache (naive static implementation)", "committedDate": "2020-01-23T09:19:23Z", "type": "commit"}, {"oid": "d724d3aab1f020d1c4b7aa71e87e39f9b1e9d69c", "url": "https://github.com/ConsenSys/teku/commit/d724d3aab1f020d1c4b7aa71e87e39f9b1e9d69c", "message": "Add TransitionCaches to the BeaconChainWithCache", "committedDate": "2020-01-23T09:27:26Z", "type": "commit"}, {"oid": "89d375ca06891b1d214094ac0a7beff94afc99cf", "url": "https://github.com/ConsenSys/teku/commit/89d375ca06891b1d214094ac0a7beff94afc99cf", "message": "Move activeValidators cache from ValidatorUtils statics to the TransitionsCache instance", "committedDate": "2020-01-23T09:27:43Z", "type": "commit"}, {"oid": "8588b1d60b72857ff10ec1a7e0130f2ea1990d0f", "url": "https://github.com/ConsenSys/teku/commit/8588b1d60b72857ff10ec1a7e0130f2ea1990d0f", "message": "Make LRUCache to evict last inserted entry instead of last accessed, since it is more appropriate for transition logic", "committedDate": "2020-01-23T09:50:49Z", "type": "commit"}, {"oid": "84ecfd1a24c5d394b183b526febce60a8c3e6776", "url": "https://github.com/ConsenSys/teku/commit/84ecfd1a24c5d394b183b526febce60a8c3e6776", "message": "Add javadocs", "committedDate": "2020-01-23T09:51:02Z", "type": "commit"}, {"oid": "c88eecc073a94bde9a3312e28730fbf69d59c7a7", "url": "https://github.com/ConsenSys/teku/commit/c88eecc073a94bde9a3312e28730fbf69d59c7a7", "message": "Apply spotless", "committedDate": "2020-01-23T10:55:07Z", "type": "commit"}, {"oid": "9a0a51f476df20d56fc11468af7d31b499365b30", "url": "https://github.com/ConsenSys/teku/commit/9a0a51f476df20d56fc11468af7d31b499365b30", "message": "Fix compiler warnings", "committedDate": "2020-01-23T11:36:38Z", "type": "commit"}, {"oid": "04f9319220e4e56f1c3b85dac1ab8f77595c25e5", "url": "https://github.com/ConsenSys/teku/commit/04f9319220e4e56f1c3b85dac1ab8f77595c25e5", "message": "Make LRUCache.copy() method thread-safe", "committedDate": "2020-01-23T12:54:11Z", "type": "commit"}, {"oid": "cfa0829bcbc02347f177b19f665d1bf927ddfbff", "url": "https://github.com/ConsenSys/teku/commit/cfa0829bcbc02347f177b19f665d1bf927ddfbff", "message": "Blocks generator: use the right keys source", "committedDate": "2020-01-23T13:14:05Z", "type": "commit"}, {"oid": "07206583d6e2e5b0df720ebcda3076328228c1b0", "url": "https://github.com/ConsenSys/teku/commit/07206583d6e2e5b0df720ebcda3076328228c1b0", "message": "Re-generate benchmark blocks for 0.9.4", "committedDate": "2020-01-23T13:48:36Z", "type": "commit"}, {"oid": "dad2554ecba9653bae9a6669c33652cda3ff3198", "url": "https://github.com/ConsenSys/teku/commit/dad2554ecba9653bae9a6669c33652cda3ff3198", "message": "Remove debug blocks printing", "committedDate": "2020-01-23T13:49:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyODA1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370328057", "body": "Could this just use `LimitedHashMap`?  The static block to add initialCachedContent would just have to be done after construction but that should be safe since we're still in the constructor so no other operations can be happening.", "bodyText": "Could this just use LimitedHashMap?  The static block to add initialCachedContent would just have to be done after construction but that should be safe since we're still in the constructor so no other operations can be happening.", "bodyHTML": "<p dir=\"auto\">Could this just use <code>LimitedHashMap</code>?  The static block to add initialCachedContent would just have to be done after construction but that should be safe since we're still in the constructor so no other operations can be happening.</p>", "author": "ajsutton", "createdAt": "2020-01-23T20:04:56Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.util.cache;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Cache made around LRU-map with fixed size, removing eldest entries (by added) when the space is\n+ * over\n+ *\n+ * @param <K> Keys type\n+ * @param <V> Values type\n+ */\n+public class LRUCache<K, V> implements Cache<K, V> {\n+\n+  private final Map<K, V> cacheData;\n+  private final int maxCapacity;\n+\n+  /**\n+   * Creates cache\n+   *\n+   * @param capacity Size of the cache\n+   */\n+  public LRUCache(int capacity) {\n+    this(capacity, Collections.emptyMap());\n+  }\n+\n+  private LRUCache(int capacity, Map<K, V> initialCachedContent) {\n+    this.maxCapacity = capacity;\n+    this.cacheData =\n+        Collections.synchronizedMap(\n+            new LinkedHashMap<>(maxCapacity + 1) {", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwMDUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370500539", "bodyText": "Yep \ud83d\udc4d\nDone: 19d72bc", "author": "Nashatyrev", "createdAt": "2020-01-24T07:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyODA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "19d72bc794a3046bed74b5f9380a3bff80835604", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\nindex 3dc87063d..f8f87c6ea 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n", "chunk": "@@ -45,18 +44,12 @@ public class LRUCache<K, V> implements Cache<K, V> {\n     this.maxCapacity = capacity;\n     this.cacheData =\n         Collections.synchronizedMap(\n-            new LinkedHashMap<>(maxCapacity + 1) {\n+            new LimitedHashMap<>(maxCapacity) {\n               {\n                 synchronized (initialCachedContent) {\n                   putAll(initialCachedContent);\n                 }\n               }\n-\n-              // This method is called just after a new entry has been added\n-              @Override\n-              protected boolean removeEldestEntry(Entry<K, V> eldest) {\n-                return size() > maxCapacity;\n-              }\n             });\n   }\n \n", "next_change": {"commit": "aa4a266eca9b4da95137bca8c8645c8137f6b643", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\nindex f8f87c6ea..334805549 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n", "chunk": "@@ -42,15 +42,12 @@ public class LRUCache<K, V> implements Cache<K, V> {\n \n   private LRUCache(int capacity, Map<K, V> initialCachedContent) {\n     this.maxCapacity = capacity;\n-    this.cacheData =\n-        Collections.synchronizedMap(\n-            new LimitedHashMap<>(maxCapacity) {\n-              {\n-                synchronized (initialCachedContent) {\n-                  putAll(initialCachedContent);\n-                }\n-              }\n-            });\n+    LimitedHashMap<K, V> cacheMap = new LimitedHashMap<>(maxCapacity);\n+    // copy safely, initialCachedContent is always a SynchronizedMap instance\n+    synchronized (initialCachedContent) {\n+      cacheMap.putAll(initialCachedContent);\n+    }\n+    this.cacheData = Collections.synchronizedMap(cacheMap);\n   }\n \n   @Override\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\nindex 3dc87063d..334805549 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n", "chunk": "@@ -43,21 +42,12 @@ public class LRUCache<K, V> implements Cache<K, V> {\n \n   private LRUCache(int capacity, Map<K, V> initialCachedContent) {\n     this.maxCapacity = capacity;\n-    this.cacheData =\n-        Collections.synchronizedMap(\n-            new LinkedHashMap<>(maxCapacity + 1) {\n-              {\n-                synchronized (initialCachedContent) {\n-                  putAll(initialCachedContent);\n-                }\n-              }\n-\n-              // This method is called just after a new entry has been added\n-              @Override\n-              protected boolean removeEldestEntry(Entry<K, V> eldest) {\n-                return size() > maxCapacity;\n-              }\n-            });\n+    LimitedHashMap<K, V> cacheMap = new LimitedHashMap<>(maxCapacity);\n+    // copy safely, initialCachedContent is always a SynchronizedMap instance\n+    synchronized (initialCachedContent) {\n+      cacheMap.putAll(initialCachedContent);\n+    }\n+    this.cacheData = Collections.synchronizedMap(cacheMap);\n   }\n \n   @Override\n", "next_change": {"commit": "05eea4d890ece90fbcf46a247d865c68991196f0", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\nindex 334805549..807ec27d0 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java\n", "chunk": "@@ -42,12 +43,13 @@ public class LRUCache<K, V> implements Cache<K, V> {\n \n   private LRUCache(int capacity, Map<K, V> initialCachedContent) {\n     this.maxCapacity = capacity;\n-    LimitedHashMap<K, V> cacheMap = new LimitedHashMap<>(maxCapacity);\n+    Map<K, V> cacheMap =\n+        ConcurrentLimitedMap.create(maxCapacity, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n     // copy safely, initialCachedContent is always a SynchronizedMap instance\n     synchronized (initialCachedContent) {\n       cacheMap.putAll(initialCachedContent);\n     }\n-    this.cacheData = Collections.synchronizedMap(cacheMap);\n+    this.cacheData = cacheMap;\n   }\n \n   @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "message": "Merge commit", "committedDate": null}, {"oid": "e559468f9ae1aa767e29764d1b95a9a438f7538d", "committedDate": "2020-03-04 11:37:15 +0300", "message": "Remerkable (Binary backing tree) initial implementation (#1133)"}, {"oid": "ed59c1324b1e18260e48994b0138088c8ae7c775", "committedDate": "2020-03-20 14:56:19 +1000", "message": "Add cache for public key -> validator index (#1426)"}, {"oid": "05eea4d890ece90fbcf46a247d865c68991196f0", "committedDate": "2020-03-31 10:52:18 -0400", "message": "[Minor] Make LRUCache use LRU strategy (#1505)"}, {"oid": "73c6879b29c87b835786d7a3f1d010eccd4f1991", "committedDate": "2020-04-03 18:57:08 +0300", "message": "Optimize backing views (#1465)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370329348", "body": "I was going to suggest we consider using the Guava cache libraries rather than writing our own, but their version of `Cache.get` throws a checked exception to allow the fallback function to throw checked exceptions which makes using the cache kind of awful.", "bodyText": "I was going to suggest we consider using the Guava cache libraries rather than writing our own, but their version of Cache.get throws a checked exception to allow the fallback function to throw checked exceptions which makes using the cache kind of awful.", "bodyHTML": "<p dir=\"auto\">I was going to suggest we consider using the Guava cache libraries rather than writing our own, but their version of <code>Cache.get</code> throws a checked exception to allow the fallback function to throw checked exceptions which makes using the cache kind of awful.</p>", "author": "ajsutton", "createdAt": "2020-01-23T20:08:04Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/cache/LRUCache.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.util.cache;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+/**\n+ * Cache made around LRU-map with fixed size, removing eldest entries (by added) when the space is\n+ * over\n+ *\n+ * @param <K> Keys type\n+ * @param <V> Values type\n+ */\n+public class LRUCache<K, V> implements Cache<K, V> {", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5OTU3OA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370499578", "bodyText": "Heh, looks like we are on the same camp regarding checked exceptions :)\nNever used Guava caches, but we may consider them for more advanced use cases. This one is pretty simple and straightforward.", "author": "Nashatyrev", "createdAt": "2020-01-24T07:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDczMDM4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370730381", "bodyText": "Just wondering, why do you guys not like checked exceptions? To be able to handle a wider array of exceptions at a higher level?", "author": "cemozerr", "createdAt": "2020-01-24T16:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3OTIyMw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370879223", "bodyText": "Checked exceptions can wind up requiring a lot of boilerplate try/catch code that makes it hard to follow control flow well.  If there's an error condition that really does need to be handled (e.g. block failing to import) then my first preference would be return a success or error result but if that's not feasible for some reason then I would use a checked exception. I wouldn't want to use an unchecked exception for something that really needs to be handled (the fact that most of the spec code throws unchecked exceptions when it fails is slightly terrifying).\nThings change a bit when working with CompletableFuture because unchecked exceptions get picked up as failed results so well and checked exceptions are even more annoying since methods like thenApply take a function and don't allow throwing checked exceptions.\nSo it's one of those highly context dependent rules...\nThe most annoying thing about checked exceptions though is when a method declares a checked exception that it really shouldn't ever throw.  Which is what happens with guava's cache get method.  It declares a checked exception so that it can allow the fallback function to throw a checked exception, but our actual fallback function shouldn't ever throw any exception so we wind up being forced to handle a checked exception that shouldn't ever be thrown so there's really nothing useful we can do once we catch it. Lots of boiler plate code and no actual value.", "author": "ajsutton", "createdAt": "2020-01-24T23:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4ODEzMQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r371988131", "bodyText": "That's interesting and great to know. Thank you very much for the detailed explanation @ajsutton", "author": "cemozerr", "createdAt": "2020-01-28T18:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMzM2MA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r372223360", "bodyText": "@cemozerr\nFrom my personal experience the major part of checked exception handlings looks like\ncatch (SomeCheckedException e) {\n  throw new SomeUncheckedException(e);\n}\nIn the best case it's\ncatch (SomeCheckedException e) {\n  throw new SomeUncheckedException(\"Error while doing that: \" + that, e);\n}\nThis is because the major part of exceptions are actually unrecoverable at a lower level from one side and from another side it doesn't make too much sense when a higher level method declares throws a bunch of irrelevant checked exceptions.\nAgree with @ajsutton that in major cases dealing with unchecked exceptions is just a lot of boilerplate code unfortunately.\nBut there were always two opposite camps of developers regarding checked exception and of course they are both right at some point", "author": "Nashatyrev", "createdAt": "2020-01-29T07:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyOTM0OA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "message": "Merge commit", "committedDate": null}, {"oid": "e559468f9ae1aa767e29764d1b95a9a438f7538d", "committedDate": "2020-03-04 11:37:15 +0300", "message": "Remerkable (Binary backing tree) initial implementation (#1133)"}, {"oid": "ed59c1324b1e18260e48994b0138088c8ae7c775", "committedDate": "2020-03-20 14:56:19 +1000", "message": "Add cache for public key -> validator index (#1426)"}, {"oid": "05eea4d890ece90fbcf46a247d865c68991196f0", "committedDate": "2020-03-31 10:52:18 -0400", "message": "[Minor] Make LRUCache use LRU strategy (#1505)"}, {"oid": "73c6879b29c87b835786d7a3f1d010eccd4f1991", "committedDate": "2020-04-03 18:57:08 +0300", "message": "Optimize backing views (#1465)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370347206", "body": "This works and I like how it winds up with very minimal changes, but I wonder if as we introduce more caches we'll wind up with a lot of boilerplate in getting the caches etc obscuring the actual business logic.\r\n\r\nI think we should land this as-is, but I am wondering if we could be a bit radical here and take advantage of polymorphism.  https://github.com/PegaSysEng/artemis/commit/1144a564f684cd8d47c5d09a1323a83ab1a700e3 is what I have in mind.  If `BeaconState` provided a `getActiveValidatorIndices` method with the actual spec logic, then `BeaconStateWithCache` could just override that method to check the cache first.  Feels really nice and clean in many ways.\r\n\r\nBut there's a couple of downsides:\r\n1. Not sure this scales well - we could wind up with half the transition code in `BeaconState`.\r\n2. I don't see this playing well with hard forks after launch (neither does our current approach)\r\n\r\nWhich I think is enough to talk me out of it, and that it's better for classes like `ValidatorUtils` to use actual instances rather than all static methods - then this polymorphism approach could be used there, and different implementations could be provided for different hard forks, but that's a bigger scope of work.\r\n\r\nYou can safely ignore this for now if you like, I just keep pondering how we need to evolve the design to be more flexible in the future...  Happy to hear any thoughts anyone has though.", "bodyText": "This works and I like how it winds up with very minimal changes, but I wonder if as we introduce more caches we'll wind up with a lot of boilerplate in getting the caches etc obscuring the actual business logic.\nI think we should land this as-is, but I am wondering if we could be a bit radical here and take advantage of polymorphism.  1144a56 is what I have in mind.  If BeaconState provided a getActiveValidatorIndices method with the actual spec logic, then BeaconStateWithCache could just override that method to check the cache first.  Feels really nice and clean in many ways.\nBut there's a couple of downsides:\n\nNot sure this scales well - we could wind up with half the transition code in BeaconState.\nI don't see this playing well with hard forks after launch (neither does our current approach)\n\nWhich I think is enough to talk me out of it, and that it's better for classes like ValidatorUtils to use actual instances rather than all static methods - then this polymorphism approach could be used there, and different implementations could be provided for different hard forks, but that's a bigger scope of work.\nYou can safely ignore this for now if you like, I just keep pondering how we need to evolve the design to be more flexible in the future...  Happy to hear any thoughts anyone has though.", "bodyHTML": "<p dir=\"auto\">This works and I like how it winds up with very minimal changes, but I wonder if as we introduce more caches we'll wind up with a lot of boilerplate in getting the caches etc obscuring the actual business logic.</p>\n<p dir=\"auto\">I think we should land this as-is, but I am wondering if we could be a bit radical here and take advantage of polymorphism.  <a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/ConsenSys/teku/commit/1144a564f684cd8d47c5d09a1323a83ab1a700e3/hovercard\" href=\"https://github.com/ConsenSys/teku/commit/1144a564f684cd8d47c5d09a1323a83ab1a700e3\"><tt>1144a56</tt></a> is what I have in mind.  If <code>BeaconState</code> provided a <code>getActiveValidatorIndices</code> method with the actual spec logic, then <code>BeaconStateWithCache</code> could just override that method to check the cache first.  Feels really nice and clean in many ways.</p>\n<p dir=\"auto\">But there's a couple of downsides:</p>\n<ol dir=\"auto\">\n<li>Not sure this scales well - we could wind up with half the transition code in <code>BeaconState</code>.</li>\n<li>I don't see this playing well with hard forks after launch (neither does our current approach)</li>\n</ol>\n<p dir=\"auto\">Which I think is enough to talk me out of it, and that it's better for classes like <code>ValidatorUtils</code> to use actual instances rather than all static methods - then this polymorphism approach could be used there, and different implementations could be provided for different hard forks, but that's a bigger scope of work.</p>\n<p dir=\"auto\">You can safely ignore this for now if you like, I just keep pondering how we need to evolve the design to be more flexible in the future...  Happy to hear any thoughts anyone has though.</p>", "author": "ajsutton", "createdAt": "2020-01-23T20:50:18Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -100,11 +101,17 @@ public static boolean is_eligible_for_activation(BeaconState state, Validator va\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Validator> validators = state.getValidators();\n-    return IntStream.range(0, validators.size())\n-        .filter(index -> is_active_validator(validators.get(index), epoch))\n-        .boxed()\n-        .collect(Collectors.toList());\n+    return BeaconStateWithCache.getTransitionCaches(state)\n+        .getActiveValidators()\n+        .get(\n+            epoch,\n+            e -> {\n+              List<Validator> validators = state.getValidators();\n+              return IntStream.range(0, validators.size())\n+                  .filter(index -> is_active_validator(validators.get(index), epoch))\n+                  .boxed()\n+                  .collect(Collectors.toList());\n+            });", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwMzQxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370503415", "bodyText": "Yep, I see what you mean and totally support this approach. The spec procedural style contradicts Java OOP. But we are still sticking to it to be closer to the original spec to easy follow spec changes.\nI think at some point this is absolutely must have, but suppose this should be a separate large refactoring and we could start it from your suggested change", "author": "Nashatyrev", "createdAt": "2020-01-24T07:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3NzE0MA==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370877140", "bodyText": "Yeah agreed, out of scope for this PR.", "author": "ajsutton", "createdAt": "2020-01-24T22:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0NzIwNg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "c61f4083cc8b2a6e835d4e8e33162a329fd7ffee", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\nindex 78e3c6513..ad11eb0f7 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\n", "chunk": "@@ -114,23 +89,6 @@ public class ValidatorsUtil {\n             });\n   }\n \n-  /**\n-   * find all validators not present in the provided list\n-   *\n-   * @param validator_indices\n-   * @return\n-   */\n-  public static List<Integer> get_validators_not_present(List<Integer> validator_indices) {\n-    List<Integer> all_indices =\n-        IntStream.range(0, validator_indices.size()).boxed().collect(Collectors.toList());\n-    Set<Integer> set_of_indices = Sets.newHashSet(all_indices);\n-    Set<Integer> set_of_validator_indices = Sets.newHashSet(validator_indices);\n-    // remove all validator indices provided and we are left with validator indices not present in\n-    // the list provided\n-    set_of_indices.removeAll(set_of_validator_indices);\n-    return new ArrayList<>(set_of_indices);\n-  }\n-\n   /**\n    * Decrease validator balance by ``delta`` with underflow protection.\n    *\n", "next_change": {"commit": "ed59c1324b1e18260e48994b0138088c8ae7c775", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\nindex ad11eb0f7..026199439 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java\n", "chunk": "@@ -89,6 +93,28 @@ public class ValidatorsUtil {\n             });\n   }\n \n+  public static Optional<Integer> getValidatorIndex(BeaconState state, BLSPublicKey publicKey) {\n+    final Integer validatorIndex =\n+        BeaconStateCache.getTransitionCaches(state)\n+            .getValidatorIndex()\n+            .get(\n+                publicKey,\n+                key -> {\n+                  SSZList<Validator> validators = state.getValidators();\n+                  for (int i = 0; i < validators.size(); i++) {\n+                    final Validator validator = validators.get(i);\n+                    if (validator.getPubkey().equals(publicKey)) {\n+                      return i;\n+                    }\n+                  }\n+                  return null;\n+                });\n+    return Optional.ofNullable(validatorIndex)\n+        // The cache is shared between all states, so filter out any cached responses for validators\n+        // that are only added into later states\n+        .filter(index -> index < state.getValidators().size());\n+  }\n+\n   /**\n    * Decrease validator balance by ``delta`` with underflow protection.\n    *\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "message": "Merge commit", "committedDate": null}, {"oid": "c61f4083cc8b2a6e835d4e8e33162a329fd7ffee", "committedDate": "2020-02-04 06:51:07 +1000", "message": "Fix warnings and delete unused code (#1129)"}, {"oid": "e559468f9ae1aa767e29764d1b95a9a438f7538d", "committedDate": "2020-03-04 11:37:15 +0300", "message": "Remerkable (Binary backing tree) initial implementation (#1133)"}, {"oid": "ed59c1324b1e18260e48994b0138088c8ae7c775", "committedDate": "2020-03-20 14:56:19 +1000", "message": "Add cache for public key -> validator index (#1426)"}, {"oid": "c3e58ed4b1987499a1143e6773b6bcbe3c5bcba3", "committedDate": "2020-03-23 10:30:28 +1000", "message": "/validator/duties - Add Proposal slots (#1415)"}, {"oid": "c6e8e56b7a0edc078a88d1b40587262d22bd4c0a", "committedDate": "2020-04-07 18:08:06 -0400", "message": "Correct module namings (#1549)"}, {"oid": "370fc7df43cad900a27a5cf5bd34dc5b69e3ad3a", "committedDate": "2020-04-11 10:29:10 +1000", "message": "Don't cache validators that are not present (#1573)"}, {"oid": "e25cbd07f367fefcb0cbe51b54def9d75c40fda1", "committedDate": "2020-04-20 13:46:25 -0400", "message": "Implement BlockValidator (#1615)"}, {"oid": "81deceb0070d240768fe3a43fa833fbb3604e9e2", "committedDate": "2020-05-05 09:25:19 +1000", "message": "Complete rename from Artemis to Teku (#1673)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370348237", "body": "Would it be better to add `getTransitionCaches` to `BeaconState` and then use polymorphism so `BeaconState` returns `TransitionCaches.getNoOp()` and `BeaconStateWithCache` overrides it to return a real cache?\r\n\r\nThat would avoid the `instanceof` checks here and in deepCopy.", "bodyText": "Would it be better to add getTransitionCaches to BeaconState and then use polymorphism so BeaconState returns TransitionCaches.getNoOp() and BeaconStateWithCache overrides it to return a real cache?\nThat would avoid the instanceof checks here and in deepCopy.", "bodyHTML": "<p dir=\"auto\">Would it be better to add <code>getTransitionCaches</code> to <code>BeaconState</code> and then use polymorphism so <code>BeaconState</code> returns <code>TransitionCaches.getNoOp()</code> and <code>BeaconStateWithCache</code> overrides it to return a real cache?</p>\n<p dir=\"auto\">That would avoid the <code>instanceof</code> checks here and in deepCopy.</p>", "author": "ajsutton", "createdAt": "2020-01-23T20:52:52Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateWithCache.java", "diffHunk": "@@ -172,6 +225,16 @@ public static BeaconStateWithCache fromBeaconState(BeaconState state) {\n         state.getFinalized_checkpoint());\n   }\n \n+  public static TransitionCaches getTransitionCaches(BeaconState state) {\n+    return state instanceof BeaconStateWithCache\n+        ? ((BeaconStateWithCache) state).getTransitionCaches()\n+        : TransitionCaches.getNoOp();\n+  }\n+\n+  public TransitionCaches getTransitionCaches() {\n+    return transitionCaches;\n+  }", "originalCommit": "dad2554ecba9653bae9a6669c33652cda3ff3198", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwODExMg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370508112", "bodyText": "Not sure about this. I would keep the core BeaconState as clear as possible of any implementation specific stuff. I believe this central class would finally become pretty complex even without those 'tool' methods.\nTo reduce boilerplate in the spec functions we could do like this Nashatyrev#6 (though after formatting I'm not sure it looks much nicer)\nHowever I have no strong opinion whether it should done this or that way.", "author": "Nashatyrev", "createdAt": "2020-01-24T07:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3Nzc5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1111#discussion_r370877792", "bodyText": "I'd stick with the current approach in this PR for now then.  Nashatyrev#6 doesn't seem too worth it.\nLet's see how it goes as we add more caches - we may come up with other ideas, especially if we do wind up moving to a more OO style as discussed above.", "author": "ajsutton", "createdAt": "2020-01-24T22:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDM0ODIzNw=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "e559468f9ae1aa767e29764d1b95a9a438f7538d", "changed_code": [{"header": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateWithCache.java b/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateWithCache.java\ndeleted file mode 100644\nindex b470f34fa..000000000\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateWithCache.java\n+++ /dev/null\n", "chunk": "@@ -1,245 +0,0 @@\n-/*\n- * Copyright 2019 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.datastructures.state;\n-\n-import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n-import org.apache.tuweni.bytes.Bytes32;\n-import tech.pegasys.artemis.datastructures.Copyable;\n-import tech.pegasys.artemis.datastructures.blocks.BeaconBlockHeader;\n-import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n-import tech.pegasys.artemis.util.SSZTypes.Bitvector;\n-import tech.pegasys.artemis.util.SSZTypes.SSZList;\n-import tech.pegasys.artemis.util.SSZTypes.SSZVector;\n-\n-public final class BeaconStateWithCache extends BeaconState {\n-\n-  private final TransitionCaches transitionCaches;\n-\n-  public BeaconStateWithCache() {\n-    super();\n-    transitionCaches = TransitionCaches.createNewEmpty();\n-  }\n-\n-  public BeaconStateWithCache(\n-      // Versioning\n-      UnsignedLong genesis_time,\n-      UnsignedLong slot,\n-      Fork fork,\n-\n-      // History\n-      BeaconBlockHeader latest_block_header,\n-      SSZVector<Bytes32> block_roots,\n-      SSZVector<Bytes32> state_roots,\n-      SSZList<Bytes32> historical_roots,\n-\n-      // Eth1\n-      Eth1Data eth1_data,\n-      SSZList<Eth1Data> eth1_data_votes,\n-      UnsignedLong eth1_deposit_index,\n-\n-      // Registry\n-      SSZList<Validator> validators,\n-      SSZList<UnsignedLong> balances,\n-\n-      // Randomness\n-      SSZVector<Bytes32> randao_mixes,\n-\n-      // Slashings\n-      SSZVector<UnsignedLong> slashings,\n-\n-      // Attestations\n-      SSZList<PendingAttestation> previous_epoch_attestations,\n-      SSZList<PendingAttestation> current_epoch_attestations,\n-\n-      // Finality\n-      Bitvector justification_bits,\n-      Checkpoint previous_justified_checkpoint,\n-      Checkpoint current_justified_checkpoint,\n-      Checkpoint finalized_checkpoint) {\n-    super(\n-        genesis_time,\n-        slot,\n-        fork,\n-        latest_block_header,\n-        block_roots,\n-        state_roots,\n-        historical_roots,\n-        eth1_data,\n-        eth1_data_votes,\n-        eth1_deposit_index,\n-        validators,\n-        balances,\n-        randao_mixes,\n-        slashings,\n-        previous_epoch_attestations,\n-        current_epoch_attestations,\n-        justification_bits,\n-        previous_justified_checkpoint,\n-        current_justified_checkpoint,\n-        finalized_checkpoint);\n-    transitionCaches = TransitionCaches.createNewEmpty();\n-  }\n-\n-  private BeaconStateWithCache(\n-      UnsignedLong genesis_time,\n-      UnsignedLong slot,\n-      Fork fork,\n-      BeaconBlockHeader latest_block_header,\n-      SSZVector<Bytes32> block_roots,\n-      SSZVector<Bytes32> state_roots,\n-      SSZList<Bytes32> historical_roots,\n-      Eth1Data eth1_data,\n-      SSZList<Eth1Data> eth1_data_votes,\n-      UnsignedLong eth1_deposit_index,\n-      SSZList<Validator> validators,\n-      SSZList<UnsignedLong> balances,\n-      SSZVector<Bytes32> randao_mixes,\n-      SSZVector<UnsignedLong> slashings,\n-      SSZList<PendingAttestation> previous_epoch_attestations,\n-      SSZList<PendingAttestation> current_epoch_attestations,\n-      Bitvector justification_bits,\n-      Checkpoint previous_justified_checkpoint,\n-      Checkpoint current_justified_checkpoint,\n-      Checkpoint finalized_checkpoint,\n-      TransitionCaches transitionCaches) {\n-    super(\n-        genesis_time,\n-        slot,\n-        fork,\n-        latest_block_header,\n-        block_roots,\n-        state_roots,\n-        historical_roots,\n-        eth1_data,\n-        eth1_data_votes,\n-        eth1_deposit_index,\n-        validators,\n-        balances,\n-        randao_mixes,\n-        slashings,\n-        previous_epoch_attestations,\n-        current_epoch_attestations,\n-        justification_bits,\n-        previous_justified_checkpoint,\n-        current_justified_checkpoint,\n-        finalized_checkpoint);\n-    this.transitionCaches = transitionCaches;\n-  }\n-\n-  public static BeaconStateWithCache deepCopy(BeaconState state) {\n-    final SSZList<Validator> validators =\n-        copyList(\n-            state.getValidators(),\n-            new SSZList<>(Validator.class, state.getValidators().getMaxSize()));\n-    final SSZList<PendingAttestation> previous_epoch_attestations =\n-        copyList(\n-            state.getPrevious_epoch_attestations(),\n-            new SSZList<>(\n-                PendingAttestation.class, state.getPrevious_epoch_attestations().getMaxSize()));\n-    final SSZList<PendingAttestation> current_epoch_attestations =\n-        copyList(\n-            state.getCurrent_epoch_attestations(),\n-            new SSZList<>(\n-                PendingAttestation.class, state.getCurrent_epoch_attestations().getMaxSize()));\n-\n-    return new BeaconStateWithCache(\n-        state.getGenesis_time(),\n-        state.getSlot(),\n-        new Fork(state.getFork()),\n-\n-        // History\n-        new BeaconBlockHeader(state.getLatest_block_header()),\n-        new SSZVector<>(state.getBlock_roots()),\n-        new SSZVector<>(state.getState_roots()),\n-        new SSZList<>(state.getHistorical_roots()),\n-\n-        // Eth1\n-        new Eth1Data(state.getEth1_data()),\n-        new SSZList<>(state.getEth1_data_votes()),\n-        state.getEth1_deposit_index(),\n-\n-        // Registry\n-        validators,\n-        new SSZList<>(state.getBalances()),\n-\n-        // Randomness\n-        new SSZVector<>(state.getRandao_mixes()),\n-\n-        // Slashings\n-        new SSZVector<>(state.getSlashings()),\n-\n-        // Attestations\n-        previous_epoch_attestations,\n-        current_epoch_attestations,\n-\n-        // Finality\n-        state.getJustification_bits().copy(),\n-        state.getPrevious_justified_checkpoint(),\n-        state.getCurrent_justified_checkpoint(),\n-        state.getFinalized_checkpoint(),\n-        state instanceof BeaconStateWithCache\n-            ? ((BeaconStateWithCache) state).transitionCaches.copy()\n-            : TransitionCaches.createNewEmpty());\n-  }\n-\n-  /**\n-   * Creates a BeaconStateWithCache with empty caches from the given BeaconState.\n-   *\n-   * @param state state to create from\n-   * @return created state with empty caches\n-   */\n-  public static BeaconStateWithCache fromBeaconState(BeaconState state) {\n-    if (state instanceof BeaconStateWithCache) return (BeaconStateWithCache) state;\n-    return new BeaconStateWithCache(\n-        state.getGenesis_time(),\n-        state.getSlot(),\n-        state.getFork(),\n-        state.getLatest_block_header(),\n-        state.getBlock_roots(),\n-        state.getState_roots(),\n-        state.getHistorical_roots(),\n-        state.getEth1_data(),\n-        state.getEth1_data_votes(),\n-        state.getEth1_deposit_index(),\n-        state.getValidators(),\n-        state.getBalances(),\n-        state.getRandao_mixes(),\n-        state.getSlashings(),\n-        state.getPrevious_epoch_attestations(),\n-        state.getCurrent_epoch_attestations(),\n-        state.getJustification_bits(),\n-        state.getPrevious_justified_checkpoint(),\n-        state.getCurrent_justified_checkpoint(),\n-        state.getFinalized_checkpoint());\n-  }\n-\n-  public static TransitionCaches getTransitionCaches(BeaconState state) {\n-    return state instanceof BeaconStateWithCache\n-        ? ((BeaconStateWithCache) state).getTransitionCaches()\n-        : TransitionCaches.getNoOp();\n-  }\n-\n-  public TransitionCaches getTransitionCaches() {\n-    return transitionCaches;\n-  }\n-\n-  private static <S extends Copyable<S>, T extends List<S>> T copyList(\n-      T sourceList, T destinationList) {\n-    for (S sourceItem : sourceList) {\n-      destinationList.add(sourceItem.copy());\n-    }\n-    return destinationList;\n-  }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "07ef3372b02fa26ce666e26b83ea6c8dfb4c25c8", "message": "Merge commit", "committedDate": null}, {"oid": "afa9209c7824e197f9b700a4fb72af52605ba0cd", "committedDate": "2020-02-20 13:30:17 +1000", "message": "Change JsonProvider to be non static and use Jackson (#1202)"}, {"oid": "6bb628647bcfc1382d45018045f14a987f1ab33c", "committedDate": "2020-02-21 15:04:05 +1000", "message": "1162 add openapi documentation for /beacon/state (#1210)"}, {"oid": "e559468f9ae1aa767e29764d1b95a9a438f7538d", "committedDate": "2020-03-04 11:37:15 +0300", "message": "Remerkable (Binary backing tree) initial implementation (#1133)"}]}, {"oid": "19d72bc794a3046bed74b5f9380a3bff80835604", "url": "https://github.com/ConsenSys/teku/commit/19d72bc794a3046bed74b5f9380a3bff80835604", "message": "Use existing LimitedHashMap instead of duplicating code", "committedDate": "2020-01-24T07:08:26Z", "type": "commit"}, {"oid": "43403794e6e081b9a084b9d3a54e28b706f136cc", "url": "https://github.com/ConsenSys/teku/commit/43403794e6e081b9a084b9d3a54e28b706f136cc", "message": "Merge remote-tracking branch 'pegasys/master' into optimize-add-cache-active-validators", "committedDate": "2020-01-24T07:22:53Z", "type": "commit"}, {"oid": "8ae65418ee21f58897ec62e63116b7fd4e03e438", "url": "https://github.com/ConsenSys/teku/commit/8ae65418ee21f58897ec62e63116b7fd4e03e438", "message": "Benchmark resource updated with a block list of 300 entries", "committedDate": "2020-01-24T07:59:46Z", "type": "commit"}, {"oid": "aa4a266eca9b4da95137bca8c8645c8137f6b643", "url": "https://github.com/ConsenSys/teku/commit/aa4a266eca9b4da95137bca8c8645c8137f6b643", "message": "Rephrase the code to fix the DoubleBraceInitialization warning", "committedDate": "2020-01-24T08:40:28Z", "type": "commit"}, {"oid": "059167f5c001f7ad23cd76019083e924b04273a4", "url": "https://github.com/ConsenSys/teku/commit/059167f5c001f7ad23cd76019083e924b04273a4", "message": "Merge branch 'master' into optimize-add-cache-active-validators", "committedDate": "2020-01-27T16:19:47Z", "type": "commit"}]}