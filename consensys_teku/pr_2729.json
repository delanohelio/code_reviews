{"pr_number": 2729, "pr_title": "Lock validator keystore files when loading", "pr_author": "cemozerr", "pr_createdAt": "2020-09-04T12:44:25Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2729", "timeline": [{"oid": "6e298d51f2ff6316a24144ac3a1201229215f12c", "url": "https://github.com/ConsenSys/teku/commit/6e298d51f2ff6316a24144ac3a1201229215f12c", "message": "Lock validator keystore files when loading", "committedDate": "2020-09-04T12:43:18Z", "type": "commit"}, {"oid": "892ed0923dbaeae5c39e709febe8e71a05f43c86", "url": "https://github.com/ConsenSys/teku/commit/892ed0923dbaeae5c39e709febe8e71a05f43c86", "message": "Fix spacing", "committedDate": "2020-09-04T13:02:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE4MzU1MA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r484183550", "body": "We need to make sure this provides a nice clear error message on the command line and not a big stack trace.  Often this is done by throwing an `InvalidConfigurationException`.", "bodyText": "We need to make sure this provides a nice clear error message on the command line and not a big stack trace.  Often this is done by throwing an InvalidConfigurationException.", "bodyHTML": "<p dir=\"auto\">We need to make sure this provides a nice clear error message on the command line and not a big stack trace.  Often this is done by throwing an <code>InvalidConfigurationException</code>.</p>", "author": "ajsutton", "createdAt": "2020-09-07T04:59:48Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreAlreadyInUseException.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+public class KeystoreAlreadyInUseException extends RuntimeException {", "originalCommit": "6e298d51f2ff6316a24144ac3a1201229215f12c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDkwODI0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r484908246", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-08T13:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDE4MzU1MA=="}], "type": "inlineReview"}, {"oid": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "url": "https://github.com/ConsenSys/teku/commit/97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "message": "Seperate out the keystore locker", "committedDate": "2020-09-08T13:25:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NjAxMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485946012", "body": "Is this really only visible for testing? Seems like someone external should be calling it in production code.", "bodyText": "Is this really only visible for testing? Seems like someone external should be calling it in production code.", "bodyHTML": "<p dir=\"auto\">Is this really only visible for testing? Seems like someone external should be calling it in production code.</p>", "author": "ajsutton", "createdAt": "2020-09-09T22:00:00Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());\n+\n+  @VisibleForTesting\n+  public void lockKeystoreFile(Path keystoreFile) {", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4OTE5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486289193", "bodyText": "Yep, removed.", "author": "cemozerr", "createdAt": "2020-09-10T12:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NjAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NzUyMw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485977523", "body": "`ProcessHandle` is able to throw `UnsupportedOperationException` if the JVM implementation or OS can't support them.  We need to handle that and just write an empty file in that case.\r\n\r\nFor compatibility with non-java clients we should also ensure we write the PID in native byte order.  So calculating our PID would be:\r\n```\r\n    byte[] pidBytes;\r\n    try {\r\n      final long pid = ProcessHandle.current().pid();\r\n      final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\r\n      buffer.putLong(pid);\r\n      pidBytes = buffer.array();\r\n    } catch (final UnsupportedOperationException e) {\r\n      LOG.warn(\"....\");\r\n      pidBytes = new byte[0];\r\n    }\r\n```\r\n\r\n\r\nAnd reading the PID would be:\r\n```\r\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\r\n    readBuffer.put(pidBytes);\r\n    final long result = readBuffer.getLong(0);\r\n```", "bodyText": "ProcessHandle is able to throw UnsupportedOperationException if the JVM implementation or OS can't support them.  We need to handle that and just write an empty file in that case.\nFor compatibility with non-java clients we should also ensure we write the PID in native byte order.  So calculating our PID would be:\n    byte[] pidBytes;\n    try {\n      final long pid = ProcessHandle.current().pid();\n      final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n      buffer.putLong(pid);\n      pidBytes = buffer.array();\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(\"....\");\n      pidBytes = new byte[0];\n    }\n\nAnd reading the PID would be:\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(pidBytes);\n    final long result = readBuffer.getLong(0);", "bodyHTML": "<p dir=\"auto\"><code>ProcessHandle</code> is able to throw <code>UnsupportedOperationException</code> if the JVM implementation or OS can't support them.  We need to handle that and just write an empty file in that case.</p>\n<p dir=\"auto\">For compatibility with non-java clients we should also ensure we write the PID in native byte order.  So calculating our PID would be:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    byte[] pidBytes;\n    try {\n      final long pid = ProcessHandle.current().pid();\n      final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n      buffer.putLong(pid);\n      pidBytes = buffer.array();\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(&quot;....&quot;);\n      pidBytes = new byte[0];\n    }\"><pre><code>    byte[] pidBytes;\n    try {\n      final long pid = ProcessHandle.current().pid();\n      final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n      buffer.putLong(pid);\n      pidBytes = buffer.array();\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(\"....\");\n      pidBytes = new byte[0];\n    }\n</code></pre></div>\n<p dir=\"auto\">And reading the PID would be:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(pidBytes);\n    final long result = readBuffer.getLong(0);\"><pre><code>    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(pidBytes);\n    final long result = readBuffer.getLong(0);\n</code></pre></div>", "author": "ajsutton", "createdAt": "2020-09-09T23:33:00Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5NjY1Mg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486296652", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:30:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NzUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjAwNw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485982007", "body": "We should check that the file is precisely `Long.BYTES` long before treating it as a PID. We need to be really conservative before deleting lock files.", "bodyText": "We should check that the file is precisely Long.BYTES long before treating it as a PID. We need to be really conservative before deleting lock files.", "bodyHTML": "<p dir=\"auto\">We should check that the file is precisely <code>Long.BYTES</code> long before treating it as a PID. We need to be really conservative before deleting lock files.</p>", "author": "ajsutton", "createdAt": "2020-09-09T23:48:24Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());\n+\n+  @VisibleForTesting\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);\n+      keystoreLockFile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error at KeystoreValidatorKeyProvider when locking keystore file.\", e);\n+    }\n+  }\n+\n+  public void deleteIfStaleLockfileExists(Path keystoreFile) {\n+    Path keystoreLockfile = Path.of(keystoreFile.toString() + \".lock\");\n+    try {\n+      byte[] pidInBytes = Files.readAllBytes(keystoreLockfile);\n+      if (pidInBytes.length != 0) {", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5ODQ0MQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486298441", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI5ODQ0NQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486298445", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485982628", "body": "Personal taste but I'd probably do:\r\n```suggestion\r\n        ProcessHandle.of(pid)\r\n            .filter(process -> !process.isAlive())\r\n            .ifPresent(\r\n                __ -> {\r\n                    if (!keystoreLockfile.toFile().delete()) {\r\n                      LOG.warn(\"Could not delete stale lockfile.\");\r\n                    }\r\n                });\r\n```\r\n\r\nIt's also possible that the process was exiting just as we came through this code so:\r\n\r\n```\r\nif (!keystoreLockfile.toFile().delete() && keystoreLockfile.toFile().exists()) {\r\n```", "bodyText": "Personal taste but I'd probably do:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ProcessHandle.of(pid)\n          \n          \n            \n                        .ifPresent(\n          \n          \n            \n                            p -> {\n          \n          \n            \n                              if (!p.isAlive()) {\n          \n          \n            \n                                if (!keystoreLockfile.toFile().delete()) {\n          \n          \n            \n                                  LOG.warn(\"Could not delete stale lockfile.\");\n          \n          \n            \n                                }\n          \n          \n            \n                              }\n          \n          \n            \n                            });\n          \n          \n            \n                    ProcessHandle.of(pid)\n          \n          \n            \n                        .filter(process -> !process.isAlive())\n          \n          \n            \n                        .ifPresent(\n          \n          \n            \n                            __ -> {\n          \n          \n            \n                                if (!keystoreLockfile.toFile().delete()) {\n          \n          \n            \n                                  LOG.warn(\"Could not delete stale lockfile.\");\n          \n          \n            \n                                }\n          \n          \n            \n                            });\n          \n      \n    \n    \n  \n\nIt's also possible that the process was exiting just as we came through this code so:\nif (!keystoreLockfile.toFile().delete() && keystoreLockfile.toFile().exists()) {", "bodyHTML": "<p dir=\"auto\">Personal taste but I'd probably do:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">ProcessHandle</span><span class=\"pl-k\">.</span>of(pid)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            .ifPresent(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                p <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                  <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>p<span class=\"pl-k\">.</span>isAlive()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>keystoreLockfile<span class=\"pl-k\">.</span>toFile()<span class=\"pl-k\">.</span>delete()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                      <span class=\"pl-c1\">LOG</span><span class=\"pl-k\">.</span>warn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Could not delete stale lockfile.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                  }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                });</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">ProcessHandle</span><span class=\"pl-k\">.</span>of(pid)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            .filter(process <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">!</span>process<span class=\"pl-k\">.</span>isAlive())</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            .ifPresent(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                __ <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>keystoreLockfile<span class=\"pl-k\">.</span>toFile()<span class=\"pl-k\">.</span>delete()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                      <span class=\"pl-c1\">LOG</span><span class=\"pl-k\">.</span>warn(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Could not delete stale lockfile.<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                });</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">It's also possible that the process was exiting just as we came through this code so:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (!keystoreLockfile.toFile().delete() &amp;&amp; keystoreLockfile.toFile().exists()) {\"><pre><code>if (!keystoreLockfile.toFile().delete() &amp;&amp; keystoreLockfile.toFile().exists()) {\n</code></pre></div>", "author": "ajsutton", "createdAt": "2020-09-09T23:50:24Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());\n+\n+  @VisibleForTesting\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);\n+      keystoreLockFile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error at KeystoreValidatorKeyProvider when locking keystore file.\", e);\n+    }\n+  }\n+\n+  public void deleteIfStaleLockfileExists(Path keystoreFile) {\n+    Path keystoreLockfile = Path.of(keystoreFile.toString() + \".lock\");\n+    try {\n+      byte[] pidInBytes = Files.readAllBytes(keystoreLockfile);\n+      if (pidInBytes.length != 0) {\n+        long pid = Longs.fromByteArray(pidInBytes);\n+        ProcessHandle.of(pid)\n+            .ifPresent(\n+                p -> {\n+                  if (!p.isAlive()) {\n+                    if (!keystoreLockfile.toFile().delete()) {\n+                      LOG.warn(\"Could not delete stale lockfile.\");\n+                    }\n+                  }\n+                });", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMjM3Mg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486302372", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMzQyNg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486303426", "bodyText": "Your last comment made me think. We actually don't have code in place to remove these lockfiles when the validator client is shutting down. Not sure if we really need to, since we already have a stale lockfile deletion mechanism at the start.", "author": "cemozerr", "createdAt": "2020-09-10T12:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5NDE5OA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486694198", "bodyText": "We do have the deleteOnExit call for the lock file so if the JVM exits it will delete the file.  I think it would be good to delete in our stop code as well actually - we don't really support running multiple Teku's in one process but no need to entrench that further when it should be fairly simple to hook in a delete call (keep the deleteOnExit though as a fallback, it won't care if the file is already deleted).", "author": "ajsutton", "createdAt": "2020-09-10T23:49:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE4Mzk4OA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488183988", "bodyText": "I think I'll fall back to making an issue about this as it seems to be pretty complex due to only the local signer attempting to delete the lockfiles, and the problem being not too high of a priority.", "author": "cemozerr", "createdAt": "2020-09-14T19:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE4NTE3MA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488185170", "bodyText": "#2793", "author": "cemozerr", "createdAt": "2020-09-14T19:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjgzOA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485982838", "body": "We shouldn't be using equals on exceptions and shouldn't be ignoring any IOException here.  Suspect the if should just be completely removed.", "bodyText": "We shouldn't be using equals on exceptions and shouldn't be ignoring any IOException here.  Suspect the if should just be completely removed.", "bodyHTML": "<p dir=\"auto\">We shouldn't be using equals on exceptions and shouldn't be ignoring any IOException here.  Suspect the if should just be completely removed.</p>", "author": "ajsutton", "createdAt": "2020-09-09T23:51:10Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());\n+\n+  @VisibleForTesting\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);\n+      keystoreLockFile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error at KeystoreValidatorKeyProvider when locking keystore file.\", e);\n+    }\n+  }\n+\n+  public void deleteIfStaleLockfileExists(Path keystoreFile) {\n+    Path keystoreLockfile = Path.of(keystoreFile.toString() + \".lock\");\n+    try {\n+      byte[] pidInBytes = Files.readAllBytes(keystoreLockfile);\n+      if (pidInBytes.length != 0) {\n+        long pid = Longs.fromByteArray(pidInBytes);\n+        ProcessHandle.of(pid)\n+            .ifPresent(\n+                p -> {\n+                  if (!p.isAlive()) {\n+                    if (!keystoreLockfile.toFile().delete()) {\n+                      LOG.warn(\"Could not delete stale lockfile.\");\n+                    }\n+                  }\n+                });\n+      }\n+    } catch (IOException e) {\n+      if (e.equals(new NoSuchFileException(keystoreLockfile.toString()))) {", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMjMxMw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486302313", "bodyText": "Removed the if.", "author": "cemozerr", "createdAt": "2020-09-10T12:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MzY2MQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485983661", "body": "`UncheckedIOException` would be a better wrapper type here.", "bodyText": "UncheckedIOException would be a better wrapper type here.", "bodyHTML": "<p dir=\"auto\"><code>UncheckedIOException</code> would be a better wrapper type here.</p>", "author": "ajsutton", "createdAt": "2020-09-09T23:54:08Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.Longs;\n+import java.io.IOException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = Longs.toByteArray(ProcessHandle.current().pid());\n+\n+  @VisibleForTesting\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);\n+      keystoreLockFile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error at KeystoreValidatorKeyProvider when locking keystore file.\", e);", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwMzUyNA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486303524", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4MzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NDAxMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485984012", "body": "Probably just create `KeystoreLocker` inline as there's no need to create it if we don't go on to create a `KeystoresValidatorKeyProvider`.", "bodyText": "Probably just create KeystoreLocker inline as there's no need to create it if we don't go on to create a KeystoresValidatorKeyProvider.", "bodyHTML": "<p dir=\"auto\">Probably just create <code>KeystoreLocker</code> inline as there's no need to create it if we don't go on to create a <code>KeystoresValidatorKeyProvider</code>.</p>", "author": "ajsutton", "createdAt": "2020-09-09T23:55:26Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/ValidatorLoader.java", "diffHunk": "@@ -110,8 +110,9 @@ private Signer createSigner(\n         keyProviders.add(new YamlValidatorKeyProvider());\n       }\n \n+      KeystoreLocker keystoreLocker = new KeystoreLocker();\n       if (config.getValidatorKeystorePasswordFilePairs() != null) {\n-        keyProviders.add(new KeystoresValidatorKeyProvider());\n+        keyProviders.add(new KeystoresValidatorKeyProvider(keystoreLocker));", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNDc0MA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486304740", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-10T12:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NDAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTA1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r485985055", "body": "We need to add tests for existing PID files that have PIDs for live processes (will need to spawn something via `ProcessBuilder` - maybe run `/bin/sleep` and skip the test if it can't be executed like on Windows).  For PID files that have a PID that isn't alive, empty PID files and PID files containing something that isn't a long.\r\n\r\nAnd probably also a non-existent directory to trigger an IOException while creating the file.", "bodyText": "We need to add tests for existing PID files that have PIDs for live processes (will need to spawn something via ProcessBuilder - maybe run /bin/sleep and skip the test if it can't be executed like on Windows).  For PID files that have a PID that isn't alive, empty PID files and PID files containing something that isn't a long.\nAnd probably also a non-existent directory to trigger an IOException while creating the file.", "bodyHTML": "<p dir=\"auto\">We need to add tests for existing PID files that have PIDs for live processes (will need to spawn something via <code>ProcessBuilder</code> - maybe run <code>/bin/sleep</code> and skip the test if it can't be executed like on Windows).  For PID files that have a PID that isn't alive, empty PID files and PID files containing something that isn't a long.</p>\n<p dir=\"auto\">And probably also a non-existent directory to trigger an IOException while creating the file.</p>", "author": "ajsutton", "createdAt": "2020-09-09T23:58:47Z", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoreLockerTest.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import com.google.common.io.Resources;\n+import java.nio.file.Path;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLockerTest {\n+\n+  private KeystoreLocker keystoreLocker = new KeystoreLocker();\n+\n+  @Test\n+  void shouldLockKeystoreFileAndFailWhenTryingCreateLockForLockedFile() throws Exception {", "originalCommit": "97bb18e9ba7494bc2f7b71a7d0eb47033ca5a00f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1NzQ3OA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486457478", "bodyText": "I've added all the tests but the last one you mentioned with the non-existent directory. Not sure how I could mock a scenario like that.", "author": "cemozerr", "createdAt": "2020-09-10T15:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MTcxMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486691712", "bodyText": "Create a temp dir (which does exist) then ask KeystoreLocker to lock a non-existent keystore in a non-existent sub directory.", "author": "ajsutton", "createdAt": "2020-09-10T23:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3Mzg3NQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488173875", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-14T19:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk4NTA1NQ=="}], "type": "inlineReview"}, {"oid": "82ec7bf17b33cc0452c1b928549f69553af4ed31", "url": "https://github.com/ConsenSys/teku/commit/82ec7bf17b33cc0452c1b928549f69553af4ed31", "message": "Read/write pid in native byte order", "committedDate": "2020-09-10T12:29:55Z", "type": "commit"}, {"oid": "4cc50cdc3109fe75a59ef574c2a5db8f67b9cc7d", "url": "https://github.com/ConsenSys/teku/commit/4cc50cdc3109fe75a59ef574c2a5db8f67b9cc7d", "message": "Add tests", "committedDate": "2020-09-10T15:54:05Z", "type": "commit"}, {"oid": "f78bfb29204788c8a51c19ddea4a6f9e07e097c0", "url": "https://github.com/ConsenSys/teku/commit/f78bfb29204788c8a51c19ddea4a6f9e07e097c0", "message": "Run spotless", "committedDate": "2020-09-10T16:00:34Z", "type": "commit"}, {"oid": "ce26011314159961e4e382a4b74d816dbf474d35", "url": "https://github.com/ConsenSys/teku/commit/ce26011314159961e4e382a4b74d816dbf474d35", "message": "Fix unit test", "committedDate": "2020-09-10T16:34:43Z", "type": "commit"}, {"oid": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "url": "https://github.com/ConsenSys/teku/commit/85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "message": "Run spotless", "committedDate": "2020-09-10T16:35:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTA2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486689062", "body": "We're still not handling `UnsupportedOperationException` that could be thrown by `ProcessHandle.current()`", "bodyText": "We're still not handling UnsupportedOperationException that could be thrown by ProcessHandle.current()", "bodyHTML": "<p dir=\"auto\">We're still not handling <code>UnsupportedOperationException</code> that could be thrown by <code>ProcessHandle.current()</code></p>", "author": "ajsutton", "createdAt": "2020-09-10T23:31:54Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = longPidToNativeByteArray(ProcessHandle.current().pid());", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMzcyMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488123722", "bodyText": "My bad. Handled it now.", "author": "cemozerr", "createdAt": "2020-09-14T18:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTcyNw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486689727", "body": "Why are we returning a boolean from this method when `lockKeystoreFile` never does anything with it?", "bodyText": "Why are we returning a boolean from this method when lockKeystoreFile never does anything with it?", "bodyHTML": "<p dir=\"auto\">Why are we returning a boolean from this method when <code>lockKeystoreFile</code> never does anything with it?</p>", "author": "ajsutton", "createdAt": "2020-09-10T23:34:14Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = longPidToNativeByteArray(ProcessHandle.current().pid());\n+\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);\n+      keystoreLockFile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unexpected error when trying to lock a keystore file.\", e);\n+    }\n+  }\n+\n+  static boolean deleteIfStaleLockfileExists(Path keystoreFile) {", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMDkxNg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488130916", "bodyText": "Made method void.", "author": "cemozerr", "createdAt": "2020-09-14T18:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTg5Ng==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486689896", "body": "We should have a single place where we create the path to the lock file instead of duplicating it here and in `deleteIfStaleLockfileExists`.", "bodyText": "We should have a single place where we create the path to the lock file instead of duplicating it here and in deleteIfStaleLockfileExists.", "bodyHTML": "<p dir=\"auto\">We should have a single place where we create the path to the lock file instead of duplicating it here and in <code>deleteIfStaleLockfileExists</code>.</p>", "author": "ajsutton", "createdAt": "2020-09-10T23:34:49Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = longPidToNativeByteArray(ProcessHandle.current().pid());\n+\n+  public void lockKeystoreFile(Path keystoreFile) {\n+    deleteIfStaleLockfileExists(keystoreFile);\n+    try {\n+      final Path keystoreLockFile =\n+          Files.write(Path.of(keystoreFile.toString() + \".lock\"), processPID, CREATE_NEW);", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMDIzOA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488130238", "bodyText": "Makes sense.", "author": "cemozerr", "createdAt": "2020-09-14T18:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4OTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MTkxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486691919", "body": "Just realised we should be copying this to a temp dir rather than assuming we can write to a file beside the resource - theoretically the tests could be running from inside JAR files and we don't want tests writing to source directories regardless.\r\n\r\nAlso, the keystore doesn't actually have to exist or be valid - it's just a path we're passing to `KeystoreLocker`.  So just create a temp dir and then point to a non-existent keystore file in that dir (ie `<tempdir>/keystore.json` but no need for `keystore.json` to actually exist.", "bodyText": "Just realised we should be copying this to a temp dir rather than assuming we can write to a file beside the resource - theoretically the tests could be running from inside JAR files and we don't want tests writing to source directories regardless.\nAlso, the keystore doesn't actually have to exist or be valid - it's just a path we're passing to KeystoreLocker.  So just create a temp dir and then point to a non-existent keystore file in that dir (ie <tempdir>/keystore.json but no need for keystore.json to actually exist.", "bodyHTML": "<p dir=\"auto\">Just realised we should be copying this to a temp dir rather than assuming we can write to a file beside the resource - theoretically the tests could be running from inside JAR files and we don't want tests writing to source directories regardless.</p>\n<p dir=\"auto\">Also, the keystore doesn't actually have to exist or be valid - it's just a path we're passing to <code>KeystoreLocker</code>.  So just create a temp dir and then point to a non-existent keystore file in that dir (ie <code>&lt;tempdir&gt;/keystore.json</code> but no need for <code>keystore.json</code> to actually exist.</p>", "author": "ajsutton", "createdAt": "2020-09-10T23:41:40Z", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoreLockerTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.deleteIfStaleLockfileExists;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.longPidToNativeByteArray;\n+\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLockerTest {\n+\n+  private KeystoreLocker keystoreLocker = new KeystoreLocker();\n+\n+  @Test\n+  void shouldLockKeystoreFileAndFailWhenTryingCreateLockForLockedFile() throws Exception {\n+    final Path keystoreFile = Path.of(Resources.getResource(\"scryptTestVector.json\").toURI());", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3MzkyMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488173922", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-09-14T19:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5Mjc4Mw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486692783", "body": "Just occurred to me that we can use our own PID for a process that's alive which then works on any platform.  And we can then just use `KeystoreLocker` itself to create the lock file.  Then try to run `KeystoreLocker` again on the same keystore and it should fail.", "bodyText": "Just occurred to me that we can use our own PID for a process that's alive which then works on any platform.  And we can then just use KeystoreLocker itself to create the lock file.  Then try to run KeystoreLocker again on the same keystore and it should fail.", "bodyHTML": "<p dir=\"auto\">Just occurred to me that we can use our own PID for a process that's alive which then works on any platform.  And we can then just use <code>KeystoreLocker</code> itself to create the lock file.  Then try to run <code>KeystoreLocker</code> again on the same keystore and it should fail.</p>", "author": "ajsutton", "createdAt": "2020-09-10T23:44:45Z", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoreLockerTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.deleteIfStaleLockfileExists;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.longPidToNativeByteArray;\n+\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLockerTest {\n+\n+  private KeystoreLocker keystoreLocker = new KeystoreLocker();\n+\n+  @Test\n+  void shouldLockKeystoreFileAndFailWhenTryingCreateLockForLockedFile() throws Exception {\n+    final Path keystoreFile = Path.of(Resources.getResource(\"scryptTestVector.json\").toURI());\n+    deletePastLockfile(keystoreFile);\n+\n+    Assertions.assertThatCode(() -> keystoreLocker.lockKeystoreFile(keystoreFile))\n+        .doesNotThrowAnyException();\n+    Assertions.assertThatThrownBy(() -> keystoreLocker.lockKeystoreFile(keystoreFile))\n+        .isExactlyInstanceOf(InvalidConfigurationException.class);\n+  }\n+\n+  @Test\n+  void doNotDeleteLockfileIfTheProcessIsAlive() throws Exception {\n+    final Path keystoreFile = Path.of(Resources.getResource(\"lockfileTest1.json\").toURI());\n+    deletePastLockfile(keystoreFile);\n+\n+    Process process = new ProcessBuilder(\"/bin/sleep\", \"5\").start();\n+    long pid = process.pid();\n+    assertThat(process.isAlive()).isTrue();\n+    createLockfileWithContent(keystoreFile, longPidToNativeByteArray(pid));", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDUyOA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488174528", "bodyText": "So basically the first and second tests were duplicates. The test you describe was test # 1. So I've deleted # 2.", "author": "cemozerr", "createdAt": "2020-09-14T19:37:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5Mjc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MzE5Ng==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r486693196", "body": "The delete method should be private and we should just be calling the public `lockKeystore` method and asserting that it either works or throws an exception.  Then check the file exists with the expected content if it should have created the lock (or that the old content exists if it should have failed).\r\n\r\nCurrently these tests are only checking that the otherwise unused return value is correct - they aren't actually checking the keystore locking really works.", "bodyText": "The delete method should be private and we should just be calling the public lockKeystore method and asserting that it either works or throws an exception.  Then check the file exists with the expected content if it should have created the lock (or that the old content exists if it should have failed).\nCurrently these tests are only checking that the otherwise unused return value is correct - they aren't actually checking the keystore locking really works.", "bodyHTML": "<p dir=\"auto\">The delete method should be private and we should just be calling the public <code>lockKeystore</code> method and asserting that it either works or throws an exception.  Then check the file exists with the expected content if it should have created the lock (or that the old content exists if it should have failed).</p>\n<p dir=\"auto\">Currently these tests are only checking that the otherwise unused return value is correct - they aren't actually checking the keystore locking really works.</p>", "author": "ajsutton", "createdAt": "2020-09-10T23:46:08Z", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoreLockerTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static org.assertj.core.api.AssertionsForClassTypes.assertThat;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.deleteIfStaleLockfileExists;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.longPidToNativeByteArray;\n+\n+import com.google.common.io.Resources;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLockerTest {\n+\n+  private KeystoreLocker keystoreLocker = new KeystoreLocker();\n+\n+  @Test\n+  void shouldLockKeystoreFileAndFailWhenTryingCreateLockForLockedFile() throws Exception {\n+    final Path keystoreFile = Path.of(Resources.getResource(\"scryptTestVector.json\").toURI());\n+    deletePastLockfile(keystoreFile);\n+\n+    Assertions.assertThatCode(() -> keystoreLocker.lockKeystoreFile(keystoreFile))\n+        .doesNotThrowAnyException();\n+    Assertions.assertThatThrownBy(() -> keystoreLocker.lockKeystoreFile(keystoreFile))\n+        .isExactlyInstanceOf(InvalidConfigurationException.class);\n+  }\n+\n+  @Test\n+  void doNotDeleteLockfileIfTheProcessIsAlive() throws Exception {\n+    final Path keystoreFile = Path.of(Resources.getResource(\"lockfileTest1.json\").toURI());\n+    deletePastLockfile(keystoreFile);\n+\n+    Process process = new ProcessBuilder(\"/bin/sleep\", \"5\").start();\n+    long pid = process.pid();\n+    assertThat(process.isAlive()).isTrue();\n+    createLockfileWithContent(keystoreFile, longPidToNativeByteArray(pid));\n+    assertThat(deleteIfStaleLockfileExists(keystoreFile)).isFalse();", "originalCommit": "85b95cc1e61058eb11f66410acc0fa59a2ae91a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE3NDkzMg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488174932", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-14T19:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MzE5Ng=="}], "type": "inlineReview"}, {"oid": "7885af913372f222b99489c7fc302e271c46aafa", "url": "https://github.com/ConsenSys/teku/commit/7885af913372f222b99489c7fc302e271c46aafa", "message": "Handle process pid unsupported operation exception", "committedDate": "2020-09-14T18:05:03Z", "type": "commit"}, {"oid": "eea639cd9d6915ce9dc13d1846477f042be557ca", "url": "https://github.com/ConsenSys/teku/commit/eea639cd9d6915ce9dc13d1846477f042be557ca", "message": "Fix tests", "committedDate": "2020-09-14T19:38:56Z", "type": "commit"}, {"oid": "2af437c7cdffe70ca9c54c8eec8ad7b8a6447667", "url": "https://github.com/ConsenSys/teku/commit/2af437c7cdffe70ca9c54c8eec8ad7b8a6447667", "message": "Run Spotless", "committedDate": "2020-09-14T19:39:21Z", "type": "commit"}, {"oid": "c8c301eed43b64120fc8f857a28ec636b374d5b5", "url": "https://github.com/ConsenSys/teku/commit/c8c301eed43b64120fc8f857a28ec636b374d5b5", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-14T19:49:10Z", "type": "commit"}, {"oid": "d15391154ad542c4cf78289904451d2ccb519950", "url": "https://github.com/ConsenSys/teku/commit/d15391154ad542c4cf78289904451d2ccb519950", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-14T21:02:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488300799", "body": "There's actually a race condition here where the file is deleted between our checking it exists and trying to read it.  We should catch `FileNotFoundException` explicitly and just return silently because there's no stale file to delete.\r\n\r\nActually there's also a race condition where two processes might be checking the stale file, deleting and creating a new one at the same time as well...  ie both processes see a stale lock file, P1 deletes it and creates its own then P2 deletes that new file and creates its own. Both processes now think they hold the lock.\r\n\r\nThere's no perfect solution to this, but if we took out a `FileChannel` lock, read the file and deleted all while holding that lock at least two Teku instances wouldn't run into that problem.", "bodyText": "There's actually a race condition here where the file is deleted between our checking it exists and trying to read it.  We should catch FileNotFoundException explicitly and just return silently because there's no stale file to delete.\nActually there's also a race condition where two processes might be checking the stale file, deleting and creating a new one at the same time as well...  ie both processes see a stale lock file, P1 deletes it and creates its own then P2 deletes that new file and creates its own. Both processes now think they hold the lock.\nThere's no perfect solution to this, but if we took out a FileChannel lock, read the file and deleted all while holding that lock at least two Teku instances wouldn't run into that problem.", "bodyHTML": "<p dir=\"auto\">There's actually a race condition here where the file is deleted between our checking it exists and trying to read it.  We should catch <code>FileNotFoundException</code> explicitly and just return silently because there's no stale file to delete.</p>\n<p dir=\"auto\">Actually there's also a race condition where two processes might be checking the stale file, deleting and creating a new one at the same time as well...  ie both processes see a stale lock file, P1 deletes it and creates its own then P2 deletes that new file and creates its own. Both processes now think they hold the lock.</p>\n<p dir=\"auto\">There's no perfect solution to this, but if we took out a <code>FileChannel</code> lock, read the file and deleted all while holding that lock at least two Teku instances wouldn't run into that problem.</p>", "author": "ajsutton", "createdAt": "2020-09-14T23:54:14Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = getProcessPID();\n+\n+  public void lockKeystore(Path keystoreFile) {\n+    Path lockfilePath = Path.of(keystoreFile.toString() + \".lock\");\n+    deleteIfStaleLockfileExists(lockfilePath);\n+    try {\n+      final Path lockfile = Files.write(lockfilePath, processPID, CREATE_NEW);\n+      lockfile.toFile().deleteOnExit();\n+    } catch (FileAlreadyExistsException e) {\n+      throw new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unexpected error when trying to lock a keystore file.\", e);\n+    }\n+  }\n+\n+  private static void deleteIfStaleLockfileExists(Path lockfilePath) {\n+    if (!lockfilePath.toFile().exists()) {\n+      return;\n+    }\n+\n+    try {\n+      byte[] pidInBytes = Files.readAllBytes(lockfilePath);\n+      if (pidInBytes.length == Long.BYTES) {\n+        long pid = nativeByteArrayToLong(pidInBytes);\n+        Optional<ProcessHandle> processHandle =\n+            ProcessHandle.of(pid).filter(ProcessHandle::isAlive);\n+        if (processHandle.isEmpty()) {\n+          if (!lockfilePath.toFile().delete() && lockfilePath.toFile().exists()) {\n+            LOG.warn(\"Could not delete stale lockfile.\");\n+          }\n+        }\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Unexpected error when trying read a keystore lockfile.\", e);\n+    }", "originalCommit": "d15391154ad542c4cf78289904451d2ccb519950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1OTAwOQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488659009", "bodyText": "Wouldn't one of the processes fail when trying to create a new one at the same time, with the same name?", "author": "cemozerr", "createdAt": "2020-09-15T13:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3MjU3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488672577", "bodyText": "Turns out that file channel lock won't allow you to delete the file all while holding that lock: https://stackoverflow.com/q/53064571/13391299", "author": "cemozerr", "createdAt": "2020-09-15T13:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY3ODQxMA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488678410", "bodyText": "I also tested this and confirmed that is the case.", "author": "cemozerr", "createdAt": "2020-09-15T13:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY4MDI4MA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488680280", "bodyText": "I've added the explicit catch for the FileNotFoundException for a semi-fix.", "author": "cemozerr", "createdAt": "2020-09-15T13:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MDUzNg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488970536", "bodyText": "Wouldn't one of the processes fail when trying to create a new one at the same time, with the same name?\n\nNo, the sequence would be that both check it's stale, one deletes and recreates, then the other deletes (the new file) and recreates.\nRather than deleting the file while it's stale, we could take a lock and just update the PID in the file. Just remember to get the lock, read and confirm it's stale and then write the new PID.", "author": "ajsutton", "createdAt": "2020-09-15T21:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1MDk1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r489550956", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-16T16:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwMDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwNTMxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488305319", "body": "Rather than running an external program and sleeping, I'd suggest just using a really high value (probably `Long.MAX_VALUE`). Linux defaults to a max PID of 32768 and can only go up to 2^22 so it should be safe enough even if other OS's vary.", "bodyText": "Rather than running an external program and sleeping, I'd suggest just using a really high value (probably Long.MAX_VALUE). Linux defaults to a max PID of 32768 and can only go up to 2^22 so it should be safe enough even if other OS's vary.", "bodyHTML": "<p dir=\"auto\">Rather than running an external program and sleeping, I'd suggest just using a really high value (probably <code>Long.MAX_VALUE</code>). Linux defaults to a max PID of 32768 and can only go up to 2^22 so it should be safe enough even if other OS's vary.</p>", "author": "ajsutton", "createdAt": "2020-09-15T00:09:20Z", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoreLockerTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.longPidToNativeByteArray;\n+import static tech.pegasys.teku.validator.client.loader.KeystoreLocker.nativeByteArrayToLong;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLockerTest {\n+\n+  private final KeystoreLocker keystoreLocker = new KeystoreLocker();\n+\n+  @Test\n+  void shouldLockKeystoreFileAndFailWhenTryingCreateLockForLockedFile(\n+      final @TempDir Path keystoreFile) throws Exception {\n+    Assertions.assertThatCode(() -> keystoreLocker.lockKeystore(keystoreFile))\n+        .doesNotThrowAnyException();\n+    Assertions.assertThatThrownBy(() -> keystoreLocker.lockKeystore(keystoreFile))\n+        .isExactlyInstanceOf(InvalidConfigurationException.class);\n+  }\n+\n+  @Test\n+  @EnabledOnOs({OS.LINUX, OS.MAC})\n+  void deleteLockfileIfTheProcessIsNotAlive(final @TempDir Path keystoreFile) throws Exception {\n+    Process process = new ProcessBuilder(\"/bin/sleep\", \"1\").start();\n+    Thread.sleep(1500);\n+    long pid = process.pid();\n+    assertThat(process.isAlive()).isFalse();", "originalCommit": "d15391154ad542c4cf78289904451d2ccb519950", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODY1NzIyOQ==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r488657229", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-09-15T13:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMwNTMxOQ=="}], "type": "inlineReview"}, {"oid": "07a9eec7f3a779ae1344b67fb3d04ddda79536ac", "url": "https://github.com/ConsenSys/teku/commit/07a9eec7f3a779ae1344b67fb3d04ddda79536ac", "message": "Resolve comments", "committedDate": "2020-09-15T14:06:38Z", "type": "commit"}, {"oid": "0fddb18de438bee06a758db74930db674eb27f83", "url": "https://github.com/ConsenSys/teku/commit/0fddb18de438bee06a758db74930db674eb27f83", "message": "Fix race condition when deleting a stale lockfile and creating new", "committedDate": "2020-09-16T15:47:55Z", "type": "commit"}, {"oid": "6d7fb505992db9e29e71f5dcca58e838552fff5e", "url": "https://github.com/ConsenSys/teku/commit/6d7fb505992db9e29e71f5dcca58e838552fff5e", "message": "Run spotless", "committedDate": "2020-09-16T16:00:40Z", "type": "commit"}, {"oid": "a050b25bfc25fb836309e9fa9ae0581a2e0fd72e", "url": "https://github.com/ConsenSys/teku/commit/a050b25bfc25fb836309e9fa9ae0581a2e0fd72e", "message": "Merge remote-tracking branch 'remotes/origin/master' into addLockfileForSigningKeystores\n\n# Conflicts:\n#\tvalidator/client/src/test/java/tech/pegasys/teku/validator/client/loader/KeystoresValidatorKeyProviderTest.java", "committedDate": "2020-09-16T16:02:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjAyNg==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r489806026", "body": "We should be doing all our IO through the `FileChannel` and need to ensure it and the lock are closed when we're done with it.\r\n\r\nIt's a bit awkward to work with but I think you wind up with:\r\n\r\n```\r\npublic class KeystoreLocker {\r\n\r\n  private static final Logger LOG = LogManager.getLogger();\r\n  private final byte[] processPID = getProcessPID();\r\n\r\n  public void lockKeystore(Path keystoreFile) {\r\n    Path lockfilePath = Path.of(keystoreFile.toString() + \".lock\");\r\n    try {\r\n      if (lockfilePath.toFile().exists()) {\r\n        attemptReplaceStaleLockFile(lockfilePath);\r\n      } else {\r\n        createNewLock(lockfilePath);\r\n      }\r\n      lockfilePath.toFile().deleteOnExit();\r\n    } catch (FileAlreadyExistsException e) {\r\n      throw keystoreInUseException(keystoreFile);\r\n    } catch (IOException e) {\r\n      throw new UncheckedIOException(\"Unexpected error when trying to lock a keystore file.\", e);\r\n    }\r\n  }\r\n\r\n  public void attemptReplaceStaleLockFile(final Path lockfilePath) throws IOException {\r\n    try (final FileChannel channel =\r\n            FileChannel.open(lockfilePath, StandardOpenOption.READ, StandardOpenOption.WRITE);\r\n        final FileLock lock = channel.tryLock()) {\r\n      if (lock == null) {\r\n        // File is already locked, consider it a valid lock\r\n        throw keystoreInUseException(lockfilePath);\r\n      }\r\n      if (channel.size() != Long.BYTES) {\r\n        throw keystoreInUseException(lockfilePath);\r\n      }\r\n      final long pidFromFile = readPidFromFile(channel);\r\n      if (processIsAlive(pidFromFile)) {\r\n        throw keystoreInUseException(lockfilePath);\r\n      }\r\n\r\n      LOG.warn(\"Stale PID file for process ID {} detected. Overwriting.\", pidFromFile);\r\n      channel.write(ByteBuffer.wrap(processPID), 0);\r\n    } catch (final FileNotFoundException e) {\r\n      // File doesn't exist so try to create it new\r\n      createNewLock(lockfilePath);\r\n    }\r\n  }\r\n\r\n  private Boolean processIsAlive(final long pid) {\r\n    return ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\r\n  }\r\n\r\n  private InvalidConfigurationException keystoreInUseException(final Path keystoreFile) {\r\n    return new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\r\n  }\r\n\r\n  private long readPidFromFile(final FileChannel channel) throws IOException {\r\n    final ByteBuffer content = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\r\n    channel.read(content, 0);\r\n    return content.getLong(0);\r\n  }\r\n\r\n  private void createNewLock(final Path lockfilePath) throws IOException {\r\n    Files.write(lockfilePath, processPID, CREATE_NEW);\r\n  }\r\n\r\n  private static byte[] getProcessPID() {\r\n    byte[] pidBytes;\r\n    try {\r\n      long pid = ProcessHandle.current().pid();\r\n      pidBytes = longPidToNativeByteArray(pid);\r\n    } catch (final UnsupportedOperationException e) {\r\n      LOG.warn(\r\n          \"Process ID can not be detected. This will inhibit Teku from \"\r\n              + \"deleting stale validator keystore lockfiles in the future\");\r\n      pidBytes = new byte[0];\r\n    }\r\n    return pidBytes;\r\n  }\r\n\r\n  static byte[] longPidToNativeByteArray(final long pid) {\r\n    final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\r\n    buffer.putLong(pid);\r\n    return buffer.array();\r\n  }\r\n\r\n  static long nativeByteArrayToLong(final byte[] bytes) {\r\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\r\n    readBuffer.put(bytes);\r\n    return readBuffer.getLong(0);\r\n  }\r\n}\r\n\r\n```", "bodyText": "We should be doing all our IO through the FileChannel and need to ensure it and the lock are closed when we're done with it.\nIt's a bit awkward to work with but I think you wind up with:\npublic class KeystoreLocker {\n\n  private static final Logger LOG = LogManager.getLogger();\n  private final byte[] processPID = getProcessPID();\n\n  public void lockKeystore(Path keystoreFile) {\n    Path lockfilePath = Path.of(keystoreFile.toString() + \".lock\");\n    try {\n      if (lockfilePath.toFile().exists()) {\n        attemptReplaceStaleLockFile(lockfilePath);\n      } else {\n        createNewLock(lockfilePath);\n      }\n      lockfilePath.toFile().deleteOnExit();\n    } catch (FileAlreadyExistsException e) {\n      throw keystoreInUseException(keystoreFile);\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Unexpected error when trying to lock a keystore file.\", e);\n    }\n  }\n\n  public void attemptReplaceStaleLockFile(final Path lockfilePath) throws IOException {\n    try (final FileChannel channel =\n            FileChannel.open(lockfilePath, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        final FileLock lock = channel.tryLock()) {\n      if (lock == null) {\n        // File is already locked, consider it a valid lock\n        throw keystoreInUseException(lockfilePath);\n      }\n      if (channel.size() != Long.BYTES) {\n        throw keystoreInUseException(lockfilePath);\n      }\n      final long pidFromFile = readPidFromFile(channel);\n      if (processIsAlive(pidFromFile)) {\n        throw keystoreInUseException(lockfilePath);\n      }\n\n      LOG.warn(\"Stale PID file for process ID {} detected. Overwriting.\", pidFromFile);\n      channel.write(ByteBuffer.wrap(processPID), 0);\n    } catch (final FileNotFoundException e) {\n      // File doesn't exist so try to create it new\n      createNewLock(lockfilePath);\n    }\n  }\n\n  private Boolean processIsAlive(final long pid) {\n    return ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\n  }\n\n  private InvalidConfigurationException keystoreInUseException(final Path keystoreFile) {\n    return new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n  }\n\n  private long readPidFromFile(final FileChannel channel) throws IOException {\n    final ByteBuffer content = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    channel.read(content, 0);\n    return content.getLong(0);\n  }\n\n  private void createNewLock(final Path lockfilePath) throws IOException {\n    Files.write(lockfilePath, processPID, CREATE_NEW);\n  }\n\n  private static byte[] getProcessPID() {\n    byte[] pidBytes;\n    try {\n      long pid = ProcessHandle.current().pid();\n      pidBytes = longPidToNativeByteArray(pid);\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(\n          \"Process ID can not be detected. This will inhibit Teku from \"\n              + \"deleting stale validator keystore lockfiles in the future\");\n      pidBytes = new byte[0];\n    }\n    return pidBytes;\n  }\n\n  static byte[] longPidToNativeByteArray(final long pid) {\n    final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    buffer.putLong(pid);\n    return buffer.array();\n  }\n\n  static long nativeByteArrayToLong(final byte[] bytes) {\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(bytes);\n    return readBuffer.getLong(0);\n  }\n}", "bodyHTML": "<p dir=\"auto\">We should be doing all our IO through the <code>FileChannel</code> and need to ensure it and the lock are closed when we're done with it.</p>\n<p dir=\"auto\">It's a bit awkward to work with but I think you wind up with:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public class KeystoreLocker {\n\n  private static final Logger LOG = LogManager.getLogger();\n  private final byte[] processPID = getProcessPID();\n\n  public void lockKeystore(Path keystoreFile) {\n    Path lockfilePath = Path.of(keystoreFile.toString() + &quot;.lock&quot;);\n    try {\n      if (lockfilePath.toFile().exists()) {\n        attemptReplaceStaleLockFile(lockfilePath);\n      } else {\n        createNewLock(lockfilePath);\n      }\n      lockfilePath.toFile().deleteOnExit();\n    } catch (FileAlreadyExistsException e) {\n      throw keystoreInUseException(keystoreFile);\n    } catch (IOException e) {\n      throw new UncheckedIOException(&quot;Unexpected error when trying to lock a keystore file.&quot;, e);\n    }\n  }\n\n  public void attemptReplaceStaleLockFile(final Path lockfilePath) throws IOException {\n    try (final FileChannel channel =\n            FileChannel.open(lockfilePath, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        final FileLock lock = channel.tryLock()) {\n      if (lock == null) {\n        // File is already locked, consider it a valid lock\n        throw keystoreInUseException(lockfilePath);\n      }\n      if (channel.size() != Long.BYTES) {\n        throw keystoreInUseException(lockfilePath);\n      }\n      final long pidFromFile = readPidFromFile(channel);\n      if (processIsAlive(pidFromFile)) {\n        throw keystoreInUseException(lockfilePath);\n      }\n\n      LOG.warn(&quot;Stale PID file for process ID {} detected. Overwriting.&quot;, pidFromFile);\n      channel.write(ByteBuffer.wrap(processPID), 0);\n    } catch (final FileNotFoundException e) {\n      // File doesn't exist so try to create it new\n      createNewLock(lockfilePath);\n    }\n  }\n\n  private Boolean processIsAlive(final long pid) {\n    return ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\n  }\n\n  private InvalidConfigurationException keystoreInUseException(final Path keystoreFile) {\n    return new InvalidConfigurationException(&quot;Keystore file &quot; + keystoreFile + &quot; already in use.&quot;);\n  }\n\n  private long readPidFromFile(final FileChannel channel) throws IOException {\n    final ByteBuffer content = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    channel.read(content, 0);\n    return content.getLong(0);\n  }\n\n  private void createNewLock(final Path lockfilePath) throws IOException {\n    Files.write(lockfilePath, processPID, CREATE_NEW);\n  }\n\n  private static byte[] getProcessPID() {\n    byte[] pidBytes;\n    try {\n      long pid = ProcessHandle.current().pid();\n      pidBytes = longPidToNativeByteArray(pid);\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(\n          &quot;Process ID can not be detected. This will inhibit Teku from &quot;\n              + &quot;deleting stale validator keystore lockfiles in the future&quot;);\n      pidBytes = new byte[0];\n    }\n    return pidBytes;\n  }\n\n  static byte[] longPidToNativeByteArray(final long pid) {\n    final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    buffer.putLong(pid);\n    return buffer.array();\n  }\n\n  static long nativeByteArrayToLong(final byte[] bytes) {\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(bytes);\n    return readBuffer.getLong(0);\n  }\n}\n\"><pre><code>public class KeystoreLocker {\n\n  private static final Logger LOG = LogManager.getLogger();\n  private final byte[] processPID = getProcessPID();\n\n  public void lockKeystore(Path keystoreFile) {\n    Path lockfilePath = Path.of(keystoreFile.toString() + \".lock\");\n    try {\n      if (lockfilePath.toFile().exists()) {\n        attemptReplaceStaleLockFile(lockfilePath);\n      } else {\n        createNewLock(lockfilePath);\n      }\n      lockfilePath.toFile().deleteOnExit();\n    } catch (FileAlreadyExistsException e) {\n      throw keystoreInUseException(keystoreFile);\n    } catch (IOException e) {\n      throw new UncheckedIOException(\"Unexpected error when trying to lock a keystore file.\", e);\n    }\n  }\n\n  public void attemptReplaceStaleLockFile(final Path lockfilePath) throws IOException {\n    try (final FileChannel channel =\n            FileChannel.open(lockfilePath, StandardOpenOption.READ, StandardOpenOption.WRITE);\n        final FileLock lock = channel.tryLock()) {\n      if (lock == null) {\n        // File is already locked, consider it a valid lock\n        throw keystoreInUseException(lockfilePath);\n      }\n      if (channel.size() != Long.BYTES) {\n        throw keystoreInUseException(lockfilePath);\n      }\n      final long pidFromFile = readPidFromFile(channel);\n      if (processIsAlive(pidFromFile)) {\n        throw keystoreInUseException(lockfilePath);\n      }\n\n      LOG.warn(\"Stale PID file for process ID {} detected. Overwriting.\", pidFromFile);\n      channel.write(ByteBuffer.wrap(processPID), 0);\n    } catch (final FileNotFoundException e) {\n      // File doesn't exist so try to create it new\n      createNewLock(lockfilePath);\n    }\n  }\n\n  private Boolean processIsAlive(final long pid) {\n    return ProcessHandle.of(pid).map(ProcessHandle::isAlive).orElse(false);\n  }\n\n  private InvalidConfigurationException keystoreInUseException(final Path keystoreFile) {\n    return new InvalidConfigurationException(\"Keystore file \" + keystoreFile + \" already in use.\");\n  }\n\n  private long readPidFromFile(final FileChannel channel) throws IOException {\n    final ByteBuffer content = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    channel.read(content, 0);\n    return content.getLong(0);\n  }\n\n  private void createNewLock(final Path lockfilePath) throws IOException {\n    Files.write(lockfilePath, processPID, CREATE_NEW);\n  }\n\n  private static byte[] getProcessPID() {\n    byte[] pidBytes;\n    try {\n      long pid = ProcessHandle.current().pid();\n      pidBytes = longPidToNativeByteArray(pid);\n    } catch (final UnsupportedOperationException e) {\n      LOG.warn(\n          \"Process ID can not be detected. This will inhibit Teku from \"\n              + \"deleting stale validator keystore lockfiles in the future\");\n      pidBytes = new byte[0];\n    }\n    return pidBytes;\n  }\n\n  static byte[] longPidToNativeByteArray(final long pid) {\n    final ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    buffer.putLong(pid);\n    return buffer.array();\n  }\n\n  static long nativeByteArrayToLong(final byte[] bytes) {\n    final ByteBuffer readBuffer = ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder());\n    readBuffer.put(bytes);\n    return readBuffer.getLong(0);\n  }\n}\n\n</code></pre></div>", "author": "ajsutton", "createdAt": "2020-09-16T23:21:01Z", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/loader/KeystoreLocker.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.client.loader;\n+\n+import static java.nio.file.StandardOpenOption.CREATE_NEW;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.FileLock;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.util.config.InvalidConfigurationException;\n+\n+public class KeystoreLocker {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final byte[] processPID = getProcessPID();\n+\n+  public void lockKeystore(Path keystoreFile) {\n+    Path lockfilePath = Path.of(keystoreFile.toString() + \".lock\");\n+    try {\n+      Path lockfile;\n+      if (lockfilePath.toFile().exists()) {\n+        FileLock lockfileLock = FileChannel.open(lockfilePath, WRITE).lock();", "originalCommit": "a050b25bfc25fb836309e9fa9ae0581a2e0fd72e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNDA1MA==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r490434050", "bodyText": "Okay replaced KeystoreLocker with this. I noticed that we don't release the file lock in attemptReplaceStaleLockFile. Was this on purpose so that we keep the lock on the lockfile until the VM quits?", "author": "cemozerr", "createdAt": "2020-09-17T17:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU2MDQ2Nw==", "url": "https://github.com/ConsenSys/teku/pull/2729#discussion_r490560467", "bodyText": "We take the lock out in the try-with-resources part so it it automatically closed (released) when we exit the try block along with closing the file channel.", "author": "ajsutton", "createdAt": "2020-09-17T21:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgwNjAyNg=="}], "type": "inlineReview"}, {"oid": "c4bd3dcb74452962b328b01409d5ef4683e69eef", "url": "https://github.com/ConsenSys/teku/commit/c4bd3dcb74452962b328b01409d5ef4683e69eef", "message": "Replace KeystoreLocker", "committedDate": "2020-09-17T17:28:07Z", "type": "commit"}, {"oid": "06eae9fdf85b721e706a3e94e722a73b09cf38b9", "url": "https://github.com/ConsenSys/teku/commit/06eae9fdf85b721e706a3e94e722a73b09cf38b9", "message": "Run spotless", "committedDate": "2020-09-17T17:29:04Z", "type": "commit"}, {"oid": "c0990509c773e354bc4e37b4adea905c4ee8414a", "url": "https://github.com/ConsenSys/teku/commit/c0990509c773e354bc4e37b4adea905c4ee8414a", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-17T17:29:42Z", "type": "commit"}, {"oid": "21ddb00bf15a947f37e992827936a924821f3334", "url": "https://github.com/ConsenSys/teku/commit/21ddb00bf15a947f37e992827936a924821f3334", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-17T20:54:59Z", "type": "commit"}, {"oid": "ca884fad7ec320e58f4cc87c9f4b618978288d90", "url": "https://github.com/ConsenSys/teku/commit/ca884fad7ec320e58f4cc87c9f4b618978288d90", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-17T21:31:35Z", "type": "commit"}, {"oid": "0281f67a02502e8276db85f2dd0feb3f12b38559", "url": "https://github.com/ConsenSys/teku/commit/0281f67a02502e8276db85f2dd0feb3f12b38559", "message": "Merge branch 'master' into addLockfileForSigningKeystores", "committedDate": "2020-09-18T13:28:09Z", "type": "commit"}]}