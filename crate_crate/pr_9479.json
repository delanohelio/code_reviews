{"pr_number": 9479, "pr_title": "Remove `RamAccountingContext`, use new eagerly ram accounting instead", "pr_author": "seut", "pr_createdAt": "2020-01-06T10:37:48Z", "pr_url": "https://github.com/crate/crate/pull/9479", "timeline": [{"oid": "48f8bb895bc41c67b86bf56e0e88093f93f8e597", "url": "https://github.com/crate/crate/commit/48f8bb895bc41c67b86bf56e0e88093f93f8e597", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-01-17T10:38:17Z", "type": "forcePushed"}, {"oid": "c6328e384abfd699242598c0d515c7e648a6f90c", "url": "https://github.com/crate/crate/commit/c6328e384abfd699242598c0d515c7e648a6f90c", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-01-20T11:30:26Z", "type": "forcePushed"}, {"oid": "96169dbef760e8dc3ab699656f04e472f3aa4869", "url": "https://github.com/crate/crate/commit/96169dbef760e8dc3ab699656f04e472f3aa4869", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-14T10:53:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3OTI0Ng==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379379246", "body": "We could also decide if we should account inside the `NodeFetchResponse` only `if (numReaders > 0)` https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56.\r\n", "bodyText": "We could also decide if we should account inside the NodeFetchResponse only if (numReaders > 0) https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56.", "bodyHTML": "<p dir=\"auto\">We could also decide if we should account inside the <code>NodeFetchResponse</code> only <code>if (numReaders &gt; 0)</code> <a href=\"https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56\">https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/execution/engine/fetch/NodeFetchResponse.java#L56</a>.</p>", "author": "seut", "createdAt": "2020-02-14T11:19:37Z", "path": "sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java", "diffHunk": "@@ -64,8 +68,22 @@ public TransportFetchOperation(TransportFetchNodeAction transportFetchNodeAction\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccounting,\n+            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),", "originalCommit": "96169dbef760e8dc3ab699656f04e472f3aa4869", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\nindex 17a4be6aed..84785ebdca 100644\n--- a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n+++ b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n", "chunk": "@@ -68,22 +64,8 @@ public class TransportFetchOperation implements FetchOperation {\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),\n+            ramAccounting,\n             listener);\n         return listener;\n     }\n-\n-    @VisibleForTesting\n-    static RamAccounting ramAccountingForIncomingResponse(RamAccounting ramAccounting,\n-                                                          IntObjectMap<? extends IntContainer> toFetch,\n-                                                          boolean closeContext) {\n-        if (toFetch.isEmpty() && closeContext) {\n-            // No data will arrive, so no ram accounting needed.\n-            // Indeed, with valid ram accounting, incoming accounted bytes may never be released because the release\n-            // logic may already happened (BatchAccumulator.close() calls do not block/wait for asynchronous responses)\n-            return RamAccounting.NO_ACCOUNTING;\n-        }\n-        // Each response may run in a different thread and thus should use its own ram accounting instance\n-        return new BlockBasedRamAccounting(ramAccounting::addBytes, MAX_BLOCK_SIZE_IN_BYTES);\n-    }\n }\n", "next_change": {"commit": "0570230ce0a2e8e6d76c2362452f62e23f9ca7d9", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\nindex 84785ebdca..17a4be6aed 100644\n--- a/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n+++ b/sql/src/main/java/io/crate/execution/engine/fetch/TransportFetchOperation.java\n", "chunk": "@@ -64,8 +68,22 @@ public class TransportFetchOperation implements FetchOperation {\n             nodeId,\n             nodeIdToReaderIdToStreamers.get(nodeId),\n             new NodeFetchRequest(jobId, fetchPhaseId, closeContext, toFetch),\n-            ramAccounting,\n+            ramAccountingForIncomingResponse(ramAccounting, toFetch, closeContext),\n             listener);\n         return listener;\n     }\n+\n+    @VisibleForTesting\n+    static RamAccounting ramAccountingForIncomingResponse(RamAccounting ramAccounting,\n+                                                          IntObjectMap<? extends IntContainer> toFetch,\n+                                                          boolean closeContext) {\n+        if (toFetch.isEmpty() && closeContext) {\n+            // No data will arrive, so no ram accounting needed.\n+            // Indeed, with valid ram accounting, incoming accounted bytes may never be released because the release\n+            // logic may already happened (BatchAccumulator.close() calls do not block/wait for asynchronous responses)\n+            return RamAccounting.NO_ACCOUNTING;\n+        }\n+        // Each response may run in a different thread and thus should use its own ram accounting instance\n+        return new BlockBasedRamAccounting(ramAccounting::addBytes, MAX_BLOCK_SIZE_IN_BYTES);\n+    }\n }\n", "next_change": null}]}}]}}, {"oid": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "url": "https://github.com/crate/crate/commit/ba89f84b2651c5a4915e10610d9501a86d0b077c", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-14T11:25:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTExOQ==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379439119", "body": "The `when in-time when` sounds weird. Maybe re-phrase to `by the time the teardown runs`\r\n\r\nOr re-phrase completely to something like the following, omitting the second part completely.\r\n\r\n```suggestion\r\n                // RamAccouting-release operations can run asynchronous after clients already received results. \r\n```", "bodyText": "The when in-time when sounds weird. Maybe re-phrase to by the time the teardown runs\nOr re-phrase completely to something like the following, omitting the second part completely.\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when\n          \n          \n            \n                            // RamAccouting-release operations can run asynchronous after clients already received results.", "bodyHTML": "<p dir=\"auto\">The <code>when in-time when</code> sounds weird. Maybe re-phrase to <code>by the time the teardown runs</code></p>\n<p dir=\"auto\">Or re-phrase completely to something like the following, omitting the second part completely.</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> <span class=\"x x-first x-last\">Due to asynchronous </span>operations<span class=\"x x-first x-last\">, Crate's completion future's may not be completed when in-time when</span></span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> <span class=\"x x-first x-last\">RamAccouting-release </span>operations<span class=\"x x-first x-last\"> can run asynchronous after clients already received results. </span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "mfussenegger", "createdAt": "2020-02-14T13:50:42Z", "path": "es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java", "diffHunk": "@@ -2210,6 +2210,21 @@ public void ensureEstimatedStats() {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n+\n+                // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "changed_code": [{"header": "diff --git a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\nindex 7b2c9e45dd..af01ba78b7 100644\n--- a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n+++ b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n", "chunk": "@@ -2210,21 +2210,6 @@ public final class InternalTestCluster extends TestCluster {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n-\n-                // Due to asynchronous operations, Crate's completion future's may not be completed when in-time when\n-                // this test tear down runs, the check will run inside an assertBusy loop.\n-                try {\n-                    assertBusy(() -> {\n-                        CircuitBreaker crateQueryBreaker = breakerService.getBreaker(\"query\");\n-                        if (crateQueryBreaker != null) {\n-                            assertThat(\"Query breaker not reset to 0 on node: \" + name,\n-                                       crateQueryBreaker.getUsed(),\n-                                       equalTo(0L));\n-                        }\n-                    });\n-                } catch (Exception e) {\n-                    throw new AssertionError(\"Exception during check for query breaker reset to 0\", e);\n-                }\n             }\n         }\n     }\n", "next_change": {"commit": "64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "changed_code": [{"header": "diff --git a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\nindex af01ba78b7..e68089765b 100644\n--- a/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n+++ b/es/es-testing/src/main/java/org/elasticsearch/test/InternalTestCluster.java\n", "chunk": "@@ -2210,6 +2210,20 @@ public final class InternalTestCluster extends TestCluster {\n                 } catch (Exception e) {\n                     throw new AssertionError(\"Exception during check for request breaker reset to 0\", e);\n                 }\n+\n+                // RamAccounting release operations can run asynchronous after clients already received results.\n+                try {\n+                    assertBusy(() -> {\n+                        CircuitBreaker crateQueryBreaker = breakerService.getBreaker(\"query\");\n+                        if (crateQueryBreaker != null) {\n+                            assertThat(\"Query breaker not reset to 0 on node: \" + name,\n+                                       crateQueryBreaker.getUsed(),\n+                                       equalTo(0L));\n+                        }\n+                    });\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Exception during check for query breaker reset to 0\", e);\n+                }\n             }\n         }\n     }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379441069", "body": "Do we need the ConcurrentRamAccounting here? I think the SingleBucketBuilder isn't used concurrently. (Yes, threads may change, but there is no concurrent use by multiple threads)", "bodyText": "Do we need the ConcurrentRamAccounting here? I think the SingleBucketBuilder isn't used concurrently. (Yes, threads may change, but there is no concurrent use by multiple threads)", "bodyHTML": "<p dir=\"auto\">Do we need the ConcurrentRamAccounting here? I think the SingleBucketBuilder isn't used concurrently. (Yes, threads may change, but there is no concurrent use by multiple threads)</p>", "author": "mfussenegger", "createdAt": "2020-02-14T13:54:46Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -278,9 +279,16 @@ private void registerContextPhases(Iterable<? extends NodeOperation> nodeOperati\n             }\n             if (ExecutionPhases.hasDirectResponseDownstream(nodeOperation.downstreamNodes())) {\n                 var executionPhase = nodeOperation.executionPhase();\n-                var ramAccounting = RamAccountingContext.forExecutionPhase(breaker(), executionPhase);\n+                CircuitBreaker breaker = breaker();\n+                int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                    breaker.getLimit(),\n+                    1\n+                );\n+                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0NTgxMg==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379445812", "bodyText": "right, good catch", "author": "seut", "createdAt": "2020-02-14T14:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex 1a240ae2a7..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n", "chunk": "@@ -284,11 +284,11 @@ public class JobSetup {\n                     breaker.getLimit(),\n                     1\n                 );\n-                var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(executionPhase.label(), breaker);\n+                var ramAccounting = new BlockBasedRamAccounting(\n+                    b -> breaker.addEstimateBytesAndMaybeBreak(b, executionPhase.label()),\n+                    ramAccountingBlockSizeInBytes);\n                 Streamer<?>[] streamers = StreamerVisitor.streamersFromOutputs(executionPhase);\n-                SingleBucketBuilder bucketBuilder = new SingleBucketBuilder(\n-                    streamers,\n-                    new BlockBasedRamAccounting(ramAccounting::addBytes, ramAccountingBlockSizeInBytes));\n+                SingleBucketBuilder bucketBuilder = new SingleBucketBuilder(streamers, ramAccounting);\n                 context.directResponseFutures.add(bucketBuilder.completionFuture().whenComplete((res, err) -> ramAccounting.close()));\n                 context.registerBatchConsumer(nodeOperation.downstreamExecutionPhaseId(), bucketBuilder);\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MjQ2Mg==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379442462", "body": "Do we need multiple MemoryManager instances here?\r\nI think if the `ramAccounting` instance is thread-safe, the `MemoryManager` instances inherit that thread-safety. So we could probably get away with using one.", "bodyText": "Do we need multiple MemoryManager instances here?\nI think if the ramAccounting instance is thread-safe, the MemoryManager instances inherit that thread-safety. So we could probably get away with using one.", "bodyHTML": "<p dir=\"auto\">Do we need multiple MemoryManager instances here?<br>\nI think if the <code>ramAccounting</code> instance is thread-safe, the <code>MemoryManager</code> instances inherit that thread-safety. So we could probably get away with using one.</p>", "author": "mfussenegger", "createdAt": "2020-02-14T13:57:36Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -803,34 +847,33 @@ public Boolean visitFetchPhase(final FetchPhase phase, final Context context) {\n \n         @Override\n         public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n-\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "originalCommit": "ba89f84b2651c5a4915e10610d9501a86d0b077c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex 1a240ae2a7..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n", "chunk": "@@ -858,13 +858,8 @@ public class JobSetup {\n                 ramAccountingBlockSizeInBytes);\n             RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n             var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerRight = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagers = List.of(memoryManager, memoryManagerLeft, memoryManagerRight);\n             lastConsumer.completionFuture().whenComplete((result, error) -> {\n-                for (MemoryManager memoryManagerToClose : memoryManagers) {\n-                    memoryManagerToClose.close();\n-                }\n+                memoryManager.close();\n                 ramAccounting.close();\n             });\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw==", "url": "https://github.com/crate/crate/pull/9479#discussion_r379451197", "body": "Same here regarding the MemoryManager instances. Sorry I had only pointed it out once as I wasn't sure if I'm missing something.", "bodyText": "Same here regarding the MemoryManager instances. Sorry I had only pointed it out once as I wasn't sure if I'm missing something.", "bodyHTML": "<p dir=\"auto\">Same here regarding the MemoryManager instances. Sorry I had only pointed it out once as I wasn't sure if I'm missing something.</p>", "author": "mfussenegger", "createdAt": "2020-02-14T14:14:38Z", "path": "sql/src/main/java/io/crate/execution/jobs/JobSetup.java", "diffHunk": "@@ -886,33 +924,33 @@ public Boolean visitNestedLoopPhase(NestedLoopPhase phase, Context context) {\n \n         @Override\n         public Boolean visitHashJoinPhase(HashJoinPhase phase, Context context) {\n-            MergePhase leftMerge = phase.leftMergePhase();\n-            MergePhase rightMerge = phase.rightMergePhase();\n-            RamAccountingContext ramAccountingLeft = leftMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), leftMerge);\n-            RamAccountingContext ramAccountingRight = rightMerge == null ? null :\n-                RamAccountingContext.forExecutionPhase(breaker(), rightMerge);\n-\n-            RamAccountingContext ramAccountingContext = RamAccountingContext.forExecutionPhase(breaker(), phase);\n-            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingContext);\n-            MemoryManager memoryManager = memoryManagerFactory.getMemoryManager(ramAccountingContext);\n+            CircuitBreaker breaker = breaker();\n+            int ramAccountingBlockSizeInBytes = BlockBasedRamAccounting.calculateBlockSizeInBytes(\n+                breaker.getLimit(),\n+                1\n+            );\n+            var ramAccounting = ConcurrentRamAccounting.forCircuitBreaker(phase.label(), breaker);\n+            var ramAccountingOfOperation = new BlockBasedRamAccounting(\n+                ramAccounting::addBytes,\n+                ramAccountingBlockSizeInBytes);\n+            RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n+            var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n+            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);", "originalCommit": "2564653f664b8caeda79b744602f3edfd7382ad9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAyMTEzNA==", "url": "https://github.com/crate/crate/pull/9479#discussion_r380021134", "bodyText": "ah thanks!", "author": "seut", "createdAt": "2020-02-17T07:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ1MTE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "changed_code": [{"header": "diff --git a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\nindex afc79291cf..2cc4597847 100644\n--- a/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n+++ b/sql/src/main/java/io/crate/execution/jobs/JobSetup.java\n", "chunk": "@@ -935,13 +935,8 @@ public class JobSetup {\n                 ramAccountingBlockSizeInBytes);\n             RowConsumer lastConsumer = context.getRowConsumer(phase, Paging.PAGE_SIZE, ramAccountingOfOperation);\n             var memoryManager = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerLeft = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagerRight = memoryManagerFactory.getMemoryManager(ramAccounting);\n-            var memoryManagers = List.of(memoryManager, memoryManagerLeft, memoryManagerRight);\n             lastConsumer.completionFuture().whenComplete((result, error) -> {\n-                for (MemoryManager memoryManagerToClose : memoryManagers) {\n-                    memoryManagerToClose.close();\n-                }\n+                memoryManager.close();\n                 ramAccounting.close();\n             });\n \n", "next_change": null}]}}, {"oid": "5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "url": "https://github.com/crate/crate/commit/5bb454a8f80cc441bdbebe3f10cfe823e14a7e42", "message": "Remove `RamAccountingContext`, use new eagerly ram accounting instead.\n\nThe old `RamAccountingContext` uses a flush buffer to prevent flushing to\nthe circuit breaker on every accounted bytes. This leads to a possible\nunderaccounting.\nAdditionally the implementation isn't thread-safe but was used\nfrom multiple threads which also leads to wrong accounting.\n\nThis implementation is superseeded by new `RamAccounting` implementations\nwhich are either thread-safe (`ConcurrentRamAccounting`) or eagerly allocate\n(on-demand) a block of bytes (`BlockBasedRamAccounting`, this one must be\ncreated dedicated per thread).", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "0570230ce0a2e8e6d76c2362452f62e23f9ca7d9", "url": "https://github.com/crate/crate/commit/0570230ce0a2e8e6d76c2362452f62e23f9ca7d9", "message": "Do not account ram for incoming close fetch context responses\n\nOn `FetchBatchAccumulator.close()` (which may called by a `kill`) calls,\na fetch requests is sent to close open fetch contexts without waiting\nfor the response by design.\nAs job related resources may already be released (in this case the ram\naccounting), the response should not result in additional accounted ram.\nAlso the response won\u2019t contain any rows and such ram accounting isn\u2019t\nneeded.", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "url": "https://github.com/crate/crate/commit/64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-17T09:19:32Z", "type": "commit"}, {"oid": "64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "url": "https://github.com/crate/crate/commit/64c205dfeb1fb70b7b661f15ad1d831cf51ab2dd", "message": "Add test assertion ensuring QUERY breaker is reset to 0", "committedDate": "2020-02-17T09:19:32Z", "type": "forcePushed"}]}