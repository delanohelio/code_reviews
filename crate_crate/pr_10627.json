{"pr_number": 10627, "pr_title": "Fix the partitions deletion from the subquery expressions.", "pr_author": "kovrus", "pr_createdAt": "2020-10-07T12:41:33Z", "pr_url": "https://github.com/crate/crate/pull/10627", "timeline": [{"oid": "8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "url": "https://github.com/crate/crate/commit/8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "message": "Make WhereClause#hasQuery return false if query is a value symbol.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type.\nThis change restores the previous behaviour.", "committedDate": "2020-10-07T12:42:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501000394", "body": "Looking at some of the usages I think this could also lead to bugs if the query is a literal `false`. \r\n\r\nMaybe we should combine this with `canMatch` ? ", "bodyText": "Looking at some of the usages I think this could also lead to bugs if the query is a literal false.\nMaybe we should combine this with canMatch ?", "bodyHTML": "<p dir=\"auto\">Looking at some of the usages I think this could also lead to bugs if the query is a literal <code>false</code>.</p>\n<p dir=\"auto\">Maybe we should combine this with <code>canMatch</code> ?</p>", "author": "mfussenegger", "createdAt": "2020-10-07T13:13:05Z", "path": "server/src/main/java/io/crate/analyze/WhereClause.java", "diffHunk": "@@ -81,7 +81,7 @@ public WhereClause(@Nullable Symbol normalizedQuery,\n     }\n \n     public boolean hasQuery() {\n-        return query != null;\n+        return query != null && !query.symbolType().isValueSymbol();", "originalCommit": "8cc6ccde61cc5464c5ae0dbe544a4f0a7a00a62a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2MDkyNw==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501060927", "bodyText": "hm do you mean combine it with the method body logic query != null && !query.symbolType().isValueSymbol() or at the hasQuery call sides? Combining it in the method body would probably be semantically incorrect Another possible solution would be just using canMatch in the DeletePlanner instead of !hasQuery https://github.com/crate/crate/blob/master/server/src/main/java/io/crate/planner/statement/DeletePlanner.java#L136 and leave the hasQuery without further modifications.", "author": "kovrus", "createdAt": "2020-10-07T14:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MDA2NQ==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501070065", "bodyText": "Another possible solution would be just using canMatch in the DeletePlanner instead of !hasQuery\n\nI like that solution \ud83d\udc4d", "author": "mfussenegger", "createdAt": "2020-10-07T14:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MTUwNg==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501071506", "bodyText": "Although I think it would also change semantics? If there still is a query, then it's not guranteed that it matches the entire query?\nI think we'd have to be explicit and check that either there is no query, or it matches everything", "author": "mfussenegger", "createdAt": "2020-10-07T14:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMDM5NA=="}], "type": "inlineReview"}, {"oid": "ecffe7207c0556d8e88fbd1e3c6d94d399ef49e6", "url": "https://github.com/crate/crate/commit/ecffe7207c0556d8e88fbd1e3c6d94d399ef49e6", "message": "Fix the deletion of partiitions from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.TRUE. This change address this issue in the\nDeletePlanner by adding an additional `canMatch` check when deciding\nwhich delete plan to execute.", "committedDate": "2020-10-08T08:08:31Z", "type": "forcePushed"}, {"oid": "edd43782abbf334e1e152034348fa1d45a032c6c", "url": "https://github.com/crate/crate/commit/edd43782abbf334e1e152034348fa1d45a032c6c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.TRUE. That resulted in the wrong plan that would\nleave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\n`canMatch` check when deciding which delete plan to execute.", "committedDate": "2020-10-08T08:21:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NDQ5Ng==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501544496", "body": "```suggestion\r\n                && (!where.hasQuery() || Literal.BOOLEAN_TRUE.equals(where.query()))) {\r\n```\r\n\r\nI think `canMatch` could also return `true` for queries that have a chance of matching a sub-set of the records. In that case we cannot delete the full partition.\r\n\r\n\r\nSee https://github.com/crate/crate/blob/ced78125bab6bead35129f2d6f1618188a8536e5/server/src/main/java/io/crate/analyze/where/WhereClauseAnalyzer.java#L142-L149 \r\n\r\n\r\n`test_where_on_date_with_null_partition_or_id_can_match_all_partitions` and `test_where_clause_that_could_match_on_null_partition_filters_correct_records` are examples where that can be the case.\r\n", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            && (!where.hasQuery() || WhereClause.canMatch(where.query()))) {\n          \n          \n            \n                            && (!where.hasQuery() || Literal.BOOLEAN_TRUE.equals(where.query()))) {\n          \n      \n    \n    \n  \n\nI think canMatch could also return true for queries that have a chance of matching a sub-set of the records. In that case we cannot delete the full partition.\nSee \n  \n    \n      crate/server/src/main/java/io/crate/analyze/where/WhereClauseAnalyzer.java\n    \n    \n        Lines 142 to 149\n      in\n      ced7812\n    \n    \n    \n    \n\n        \n          \n           } else if (queryPartitionMap.size() > 0) { \n        \n\n        \n          \n               PartitionResult partitionResult = tieBreakPartitionQueries( \n        \n\n        \n          \n                   normalizer, queryPartitionMap, coordinatorTxnCtx); \n        \n\n        \n          \n               return partitionResult == null \n        \n\n        \n          \n                   // if partitionResult is null we can't narrow the partitions and keep the full query + use all partitions \n        \n\n        \n          \n                   // the query will then be evaluated correctly within each partition to see whether it matches or not \n        \n\n        \n          \n                   ? new PartitionResult(query, Lists2.map(tableInfo.partitions(), PartitionName::asIndexName)) \n        \n\n        \n          \n                   : partitionResult; \n        \n    \n  \n\n\ntest_where_on_date_with_null_partition_or_id_can_match_all_partitions and test_where_clause_that_could_match_on_null_partition_filters_correct_records are examples where that can be the case.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">&amp;&amp;</span> (<span class=\"pl-k\">!</span>where<span class=\"pl-k\">.</span>hasQuery() <span class=\"pl-k\">||</span> <span class=\"pl-smi x x-first\">WhereClause</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">canMatch</span>(where<span class=\"pl-k\">.</span>query()))) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-k\">&amp;&amp;</span> (<span class=\"pl-k\">!</span>where<span class=\"pl-k\">.</span>hasQuery() <span class=\"pl-k\">||</span> <span class=\"pl-smi x x-first\">Literal</span><span class=\"pl-c1\"><span class=\"pl-k x\">.</span><span class=\"x\">BOOLEAN_TRUE</span></span><span class=\"pl-k x\">.</span><span class=\"x x-last\">equals</span>(where<span class=\"pl-k\">.</span>query()))) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I think <code>canMatch</code> could also return <code>true</code> for queries that have a chance of matching a sub-set of the records. In that case we cannot delete the full partition.</p>\n<p dir=\"auto\">See <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/crate/crate/blob/ced78125bab6bead35129f2d6f1618188a8536e5/server/src/main/java/io/crate/analyze/where/WhereClauseAnalyzer.java#L142-L149\">crate/server/src/main/java/io/crate/analyze/where/WhereClauseAnalyzer.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 142 to 149\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/crate/crate/commit/ced78125bab6bead35129f2d6f1618188a8536e5\">ced7812</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L142\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"142\"></td>\n          <td id=\"LC142\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (queryPartitionMap<span class=\"pl-k\">.</span>size() <span class=\"pl-k\">&gt;</span> <span class=\"pl-c1\">0</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L143\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"143\"></td>\n          <td id=\"LC143\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-smi\">PartitionResult</span> partitionResult <span class=\"pl-k\">=</span> tieBreakPartitionQueries( </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L144\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"144\"></td>\n          <td id=\"LC144\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         normalizer, queryPartitionMap, coordinatorTxnCtx); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L145\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"145\"></td>\n          <td id=\"LC145\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">return</span> partitionResult <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L146\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"146\"></td>\n          <td id=\"LC146\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-c\"><span class=\"pl-c\">//</span> if partitionResult is null we can't narrow the partitions and keep the full query + use all partitions</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L147\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"147\"></td>\n          <td id=\"LC147\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-c\"><span class=\"pl-c\">//</span> the query will then be evaluated correctly within each partition to see whether it matches or not</span> </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L148\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"148\"></td>\n          <td id=\"LC148\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">?</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">PartitionResult</span>(query, <span class=\"pl-smi\">Lists2</span><span class=\"pl-k\">.</span>map(tableInfo<span class=\"pl-k\">.</span>partitions(), <span class=\"pl-smi\">PartitionName</span><span class=\"pl-k\">::</span>asIndexName)) </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L149\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"149\"></td>\n          <td id=\"LC149\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">         <span class=\"pl-k\">:</span> partitionResult; </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p dir=\"auto\"><code>test_where_on_date_with_null_partition_or_id_can_match_all_partitions</code> and <code>test_where_clause_that_could_match_on_null_partition_filters_correct_records</code> are examples where that can be the case.</p>", "author": "mfussenegger", "createdAt": "2020-10-08T08:37:25Z", "path": "server/src/main/java/io/crate/planner/statement/DeletePlanner.java", "diffHunk": "@@ -133,7 +133,8 @@ public void executeOrFail(DependencyCarrier executor,\n                 subQueryResults,\n                 plannerContext.transactionContext(),\n                 executor.nodeContext());\n-            if (!where.partitions().isEmpty() && !where.hasQuery()) {\n+            if (!where.partitions().isEmpty()\n+                && (!where.hasQuery() || WhereClause.canMatch(where.query()))) {", "originalCommit": "edd43782abbf334e1e152034348fa1d45a032c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NTYxOQ==", "url": "https://github.com/crate/crate/pull/10627#discussion_r501545619", "bodyText": "Yep, true. WIll check the quality against the Literal.BOOLEAN_TRUE \ud83d\udc4d tnx", "author": "kovrus", "createdAt": "2020-10-08T08:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NDQ5Ng=="}], "type": "inlineReview"}, {"oid": "abcc3cea66a2172274a9744ddd9b00d58e9fa13a", "url": "https://github.com/crate/crate/commit/abcc3cea66a2172274a9744ddd9b00d58e9fa13a", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:40:07Z", "type": "forcePushed"}, {"oid": "96bb1c9148d72b9211abe8311681e6bb949df87c", "url": "https://github.com/crate/crate/commit/96bb1c9148d72b9211abe8311681e6bb949df87c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:43:38Z", "type": "commit"}, {"oid": "96bb1c9148d72b9211abe8311681e6bb949df87c", "url": "https://github.com/crate/crate/commit/96bb1c9148d72b9211abe8311681e6bb949df87c", "message": "Fix the partitions deletion from the subquery expressions.\n\nThis change fixes the regression introduced by\nhttps://github.com/crate/crate/pull/9707 in the `WhereClause`.\nThe `WhereClause#hasQuery` before the removal of the `QuerySpec`\nretuned the false if the normalized query was a symbol of the value type\nrepresented by Literal.BOOLEAN_TRUE. That resulted in the wrong plan that\nwould leave empty orphaned partitions after the delition.\n\nThis change address this issue in the DeletePlanner by adding an additional\nwhere clause = Literal.BOOLEAN_TRUE check to decide which delete plan to execute.", "committedDate": "2020-10-08T08:43:38Z", "type": "forcePushed"}]}