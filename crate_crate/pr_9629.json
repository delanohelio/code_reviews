{"pr_number": 9629, "pr_title": "Add support for JOIN USING statements", "pr_author": "marregui", "pr_createdAt": "2020-02-06T16:18:22Z", "pr_url": "https://github.com/crate/crate/pull/9629", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMDUxOA==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376120518", "body": "Is it really safe to cast to `Table` here? What if `left` or `right` is a sub query?", "bodyText": "Is it really safe to cast to Table here? What if left or right is a sub query?", "bodyHTML": "<p dir=\"auto\">Is it really safe to cast to <code>Table</code> here? What if <code>left</code> or <code>right</code> is a sub query?</p>", "author": "kovrus", "createdAt": "2020-02-06T22:35:18Z", "path": "sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java", "diffHunk": "@@ -1190,7 +1189,9 @@ public Node visitJoinRelation(SqlBaseParser.JoinRelationContext context) {\n                 criteria = new JoinOn((Expression) visit(context.joinCriteria().booleanExpression()));\n             } else if (context.joinCriteria().USING() != null) {\n                 List<String> columns = identsToStrings(context.joinCriteria().ident());\n-                criteria = new JoinUsing(columns);\n+                Table leftTable = (Table) left;", "originalCommit": "46d2f639e90c7700edbc56173b1881c85851c96e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI2OTE0Nw==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376269147", "bodyText": "Not safe, I will now add tests, like the one #9551 , which will highlight in catastrophic form exactly this :)", "author": "marregui", "createdAt": "2020-02-07T08:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEyMDUxOA=="}], "type": "inlineReview"}, {"oid": "5cd2dde7833471d06c59fb3c1723262646e6285a", "url": "https://github.com/crate/crate/commit/5cd2dde7833471d06c59fb3c1723262646e6285a", "message": "Add less trivial tests and account for cases where left/right are not Tables", "committedDate": "2020-02-07T12:26:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ2NDgwMQ==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376464801", "body": "Please revert unrelated indentation changes", "bodyText": "Please revert unrelated indentation changes", "bodyHTML": "<p dir=\"auto\">Please revert unrelated indentation changes</p>", "author": "mfussenegger", "createdAt": "2020-02-07T15:52:13Z", "path": "sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java", "diffHunk": "@@ -480,8 +480,8 @@ public Node visitRestore(SqlBaseParser.RestoreContext context) {\n                 extractGenericProperties(context.withProperties()));\n         }\n         return new RestoreSnapshot(getQualifiedName(context.qname()),\n-            visitCollection(context.tableWithPartitions().tableWithPartition(), Table.class),\n-            extractGenericProperties(context.withProperties()));\n+                                   visitCollection(context.tableWithPartitions().tableWithPartition(), Table.class),", "originalCommit": "4acfea6833db8a10b35265a8c771dc18314bac0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ2NTMzNQ==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376465335", "body": "Please also revert these removals. It causes noise that is unrelated to the change of the PR.\r\n\r\n I know the IDE bugs you about it, but for tests it doesn't matter and it is usually annoying to re-add it once any of the methods tell the IDE that they throw something.", "bodyText": "Please also revert these removals. It causes noise that is unrelated to the change of the PR.\nI know the IDE bugs you about it, but for tests it doesn't matter and it is usually annoying to re-add it once any of the methods tell the IDE that they throw something.", "bodyHTML": "<p dir=\"auto\">Please also revert these removals. It causes noise that is unrelated to the change of the PR.</p>\n<p dir=\"auto\">I know the IDE bugs you about it, but for tests it doesn't matter and it is usually annoying to re-add it once any of the methods tell the IDE that they throw something.</p>", "author": "mfussenegger", "createdAt": "2020-02-07T15:53:14Z", "path": "sql/src/test/java/io/crate/analyze/SelectStatementAnalyzerTest.java", "diffHunk": "@@ -161,15 +161,15 @@ public void testOrderedSelect() throws Exception {\n     }\n \n     @Test\n-    public void testNegativeLiteral() throws Exception {\n+    public void testNegativeLiteral() {\n         AnalyzedRelation relation =  analyze(\"select * from sys.nodes where port['http'] = -400\");\n         Function whereClause = (Function) relation.where().query();\n         Symbol symbol = whereClause.arguments().get(1);\n-        assertThat(((Literal) symbol).value(), is(-400));\n+        assertThat(((Literal<?>) symbol).value(), is(-400));\n     }\n \n     @Test\n-    public void testSimpleSelect() throws Exception {\n+    public void testSimpleSelect() {", "originalCommit": "4acfea6833db8a10b35265a8c771dc18314bac0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0ODIyNw==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376548227", "bodyText": "My bad, I was getting blinded by the yellow column in the IDE, which hid some red.\nI have seen people treat warnings as errors in other lives.", "author": "marregui", "createdAt": "2020-02-07T18:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ2NTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjc0OQ==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376626749", "body": "This instanceof handling in this method might be easy to forget to update in case we add new relations.\r\n\r\nI like the solution you had in the first commit better. Was there a reason why you choose to go with this instead?", "bodyText": "This instanceof handling in this method might be easy to forget to update in case we add new relations.\nI like the solution you had in the first commit better. Was there a reason why you choose to go with this instead?", "bodyHTML": "<p dir=\"auto\">This instanceof handling in this method might be easy to forget to update in case we add new relations.</p>\n<p dir=\"auto\">I like the solution you had in the first commit better. Was there a reason why you choose to go with this instead?</p>", "author": "mfussenegger", "createdAt": "2020-02-07T21:57:27Z", "path": "sql-parser/src/main/java/io/crate/sql/parser/AstBuilder.java", "diffHunk": "@@ -1190,14 +1190,35 @@ public Node visitJoinRelation(SqlBaseParser.JoinRelationContext context) {\n                 criteria = new JoinOn((Expression) visit(context.joinCriteria().booleanExpression()));\n             } else if (context.joinCriteria().USING() != null) {\n                 List<String> columns = identsToStrings(context.joinCriteria().ident());\n-                criteria = new JoinUsing(columns);\n+                criteria = new JoinUsing(extractQualifiedName(left), extractQualifiedName(right), columns);\n             } else {\n                 throw new IllegalArgumentException(\"Unsupported join criteria\");\n             }\n         }\n         return new Join(getJoinType(context.joinType()), left, right, Optional.of(criteria));\n     }\n \n+    private static QualifiedName extractQualifiedName(Relation rel) {", "originalCommit": "1e2173c06f817ebea1aca00f3ecbadc5da7628b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5NjkzMw==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376696933", "bodyText": "I like the original commit better too.", "author": "marregui", "createdAt": "2020-02-08T08:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgxNDQzMg==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376814432", "body": "Not sure if using randomization is justified here. I think it would be easier to understand if we tested the different scenarios explicitly.", "bodyText": "Not sure if using randomization is justified here. I think it would be easier to understand if we tested the different scenarios explicitly.", "bodyHTML": "<p dir=\"auto\">Not sure if using randomization is justified here. I think it would be easier to understand if we tested the different scenarios explicitly.</p>", "author": "mfussenegger", "createdAt": "2020-02-09T20:52:56Z", "path": "sql-parser/src/test/java/io/crate/sql/tree/JoinUsingTests.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.sql.tree;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+public class JoinUsingTests {\n+\n+    @Test\n+    public void testToExpression() {\n+        int n = ThreadLocalRandom.current().nextInt(100);", "originalCommit": "bf91bafe97e0da36a69b42e2effd36d78920e0a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgxNTk2NA==", "url": "https://github.com/crate/crate/pull/9629#discussion_r376815964", "body": "How about something like the following to avoid the duplicate instanceof:\r\n\r\n```\r\ndiff --git a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\r\nindex 80f718714f..8e3c5da7cf 100644\r\n--- a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\r\n+++ b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\r\n@@ -107,7 +107,6 @@ import javax.annotation.Nullable;\r\n import java.util.ArrayList;\r\n import java.util.Collection;\r\n import java.util.Collections;\r\n-import java.util.Iterator;\r\n import java.util.List;\r\n import java.util.Locale;\r\n import java.util.Map;\r\n@@ -247,48 +246,45 @@ public class RelationAnalyzer extends DefaultTraversalVisitor<AnalyzedRelation,\r\n \r\n     @Override\r\n     protected AnalyzedRelation visitJoin(Join node, StatementAnalysisContext statementContext) {\r\n-        node.getLeft().accept(this, statementContext);\r\n-        node.getRight().accept(this, statementContext);\r\n+        var leftRel = node.getLeft().accept(this, statementContext);\r\n+        var rightRel = node.getRight().accept(this, statementContext);\r\n \r\n         RelationAnalysisContext relationContext = statementContext.currentRelationContext();\r\n         Optional<JoinCriteria> optCriteria = node.getCriteria();\r\n         Symbol joinCondition = null;\r\n         if (optCriteria.isPresent()) {\r\n             JoinCriteria joinCriteria = optCriteria.get();\r\n-            if (joinCriteria instanceof JoinOn || joinCriteria instanceof JoinUsing) {\r\n-                final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\r\n-                ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\r\n-                    functions,\r\n-                    coordinatorTxnCtx,\r\n-                    statementContext.convertParamFunction(),\r\n-                    new FullQualifiedNameFieldProvider(\r\n-                        relationContext.sources(),\r\n-                        relationContext.parentSources(),\r\n-                        coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\r\n-                    new SubqueryAnalyzer(this, statementContext));\r\n-                Expression expr;\r\n-                if (joinCriteria instanceof JoinOn) {\r\n-                    expr = ((JoinOn) joinCriteria).getExpression();\r\n-                } else {\r\n-                    Iterator<QualifiedName> rels = relationContext.sources().keySet().iterator();\r\n-                    QualifiedName left = rels.hasNext() ? rels.next() : null;\r\n-                    QualifiedName right = rels.hasNext() ? rels.next() : null;\r\n-                    if (null == left || null == right) {\r\n-                        throw new IllegalStateException(\"joining tables are undefined\");\r\n-                    }\r\n-                    expr = JoinUsing.toExpression(left, right, ((JoinUsing) joinCriteria).getColumns());\r\n-                }\r\n-                try {\r\n-                    joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\r\n-                } catch (RelationUnknown e) {\r\n-                    throw new RelationValidationException(e.getTableIdents(),\r\n-                        String.format(Locale.ENGLISH,\r\n-                        \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\r\n-                }\r\n+            final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\r\n+            ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\r\n+                functions,\r\n+                coordinatorTxnCtx,\r\n+                statementContext.convertParamFunction(),\r\n+                new FullQualifiedNameFieldProvider(\r\n+                    relationContext.sources(),\r\n+                    relationContext.parentSources(),\r\n+                    coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\r\n+                new SubqueryAnalyzer(this, statementContext)\r\n+            );\r\n+            final Expression expr;\r\n+            if (joinCriteria instanceof JoinOn) {\r\n+                expr = ((JoinOn) joinCriteria).getExpression();\r\n+            } else if (joinCriteria instanceof JoinUsing) {\r\n+                expr = JoinUsing.toExpression(\r\n+                    leftRel.getQualifiedName(),\r\n+                    rightRel.getQualifiedName(),\r\n+                    ((JoinUsing) joinCriteria).getColumns()\r\n+                );\r\n             } else {\r\n                 throw new UnsupportedOperationException(String.format(Locale.ENGLISH, \"join criteria %s not supported\",\r\n                     joinCriteria.getClass().getSimpleName()));\r\n             }\r\n+            try {\r\n+                joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\r\n+            } catch (RelationUnknown e) {\r\n+                throw new RelationValidationException(e.getTableIdents(),\r\n+                    String.format(Locale.ENGLISH,\r\n+                    \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\r\n+            }\r\n         }\r\n \r\n         relationContext.addJoinType(JoinType.values()[node.getType().ordinal()], joinCondition);\r\n\r\n```\r\n\r\nand to avoid the left / right null cases.", "bodyText": "How about something like the following to avoid the duplicate instanceof:\ndiff --git a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\nindex 80f718714f..8e3c5da7cf 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n@@ -107,7 +107,6 @@ import javax.annotation.Nullable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n@@ -247,48 +246,45 @@ public class RelationAnalyzer extends DefaultTraversalVisitor<AnalyzedRelation,\n \n     @Override\n     protected AnalyzedRelation visitJoin(Join node, StatementAnalysisContext statementContext) {\n-        node.getLeft().accept(this, statementContext);\n-        node.getRight().accept(this, statementContext);\n+        var leftRel = node.getLeft().accept(this, statementContext);\n+        var rightRel = node.getRight().accept(this, statementContext);\n \n         RelationAnalysisContext relationContext = statementContext.currentRelationContext();\n         Optional<JoinCriteria> optCriteria = node.getCriteria();\n         Symbol joinCondition = null;\n         if (optCriteria.isPresent()) {\n             JoinCriteria joinCriteria = optCriteria.get();\n-            if (joinCriteria instanceof JoinOn || joinCriteria instanceof JoinUsing) {\n-                final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n-                ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n-                    functions,\n-                    coordinatorTxnCtx,\n-                    statementContext.convertParamFunction(),\n-                    new FullQualifiedNameFieldProvider(\n-                        relationContext.sources(),\n-                        relationContext.parentSources(),\n-                        coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n-                    new SubqueryAnalyzer(this, statementContext));\n-                Expression expr;\n-                if (joinCriteria instanceof JoinOn) {\n-                    expr = ((JoinOn) joinCriteria).getExpression();\n-                } else {\n-                    Iterator<QualifiedName> rels = relationContext.sources().keySet().iterator();\n-                    QualifiedName left = rels.hasNext() ? rels.next() : null;\n-                    QualifiedName right = rels.hasNext() ? rels.next() : null;\n-                    if (null == left || null == right) {\n-                        throw new IllegalStateException(\"joining tables are undefined\");\n-                    }\n-                    expr = JoinUsing.toExpression(left, right, ((JoinUsing) joinCriteria).getColumns());\n-                }\n-                try {\n-                    joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n-                } catch (RelationUnknown e) {\n-                    throw new RelationValidationException(e.getTableIdents(),\n-                        String.format(Locale.ENGLISH,\n-                        \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\n-                }\n+            final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n+            ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n+                functions,\n+                coordinatorTxnCtx,\n+                statementContext.convertParamFunction(),\n+                new FullQualifiedNameFieldProvider(\n+                    relationContext.sources(),\n+                    relationContext.parentSources(),\n+                    coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n+                new SubqueryAnalyzer(this, statementContext)\n+            );\n+            final Expression expr;\n+            if (joinCriteria instanceof JoinOn) {\n+                expr = ((JoinOn) joinCriteria).getExpression();\n+            } else if (joinCriteria instanceof JoinUsing) {\n+                expr = JoinUsing.toExpression(\n+                    leftRel.getQualifiedName(),\n+                    rightRel.getQualifiedName(),\n+                    ((JoinUsing) joinCriteria).getColumns()\n+                );\n             } else {\n                 throw new UnsupportedOperationException(String.format(Locale.ENGLISH, \"join criteria %s not supported\",\n                     joinCriteria.getClass().getSimpleName()));\n             }\n+            try {\n+                joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n+            } catch (RelationUnknown e) {\n+                throw new RelationValidationException(e.getTableIdents(),\n+                    String.format(Locale.ENGLISH,\n+                    \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\n+            }\n         }\n \n         relationContext.addJoinType(JoinType.values()[node.getType().ordinal()], joinCondition);\n\n\nand to avoid the left / right null cases.", "bodyHTML": "<p dir=\"auto\">How about something like the following to avoid the duplicate instanceof:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"diff --git a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\nindex 80f718714f..8e3c5da7cf 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n@@ -107,7 +107,6 @@ import javax.annotation.Nullable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n@@ -247,48 +246,45 @@ public class RelationAnalyzer extends DefaultTraversalVisitor&lt;AnalyzedRelation,\n \n     @Override\n     protected AnalyzedRelation visitJoin(Join node, StatementAnalysisContext statementContext) {\n-        node.getLeft().accept(this, statementContext);\n-        node.getRight().accept(this, statementContext);\n+        var leftRel = node.getLeft().accept(this, statementContext);\n+        var rightRel = node.getRight().accept(this, statementContext);\n \n         RelationAnalysisContext relationContext = statementContext.currentRelationContext();\n         Optional&lt;JoinCriteria&gt; optCriteria = node.getCriteria();\n         Symbol joinCondition = null;\n         if (optCriteria.isPresent()) {\n             JoinCriteria joinCriteria = optCriteria.get();\n-            if (joinCriteria instanceof JoinOn || joinCriteria instanceof JoinUsing) {\n-                final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n-                ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n-                    functions,\n-                    coordinatorTxnCtx,\n-                    statementContext.convertParamFunction(),\n-                    new FullQualifiedNameFieldProvider(\n-                        relationContext.sources(),\n-                        relationContext.parentSources(),\n-                        coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n-                    new SubqueryAnalyzer(this, statementContext));\n-                Expression expr;\n-                if (joinCriteria instanceof JoinOn) {\n-                    expr = ((JoinOn) joinCriteria).getExpression();\n-                } else {\n-                    Iterator&lt;QualifiedName&gt; rels = relationContext.sources().keySet().iterator();\n-                    QualifiedName left = rels.hasNext() ? rels.next() : null;\n-                    QualifiedName right = rels.hasNext() ? rels.next() : null;\n-                    if (null == left || null == right) {\n-                        throw new IllegalStateException(&quot;joining tables are undefined&quot;);\n-                    }\n-                    expr = JoinUsing.toExpression(left, right, ((JoinUsing) joinCriteria).getColumns());\n-                }\n-                try {\n-                    joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n-                } catch (RelationUnknown e) {\n-                    throw new RelationValidationException(e.getTableIdents(),\n-                        String.format(Locale.ENGLISH,\n-                        &quot;missing FROM-clause entry for relation '%s'&quot;, e.getTableIdents()));\n-                }\n+            final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n+            ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n+                functions,\n+                coordinatorTxnCtx,\n+                statementContext.convertParamFunction(),\n+                new FullQualifiedNameFieldProvider(\n+                    relationContext.sources(),\n+                    relationContext.parentSources(),\n+                    coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n+                new SubqueryAnalyzer(this, statementContext)\n+            );\n+            final Expression expr;\n+            if (joinCriteria instanceof JoinOn) {\n+                expr = ((JoinOn) joinCriteria).getExpression();\n+            } else if (joinCriteria instanceof JoinUsing) {\n+                expr = JoinUsing.toExpression(\n+                    leftRel.getQualifiedName(),\n+                    rightRel.getQualifiedName(),\n+                    ((JoinUsing) joinCriteria).getColumns()\n+                );\n             } else {\n                 throw new UnsupportedOperationException(String.format(Locale.ENGLISH, &quot;join criteria %s not supported&quot;,\n                     joinCriteria.getClass().getSimpleName()));\n             }\n+            try {\n+                joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n+            } catch (RelationUnknown e) {\n+                throw new RelationValidationException(e.getTableIdents(),\n+                    String.format(Locale.ENGLISH,\n+                    &quot;missing FROM-clause entry for relation '%s'&quot;, e.getTableIdents()));\n+            }\n         }\n \n         relationContext.addJoinType(JoinType.values()[node.getType().ordinal()], joinCondition);\n\"><pre><code>diff --git a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\nindex 80f718714f..8e3c5da7cf 100644\n--- a/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n+++ b/sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java\n@@ -107,7 +107,6 @@ import javax.annotation.Nullable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n@@ -247,48 +246,45 @@ public class RelationAnalyzer extends DefaultTraversalVisitor&lt;AnalyzedRelation,\n \n     @Override\n     protected AnalyzedRelation visitJoin(Join node, StatementAnalysisContext statementContext) {\n-        node.getLeft().accept(this, statementContext);\n-        node.getRight().accept(this, statementContext);\n+        var leftRel = node.getLeft().accept(this, statementContext);\n+        var rightRel = node.getRight().accept(this, statementContext);\n \n         RelationAnalysisContext relationContext = statementContext.currentRelationContext();\n         Optional&lt;JoinCriteria&gt; optCriteria = node.getCriteria();\n         Symbol joinCondition = null;\n         if (optCriteria.isPresent()) {\n             JoinCriteria joinCriteria = optCriteria.get();\n-            if (joinCriteria instanceof JoinOn || joinCriteria instanceof JoinUsing) {\n-                final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n-                ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n-                    functions,\n-                    coordinatorTxnCtx,\n-                    statementContext.convertParamFunction(),\n-                    new FullQualifiedNameFieldProvider(\n-                        relationContext.sources(),\n-                        relationContext.parentSources(),\n-                        coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n-                    new SubqueryAnalyzer(this, statementContext));\n-                Expression expr;\n-                if (joinCriteria instanceof JoinOn) {\n-                    expr = ((JoinOn) joinCriteria).getExpression();\n-                } else {\n-                    Iterator&lt;QualifiedName&gt; rels = relationContext.sources().keySet().iterator();\n-                    QualifiedName left = rels.hasNext() ? rels.next() : null;\n-                    QualifiedName right = rels.hasNext() ? rels.next() : null;\n-                    if (null == left || null == right) {\n-                        throw new IllegalStateException(\"joining tables are undefined\");\n-                    }\n-                    expr = JoinUsing.toExpression(left, right, ((JoinUsing) joinCriteria).getColumns());\n-                }\n-                try {\n-                    joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n-                } catch (RelationUnknown e) {\n-                    throw new RelationValidationException(e.getTableIdents(),\n-                        String.format(Locale.ENGLISH,\n-                        \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\n-                }\n+            final CoordinatorTxnCtx coordinatorTxnCtx = statementContext.transactionContext();\n+            ExpressionAnalyzer expressionAnalyzer = new ExpressionAnalyzer(\n+                functions,\n+                coordinatorTxnCtx,\n+                statementContext.convertParamFunction(),\n+                new FullQualifiedNameFieldProvider(\n+                    relationContext.sources(),\n+                    relationContext.parentSources(),\n+                    coordinatorTxnCtx.sessionContext().searchPath().currentSchema()),\n+                new SubqueryAnalyzer(this, statementContext)\n+            );\n+            final Expression expr;\n+            if (joinCriteria instanceof JoinOn) {\n+                expr = ((JoinOn) joinCriteria).getExpression();\n+            } else if (joinCriteria instanceof JoinUsing) {\n+                expr = JoinUsing.toExpression(\n+                    leftRel.getQualifiedName(),\n+                    rightRel.getQualifiedName(),\n+                    ((JoinUsing) joinCriteria).getColumns()\n+                );\n             } else {\n                 throw new UnsupportedOperationException(String.format(Locale.ENGLISH, \"join criteria %s not supported\",\n                     joinCriteria.getClass().getSimpleName()));\n             }\n+            try {\n+                joinCondition = expressionAnalyzer.convert(expr, relationContext.expressionAnalysisContext());\n+            } catch (RelationUnknown e) {\n+                throw new RelationValidationException(e.getTableIdents(),\n+                    String.format(Locale.ENGLISH,\n+                    \"missing FROM-clause entry for relation '%s'\", e.getTableIdents()));\n+            }\n         }\n \n         relationContext.addJoinType(JoinType.values()[node.getType().ordinal()], joinCondition);\n\n</code></pre></div>\n<p dir=\"auto\">and to avoid the left / right null cases.</p>", "author": "mfussenegger", "createdAt": "2020-02-09T21:14:52Z", "path": "sql/src/main/java/io/crate/analyze/relations/RelationAnalyzer.java", "diffHunk": "@@ -253,7 +255,7 @@ protected AnalyzedRelation visitJoin(Join node, StatementAnalysisContext stateme\n         Symbol joinCondition = null;\n         if (optCriteria.isPresent()) {\n             JoinCriteria joinCriteria = optCriteria.get();\n-            if (joinCriteria instanceof JoinOn) {\n+            if (joinCriteria instanceof JoinOn || joinCriteria instanceof JoinUsing) {", "originalCommit": "bf91bafe97e0da36a69b42e2effd36d78920e0a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9b98ed7b4007e8b8831b9f78c03cd88bdc0c48e", "url": "https://github.com/crate/crate/commit/a9b98ed7b4007e8b8831b9f78c03cd88bdc0c48e", "message": "Add support for JOIN USING statements\n\nAn alternative to JOIN ON, when the column name(s) are the same in\nboth relations.\n\ne.g. SELECT * FROM t1 JOIN t2 USING (col1, col2)\n     SELECT * FROM t1 JOIN t2 ON t1.col1 = t2.col1 AND t1.col2 = t2.col2", "committedDate": "2020-02-10T09:00:07Z", "type": "commit"}, {"oid": "a9b98ed7b4007e8b8831b9f78c03cd88bdc0c48e", "url": "https://github.com/crate/crate/commit/a9b98ed7b4007e8b8831b9f78c03cd88bdc0c48e", "message": "Add support for JOIN USING statements\n\nAn alternative to JOIN ON, when the column name(s) are the same in\nboth relations.\n\ne.g. SELECT * FROM t1 JOIN t2 USING (col1, col2)\n     SELECT * FROM t1 JOIN t2 ON t1.col1 = t2.col1 AND t1.col2 = t2.col2", "committedDate": "2020-02-10T09:00:07Z", "type": "forcePushed"}]}