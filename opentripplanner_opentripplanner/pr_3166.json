{"pr_number": 3166, "pr_title": "Re-implementation of SIRI support", "pr_author": "lassetyr", "pr_createdAt": "2020-08-28T07:18:50Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166", "merge_commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "timeline": [{"oid": "5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "message": "Initial commit of SIRI-reimplementation from OTP1", "committedDate": "2020-08-07T08:18:26Z", "type": "commit"}, {"oid": "61802f4468da112388c9c31121ce5e52d58cf063", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/61802f4468da112388c9c31121ce5e52d58cf063", "message": "Merge branch 'kyyticom-remove-alert-patcher' into siri-realtime", "committedDate": "2020-08-10T12:44:55Z", "type": "commit"}, {"oid": "5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "message": "Updating SIRI-implementation to changes from PR #3134", "committedDate": "2020-08-11T06:53:51Z", "type": "commit"}, {"oid": "49880da748519e1e260413636efa6fe77c20d1ba", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/49880da748519e1e260413636efa6fe77c20d1ba", "message": "Avoiding NPE when setting id on alert", "committedDate": "2020-08-11T11:04:37Z", "type": "commit"}, {"oid": "d87862c309aa01e515406a6597c2cc0bd1a7c263", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d87862c309aa01e515406a6597c2cc0bd1a7c263", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-08-27T10:32:53Z", "type": "commit"}, {"oid": "2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "message": "Returning decoded id as SituationNumber", "committedDate": "2020-08-27T14:05:40Z", "type": "commit"}, {"oid": "ab89d17d5a1626a02986591efc97c43bae82cc24", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ab89d17d5a1626a02986591efc97c43bae82cc24", "message": "Added GraphQL-field for severity", "committedDate": "2020-08-27T14:06:37Z", "type": "commit"}, {"oid": "363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "message": "Also checking for sibling-matches when applying TransitAlerts to Leg", "committedDate": "2020-08-27T14:07:37Z", "type": "commit"}, {"oid": "af2f6dbce50f6d74369692095008d63c40d145db", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/af2f6dbce50f6d74369692095008d63c40d145db", "message": "Handling SIRI ET-updates with only RecordedCalls", "committedDate": "2020-08-27T14:09:24Z", "type": "commit"}, {"oid": "98ae088441b9ff37eea34c67d5417be2d11833c4", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/98ae088441b9ff37eea34c67d5417be2d11833c4", "message": "Added simple retry-functionality for when the SIRI-request times out.", "committedDate": "2020-08-27T14:27:12Z", "type": "commit"}, {"oid": "ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-04T08:18:45Z", "type": "commit"}, {"oid": "9c24322f269177b9cdf4f381fbc8a2b36d462d13", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9c24322f269177b9cdf4f381fbc8a2b36d462d13", "message": "Updating siri-protobuf-mapper to public version", "committedDate": "2020-09-09T13:37:26Z", "type": "commit"}, {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1853a44ae4cac535aad915f92e24aff2912056b3", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-09T14:52:06Z", "type": "commit"}, {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/abe0d21c32aca02da5acae76ea4595cdfc3895ae", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-14T10:48:39Z", "type": "commit"}, {"oid": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "message": "Clean code\n  - Avoid adding new methods just because there is one extra argument.\n  - Remove unused code.\n  - Make a few things final.\n  - catch typed exceptions(IOException|JAXBException|XMLStreamException) not just the generic Exception - avoid entering a infinite loop on NPE.\n  - Remove obsolete null checks.\n  - Remove empty JavaDoc tags.", "committedDate": "2020-09-14T14:06:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzkzNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487717934", "body": "Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.", "bodyText": "Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.", "bodyHTML": "<p dir=\"auto\">Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.</p>", "author": "t2gran", "createdAt": "2020-09-14T07:52:08Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDI4NQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494990285", "bodyText": "Done", "author": "lassetyr", "createdAt": "2020-09-25T13:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "7fdbcea712bab20251082750842d0c5c7f0d4f49", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\nindex 7eb79d356c..aa7eb35f00 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n", "chunk": "@@ -1,16 +1,3 @@\n-/* This program is free software: you can redistribute it and/or\n- modify it under the terms of the GNU Lesser General Public License\n- as published by the Free Software Foundation, either version 3 of\n- the License, or (at your option) any later version.\n-\n- This program is distributed in the hope that it will be useful,\n- but WITHOUT ANY WARRANTY; without even the implied warranty of\n- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- GNU General Public License for more details.\n-\n- You should have received a copy of the GNU General Public License\n- along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n-\n package org.opentripplanner.ext.siri.updater;\n \n import com.google.cloud.pubsub.v1.AckReplyConsumer;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\nindex 7eb79d356c..aa7eb35f00 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n", "chunk": "@@ -1,16 +1,3 @@\n-/* This program is free software: you can redistribute it and/or\n- modify it under the terms of the GNU Lesser General Public License\n- as published by the Free Software Foundation, either version 3 of\n- the License, or (at your option) any later version.\n-\n- This program is distributed in the hope that it will be useful,\n- but WITHOUT ANY WARRANTY; without even the implied warranty of\n- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- GNU General Public License for more details.\n-\n- You should have received a copy of the GNU General Public License\n- along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n-\n package org.opentripplanner.ext.siri.updater;\n \n import com.google.cloud.pubsub.v1.AckReplyConsumer;\n", "next_change": null}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDQwNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487720406", "body": "Empty annotations can just be removed.\r\n", "bodyText": "Empty annotations can just be removed.", "bodyHTML": "<p dir=\"auto\">Empty annotations can just be removed.</p>", "author": "t2gran", "createdAt": "2020-09-14T07:56:26Z", "path": "src/main/java/org/opentripplanner/routing/StopTimesHelper.java", "diffHunk": "@@ -34,6 +34,8 @@\n    * @param timeRange Searches forward for timeRange seconds from startTime\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n+   * @param includeCancelledTrips If true, cancelled trips will also be included in result\n+   * @return", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjYzNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972636", "bodyText": "I fixed this.", "author": "t2gran", "createdAt": "2020-09-14T14:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\nindex c9959ea665..3a22a74bae 100644\n--- a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n+++ b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n", "chunk": "@@ -35,7 +35,6 @@ public class StopTimesHelper {\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n    * @param includeCancelledTrips If true, cancelled trips will also be included in result\n-   * @return\n    */\n   public static List<StopTimesInPattern> stopTimesForStop(\n       RoutingService routingService,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\nindex c9959ea665..3a22a74bae 100644\n--- a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n+++ b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n", "chunk": "@@ -35,7 +35,6 @@ public class StopTimesHelper {\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n    * @param includeCancelledTrips If true, cancelled trips will also be included in result\n-   * @return\n    */\n   public static List<StopTimesInPattern> stopTimesForStop(\n       RoutingService routingService,\n", "next_change": null}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "cf8777442c3b5a13e219e0eae31b595d3a05fe97", "committedDate": "2021-01-29 10:45:51 +0100", "message": "Encapsulate fields in TripTimesShort"}, {"oid": "16170f340345dd3c68e8ce7a8d56067dc0be7367", "committedDate": "2021-03-24 17:55:51 +0100", "message": "Clean code - make sure if is followed by `{}`."}, {"oid": "a4238b9e374d6c4ac17885244ac9791b638e2b4e", "committedDate": "2021-07-23 14:55:38 +0200", "message": "Add PickDrop enum and simplify StopPattern"}, {"oid": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "committedDate": "2021-07-23 15:25:47 +0200", "message": "Encapsulate fields in TripPattern"}, {"oid": "a86208e0283a6d191a35d33e09b3ab7922130fd0", "committedDate": "2021-07-23 15:54:11 +0200", "message": "Encapsulate fields in TripTimes"}, {"oid": "58b429176933dbd5629a52e945a141089bd9c4e9", "committedDate": "2021-07-27 12:19:34 +0200", "message": "Rename TripTimeShort to TripTimeOnDate"}, {"oid": "0ba64706337946bcd989f09377f12b076e892769", "committedDate": "2021-07-27 14:05:27 +0200", "message": "Encapsulate fields in Timetable"}, {"oid": "6c573cb33e8c32335b41693537e03ca49fa3c649", "committedDate": "2021-07-28 11:40:09 +0200", "message": "Only check StopPattern for cancellations on stops"}, {"oid": "f1d0c27f09631d491270cc11d04856b261fccdf0", "committedDate": "2021-08-03 14:20:53 +0200", "message": "Move StopTimesHelper to its own package"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMjY2Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487722666", "body": "Add as JavaDoc", "bodyText": "Add as JavaDoc", "bodyHTML": "<p dir=\"auto\">Add as JavaDoc</p>", "author": "t2gran", "createdAt": "2020-09-14T08:00:24Z", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDQ4Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494990487", "bodyText": "Done", "author": "lassetyr", "createdAt": "2020-09-25T13:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMjY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "655f5c816d61de60833f95a73006669ca9963d4f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbfa..6f864480e7 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,7 +641,9 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n \n-    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    /**\n+     * Need an equals() since trips in a pattern are no longer necessarily running on the same service ID.\n+     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n", "next_change": {"commit": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 6f864480e7..890dc1c7ed 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -642,7 +642,28 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     }\n \n     /**\n-     * Need an equals() since trips in a pattern are no longer necessarily running on the same service ID.\n+     * Need an equals() since trips in a pattern are no longer necessarily running on the same\n+     * service ID.\n+     * <p>\n+     * A TransitEntity SHOULD not implement hashCode/equals. We make an EXCEPTION to this for\n+     * TripPattern, because the alternative is worse. Since TripPatterns are cloned and changed by\n+     * realtime updates and exist in a \"global\" space in Sets/Maps, the equals and hash code\n+     * need to include all elements that can be changed. We could make a wrapper type and implement\n+     * hc/eq for that and use that in all Set/Maps, but that would also ve quite messy. The REAL\n+     * fix to this problem is to make TripPattern unique within the context it live. This is a\n+     * larger task and should be addressed when implementing the issue:\n+     * https://github.com/opentripplanner/OpenTripPlanner/issues/3030\n+     * <p>\n+     * The TripPattern is used as a <em>key</em> in a Set/Map in quite a few places. Use a reg-exp\n+     * search for \"(Map|Set)<TripPattern\") to find the places where it is used.\n+     * <p>\n+     * Note! Classes that have mutable fields that are part of eq/hc are vulnerable. If added to a\n+     * Set/Map the set/map MUST be re-indexed it the object is mutated. When mutating TripPattens\n+     * make sure the object is NOT part of an existing Set/Map.\n+     * <p>\n+     * {@code hopGeometries}  is NOT part of the equals/hashCode methods to avoid costly\n+     * computations. Hence; It is not allowed to ONLY change the hopGeometries, but at least one\n+     * other field must be changed.\n      */\n     @Override\n     public boolean equals(Object o) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbfa..890dc1c7ed 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,7 +641,30 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n \n-    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    /**\n+     * Need an equals() since trips in a pattern are no longer necessarily running on the same\n+     * service ID.\n+     * <p>\n+     * A TransitEntity SHOULD not implement hashCode/equals. We make an EXCEPTION to this for\n+     * TripPattern, because the alternative is worse. Since TripPatterns are cloned and changed by\n+     * realtime updates and exist in a \"global\" space in Sets/Maps, the equals and hash code\n+     * need to include all elements that can be changed. We could make a wrapper type and implement\n+     * hc/eq for that and use that in all Set/Maps, but that would also ve quite messy. The REAL\n+     * fix to this problem is to make TripPattern unique within the context it live. This is a\n+     * larger task and should be addressed when implementing the issue:\n+     * https://github.com/opentripplanner/OpenTripPlanner/issues/3030\n+     * <p>\n+     * The TripPattern is used as a <em>key</em> in a Set/Map in quite a few places. Use a reg-exp\n+     * search for \"(Map|Set)<TripPattern\") to find the places where it is used.\n+     * <p>\n+     * Note! Classes that have mutable fields that are part of eq/hc are vulnerable. If added to a\n+     * Set/Map the set/map MUST be re-indexed it the object is mutated. When mutating TripPattens\n+     * make sure the object is NOT part of an existing Set/Map.\n+     * <p>\n+     * {@code hopGeometries}  is NOT part of the equals/hashCode methods to avoid costly\n+     * computations. Hence; It is not allowed to ONLY change the hopGeometries, but at least one\n+     * other field must be changed.\n+     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n", "next_change": {"commit": "d8afd66107af2c11641b13cdfa0c02841c11ed7f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 890dc1c7ed..9610aaf372 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,64 +653,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n \n-    /**\n-     * Need an equals() since trips in a pattern are no longer necessarily running on the same\n-     * service ID.\n-     * <p>\n-     * A TransitEntity SHOULD not implement hashCode/equals. We make an EXCEPTION to this for\n-     * TripPattern, because the alternative is worse. Since TripPatterns are cloned and changed by\n-     * realtime updates and exist in a \"global\" space in Sets/Maps, the equals and hash code\n-     * need to include all elements that can be changed. We could make a wrapper type and implement\n-     * hc/eq for that and use that in all Set/Maps, but that would also ve quite messy. The REAL\n-     * fix to this problem is to make TripPattern unique within the context it live. This is a\n-     * larger task and should be addressed when implementing the issue:\n-     * https://github.com/opentripplanner/OpenTripPlanner/issues/3030\n-     * <p>\n-     * The TripPattern is used as a <em>key</em> in a Set/Map in quite a few places. Use a reg-exp\n-     * search for \"(Map|Set)<TripPattern\") to find the places where it is used.\n-     * <p>\n-     * Note! Classes that have mutable fields that are part of eq/hc are vulnerable. If added to a\n-     * Set/Map the set/map MUST be re-indexed it the object is mutated. When mutating TripPattens\n-     * make sure the object is NOT part of an existing Set/Map.\n-     * <p>\n-     * {@code hopGeometries}  is NOT part of the equals/hashCode methods to avoid costly\n-     * computations. Hence; It is not allowed to ONLY change the hopGeometries, but at least one\n-     * other field must be changed.\n-     */\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        TripPattern that = (TripPattern) o;\n-        return directionId == that.directionId &&\n-                Objects.equals(id, that.id) &&\n-                Objects.equals(name, that.name) &&\n-                Objects.equals(route, that.route) &&\n-                Objects.equals(stopPattern, that.stopPattern) &&\n-                Objects.equals(scheduledTimetable, that.scheduledTimetable) &&\n-                Objects.equals(trips, that.trips) &&\n-                Objects.equals(services, that.services) &&\n-                Arrays.equals(perStopFlags, that.perStopFlags);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return 31 * Objects.hash(\n-            id,\n-            name,\n-            route,\n-            directionId,\n-            stopPattern,\n-            scheduledTimetable,\n-            trips,\n-            services\n-        ) + Arrays.hashCode(perStopFlags);\n-    }\n }\n", "next_change": {"commit": "7fdcfaf8104e8b2fa94ef78591c7471399dad484", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 9610aaf372..83329f8610 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -652,5 +641,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "d57c16470beca49f137f0c7b8f7097482e4a9137", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 83329f8610..4b7fa7e328 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,4 +665,5 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n }\n", "next_change": {"commit": "945184168355309126bbeb74919f6d3df1d37fa6", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 4b7fa7e328..94a91c45b8 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -665,5 +643,4 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "be23b905919c899bb3ec790669334ba5b3a84619", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 94a91c45b8..07625c72a6 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -643,4 +667,5 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n }\n", "next_change": {"commit": "58ae629e67912dd4f984dd6300e3e1397806e09c", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 07625c72a6..b6c23dd4fd 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -667,5 +645,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex b6c23dd4fd..884b6c2512 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -639,7 +608,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n      */\n     public String getFeedId() {\n         // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return route.getId().getFeedId();\n+        return getRoute().getId().getFeedId();\n     }\n \n     private static Coordinate coordinate(Stop s) {\n", "next_change": {"commit": "55c7116430720c1c91c2673787cb9593f64d658f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 884b6c2512..45de28a851 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -608,7 +604,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n      */\n     public String getFeedId() {\n         // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return getRoute().getId().getFeedId();\n+        return route.getId().getFeedId();\n     }\n \n     private static Coordinate coordinate(Stop s) {\n", "next_change": {"commit": "acf334d3ee4956c41586785ceba398104a8e43c4", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 45de28a851..d6e020e01e 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -607,7 +607,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n         return route.getId().getFeedId();\n     }\n \n-    private static Coordinate coordinate(Stop s) {\n+    private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n }\n", "next_change": {"commit": "594f8f4b4825bfc1e8513df756fbc20f499c9e26", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex d6e020e01e..d9004abe4a 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -607,6 +619,14 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n         return route.getId().getFeedId();\n     }\n \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        // The serialized graph contains cyclic references TripPattern <--> Timetable.\n+        // The Timetable must be indexed from here (rather than in its own readObject method)\n+        // to ensure that the stops field it uses in TripPattern is already deserialized.\n+        scheduledTimetable.finish();\n+    }\n+\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n", "next_change": {"commit": "848c857db3f9b6c71b6aab429c7b0e4326b2b566", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex d9004abe4a..83e75aac7c 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -630,4 +684,24 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    public void removeVehiclePositionIf(Predicate<String> predicate) {\n+        vehiclePositions.keySet().removeIf(predicate);\n+        if(vehiclePositions.isEmpty()) {\n+            // saves a bit of memory for patterns that no longer have positions\n+            vehiclePositions = Map.of();\n+        }\n+    }\n+\n+    public Map<String, RealtimeVehiclePosition> getVehiclePositions() {\n+        return Map.copyOf(vehiclePositions);\n+    }\n+\n+    public void addVehiclePosition(String tripId, RealtimeVehiclePosition vehiclePositions) {\n+        // the default value is Map.of() which saves memory but is immutable\n+        if(this.vehiclePositions.isEmpty()) {\n+            this.vehiclePositions = new HashMap<>();\n+        }\n+        this.vehiclePositions.put(tripId, vehiclePositions);\n+    }\n }\n", "next_change": {"commit": "a01a41d0d979f959a0c9a712db8a7c9d91970ecf", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 83e75aac7c..115d5937af 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -684,24 +677,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n-    public void removeVehiclePositionIf(Predicate<String> predicate) {\n-        vehiclePositions.keySet().removeIf(predicate);\n-        if(vehiclePositions.isEmpty()) {\n-            // saves a bit of memory for patterns that no longer have positions\n-            vehiclePositions = Map.of();\n-        }\n-    }\n-\n-    public Map<String, RealtimeVehiclePosition> getVehiclePositions() {\n-        return Map.copyOf(vehiclePositions);\n-    }\n-\n-    public void addVehiclePosition(String tripId, RealtimeVehiclePosition vehiclePositions) {\n-        // the default value is Map.of() which saves memory but is immutable\n-        if(this.vehiclePositions.isEmpty()) {\n-            this.vehiclePositions = new HashMap<>();\n-        }\n-        this.vehiclePositions.put(tripId, vehiclePositions);\n-    }\n }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 115d5937af..f6cc4bd6e9 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -46,635 +47,698 @@ import org.slf4j.LoggerFactory;\n  */\n public final class TripPattern extends TransitEntity implements Cloneable, Serializable {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(TripPattern.class);\n-\n-    private static final long serialVersionUID = 1;\n-\n-    private String name;\n-\n-    private final Route route;\n-\n-    /**\n-     * The stop-pattern help us reuse the same stops in several trip-patterns; Hence\n-     * saving memory. The field should not be accessible outside the class, and all access\n-     * is done through method delegation, like the {@link #numberOfStops()} and\n-     * {@link #canBoard(int)} methods.\n-     */\n-    private final StopPattern stopPattern;\n-\n-    private final Timetable scheduledTimetable = new Timetable(this);\n-\n-    /**\n-     * Geometries of each inter-stop segment of the tripPattern.\n-     */\n-    private byte[][] hopGeometries = null;\n-\n-    /**\n-     * The original TripPattern this replaces at least for one modified trip.\n-     */\n-    private TripPattern originalTripPattern = null;\n-\n-    /**\n-     * Has the TripPattern been created by a real-time update.\n-     */\n-    private boolean createdByRealtimeUpdater = false;\n-\n-    // TODO MOVE codes INTO Timetable or TripTimes\n-    private BitSet services;\n-\n-    public TripPattern(FeedScopedId id, Route route, StopPattern stopPattern) {\n-        super(id);\n-        this.route = route;\n-        this.stopPattern = stopPattern;\n-    }\n-\n-    /** The human-readable, unique name for this trip pattern. */\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    /**\n-     * The GTFS Route of all trips in this pattern.\n-     */\n-    public Route getRoute() {\n-        return route;\n-    }\n-\n-    /**\n-     * Convenience method to get the route traverse mode, the mode for all trips in this pattern.\n-     */\n-    public TransitMode getMode() {\n-        return route.getMode();\n+  private static final Logger LOG = LoggerFactory.getLogger(TripPattern.class);\n+\n+  private static final long serialVersionUID = 1;\n+\n+  private String name;\n+\n+  private final Route route;\n+\n+  /**\n+   * The stop-pattern help us reuse the same stops in several trip-patterns; Hence\n+   * saving memory. The field should not be accessible outside the class, and all access\n+   * is done through method delegation, like the {@link #numberOfStops()} and\n+   * {@link #canBoard(int)} methods.\n+   */\n+  private final StopPattern stopPattern;\n+\n+  private final Timetable scheduledTimetable = new Timetable(this);\n+\n+  /**\n+   * Geometries of each inter-stop segment of the tripPattern.\n+   */\n+  private byte[][] hopGeometries = null;\n+\n+  /**\n+   * The original TripPattern this replaces at least for one modified trip.\n+   */\n+  private TripPattern originalTripPattern = null;\n+\n+  /**\n+   * Has the TripPattern been created by a real-time update.\n+   */\n+  private boolean createdByRealtimeUpdater = false;\n+\n+  // TODO MOVE codes INTO Timetable or TripTimes\n+  private BitSet services;\n+\n+  public TripPattern(FeedScopedId id, Route route, StopPattern stopPattern) {\n+    super(id);\n+    this.route = route;\n+    this.stopPattern = stopPattern;\n+  }\n+\n+  /** The human-readable, unique name for this trip pattern. */\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  /**\n+   * The GTFS Route of all trips in this pattern.\n+   */\n+  public Route getRoute() {\n+    return route;\n+  }\n+\n+  /**\n+   * Convenience method to get the route traverse mode, the mode for all trips in this pattern.\n+   */\n+  public TransitMode getMode() {\n+    return route.getMode();\n+  }\n+\n+  public String getNetexSubmode() {\n+    return route.getNetexSubmode();\n+  }\n+\n+  public LineString getHopGeometry(int stopPosInPattern) {\n+    if (hopGeometries != null) {\n+      return CompactLineString.uncompactLineString(hopGeometries[stopPosInPattern], false);\n+    } else {\n+      return GeometryUtils\n+        .getGeometryFactory()\n+        .createLineString(\n+          new Coordinate[] {\n+            coordinate(stopPattern.getStop(stopPosInPattern)),\n+            coordinate(stopPattern.getStop(stopPosInPattern + 1)),\n+          }\n+        );\n     }\n+  }\n+\n+  public StopPattern getStopPattern() {\n+    return stopPattern;\n+  }\n+\n+  public void setHopGeometries(LineString[] hopGeometries) {\n+    this.hopGeometries = new byte[hopGeometries.length][];\n+\n+    for (int i = 0; i < hopGeometries.length; i++) {\n+      setHopGeometry(i, hopGeometries[i]);\n+    }\n+  }\n+\n+  public void setHopGeometry(int i, LineString hopGeometry) {\n+    this.hopGeometries[i] = CompactLineString.compactLineString(hopGeometry, false);\n+  }\n+\n+  /**\n+   * This will copy the geometry from another TripPattern to this one. It checks if each hop is\n+   * between the same stops before copying that hop geometry. If the stops are different but lie\n+   * within same station, old geometry will be used with overwrite on first and last point\n+   * (to match new stop places). Otherwise, it will default to straight lines between hops.\n+   *\n+   * @param other TripPattern to copy geometry from\n+   */\n+  public void setHopGeometriesFromPattern(TripPattern other) {\n+    this.hopGeometries = new byte[numberOfStops() - 1][];\n+\n+    // This accounts for the new TripPattern provided by a real-time update and the one that is\n+    // being replaced having a different number of stops. In that case the geometry will be\n+    // preserved up until the first mismatching stop, and a straight line will be used for\n+    // all segments after that.\n+    int sizeOfShortestPattern = Math.min(numberOfStops(), other.numberOfStops());\n+\n+    for (int i = 0; i < sizeOfShortestPattern - 1; i++) {\n+      final StopLocation oldOriginStop = this.getStop(i);\n+      final StopLocation oldDestinationStop = this.getStop(i + 1);\n+      final Station oldOriginStation = this.getStop(i).getParentStation();\n+      final Station oldDestinationStation = this.getStop(i + 1).getParentStation();\n+\n+      final StopLocation newOriginStop = other.getStop(i);\n+      final StopLocation newDestinationStop = other.getStop(i + 1);\n+      final Station newOriginStation = other.getStop(i).getParentStation();\n+      final Station newDestinationStation = other.getStop(i + 1).getParentStation();\n+\n+      boolean stopsAreSame =\n+        oldOriginStop.equals(newOriginStop) && oldDestinationStop.equals(newDestinationStop);\n+      boolean parentStationsAreSame =\n+        Objects.equals(oldOriginStation, newOriginStation) &&\n+        Objects.equals(oldDestinationStation, newDestinationStation);\n+\n+      LineString hopGeometry = other.getHopGeometry(i);\n+\n+      if (hopGeometry != null && stopsAreSame) {\n+        // Copy hop geometry from previous pattern\n+        this.setHopGeometry(i, other.getHopGeometry(i));\n+      } else if (hopGeometry != null && parentStationsAreSame) {\n+        // Use old geometry but patch first and last point with new stops\n+        Coordinate newStart = new Coordinate(\n+          other.getStop(i).getCoordinate().longitude(),\n+          other.getStop(i).getCoordinate().latitude()\n+        );\n \n-    public String getNetexSubmode() {\n-        return route.getNetexSubmode();\n-    }\n+        Coordinate newEnd = new Coordinate(\n+          other.getStop(i + 1).getCoordinate().longitude(),\n+          other.getStop(i + 1).getCoordinate().latitude()\n+        );\n \n-    public LineString getHopGeometry(int stopPosInPattern) {\n-        if (hopGeometries != null) {\n-            return CompactLineString.uncompactLineString(\n-                    hopGeometries[stopPosInPattern],\n-                    false\n-            );\n-        } else {\n-            return GeometryUtils.getGeometryFactory().createLineString(\n-                    new Coordinate[]{\n-                            coordinate(stopPattern.getStop(stopPosInPattern)),\n-                            coordinate(stopPattern.getStop(stopPosInPattern + 1))\n-                    }\n-            );\n+        Coordinate[] coordinates = other.getHopGeometry(i).getCoordinates().clone();\n+        coordinates[0].setCoordinate(newStart);\n+        coordinates[coordinates.length - 1].setCoordinate(newEnd);\n+\n+        this.setHopGeometry(i, GeometryUtils.getGeometryFactory().createLineString(coordinates));\n+      } else {\n+        // Create new straight-line geometry for hop\n+        this.setHopGeometry(\n+            i,\n+            GeometryUtils\n+              .getGeometryFactory()\n+              .createLineString(\n+                new Coordinate[] {\n+                  coordinate(stopPattern.getStop(i)),\n+                  coordinate(stopPattern.getStop(i + 1)),\n+                }\n+              )\n+          );\n+      }\n+    }\n+  }\n+\n+  public LineString getGeometry() {\n+    if (hopGeometries == null || hopGeometries.length == 0) {\n+      return null;\n+    }\n+\n+    List<LineString> lineStrings = new ArrayList<>();\n+    for (int i = 0; i < hopGeometries.length; i++) {\n+      lineStrings.add(getHopGeometry(i));\n+    }\n+    return GeometryUtils.concatenateLineStrings(lineStrings);\n+  }\n+\n+  public int numHopGeometries() {\n+    return hopGeometries.length;\n+  }\n+\n+  public int numberOfStops() {\n+    return stopPattern.getSize();\n+  }\n+\n+  public StopLocation getStop(int stopPosInPattern) {\n+    return stopPattern.getStop(stopPosInPattern);\n+  }\n+\n+  public StopLocation firstStop() {\n+    return getStop(0);\n+  }\n+\n+  public StopLocation lastStop() {\n+    return getStop(stopPattern.getSize() - 1);\n+  }\n+\n+  /** Read only list of stops */\n+  public List<StopLocation> getStops() {\n+    return stopPattern.getStops();\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop}. The search start at\n+   * position {@code 0}. Return a negative number if not found. Use {@link\n+   * #findAlightStopPositionInPattern(StopLocation)} or {@link #findBoardingStopPositionInPattern(StopLocation)}\n+   * if possible.\n+   */\n+  public int findStopPosition(StopLocation stop) {\n+    return stopPattern.findStopPosition(stop);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code station} where it is\n+   * allowed to board. The search start at position {@code 0}. Return a negative number if not\n+   * found.\n+   */\n+  public int findBoardingStopPositionInPattern(Station station) {\n+    return stopPattern.findBoardingPosition(station);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code station} where it is\n+   * allowed to alight. The search start at position {@code 1}. Return a negative number if not\n+   * found.\n+   */\n+  public int findAlightStopPositionInPattern(Station station) {\n+    return stopPattern.findAlightPosition(station);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n+   * to board. The search start at position {@code 0}. Return a negative number if not found.\n+   */\n+  public int findBoardingStopPositionInPattern(StopLocation stop) {\n+    return stopPattern.findBoardingPosition(stop);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n+   * to alight. The search start at position {@code 1}. Return a negative number if not found.\n+   */\n+  public int findAlightStopPositionInPattern(StopLocation stop) {\n+    return stopPattern.findAlightPosition(stop);\n+  }\n+\n+  /** Returns whether passengers can alight at a given stop */\n+  public boolean canAlight(int stopIndex) {\n+    return stopPattern.canAlight(stopIndex);\n+  }\n+\n+  /** Returns whether passengers can board at a given stop */\n+  public boolean canBoard(int stopIndex) {\n+    return stopPattern.canBoard(stopIndex);\n+  }\n+\n+  /**\n+   * Returns whether passengers can board at a given stop.\n+   * This is an inefficient method iterating over the stops, do not use it in routing.\n+   */\n+  public boolean canBoard(StopLocation stop) {\n+    return stopPattern.canBoard(stop);\n+  }\n+\n+  /** Returns whether a given stop is wheelchair-accessible. */\n+  public boolean wheelchairAccessible(int stopIndex) {\n+    return stopPattern.getStop(stopIndex).getWheelchairBoarding() == WheelChairBoarding.POSSIBLE;\n+  }\n+\n+  public PickDrop getAlightType(int stopIndex) {\n+    return stopPattern.getDropoff(stopIndex);\n+  }\n+\n+  public PickDrop getBoardType(int stopIndex) {\n+    return stopPattern.getPickup(stopIndex);\n+  }\n+\n+  public boolean isBoardAndAlightAt(int stopIndex, PickDrop value) {\n+    return getBoardType(stopIndex).is(value) && getAlightType(stopIndex).is(value);\n+  }\n+\n+  public boolean stopPatternIsEqual(TripPattern other) {\n+    return stopPattern.equals(other.stopPattern);\n+  }\n+\n+  public Trip getTrip(int tripIndex) {\n+    return scheduledTimetable.getTripTimes(tripIndex).getTrip();\n+  }\n+\n+  /* METHODS THAT DELEGATE TO THE SCHEDULED TIMETABLE */\n+\n+  // TODO: These should probably be deprecated. That would require grabbing the scheduled timetable,\n+  // and would avoid mistakes where real-time updates are accidentally not taken into account.\n+\n+  /**\n+   * Add the given tripTimes to this pattern's scheduled timetable, recording the corresponding\n+   * trip as one of the scheduled trips on this pattern.\n+   */\n+  public void add(TripTimes tt) {\n+    // Only scheduled trips (added at graph build time, rather than directly to the timetable\n+    // via updates) are in this list.\n+    scheduledTimetable.addTripTimes(tt);\n+\n+    // Check that all trips added to this pattern are on the initially declared route.\n+    // Identity equality is valid on GTFS entity objects.\n+    if (this.route != tt.getTrip().getRoute()) {\n+      LOG.warn(\n+        \"The trip {} is on route {} but its stop pattern is on route {}.\",\n+        tt.getTrip(),\n+        tt.getTrip().getRoute(),\n+        route\n+      );\n+    }\n+  }\n+\n+  /**\n+   * Add the given FrequencyEntry to this pattern's scheduled timetable, recording the corresponding\n+   * trip as one of the scheduled trips on this pattern.\n+   * TODO possible improvements: combine freq entries and TripTimes. Do not keep trips list in TripPattern\n+   * since it is redundant.\n+   */\n+  public void add(FrequencyEntry freq) {\n+    scheduledTimetable.addFrequencyEntry(freq);\n+    if (this.getRoute() != freq.tripTimes.getTrip().getRoute()) {\n+      LOG.warn(\n+        \"The trip {} is on a different route than its stop pattern, which is on {}.\",\n+        freq.tripTimes.getTrip(),\n+        route\n+      );\n+    }\n+  }\n+\n+  /**\n+   * Remove all trips matching the given predicate.\n+   * @param removeTrip it the predicate returns true\n+   */\n+  public void removeTrips(Predicate<Trip> removeTrip) {\n+    scheduledTimetable.getTripTimes().removeIf(tt -> removeTrip.test(tt.getTrip()));\n+  }\n+\n+  public void setOriginalTripPattern(TripPattern originalTripPattern) {\n+    this.originalTripPattern = originalTripPattern;\n+  }\n+\n+  /**\n+   * The direction for all the trips in this pattern.\n+   */\n+  public Direction getDirection() {\n+    return scheduledTimetable.getDirection();\n+  }\n+\n+  /**\n+   * This pattern may have multiple Timetable objects, but they should all contain TripTimes\n+   * for the same trips, in the same order (that of the scheduled Timetable). An exception to\n+   * this rule may arise if unscheduled trips are added to a Timetable. For that case we need\n+   * to search for trips/TripIds in the Timetable rather than the enclosing TripPattern.\n+   */\n+  public Stream<Trip> scheduledTripsAsStream() {\n+    return scheduledTimetable.getTripTimes().stream().map(TripTimes::getTrip).distinct();\n+  }\n+\n+  /**\n+   * This is the \"original\" timetable holding the scheduled stop times from GTFS, with no\n+   * realtime updates applied. If realtime stoptime updates are applied, next/previous departure\n+   * searches will be conducted using a different, updated timetable in a snapshot.\n+   */\n+  public Timetable getScheduledTimetable() {\n+    return scheduledTimetable;\n+  }\n+\n+  /**\n+   * Has the TripPattern been created by a real-time update.\n+   */\n+  public boolean isCreatedByRealtimeUpdater() {\n+    return createdByRealtimeUpdater;\n+  }\n+\n+  public void setCreatedByRealtimeUpdater() {\n+    createdByRealtimeUpdater = true;\n+  }\n+\n+  private static String stopNameAndId(StopLocation stop) {\n+    return stop.getName() + \" (\" + stop.getId().toString() + \")\";\n+  }\n+\n+  /**\n+   * Static method that creates unique human-readable names for a collection of TableTripPatterns.\n+   * Perhaps this should be in TripPattern, and apply to Frequency patterns as well. TODO: resolve\n+   * this question: can a frequency and table pattern have the same stoppattern? If so should they\n+   * have the same \"unique\" name?\n+   *\n+   * The names should be dataset unique, not just route-unique?\n+   *\n+   * A TripPattern groups all trips visiting a particular pattern of stops on a particular route.\n+   * GFTS Route names are intended for very general customer information, but sometimes there is a\n+   * need to know where a particular trip actually goes. For example, the New York City N train\n+   * has at least four different variants: express (over the Manhattan bridge) and local (via\n+   * lower Manhattan and the tunnel), in two directions (to Astoria or to Coney Island). During\n+   * construction, a fifth variant sometimes appears: trains use the D line to Coney Island after\n+   * 59th St (or from Coney Island to 59th in the opposite direction).\n+   *\n+   * TripPattern names are machine-generated on a best-effort basis. They are guaranteed to be\n+   * unique (among TripPatterns for a single Route) but not stable across graph builds, especially\n+   * when different versions of GTFS inputs are used. For instance, if a variant is the only\n+   * variant of the N that ends at Coney Island, the name will be \"N to Coney Island\". But if\n+   * multiple variants end at Coney Island (but have different stops elsewhere), that name would\n+   * not be chosen. OTP also tries start and intermediate stations (\"from Coney Island\", or \"via\n+   * Whitehall\", or even combinations (\"from Coney Island via Whitehall\"). But if there is no way\n+   * to create a unique name from start/end/intermediate stops, then the best we can do is to\n+   * create a \"like [trip id]\" name, which at least tells you where in the GTFS you can find a\n+   * related trip.\n+   */\n+  // TODO: pass in a transit index that contains a Multimap<Route, TripPattern> and derive all TableTripPatterns\n+  // TODO: use headsigns before attempting to machine-generate names\n+  // TODO: combine from/to and via in a single name. this could be accomplished by grouping the trips by destination,\n+  // then disambiguating in groups of size greater than 1.\n+  /*\n+   * Another possible approach: for each route, determine the necessity of each field (which\n+   * combination will create unique names). from, to, via, express. Then concatenate all necessary\n+   * fields. Express should really be determined from number of stops and/or run time of trips.\n+   */\n+  public static void generateUniqueNames(\n+    Collection<TripPattern> tableTripPatterns,\n+    DataImportIssueStore issueStore\n+  ) {\n+    LOG.info(\"Generating unique names for stop patterns on each route.\");\n+    Set<String> usedRouteNames = Sets.newHashSet();\n+    Map<Route, String> uniqueRouteNames = Maps.newHashMap();\n+\n+    /* Group TripPatterns by Route */\n+    Multimap<Route, TripPattern> patternsByRoute = ArrayListMultimap.create();\n+    for (TripPattern ttp : tableTripPatterns) {\n+      patternsByRoute.put(ttp.route, ttp);\n+    }\n+\n+    /* Ensure we have a unique name for every Route */\n+    for (Route route : patternsByRoute.keySet()) {\n+      String routeName = route.getName();\n+      if (usedRouteNames.contains(routeName)) {\n+        int i = 2;\n+        String generatedRouteName;\n+        do generatedRouteName = routeName + \" \" + (i++); while (\n+          usedRouteNames.contains(generatedRouteName)\n+        );\n+        issueStore.add(new NonUniqueRouteName(generatedRouteName));\n+        routeName = generatedRouteName;\n+      }\n+      usedRouteNames.add(routeName);\n+      uniqueRouteNames.put(route, routeName);\n+    }\n+\n+    /* Iterate over all routes, giving the patterns within each route unique names. */\n+    ROUTE:for (Route route : patternsByRoute.keySet()) {\n+      Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n+      String routeName = uniqueRouteNames.get(route);\n+\n+      /* Simplest case: there's only one route variant, so we'll just give it the route's name. */\n+      if (routeTripPatterns.size() == 1) {\n+        routeTripPatterns.iterator().next().setName(routeName);\n+        continue;\n+      }\n+\n+      /* Do the patterns within this Route have a unique start, end, or via Stop? */\n+      Multimap<String, TripPattern> signs = ArrayListMultimap.create(); // prefer headsigns\n+      Multimap<StopLocation, TripPattern> starts = ArrayListMultimap.create();\n+      Multimap<StopLocation, TripPattern> ends = ArrayListMultimap.create();\n+      Multimap<StopLocation, TripPattern> vias = ArrayListMultimap.create();\n+\n+      for (TripPattern pattern : routeTripPatterns) {\n+        StopLocation start = pattern.firstStop();\n+        StopLocation end = pattern.lastStop();\n+        starts.put(start, pattern);\n+        ends.put(end, pattern);\n+        for (StopLocation stop : pattern.getStops()) {\n+          vias.put(stop, pattern);\n         }\n-    }\n-\n-    public void setHopGeometries(LineString[] hopGeometries) {\n-        this.hopGeometries = new byte[hopGeometries.length][];\n-\n-        for (int i = 0; i < hopGeometries.length; i++) {\n-            setHopGeometry(i, hopGeometries[i]);\n+      }\n+      PATTERN:for (TripPattern pattern : routeTripPatterns) {\n+        StringBuilder sb = new StringBuilder(routeName);\n+\n+        /* First try to name with destination. */\n+        var end = pattern.lastStop();\n+        sb.append(\" to \" + stopNameAndId(end));\n+        if (ends.get(end).size() == 1) {\n+          pattern.setName(sb.toString());\n+          continue PATTERN; // only pattern with this last stop\n         }\n-    }\n-\n-    public void setHopGeometry(int i, LineString hopGeometry) {\n-        this.hopGeometries[i] = CompactLineString.compactLineString(hopGeometry,false);\n-    }\n \n-    /**\n-     * This will copy the geometry from another TripPattern to this one. It checks if each hop is\n-     * between the same stops before copying that hop geometry. If the stops are different, a\n-     * straight-line hop-geometry will be used instead.\n-     *\n-     * @param other TripPattern to copy geometry from\n-     */\n-    public void setHopGeometriesFromPattern(TripPattern other) {\n-        this.hopGeometries = new byte[numberOfStops() - 1][];\n-\n-        // This accounts for the new TripPattern provided by a real-time update and the one that is\n-        // being replaced having a different number of stops. In that case the geometry will be\n-        // preserved up until the first mismatching stop, and a straight line will be used for\n-        // all segments after that.\n-        int sizeOfShortestPattern = Math.min(numberOfStops(), other.numberOfStops());\n-\n-        for (int i = 0; i < sizeOfShortestPattern - 1; i++) {\n-            if (other.getHopGeometry(i) != null\n-                && other.getStop(i).equals(this.getStop(i))\n-                && other.getStop(i + 1).equals(this.getStop(i + 1))) {\n-                // Copy hop geometry from previous pattern\n-                this.setHopGeometry(i, other.getHopGeometry(i));\n-            } else {\n-                // Create new straight-line geometry for hop\n-                this.setHopGeometry(i,\n-                    GeometryUtils.getGeometryFactory().createLineString(\n-                        new Coordinate[]{\n-                            coordinate(stopPattern.getStop(i)),\n-                            coordinate(stopPattern.getStop(i + 1))\n-                        }\n-                    )\n-                );\n-            }\n+        /* Then try to name with origin. */\n+        var start = pattern.firstStop();\n+        sb.append(\" from \" + stopNameAndId(start));\n+        if (starts.get(start).size() == 1) {\n+          pattern.setName((sb.toString()));\n+          continue PATTERN; // only pattern with this first stop\n         }\n-    }\n-\n-    public LineString getGeometry() {\n-        if(hopGeometries == null || hopGeometries.length==0) { return null; }\n \n-        List<LineString> lineStrings = new ArrayList<>();\n-        for (int i = 0; i < hopGeometries.length; i++) {\n-            lineStrings.add(getHopGeometry(i));\n+        /* Check whether (end, start) is unique. */\n+        Collection<TripPattern> tripPatterns = starts.get(start);\n+        Set<TripPattern> remainingPatterns = new HashSet<>(tripPatterns);\n+        remainingPatterns.retainAll(ends.get(end)); // set intersection\n+        if (remainingPatterns.size() == 1) {\n+          pattern.setName((sb.toString()));\n+          continue PATTERN;\n         }\n-        return GeometryUtils.concatenateLineStrings(lineStrings);\n-    }\n \n-    public int numHopGeometries() {\n-        return hopGeometries.length;\n-    }\n-\n-    public int numberOfStops() {\n-        return stopPattern.getSize();\n-    }\n-\n-    public StopLocation getStop(int stopPosInPattern) {\n-        return stopPattern.getStop(stopPosInPattern);\n-    }\n-\n-    public StopLocation firstStop() {\n-        return getStop(0);\n-    }\n-\n-    public StopLocation lastStop() {\n-        return getStop(stopPattern.getSize()-1);\n-    }\n-\n-    /** Read only list of stops */\n-    public List<StopLocation> getStops() {\n-        return stopPattern.getStops();\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop}. The search start at\n-     * position {@code 0}. Return a negative number if not found. Use {@link\n-     * #findAlightStopPositionInPattern(StopLocation)} or {@link #findBoardingStopPositionInPattern(StopLocation)}\n-     * if possible.\n-     */\n-    public int findStopPosition(StopLocation stop) {\n-        return stopPattern.findStopPosition(stop);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code station} where it is\n-     * allowed to board. The search start at position {@code 0}. Return a negative number if not\n-     * found.\n-     */\n-    public int findBoardingStopPositionInPattern(Station station) {\n-        return stopPattern.findBoardingPosition(station);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code station} where it is\n-     * allowed to alight. The search start at position {@code 1}. Return a negative number if not\n-     * found.\n-     */\n-    public int findAlightStopPositionInPattern(Station station) {\n-        return stopPattern.findAlightPosition(station);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n-     * to board. The search start at position {@code 0}. Return a negative number if not found.\n-     */\n-    public int findBoardingStopPositionInPattern(StopLocation stop) {\n-        return stopPattern.findBoardingPosition(stop);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n-     * to alight. The search start at position {@code 1}. Return a negative number if not found.\n-     */\n-    public int findAlightStopPositionInPattern(StopLocation stop) {\n-        return stopPattern.findAlightPosition(stop);\n-    }\n-\n-    /** Returns whether passengers can alight at a given stop */\n-    public boolean canAlight(int stopIndex) {\n-        return stopPattern.canAlight(stopIndex);\n-    }\n-\n-    /** Returns whether passengers can board at a given stop */\n-    public boolean canBoard(int stopIndex) {\n-        return stopPattern.canBoard(stopIndex);\n-    }\n-\n-    /**\n-     * Returns whether passengers can board at a given stop.\n-     * This is an inefficient method iterating over the stops, do not use it in routing.\n-     */\n-    public boolean canBoard(StopLocation stop) {\n-        return stopPattern.canBoard(stop);\n-    }\n-\n-    /** Returns whether a given stop is wheelchair-accessible. */\n-    public boolean wheelchairAccessible(int stopIndex) {\n-        return stopPattern.getStop(stopIndex).getWheelchairBoarding() == WheelChairBoarding.POSSIBLE;\n-    }\n-\n-    public PickDrop getAlightType(int stopIndex) {\n-        return stopPattern.getDropoff(stopIndex);\n-    }\n-\n-    public PickDrop getBoardType(int stopIndex) {\n-        return stopPattern.getPickup(stopIndex);\n-    }\n-\n-    public boolean isBoardAndAlightAt(int stopIndex, PickDrop value) {\n-        return getBoardType(stopIndex).is(value) && getAlightType(stopIndex).is(value);\n-    }\n-\n-    public boolean stopPatternIsEqual(TripPattern other) {\n-        return stopPattern.equals(other.stopPattern);\n-    }\n-\n-    public Trip getTrip(int tripIndex) {\n-        return scheduledTimetable.getTripTimes(tripIndex).getTrip();\n-    }\n-\n-    /* METHODS THAT DELEGATE TO THE SCHEDULED TIMETABLE */\n-\n-    // TODO: These should probably be deprecated. That would require grabbing the scheduled timetable,\n-    // and would avoid mistakes where real-time updates are accidentally not taken into account.\n-\n-    /**\n-     * Add the given tripTimes to this pattern's scheduled timetable, recording the corresponding\n-     * trip as one of the scheduled trips on this pattern.\n-     */\n-    public void add(TripTimes tt) {\n-        // Only scheduled trips (added at graph build time, rather than directly to the timetable\n-        // via updates) are in this list.\n-        scheduledTimetable.addTripTimes(tt);\n-\n-        // Check that all trips added to this pattern are on the initially declared route.\n-        // Identity equality is valid on GTFS entity objects.\n-        if (this.route != tt.getTrip().getRoute()) {\n-            LOG.warn(\"The trip {} is on route {} but its stop pattern is on route {}.\",\n-                tt.getTrip(), tt.getTrip().getRoute(),\n-                route\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Add the given FrequencyEntry to this pattern's scheduled timetable, recording the corresponding\n-     * trip as one of the scheduled trips on this pattern.\n-     * TODO possible improvements: combine freq entries and TripTimes. Do not keep trips list in TripPattern\n-     * since it is redundant.\n-     */\n-    public void add(FrequencyEntry freq) {\n-        scheduledTimetable.addFrequencyEntry(freq);\n-        if (this.getRoute() != freq.tripTimes.getTrip().getRoute()) {\n-            LOG.warn(\"The trip {} is on a different route than its stop pattern, which is on {}.\",\n-                freq.tripTimes.getTrip(),\n-                route\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Remove all trips matching the given predicate.\n-     * @param removeTrip it the predicate returns true\n-     */\n-    public void removeTrips(Predicate<Trip> removeTrip) {\n-        scheduledTimetable.getTripTimes().removeIf(tt -> removeTrip.test(tt.getTrip()));\n-    }\n-\n-    public void setOriginalTripPattern(TripPattern originalTripPattern) {\n-        this.originalTripPattern = originalTripPattern;\n-    }\n-\n-    /**\n-     * The direction for all the trips in this pattern.\n-     */\n-    public Direction getDirection() {\n-        return scheduledTimetable.getDirection();\n-    }\n-\n-    /**\n-     * This pattern may have multiple Timetable objects, but they should all contain TripTimes\n-     * for the same trips, in the same order (that of the scheduled Timetable). An exception to\n-     * this rule may arise if unscheduled trips are added to a Timetable. For that case we need\n-     * to search for trips/TripIds in the Timetable rather than the enclosing TripPattern.\n-     */\n-    public Stream<Trip> scheduledTripsAsStream() {\n-        return scheduledTimetable.getTripTimes().stream().map(TripTimes::getTrip).distinct();\n-    }\n-\n-    /**\n-     * This is the \"original\" timetable holding the scheduled stop times from GTFS, with no\n-     * realtime updates applied. If realtime stoptime updates are applied, next/previous departure\n-     * searches will be conducted using a different, updated timetable in a snapshot.\n-     */\n-    public Timetable getScheduledTimetable() {\n-        return scheduledTimetable;\n-    }\n-\n-    /**\n-     * Has the TripPattern been created by a real-time update.\n-     */\n-    public boolean isCreatedByRealtimeUpdater() {\n-        return createdByRealtimeUpdater;\n-    }\n-\n-    public void setCreatedByRealtimeUpdater() {\n-        createdByRealtimeUpdater = true;\n-    }\n-\n-    private static String stopNameAndId (StopLocation stop) {\n-        return stop.getName() + \" (\" + stop.getId().toString() + \")\";\n-    }\n-\n-    /**\n-     * Static method that creates unique human-readable names for a collection of TableTripPatterns.\n-     * Perhaps this should be in TripPattern, and apply to Frequency patterns as well. TODO: resolve\n-     * this question: can a frequency and table pattern have the same stoppattern? If so should they\n-     * have the same \"unique\" name?\n-     *\n-     * The names should be dataset unique, not just route-unique?\n-     *\n-     * A TripPattern groups all trips visiting a particular pattern of stops on a particular route.\n-     * GFTS Route names are intended for very general customer information, but sometimes there is a\n-     * need to know where a particular trip actually goes. For example, the New York City N train\n-     * has at least four different variants: express (over the Manhattan bridge) and local (via\n-     * lower Manhattan and the tunnel), in two directions (to Astoria or to Coney Island). During\n-     * construction, a fifth variant sometimes appears: trains use the D line to Coney Island after\n-     * 59th St (or from Coney Island to 59th in the opposite direction).\n-     *\n-     * TripPattern names are machine-generated on a best-effort basis. They are guaranteed to be\n-     * unique (among TripPatterns for a single Route) but not stable across graph builds, especially\n-     * when different versions of GTFS inputs are used. For instance, if a variant is the only\n-     * variant of the N that ends at Coney Island, the name will be \"N to Coney Island\". But if\n-     * multiple variants end at Coney Island (but have different stops elsewhere), that name would\n-     * not be chosen. OTP also tries start and intermediate stations (\"from Coney Island\", or \"via\n-     * Whitehall\", or even combinations (\"from Coney Island via Whitehall\"). But if there is no way\n-     * to create a unique name from start/end/intermediate stops, then the best we can do is to\n-     * create a \"like [trip id]\" name, which at least tells you where in the GTFS you can find a\n-     * related trip.\n-     */\n-    // TODO: pass in a transit index that contains a Multimap<Route, TripPattern> and derive all TableTripPatterns\n-    // TODO: use headsigns before attempting to machine-generate names\n-    // TODO: combine from/to and via in a single name. this could be accomplished by grouping the trips by destination,\n-    // then disambiguating in groups of size greater than 1.\n-    /*\n-     * Another possible approach: for each route, determine the necessity of each field (which\n-     * combination will create unique names). from, to, via, express. Then concatenate all necessary\n-     * fields. Express should really be determined from number of stops and/or run time of trips.\n-     */\n-    public static void generateUniqueNames (\n-            Collection<TripPattern> tableTripPatterns,\n-            DataImportIssueStore issueStore\n-    ) {\n-        LOG.info(\"Generating unique names for stop patterns on each route.\");\n-        Set<String> usedRouteNames = Sets.newHashSet();\n-        Map<Route, String> uniqueRouteNames = Maps.newHashMap();\n-\n-        /* Group TripPatterns by Route */\n-        Multimap<Route, TripPattern> patternsByRoute = ArrayListMultimap.create();\n-        for (TripPattern ttp : tableTripPatterns) {\n-            patternsByRoute.put(ttp.route, ttp);\n-        }\n-\n-        /* Ensure we have a unique name for every Route */\n-        for (Route route : patternsByRoute.keySet()) {\n-            String routeName = route.getName();\n-            if (usedRouteNames.contains(routeName)) {\n-                int i = 2;\n-                String generatedRouteName;\n-                do generatedRouteName = routeName + \" \" + (i++);\n-                while (usedRouteNames.contains(generatedRouteName));\n-                issueStore.add(new NonUniqueRouteName(generatedRouteName));\n-                routeName = generatedRouteName;\n-            }\n-            usedRouteNames.add(routeName);\n-            uniqueRouteNames.put(route, routeName);\n+        /* Still not unique; try (end, start, via) for each via. */\n+        for (var via : pattern.getStops()) {\n+          if (via.equals(start) || via.equals(end)) continue;\n+          Set<TripPattern> intersection = new HashSet<>();\n+          intersection.addAll(remainingPatterns);\n+          intersection.retainAll(vias.get(via));\n+          if (intersection.size() == 1) {\n+            sb.append(\" via \" + stopNameAndId(via));\n+            pattern.setName((sb.toString()));\n+            continue PATTERN;\n+          }\n         }\n \n-        /* Iterate over all routes, giving the patterns within each route unique names. */\n-        ROUTE : for (Route route : patternsByRoute.keySet()) {\n-            Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n-            String routeName = uniqueRouteNames.get(route);\n-\n-            /* Simplest case: there's only one route variant, so we'll just give it the route's name. */\n-            if (routeTripPatterns.size() == 1) {\n-                routeTripPatterns.iterator().next().setName(routeName);\n-                continue;\n-            }\n-\n-            /* Do the patterns within this Route have a unique start, end, or via Stop? */\n-            Multimap<String, TripPattern> signs   = ArrayListMultimap.create(); // prefer headsigns\n-            Multimap<StopLocation, TripPattern> starts  = ArrayListMultimap.create();\n-            Multimap<StopLocation, TripPattern> ends    = ArrayListMultimap.create();\n-            Multimap<StopLocation, TripPattern> vias    = ArrayListMultimap.create();\n-\n-            for (TripPattern pattern : routeTripPatterns) {\n-                StopLocation start = pattern.firstStop();\n-                StopLocation end   = pattern.lastStop();\n-                starts.put(start, pattern);\n-                ends.put(end, pattern);\n-                for (StopLocation stop : pattern.getStops()) {\n-                    vias.put(stop, pattern);\n-                }\n-            }\n-            PATTERN : for (TripPattern pattern : routeTripPatterns) {\n-                StringBuilder sb = new StringBuilder(routeName);\n-\n-                /* First try to name with destination. */\n-                var end = pattern.lastStop();\n-                sb.append(\" to \" + stopNameAndId(end));\n-                if (ends.get(end).size() == 1) {\n-                    pattern.setName(sb.toString());\n-                    continue PATTERN; // only pattern with this last stop\n-                }\n-\n-                /* Then try to name with origin. */\n-                var start = pattern.firstStop();\n-                sb.append(\" from \" + stopNameAndId(start));\n-                if (starts.get(start).size() == 1) {\n-                    pattern.setName((sb.toString()));\n-                    continue PATTERN; // only pattern with this first stop\n-                }\n-\n-                /* Check whether (end, start) is unique. */\n-                Collection<TripPattern> tripPatterns = starts.get(start);\n-                Set<TripPattern> remainingPatterns = new HashSet<>(tripPatterns);\n-                remainingPatterns.retainAll(ends.get(end)); // set intersection\n-                if (remainingPatterns.size() == 1) {\n-                    pattern.setName((sb.toString()));\n-                    continue PATTERN;\n-                }\n-\n-                /* Still not unique; try (end, start, via) for each via. */\n-                for (var via : pattern.getStops()) {\n-                    if (via.equals(start) || via.equals(end)) continue;\n-                    Set<TripPattern> intersection = new HashSet<>();\n-                    intersection.addAll(remainingPatterns);\n-                    intersection.retainAll(vias.get(via));\n-                    if (intersection.size() == 1) {\n-                        sb.append(\" via \" + stopNameAndId(via));\n-                        pattern.setName((sb.toString()));\n-                        continue PATTERN;\n-                    }\n-                }\n-\n-                /* Still not unique; check for express. */\n-                if (remainingPatterns.size() == 2) {\n-                    // There are exactly two patterns sharing this start/end.\n-                    // The current one must be a subset of the other, because it has no unique via.\n-                    // Therefore we call it the express.\n-                    sb.append(\" express\");\n-                } else {\n-                    // The final fallback: reference a specific trip ID.\n-                    Trip trip = null;\n-                    if (!pattern.scheduledTimetable.getTripTimes().isEmpty()) {\n-                        trip = pattern.scheduledTimetable.getTripTimes().get(0).getTrip();\n-                    } else if (!pattern.scheduledTimetable.getFrequencyEntries().isEmpty()) {\n-                        trip = pattern.scheduledTimetable.getFrequencyEntries().get(0).tripTimes.getTrip();\n-                    }\n-\n-                    if (trip != null) {\n-                        sb.append(\" like trip \").append(trip.getId());\n-                    }\n-\n-                }\n-                pattern.setName((sb.toString()));\n-            } // END foreach PATTERN\n-        } // END foreach ROUTE\n-\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Done generating unique names for stop patterns on each route.\");\n-            for (Route route : patternsByRoute.keySet()) {\n-                Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n-                LOG.debug(\"Named {} patterns in route {}\", routeTripPatterns.size(), uniqueRouteNames.get(route));\n-                for (TripPattern pattern : routeTripPatterns) {\n-                    LOG.debug(\"    {} ({} stops)\", pattern.name, pattern.stopPattern.getSize());\n-                }\n-            }\n+        /* Still not unique; check for express. */\n+        if (remainingPatterns.size() == 2) {\n+          // There are exactly two patterns sharing this start/end.\n+          // The current one must be a subset of the other, because it has no unique via.\n+          // Therefore we call it the express.\n+          sb.append(\" express\");\n+        } else {\n+          // The final fallback: reference a specific trip ID.\n+          Trip trip = null;\n+          if (!pattern.scheduledTimetable.getTripTimes().isEmpty()) {\n+            trip = pattern.scheduledTimetable.getTripTimes().get(0).getTrip();\n+          } else if (!pattern.scheduledTimetable.getFrequencyEntries().isEmpty()) {\n+            trip = pattern.scheduledTimetable.getFrequencyEntries().get(0).tripTimes.getTrip();\n+          }\n+\n+          if (trip != null) {\n+            sb.append(\" like trip \").append(trip.getId());\n+          }\n         }\n-    }\n-\n-    /**\n-     * A bit of a strange place to set service codes all at once when TripTimes are already added,\n-     * but we need a reference to the Graph or at least the codes map. This could also be\n-     * placed in the hop factory itself.\n-     */\n-    public void setServiceCodes (Map<FeedScopedId, Integer> serviceCodes) {\n-        setServices(new BitSet());\n-        scheduledTripsAsStream().forEach (trip -> {\n-            FeedScopedId serviceId = trip.getServiceId();\n-            if (serviceCodes.containsKey(serviceId)) {\n-                services.set(serviceCodes.get(serviceId));\n-            }\n-            else {\n-                LOG.warn(\"Service \" + serviceId + \" not found in service codes not found.\");\n-            }\n-        });\n-        scheduledTimetable.setServiceCodes (serviceCodes);\n-    }\n-\n-    /**\n-     * A set of serviceIds with at least one trip in this pattern.\n-     * Trips in a pattern are no longer necessarily running on the same service ID.\n-     */ /**\n-     * @return bitset of service codes\n-     */\n-    public BitSet getServices() {\n-        return services;\n-    }\n-\n-    /**\n-     * @param services bitset of service codes\n-     */\n-    public void setServices(BitSet services) {\n-        this.services = services;\n-    }\n-\n-    public String getTripHeadsign() {\n-        return scheduledTimetable.getTripTimes(0).getTrip().getTripHeadsign();\n-    }\n-\n-    public static boolean idsAreUniqueAndNotNull(Collection<TripPattern> tripPatterns) {\n-        Set<FeedScopedId> seen = new HashSet<>();\n-        return tripPatterns.stream()\n-            .map(TransitEntity::getId)\n-            .allMatch(t -> t != null && seen.add(t));\n-    }\n-\n-    public boolean matchesModeOrSubMode(TransitMode mode, String transportSubmode) {\n-        return getMode().equals(mode) || (\n-                getNetexSubmode() != null && getNetexSubmode().equals(transportSubmode)\n+        pattern.setName((sb.toString()));\n+      } // END foreach PATTERN\n+    } // END foreach ROUTE\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Done generating unique names for stop patterns on each route.\");\n+      for (Route route : patternsByRoute.keySet()) {\n+        Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n+        LOG.debug(\n+          \"Named {} patterns in route {}\",\n+          routeTripPatterns.size(),\n+          uniqueRouteNames.get(route)\n         );\n-    }\n-\n-    public String toString () {\n-        return String.format(\"<TripPattern %s>\", this.getId());\n-    }\n-\n-    /**\n-     * In most cases we want to use identity equality for Trips.\n-     * However, in some cases we want a way to consistently identify trips across versions of a GTFS feed, when the\n-     * feed publisher cannot ensure stable trip IDs. Therefore we define some additional hash functions.\n-     * Hash collisions are theoretically possible, so these identifiers should only be used to detect when two\n-     * trips are the same with a high degree of probability.\n-     * An example application is avoiding double-booking of a particular bus trip for school field trips.\n-     * Using Murmur hash function. see http://programmers.stackexchange.com/a/145633 for comparison.\n-     *\n-     * @param trip a trip object within this pattern, or null to hash the pattern itself independent any specific trip.\n-     * @return the semantic hash of a Trip in this pattern as a printable String.\n-     *\n-     * TODO deal with frequency-based trips\n-     */\n-    public String semanticHashString(Trip trip) {\n-        HashFunction murmur = Hashing.murmur3_32();\n-        BaseEncoding encoder = BaseEncoding.base64Url().omitPadding();\n-        StringBuilder sb = new StringBuilder(50);\n-        sb.append(encoder.encode(stopPattern.semanticHash(murmur).asBytes()));\n-        if (trip != null) {\n-            TripTimes tripTimes = scheduledTimetable.getTripTimes(trip);\n-            if (tripTimes == null) { return null; }\n-            sb.append(':');\n-            sb.append(encoder.encode(tripTimes.semanticHash(murmur).asBytes()));\n+        for (TripPattern pattern : routeTripPatterns) {\n+          LOG.debug(\"    {} ({} stops)\", pattern.name, pattern.stopPattern.getSize());\n         }\n-        return sb.toString();\n-    }\n-\n-    public TripPattern clone () {\n-        try {\n-            return (TripPattern) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            /* cannot happen */\n-            throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A bit of a strange place to set service codes all at once when TripTimes are already added,\n+   * but we need a reference to the Graph or at least the codes map. This could also be\n+   * placed in the hop factory itself.\n+   */\n+  public void setServiceCodes(Map<FeedScopedId, Integer> serviceCodes) {\n+    setServices(new BitSet());\n+    scheduledTripsAsStream()\n+      .forEach(trip -> {\n+        FeedScopedId serviceId = trip.getServiceId();\n+        if (serviceCodes.containsKey(serviceId)) {\n+          services.set(serviceCodes.get(serviceId));\n+        } else {\n+          LOG.warn(\"Service \" + serviceId + \" not found in service codes not found.\");\n         }\n-    }\n-\n-    /**\n-     * Get the feed id this trip pattern belongs to.\n-     *\n-     * @return feed id for this trip pattern\n-     */\n-    public String getFeedId() {\n-        // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return route.getId().getFeedId();\n-    }\n-\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        // The serialized graph contains cyclic references TripPattern <--> Timetable.\n-        // The Timetable must be indexed from here (rather than in its own readObject method)\n-        // to ensure that the stops field it uses in TripPattern is already deserialized.\n-        scheduledTimetable.finish();\n-    }\n-\n-    private static Coordinate coordinate(StopLocation s) {\n-        return new Coordinate(s.getLon(), s.getLat());\n-    }\n+      });\n+    scheduledTimetable.setServiceCodes(serviceCodes);\n+  }\n+\n+  /**\n+   * Sets service code for pattern if it's not already set\n+   *\n+   * @param serviceCode service code that needs to be set\n+   */\n+  public void setServiceCode(int serviceCode) {\n+    if (!getServices().get(serviceCode)) {\n+      final BitSet services = (BitSet) getServices().clone();\n+      services.set(serviceCode);\n+      setServices(services);\n+    }\n+  }\n+\n+  /**\n+   * A set of serviceIds with at least one trip in this pattern.\n+   * Trips in a pattern are no longer necessarily running on the same service ID.\n+   *\n+   * @return bitset of service codes\n+   */\n+  public BitSet getServices() {\n+    return services;\n+  }\n+\n+  /**\n+   * @param services bitset of service codes\n+   */\n+  public void setServices(BitSet services) {\n+    this.services = services;\n+  }\n+\n+  public String getTripHeadsign() {\n+    return scheduledTimetable.getTripTimes(0).getTrip().getTripHeadsign();\n+  }\n+\n+  public static boolean idsAreUniqueAndNotNull(Collection<TripPattern> tripPatterns) {\n+    Set<FeedScopedId> seen = new HashSet<>();\n+    return tripPatterns.stream().map(TransitEntity::getId).allMatch(t -> t != null && seen.add(t));\n+  }\n+\n+  public boolean matchesModeOrSubMode(TransitMode mode, String transportSubmode) {\n+    return (\n+      getMode().equals(mode) ||\n+      (getNetexSubmode() != null && getNetexSubmode().equals(transportSubmode))\n+    );\n+  }\n+\n+  public String toString() {\n+    return String.format(\"<TripPattern %s>\", this.getId());\n+  }\n+\n+  /**\n+   * In most cases we want to use identity equality for Trips.\n+   * However, in some cases we want a way to consistently identify trips across versions of a GTFS feed, when the\n+   * feed publisher cannot ensure stable trip IDs. Therefore we define some additional hash functions.\n+   * Hash collisions are theoretically possible, so these identifiers should only be used to detect when two\n+   * trips are the same with a high degree of probability.\n+   * An example application is avoiding double-booking of a particular bus trip for school field trips.\n+   * Using Murmur hash function. see http://programmers.stackexchange.com/a/145633 for comparison.\n+   *\n+   * @param trip a trip object within this pattern, or null to hash the pattern itself independent any specific trip.\n+   * @return the semantic hash of a Trip in this pattern as a printable String.\n+   *\n+   * TODO deal with frequency-based trips\n+   */\n+  public String semanticHashString(Trip trip) {\n+    HashFunction murmur = Hashing.murmur3_32();\n+    BaseEncoding encoder = BaseEncoding.base64Url().omitPadding();\n+    StringBuilder sb = new StringBuilder(50);\n+    sb.append(encoder.encode(stopPattern.semanticHash(murmur).asBytes()));\n+    if (trip != null) {\n+      TripTimes tripTimes = scheduledTimetable.getTripTimes(trip);\n+      if (tripTimes == null) {\n+        return null;\n+      }\n+      sb.append(':');\n+      sb.append(encoder.encode(tripTimes.semanticHash(murmur).asBytes()));\n+    }\n+    return sb.toString();\n+  }\n+\n+  public TripPattern clone() {\n+    try {\n+      return (TripPattern) super.clone();\n+    } catch (CloneNotSupportedException e) {\n+      /* cannot happen */\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Get the feed id this trip pattern belongs to.\n+   *\n+   * @return feed id for this trip pattern\n+   */\n+  public String getFeedId() {\n+    // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n+    return route.getId().getFeedId();\n+  }\n+\n+  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    in.defaultReadObject();\n+    // The serialized graph contains cyclic references TripPattern <--> Timetable.\n+    // The Timetable must be indexed from here (rather than in its own readObject method)\n+    // to ensure that the stops field it uses in TripPattern is already deserialized.\n+    scheduledTimetable.finish();\n+  }\n+\n+  private static Coordinate coordinate(StopLocation s) {\n+    return new Coordinate(s.getLon(), s.getLat());\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex f6cc4bd6e9..542ad1888c 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -737,8 +734,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n-\n-  private static Coordinate coordinate(StopLocation s) {\n-    return new Coordinate(s.getLon(), s.getLat());\n-  }\n }\n", "next_change": {"commit": "299e099bb81dfcc2564362b514941aa063a2ad3e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 542ad1888c..3eb453f3d1 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -734,4 +718,41 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n+\n+  /**\n+   * Check if given stop and next stop on this trip pattern and other are equal.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if stop and next stop are equal on bouth trip patterns, else false\n+   */\n+  private boolean sameStops(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index);\n+    var otherDestination = other.getStop(index + 1);\n+    var origin = getStop(index);\n+    var destination = getStop(index + 1);\n+\n+    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n+  }\n+\n+  /**\n+   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if the stops have the same stations, else false. If any station is null then\n+   * false.\n+   */\n+  private boolean sameStations(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index).getParentStation();\n+    var otherDestination = other.getStop(index + 1).getParentStation();\n+    var origin = getStop(index).getParentStation();\n+    var destionation = getStop(index + 1).getParentStation();\n+\n+    if (origin == null || destionation == null) {\n+      return false;\n+    }\n+\n+    return origin.equals(otherOrigin) && destionation.equals(otherDestination);\n+  }\n }\n", "next_change": {"commit": "58d46b727f471f87a358bb475fa135b3459be11d", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 3eb453f3d1..dfa76dcf46 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -718,41 +741,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n-\n-  /**\n-   * Check if given stop and next stop on this trip pattern and other are equal.\n-   *\n-   * @param other Other instance of trip pattern with list of stops. May not be null.\n-   * @param index Given index for stop\n-   * @return true if stop and next stop are equal on bouth trip patterns, else false\n-   */\n-  private boolean sameStops(TripPattern other, int index) {\n-    var otherOrigin = other.getStop(index);\n-    var otherDestination = other.getStop(index + 1);\n-    var origin = getStop(index);\n-    var destination = getStop(index + 1);\n-\n-    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n-  }\n-\n-  /**\n-   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n-   *\n-   * @param other Other instance of trip pattern with list of stops. May not be null.\n-   * @param index Given index for stop\n-   * @return true if the stops have the same stations, else false. If any station is null then\n-   * false.\n-   */\n-  private boolean sameStations(TripPattern other, int index) {\n-    var otherOrigin = other.getStop(index).getParentStation();\n-    var otherDestination = other.getStop(index + 1).getParentStation();\n-    var origin = getStop(index).getParentStation();\n-    var destionation = getStop(index + 1).getParentStation();\n-\n-    if (origin == null || destionation == null) {\n-      return false;\n-    }\n-\n-    return origin.equals(otherOrigin) && destionation.equals(otherDestination);\n-  }\n }\n", "next_change": {"commit": "ec4cc70876ec8faae730c7000d1c5d5634527428", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex dfa76dcf46..1fab7bd926 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -741,4 +718,47 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n+\n+  /**\n+   * Check if given stop and next stop on this trip pattern and other are equal.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if stop and next stop are equal on bouth trip patterns, else false\n+   */\n+  private boolean sameStops(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index);\n+    var otherDestination = other.getStop(index + 1);\n+    var origin = getStop(index);\n+    var destination = getStop(index + 1);\n+\n+    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n+  }\n+\n+  /**\n+   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if the stops have the same stations, else false. If any station is null then\n+   * false.\n+   */\n+  private boolean sameStations(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index).getParentStation();\n+    var otherDestination = other.getStop(index + 1).getParentStation();\n+    var origin = getStop(index).getParentStation();\n+    var destionation = getStop(index + 1).getParentStation();\n+\n+    var sameOrigin = Optional\n+      .ofNullable(origin)\n+      .map(o -> o.equals(otherOrigin))\n+      .orElse(getStop(index).equals(other.getStop(index)));\n+\n+    var sameDestination = Optional\n+      .ofNullable(destionation)\n+      .map(o -> o.equals(otherDestination))\n+      .orElse(getStop(index + 1).equals(other.getStop(index + 1)));\n+\n+    return sameOrigin && sameDestination;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "16c031b5ff80729111eb04c8f015276abfc59128", "committedDate": "2020-10-05 10:23:48 +0300", "message": "Add patterns to patternsForStop only if they are coming from real-time updates"}, {"oid": "d8afd66107af2c11641b13cdfa0c02841c11ed7f", "committedDate": "2020-10-05 11:31:50 +0300", "message": "Make TransitEntity equals and hashcode non-extendable"}, {"oid": "e2fa33c192e6af4b6d9ca4bcd99d74a1528ed6ce", "committedDate": "2020-10-06 12:35:54 +0300", "message": "Add setCreatedByRealtimeUpdater"}, {"oid": "7fdcfaf8104e8b2fa94ef78591c7471399dad484", "committedDate": "2020-10-08 19:17:30 +0200", "message": "Fix issue #3195 - Build and load GTFS files for San Francisco Bay Area.  - Make `StopLevel` Serializable.  - The `TripPattern#getGeometry()` should return null, not fail with a NPE when there is no geometry - no matter the cause."}, {"oid": "d57c16470beca49f137f0c7b8f7097482e4a9137", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Remove generic type argument from TransitEntity, the 'id' is now a FeedScopedId."}, {"oid": "236c05560fabc07658d98c2b68345c83ade4446f", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Encapsulate id as \"read-only\" in TransitEntity. This require some refactorings, like generating the TripPattern id at the time it is created, not as a post processing step. It also require all sub-classes of transit entity to have a constructor with the id as a parameter. THIS COMMIT COMPILES, BUT TESTS FAILS BECAUSE GENERATING TRIP PATTERN IDS IS LEFT TO THE NEXT COMMIT."}, {"oid": "945184168355309126bbeb74919f6d3df1d37fa6", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Generate TripPattern id BEFORE creating new pattern to be able to make the `TripPattern.id` read-only."}, {"oid": "be23b905919c899bb3ec790669334ba5b3a84619", "committedDate": "2020-10-09 11:55:38 +0200", "message": "Merge remote-tracking branch 'otp/2.0-rc' into dev-2.x"}, {"oid": "58ae629e67912dd4f984dd6300e3e1397806e09c", "committedDate": "2020-10-12 11:10:18 +0200", "message": "Merge branch 'dev-2.x' into otp2_cleanup_TransitEntity"}, {"oid": "9d68c276f351e37f3a56e6e278bf6f9e5e71e038", "committedDate": "2020-12-16 11:41:06 +0200", "message": "Fix geometry response to contain full data up to last stop"}, {"oid": "6591b59ff43d57d4e46537bc064e66a8a7017bc8", "committedDate": "2021-02-02 13:56:03 +0100", "message": "Add Direction enum to OTP model and add Netex mapping"}, {"oid": "f6dd7393d91fb897fae7a4d632f0de0cc11efa4a", "committedDate": "2021-02-04 16:39:46 +0100", "message": "Changes based on comments"}, {"oid": "16170f340345dd3c68e8ce7a8d56067dc0be7367", "committedDate": "2021-03-24 17:55:51 +0100", "message": "Clean code - make sure if is followed by `{}`."}, {"oid": "a4238b9e374d6c4ac17885244ac9791b638e2b4e", "committedDate": "2021-07-23 14:55:38 +0200", "message": "Add PickDrop enum and simplify StopPattern"}, {"oid": "fd9fe2a3391bda1eb10acf101f338ea0651620c4", "committedDate": "2021-07-23 15:05:03 +0200", "message": "Remove perStopFlags from TripPattern"}, {"oid": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "committedDate": "2021-07-23 15:25:47 +0200", "message": "Encapsulate fields in TripPattern"}, {"oid": "69dd76a878fd365e2bb4755b60c9c7be30041c14", "committedDate": "2021-07-23 15:29:06 +0200", "message": "Remove trips from TripPattern - refer to TripTimes instead"}, {"oid": "a86208e0283a6d191a35d33e09b3ab7922130fd0", "committedDate": "2021-07-23 15:54:11 +0200", "message": "Encapsulate fields in TripTimes"}, {"oid": "55c7116430720c1c91c2673787cb9593f64d658f", "committedDate": "2021-07-27 12:42:52 +0200", "message": "Remove getters for fields in same class"}, {"oid": "0ba64706337946bcd989f09377f12b076e892769", "committedDate": "2021-07-27 14:05:27 +0200", "message": "Encapsulate fields in Timetable"}, {"oid": "acf334d3ee4956c41586785ceba398104a8e43c4", "committedDate": "2021-12-10 12:51:40 +0100", "message": "Replace Stop with StopLocation in internal logic"}, {"oid": "c35a6f125a95433e737adfa103070b07ee8df888", "committedDate": "2021-12-10 12:51:40 +0100", "message": "Disallow getting on or off at flex stops during transit search"}, {"oid": "3ad7cc19099a2c29d59b5609b7e2e56167364b37", "committedDate": "2021-12-10 12:51:42 +0100", "message": "Raptor pickup/dropoff permissions during instanciation"}, {"oid": "9a599ab0cf4c0ea7e0e51677a96245236c71e73e", "committedDate": "2021-12-17 13:50:40 +0200", "message": "feat: Read in and expose Netex submode in Transmodel API"}, {"oid": "539bf9a3cbca42512b6d65085e91133d1e4205ee", "committedDate": "2021-12-20 12:06:18 +0100", "message": "refactor: cleanup TripPattern"}, {"oid": "907a752feb3be63a700b4fd18ad20be30f3d7556", "committedDate": "2022-01-06 23:11:51 +0200", "message": "Apply suggestions from code review"}, {"oid": "594f8f4b4825bfc1e8513df756fbc20f499c9e26", "committedDate": "2022-01-07 16:44:53 +0100", "message": "refactor: Encapsulate StopPattern in TripPattern"}, {"oid": "1390922298386f03152d6696caf1a6ff3dcc24f5", "committedDate": "2022-01-11 02:08:01 +0100", "message": "feat: Support for GTFS Trip, Route, Stop & Station Transfers"}, {"oid": "768117c09e4a1d2845f3db933b53a0cf6448455a", "committedDate": "2022-01-14 11:31:21 +0100", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_not_allowed_transfers"}, {"oid": "bab6818d9fec41ca2b415526350df5515f5911cb", "committedDate": "2022-02-09 11:12:01 +0200", "message": "Add javadoc"}, {"oid": "8405e27b47553745872554e94bb59faf94a8ebe4", "committedDate": "2022-02-09 16:08:22 +0200", "message": "Add constrained transfers to patterns generated by realtime updates"}, {"oid": "b67507f8179ccdddc0bb0d2e583dfad8abfe0def", "committedDate": "2022-02-10 15:47:52 +0200", "message": "Add documentation"}, {"oid": "289e69198016bf152890f6f8fa0f11621a031d0a", "committedDate": "2022-02-11 15:55:42 +0200", "message": "Merge pull request #3878 from entur/otp2_realtime_constrained_transfers"}, {"oid": "461ba982285aa33774e97923b2bb8124b0b13a82", "committedDate": "2022-02-18 15:10:18 +0200", "message": "feat: Add support for frequency trips"}, {"oid": "fefb82d270a81315a545df863de31218eb43b4f9", "committedDate": "2022-02-21 13:30:59 +0100", "message": "refactor: Convert TripPattern.getTrips() to scheduledTripsAsStream()."}, {"oid": "48847620e316e41540c98d315c05a6c41e2817ea", "committedDate": "2022-03-10 19:50:36 +0200", "message": "Create new pattern if there are skipped stops so routing ignores the stops"}, {"oid": "59fbd011f0ba0fc4addabbd8ea7567f551519fdd", "committedDate": "2022-03-11 16:10:03 +0100", "message": "First initial port of IBI code"}, {"oid": "848c857db3f9b6c71b6aab429c7b0e4326b2b566", "committedDate": "2022-03-11 16:10:03 +0100", "message": "Encapsulate positions logic"}, {"oid": "d23d1c99424b76fd55ca23d60176cbc82d5a8144", "committedDate": "2022-03-11 16:10:04 +0100", "message": "Introduce vehicle positions to GraphQL API"}, {"oid": "a01a41d0d979f959a0c9a712db8a7c9d91970ecf", "committedDate": "2022-03-11 16:10:04 +0100", "message": "Move position updates into service"}, {"oid": "7e60e473f9d460d9549b20765f922f87a143b823", "committedDate": "2022-03-15 14:39:58 +0100", "message": "10924 journey pattern geometries"}, {"oid": "1409738aa90fe5cd798f2837709d8d24af9b1e9a", "committedDate": "2022-03-18 10:52:40 +0100", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into vehicle-positions"}, {"oid": "e014badc5571fd0adbfa7ce2c23e835bc03b1fd0", "committedDate": "2022-03-21 16:08:44 +0100", "message": "refactor: Fix Javadoc comments that don't belong to any class, method or field"}, {"oid": "aa06e31d0739586374cd8fca1219c1dc5e5e9c69", "committedDate": "2022-03-22 12:08:47 +0100", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into vehicle-positions"}, {"oid": "7526b175afaced0ef7d4ee63a18cc2046673e4a7", "committedDate": "2022-03-24 09:58:03 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into gtfsrt-cancelled-stops"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "269afb6d3c6604cd86fc8643c3d43d24661786f2", "committedDate": "2022-04-24 10:49:28 +0300", "message": "Switch from internal jcommander implementation usage to guava"}, {"oid": "3a4d2f2827fe3d812f78eb464c779b6dbedd40da", "committedDate": "2022-04-28 13:33:33 +0300", "message": "Extract and use getRepresentativeTripTimes"}, {"oid": "299e099bb81dfcc2564362b514941aa063a2ad3e", "committedDate": "2022-04-29 11:04:13 +0200", "message": "Bugfix on setHopGemometriesFromPattern"}, {"oid": "58d46b727f471f87a358bb475fa135b3459be11d", "committedDate": "2022-04-29 14:51:13 +0200", "message": "Rename 'WheelChairBoarding' to 'WheelchairBoarding'"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "d484f45f4d6f87f6c490a392c2dbe2daad69e29c", "committedDate": "2022-05-09 14:10:26 +0200", "message": "refactor: Move some core model classes"}, {"oid": "ec4cc70876ec8faae730c7000d1c5d5634527428", "committedDate": "2022-05-10 14:51:05 +0200", "message": "Consider null stations for comparing stations on stops"}, {"oid": "e36df475d9251f6f7dd98a4d8d0dc99ba186bcf7", "committedDate": "2022-05-10 15:43:33 +0200", "message": "Merge branch 'dev-2.x' into trippattern_geometries_fix"}, {"oid": "fa8a6b88525379e17830d4d539882ff449a3dfcb", "committedDate": "2022-05-12 15:06:09 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_transit_model"}, {"oid": "5b2c4d18588bdf5a7de7d93418e0b3ebc68279a6", "committedDate": "2022-05-19 18:22:44 +0200", "message": "refactor: Move BikeAccess, GroupOfRoutes, Route and TransitMode"}, {"oid": "ca18067621142a2383434caa048c3dc1767e2fdc", "committedDate": "2022-05-20 16:06:50 +0200", "message": "Rename WheelchairBoarding to WheelchairAccessibility"}, {"oid": "c434eced011a749c6fdb6afd55fb21b9331211f7", "committedDate": "2022-05-24 11:26:15 +0200", "message": "Rename variables and methods from 'wheelchairBoarding' to 'wheelchairAccessibility'"}, {"oid": "688a57b608d36473a608dbf8e8967cdc3e4b46dd", "committedDate": "2022-05-24 14:15:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_transit_model_p2"}, {"oid": "b68ea1a5bccbcfc98d46ebac6490056a69c44550", "committedDate": "2022-05-25 15:44:44 +0200", "message": "refactor: Move Trip to new location."}, {"oid": "123eb90ab3514c6838947bf1eac91a155ee57add", "committedDate": "2022-05-25 15:44:48 +0200", "message": "refactor: Cleanup Trip"}, {"oid": "f8f232ad48ed87efd67d9bc7ea528b7f04c2a76a", "committedDate": "2022-06-02 14:20:02 +0200", "message": "feature: Make SubMode a type"}, {"oid": "7e1ad0d6e1f8ee191e2e4ae0bd8ef404cea162d3", "committedDate": "2022-06-10 23:11:40 +0200", "message": "Include frequency trips"}, {"oid": "86436740190ee2c11bdd5470aeef4bde3c562f26", "committedDate": "2022-06-13 17:16:30 +0200", "message": "refactor: Cleanup model framework and prepare for adding context."}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b0c367119fc2b637823337923b5504444eb45a52", "committedDate": "2022-06-13 17:38:22 +0200", "message": "refactor: Move Stop related classes into package site"}, {"oid": "6e2067aa11bc9a443b1e643845e23128108e4bfc", "committedDate": "2022-06-13 18:49:32 +0200", "message": "Code cleanup"}, {"oid": "287283d19dcb8be174a9e88a954b5af67df6a44d", "committedDate": "2022-06-16 12:34:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "7b7e4c14963355cebf9b23ad0a07622933f94d9f", "committedDate": "2022-06-21 11:11:11 +0200", "message": "Merge pull request #4214 from leonardehrenfried/fix-frequency-geometries"}, {"oid": "557f4b1e06f2feeaa6e47a04e7e359d67b1f54a4", "committedDate": "2022-06-21 13:58:28 +0200", "message": "Merge branch 'dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "10ab8f909703b183f1f1086f6baa8776481a21f8", "committedDate": "2022-07-06 15:06:50 +0300", "message": "Remove unused code"}, {"oid": "181b1791d29c18d7c9515d7c3643457442ed395e", "committedDate": "2022-07-09 19:36:37 +0300", "message": "Do not require route names to be unique"}, {"oid": "87142f78193dde8932cffc31cbf3db1442667bf1", "committedDate": "2022-07-09 19:41:44 +0300", "message": "Utilize headsign for generating unique pattern names"}, {"oid": "73b5281528cddc2e60e3456d975ce11468bf2334", "committedDate": "2022-07-19 15:15:16 +0200", "message": "refactor: Move direction to new transit model"}, {"oid": "3b4316833886ff242325e031fa13264850b5317e", "committedDate": "2022-07-19 15:48:45 +0200", "message": "refactor: Move Transit- and Sub- Mode to basic"}, {"oid": "b10f9f409887b9c17c38d8c778a2c58453c0e208", "committedDate": "2022-07-27 11:13:19 +0200", "message": "Move TripPattern and StopPattern to network package"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NzYwMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487747601", "body": "Use the <project-root>/intellij-code-style.xml to format the code.", "bodyText": "Use the /intellij-code-style.xml to format the code.", "bodyHTML": "<p dir=\"auto\">Use the /intellij-code-style.xml to format the code.</p>", "author": "t2gran", "createdAt": "2020-09-14T08:43:10Z", "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -11,27 +11,7 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.AffectedLineStructure;\n-import uk.org.siri.siri20.AffectedRouteStructure;\n-import uk.org.siri.siri20.AffectedStopPlaceStructure;\n-import uk.org.siri.siri20.AffectedStopPointStructure;\n-import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n-import uk.org.siri.siri20.AffectsScopeStructure;\n-import uk.org.siri.siri20.DataFrameRefStructure;\n-import uk.org.siri.siri20.DefaultedTextStructure;\n-import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n-import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n-import uk.org.siri.siri20.InfoLinkStructure;\n-import uk.org.siri.siri20.LineRef;\n-import uk.org.siri.siri20.PtSituationElement;\n-import uk.org.siri.siri20.RoutePointTypeEnumeration;\n-import uk.org.siri.siri20.ServiceDelivery;\n-import uk.org.siri.siri20.SeverityEnumeration;\n-import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n-import uk.org.siri.siri20.SituationNumber;\n-import uk.org.siri.siri20.StopPointRef;\n-import uk.org.siri.siri20.VehicleJourneyRef;\n-import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+import uk.org.siri.siri20.*;\n \n import java.math.BigInteger;\n import java.time.ZonedDateTime;\n", "next_change": null}, {"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -11,27 +11,7 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.AffectedLineStructure;\n-import uk.org.siri.siri20.AffectedRouteStructure;\n-import uk.org.siri.siri20.AffectedStopPlaceStructure;\n-import uk.org.siri.siri20.AffectedStopPointStructure;\n-import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n-import uk.org.siri.siri20.AffectsScopeStructure;\n-import uk.org.siri.siri20.DataFrameRefStructure;\n-import uk.org.siri.siri20.DefaultedTextStructure;\n-import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n-import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n-import uk.org.siri.siri20.InfoLinkStructure;\n-import uk.org.siri.siri20.LineRef;\n-import uk.org.siri.siri20.PtSituationElement;\n-import uk.org.siri.siri20.RoutePointTypeEnumeration;\n-import uk.org.siri.siri20.ServiceDelivery;\n-import uk.org.siri.siri20.SeverityEnumeration;\n-import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n-import uk.org.siri.siri20.SituationNumber;\n-import uk.org.siri.siri20.StopPointRef;\n-import uk.org.siri.siri20.VehicleJourneyRef;\n-import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+import uk.org.siri.siri20.*;\n \n import java.math.BigInteger;\n import java.time.ZonedDateTime;\n", "next_change": {"commit": "376e0b3a16f04408735feb20fa18e4a577503e82", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 5816fe2580..a0b9b38143 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -15,6 +15,7 @@ import uk.org.siri.siri20.*;\n \n import java.math.BigInteger;\n import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n", "next_change": {"commit": "06b33ca2b8a7f3ec48c675d99c85ecf62c53e2ca", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex a0b9b38143..7e7467dfb1 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -11,14 +18,27 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.*;\n-\n-import java.math.BigInteger;\n-import java.time.ZonedDateTime;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n \n public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n   private static final String FEED_ID = \"FEED\";\n", "next_change": {"commit": "a227ff212df1c0f808615b33e3da3e20210903eb", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 7e7467dfb1..e13f92c05f 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -18,27 +13,14 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.AffectedLineStructure;\n-import uk.org.siri.siri20.AffectedRouteStructure;\n-import uk.org.siri.siri20.AffectedStopPlaceStructure;\n-import uk.org.siri.siri20.AffectedStopPointStructure;\n-import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n-import uk.org.siri.siri20.AffectsScopeStructure;\n-import uk.org.siri.siri20.DataFrameRefStructure;\n-import uk.org.siri.siri20.DefaultedTextStructure;\n-import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n-import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n-import uk.org.siri.siri20.InfoLinkStructure;\n-import uk.org.siri.siri20.LineRef;\n-import uk.org.siri.siri20.PtSituationElement;\n-import uk.org.siri.siri20.RoutePointTypeEnumeration;\n-import uk.org.siri.siri20.ServiceDelivery;\n-import uk.org.siri.siri20.SeverityEnumeration;\n-import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n-import uk.org.siri.siri20.SituationNumber;\n-import uk.org.siri.siri20.StopPointRef;\n-import uk.org.siri.siri20.VehicleJourneyRef;\n-import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+import uk.org.siri.siri20.*;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n \n public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n   private static final String FEED_ID = \"FEED\";\n", "next_change": {"commit": "ff319bc3725bc4e8f1d7a6ab09556cf9df204e11", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex e13f92c05f..55d10af5e5 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -13,14 +19,27 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.*;\n-\n-import java.math.BigInteger;\n-import java.time.ZonedDateTime;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n \n public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n   private static final String FEED_ID = \"FEED\";\n", "next_change": {"commit": "1fda3ee4737aa14ba7c4209fde1ce3fe01f21e3b", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 55d10af5e5..d0e6dc2cd5 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -41,6 +35,13 @@ import uk.org.siri.siri20.StopPointRef;\n import uk.org.siri.siri20.VehicleJourneyRef;\n import uk.org.siri.siri20.WorkflowStatusEnumeration;\n \n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n   private static final String FEED_ID = \"FEED\";\n \n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex d0e6dc2cd5..3a522ae8b6 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -35,14 +47,8 @@ import uk.org.siri.siri20.StopPointRef;\n import uk.org.siri.siri20.VehicleJourneyRef;\n import uk.org.siri.siri20.WorkflowStatusEnumeration;\n \n-import java.math.BigInteger;\n-import java.time.ZonedDateTime;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n-\n public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+\n   private static final String FEED_ID = \"FEED\";\n \n   SiriAlertsUpdateHandler alertsUpdateHandler;\n", "next_change": {"commit": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 3a522ae8b6..4d90266b21 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -57,6 +58,8 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n \n   RoutingService routingService;\n \n+  TransitService transitService;\n+\n   @Test\n   public void testSiriSxUpdateForStop() {\n     init();\n", "next_change": {"commit": "b277b5d0ffd303c26f9b9ad80131f1b7e1e2d78b", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 4d90266b21..d19a68dd26 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -56,8 +57,6 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n \n   TransitAlertServiceImpl transitAlertService;\n \n-  RoutingService routingService;\n-\n   TransitService transitService;\n \n   @Test\n", "next_change": {"commit": "45b2ee791966c54fbba201290225e66e7945c8a1", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex d19a68dd26..4be9b4bacc 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -59,9 +65,37 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n \n   TransitService transitService;\n \n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+\n+  @BeforeEach\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+\n+    if (transitService == null) {\n+      transitService = new DefaultTransitService(transitModel);\n+      transitModel.setUpdaterManager(new GraphUpdaterManager(graph, transitModel, List.of()));\n+    } else {\n+      transitAlertService.getAllAlerts().clear();\n+    }\n+    if (alertsUpdateHandler == null) {\n+      transitAlertService = new TransitAlertServiceImpl(transitModel);\n+      alertsUpdateHandler =\n+        new SiriAlertsUpdateHandler(\n+          FEED_ID,\n+          transitModel,\n+          transitAlertService,\n+          SiriFuzzyTripMatcher.of(transitService),\n+          0\n+        );\n+    }\n+  }\n+\n   @Test\n   public void testSiriSxUpdateForStop() {\n-    init();\n     assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n     final String situationNumber = \"TST:SituationNumber:1234\";\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 5816fe2580..3a522ae8b6 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -1033,4 +1199,3 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n     return \"gtfs/interlining\";\n   }\n }\n-\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 3a522ae8b6..ffc65b1045 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -1193,9 +1198,4 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n \n     return affects;\n   }\n-\n-  @Override\n-  public String getFeedName() {\n-    return \"gtfs/interlining\";\n-  }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "a534ac2546944ec6921f2131ced5d9325e5dd2dd", "committedDate": "2020-11-12 12:10:31 +0100", "message": "Taking graph timezone into account when calculating alert validity"}, {"oid": "376e0b3a16f04408735feb20fa18e4a577503e82", "committedDate": "2021-01-07 10:15:01 +0100", "message": "Returning 'null' when endTime is not set"}, {"oid": "261b7cc30e75288eb5f93b2290db56f53bdf700e", "committedDate": "2021-01-07 12:26:51 +0100", "message": "Update test to verify effective endDate when multiple timeperiods are set"}, {"oid": "f5c9762fe7366e40cb2f8c8c8029c2a146e4c5c5", "committedDate": "2021-07-28 14:36:00 +0200", "message": "Alerts tagged on trip for specific dates now rely on ServiceDate, not generated validity"}, {"oid": "73059708382f4d8d6913560bc9630b53a1def44c", "committedDate": "2021-07-29 09:22:07 +0200", "message": "Keeping business-logic out of the EntitySelector"}, {"oid": "4b11bf091ba29d47bed32e94614cc8350beb4071", "committedDate": "2021-10-13 09:01:53 +0200", "message": "Changing int to Integer to allow null-values"}, {"oid": "06b33ca2b8a7f3ec48c675d99c85ecf62c53e2ca", "committedDate": "2021-11-11 14:43:07 +0100", "message": "refactor: Remove dependency from updaters to GraphUpdaterManager"}, {"oid": "a227ff212df1c0f808615b33e3da3e20210903eb", "committedDate": "2021-11-13 22:18:57 +0200", "message": "Refactor transit alert's severity"}, {"oid": "ff319bc3725bc4e8f1d7a6ab09556cf9df204e11", "committedDate": "2021-11-23 13:17:34 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into alert-updates"}, {"oid": "9b8bb16f5baf831ad256710b9ba4010f3ce1dfc3", "committedDate": "2021-11-30 16:49:00 +0200", "message": "Include alerts with no or unhandled entities"}, {"oid": "daa133377a80aa5f1a12a78fccae2aa2088c4b3f", "committedDate": "2021-12-13 16:55:55 +0200", "message": "Don't always add Unknown entity to siri alerts and update tests"}, {"oid": "2eb024a0c680d44ffd01c47a8e2d67833afac719", "committedDate": "2022-01-07 16:45:37 +0200", "message": "Clean code"}, {"oid": "1fda3ee4737aa14ba7c4209fde1ce3fe01f21e3b", "committedDate": "2022-03-21 19:59:56 +0100", "message": "refactor: Remove unnecessary semicolons"}, {"oid": "fad24587cd947104448cfa1fb96e2d46ec3afd78", "committedDate": "2022-03-28 12:33:34 +0300", "message": "Re-add some GTFS-based tests"}, {"oid": "c6f0112e1ba95aecbce5f49844e6e6f440063238", "committedDate": "2022-03-30 17:21:01 +0300", "message": "Inline variable"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "8b5ec045699d61748660478ea64a2edc4c99ccb4", "committedDate": "2022-05-06 18:55:25 +0200", "message": "refactor: Ues TransitModelForTest.id factory method in test"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "87e177d3c84fe4e2d526fdc7cc342861585070bb", "committedDate": "2022-06-01 15:14:17 +0200", "message": "@WIP: Moving StopConditions from TransitAlert to EntitySelector"}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "committedDate": "2022-06-15 13:49:47 +0200", "message": "Introduce TransitService"}, {"oid": "d19e79c6752ba0197f71c1868767dd211b210260", "committedDate": "2022-06-15 14:53:36 +0200", "message": "Fix unit test"}, {"oid": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "committedDate": "2022-06-15 16:35:25 +0200", "message": "Migrate methods from RoutingService to TransitService"}, {"oid": "69408e579c9da646b396d2d2e28377b1e598d7b7", "committedDate": "2022-06-16 14:53:52 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_refactor_transit_service"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "committedDate": "2022-06-30 14:00:01 +0300", "message": "Convert java.util to java.time classes"}, {"oid": "104c707a268e954ea21e61645ce2f93b6c1acadc", "committedDate": "2022-07-05 17:40:24 +0300", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_convert_legacy_times"}, {"oid": "95ebdf26498025f5cb470f3cb7360135538e9ee6", "committedDate": "2022-07-06 15:08:13 +0300", "message": "Convert Alerts to use LocalDate"}, {"oid": "c14f86b99d0f7c0aa38c91b111b6b38d4217df30", "committedDate": "2022-07-12 16:36:39 +0200", "message": "Encapsulate access to TransitModel/StopModel properties (#4265)"}, {"oid": "e5475ab4184dd451716c7273991ffa4fbb3d97ec", "committedDate": "2022-07-26 18:30:44 +0200", "message": "Migrate RoutingService to using TransitService"}, {"oid": "b277b5d0ffd303c26f9b9ad80131f1b7e1e2d78b", "committedDate": "2022-07-27 10:21:24 +0200", "message": "Clean up usage of RoutingService"}, {"oid": "1e78dbfb2082be5402528b325a54c4cf1b9ca23c", "committedDate": "2022-08-24 20:02:59 +0200", "message": "refactor: Keep the fuzzyTripMatcher in updaters, allow for customizations."}, {"oid": "54febd2708c2a263e6b2241c42ce70ec017da9d8", "committedDate": "2022-10-21 13:30:15 +0200", "message": "Merge branch 'dev-2.x' into refactor_siri_stopconditions"}, {"oid": "72801c7aa875a39447fa1debd542be46c8474617", "committedDate": "2022-10-25 21:50:50 +0300", "message": "Extract separate EntityKey"}, {"oid": "18903a6b41f01bc372b8fa4c9667e2af907190d4", "committedDate": "2022-11-04 14:15:37 +0200", "message": "Add filtering of stopConditions and serviceDate"}, {"oid": "afd02a7e74cf1d7795756815fa1520247a2992be", "committedDate": "2023-01-20 11:18:14 +0200", "message": "refactor: Make TransitAlert a TransitEntity"}, {"oid": "f8ea03240f72d884d73c53ddb348cf194d77f42a", "committedDate": "2023-01-20 15:28:55 +0200", "message": "Extract AffectsMapper"}, {"oid": "f67d9a0cbe56e524d8a3fc4444906d2bfe83a557", "committedDate": "2023-02-24 15:04:31 +0100", "message": "Adding test"}, {"oid": "66c828d9e921881cb0ef359f6440dd615461a7ea", "committedDate": "2023-02-24 15:10:55 +0100", "message": "Formatting"}, {"oid": "45b2ee791966c54fbba201290225e66e7945c8a1", "committedDate": "2023-03-31 10:49:50 +0200", "message": "fix siri alerts operatingDay resolving when entering DST"}, {"oid": "5900d238481b6b0674a4e55d3eb89ba0a8abb104", "committedDate": "2023-06-06 16:07:28 +0200", "message": "refactor: Apply code review"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NDA5Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487784097", "body": "**FYI**\r\n\r\nThese methods made me ask: Should these be pushed into the `TransitAlert` class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of `TransitAlert.entities` is always filtered down to a specific type - So maybe just keeping a set of `Selectors` for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?  \r\n\r\nI do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.", "bodyText": "FYI\nThese methods made me ask: Should these be pushed into the TransitAlert class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of TransitAlert.entities is always filtered down to a specific type - So maybe just keeping a set of Selectors for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?\nI do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.", "bodyHTML": "<p dir=\"auto\"><strong>FYI</strong></p>\n<p dir=\"auto\">These methods made me ask: Should these be pushed into the <code>TransitAlert</code> class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of <code>TransitAlert.entities</code> is always filtered down to a specific type - So maybe just keeping a set of <code>Selectors</code> for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?</p>\n<p dir=\"auto\">I do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.</p>", "author": "t2gran", "createdAt": "2020-09-14T09:43:46Z", "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+\n+    SiriAlertsUpdateHandler alertsUpdateHandler;\n+\n+    TransitAlertServiceImpl transitAlertService;\n+\n+    RoutingService routingService;\n+    private String feedId = \"FEED\";\n+\n+    public void init() {\n+            if (routingService == null) {\n+                routingService = new RoutingService(graph);\n+                graph.updaterManager = new GraphUpdaterManager(graph);\n+\n+            } else {\n+                transitAlertService.getAllAlerts().clear();\n+            }\n+            if (alertsUpdateHandler == null) {\n+                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+\n+                transitAlertService = new TransitAlertServiceImpl(graph);\n+                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+\n+                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+            }\n+        }\n+\n+        @Test\n+        public void testSiriSxUpdateForStop() {\n+            init();\n+            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final String situationNumber = \"TST:SituationNumber:1234\";\n+            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n+            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+\n+            PtSituationElement ptSituation = createPtSituationElement(\n+                    situationNumber,\n+                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+                    createAffectsStop(stopConditions, stopId.getId()));\n+\n+            long priorityValue = 3;\n+            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+\n+            InfoLinkStructure infoLink = new InfoLinkStructure();\n+            final String infoLinkUri = \"http://www.test.com\";\n+            final String infoLinkLabel = \"testlabel\";\n+\n+            infoLink.setUri(infoLinkUri);\n+            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+\n+            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+\n+            final String reportType = \"incident\";\n+            ptSituation.setReportType(reportType);\n+\n+            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+            alertsUpdateHandler.update(serviceDelivery);\n+\n+            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+            assertNotNull(stopPatches);\n+            assertEquals(1, stopPatches.size());\n+            final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+            assertFalse(containsTripEntity(transitAlert));\n+            assertEquals(situationNumber, transitAlert.getId());\n+            assertEquals(reportType, transitAlert.alertType);\n+            assertEquals(severity.value(), transitAlert.severity);\n+            assertEquals(priorityValue, transitAlert.priority);\n+\n+            assertTrue(matchesEntity(transitAlert, stopId));\n+\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+\n+            assertNotNull(transitAlert.getAlertUrlList());\n+            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+\n+            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+            AlertUrl alertUrl = alertUrlList.get(0);\n+            assertEquals(infoLinkUri, alertUrl.uri);\n+            assertEquals(infoLinkLabel, alertUrl.label);\n+\n+        }\n+\n+    private boolean containsStopEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Stop) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsTripEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Trip) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Route) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.StopAndRoute) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac87..5816fe2580 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 5816fe2580..3a522ae8b6 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -1033,4 +1199,3 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n     return \"gtfs/interlining\";\n   }\n }\n-\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 3a522ae8b6..ffc65b1045 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -1193,9 +1198,4 @@ public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n \n     return affects;\n   }\n-\n-  @Override\n-  public String getFeedName() {\n-    return \"gtfs/interlining\";\n-  }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "a534ac2546944ec6921f2131ced5d9325e5dd2dd", "committedDate": "2020-11-12 12:10:31 +0100", "message": "Taking graph timezone into account when calculating alert validity"}, {"oid": "376e0b3a16f04408735feb20fa18e4a577503e82", "committedDate": "2021-01-07 10:15:01 +0100", "message": "Returning 'null' when endTime is not set"}, {"oid": "261b7cc30e75288eb5f93b2290db56f53bdf700e", "committedDate": "2021-01-07 12:26:51 +0100", "message": "Update test to verify effective endDate when multiple timeperiods are set"}, {"oid": "f5c9762fe7366e40cb2f8c8c8029c2a146e4c5c5", "committedDate": "2021-07-28 14:36:00 +0200", "message": "Alerts tagged on trip for specific dates now rely on ServiceDate, not generated validity"}, {"oid": "73059708382f4d8d6913560bc9630b53a1def44c", "committedDate": "2021-07-29 09:22:07 +0200", "message": "Keeping business-logic out of the EntitySelector"}, {"oid": "4b11bf091ba29d47bed32e94614cc8350beb4071", "committedDate": "2021-10-13 09:01:53 +0200", "message": "Changing int to Integer to allow null-values"}, {"oid": "06b33ca2b8a7f3ec48c675d99c85ecf62c53e2ca", "committedDate": "2021-11-11 14:43:07 +0100", "message": "refactor: Remove dependency from updaters to GraphUpdaterManager"}, {"oid": "a227ff212df1c0f808615b33e3da3e20210903eb", "committedDate": "2021-11-13 22:18:57 +0200", "message": "Refactor transit alert's severity"}, {"oid": "ff319bc3725bc4e8f1d7a6ab09556cf9df204e11", "committedDate": "2021-11-23 13:17:34 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into alert-updates"}, {"oid": "9b8bb16f5baf831ad256710b9ba4010f3ce1dfc3", "committedDate": "2021-11-30 16:49:00 +0200", "message": "Include alerts with no or unhandled entities"}, {"oid": "daa133377a80aa5f1a12a78fccae2aa2088c4b3f", "committedDate": "2021-12-13 16:55:55 +0200", "message": "Don't always add Unknown entity to siri alerts and update tests"}, {"oid": "2eb024a0c680d44ffd01c47a8e2d67833afac719", "committedDate": "2022-01-07 16:45:37 +0200", "message": "Clean code"}, {"oid": "1fda3ee4737aa14ba7c4209fde1ce3fe01f21e3b", "committedDate": "2022-03-21 19:59:56 +0100", "message": "refactor: Remove unnecessary semicolons"}, {"oid": "fad24587cd947104448cfa1fb96e2d46ec3afd78", "committedDate": "2022-03-28 12:33:34 +0300", "message": "Re-add some GTFS-based tests"}, {"oid": "c6f0112e1ba95aecbce5f49844e6e6f440063238", "committedDate": "2022-03-30 17:21:01 +0300", "message": "Inline variable"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "8b5ec045699d61748660478ea64a2edc4c99ccb4", "committedDate": "2022-05-06 18:55:25 +0200", "message": "refactor: Ues TransitModelForTest.id factory method in test"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "87e177d3c84fe4e2d526fdc7cc342861585070bb", "committedDate": "2022-06-01 15:14:17 +0200", "message": "@WIP: Moving StopConditions from TransitAlert to EntitySelector"}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "committedDate": "2022-06-15 13:49:47 +0200", "message": "Introduce TransitService"}, {"oid": "d19e79c6752ba0197f71c1868767dd211b210260", "committedDate": "2022-06-15 14:53:36 +0200", "message": "Fix unit test"}, {"oid": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "committedDate": "2022-06-15 16:35:25 +0200", "message": "Migrate methods from RoutingService to TransitService"}, {"oid": "69408e579c9da646b396d2d2e28377b1e598d7b7", "committedDate": "2022-06-16 14:53:52 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_refactor_transit_service"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "committedDate": "2022-06-30 14:00:01 +0300", "message": "Convert java.util to java.time classes"}, {"oid": "104c707a268e954ea21e61645ce2f93b6c1acadc", "committedDate": "2022-07-05 17:40:24 +0300", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_convert_legacy_times"}, {"oid": "95ebdf26498025f5cb470f3cb7360135538e9ee6", "committedDate": "2022-07-06 15:08:13 +0300", "message": "Convert Alerts to use LocalDate"}, {"oid": "c14f86b99d0f7c0aa38c91b111b6b38d4217df30", "committedDate": "2022-07-12 16:36:39 +0200", "message": "Encapsulate access to TransitModel/StopModel properties (#4265)"}, {"oid": "e5475ab4184dd451716c7273991ffa4fbb3d97ec", "committedDate": "2022-07-26 18:30:44 +0200", "message": "Migrate RoutingService to using TransitService"}, {"oid": "b277b5d0ffd303c26f9b9ad80131f1b7e1e2d78b", "committedDate": "2022-07-27 10:21:24 +0200", "message": "Clean up usage of RoutingService"}, {"oid": "1e78dbfb2082be5402528b325a54c4cf1b9ca23c", "committedDate": "2022-08-24 20:02:59 +0200", "message": "refactor: Keep the fuzzyTripMatcher in updaters, allow for customizations."}, {"oid": "54febd2708c2a263e6b2241c42ce70ec017da9d8", "committedDate": "2022-10-21 13:30:15 +0200", "message": "Merge branch 'dev-2.x' into refactor_siri_stopconditions"}, {"oid": "72801c7aa875a39447fa1debd542be46c8474617", "committedDate": "2022-10-25 21:50:50 +0300", "message": "Extract separate EntityKey"}, {"oid": "18903a6b41f01bc372b8fa4c9667e2af907190d4", "committedDate": "2022-11-04 14:15:37 +0200", "message": "Add filtering of stopConditions and serviceDate"}, {"oid": "afd02a7e74cf1d7795756815fa1520247a2992be", "committedDate": "2023-01-20 11:18:14 +0200", "message": "refactor: Make TransitAlert a TransitEntity"}, {"oid": "f8ea03240f72d884d73c53ddb348cf194d77f42a", "committedDate": "2023-01-20 15:28:55 +0200", "message": "Extract AffectsMapper"}, {"oid": "f67d9a0cbe56e524d8a3fc4444906d2bfe83a557", "committedDate": "2023-02-24 15:04:31 +0100", "message": "Adding test"}, {"oid": "66c828d9e921881cb0ef359f6440dd615461a7ea", "committedDate": "2023-02-24 15:10:55 +0100", "message": "Formatting"}, {"oid": "45b2ee791966c54fbba201290225e66e7945c8a1", "committedDate": "2023-03-31 10:49:50 +0200", "message": "fix siri alerts operatingDay resolving when entering DST"}, {"oid": "5900d238481b6b0674a4e55d3eb89ba0a8abb104", "committedDate": "2023-06-06 16:07:28 +0200", "message": "refactor: Apply code review"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzMDk4NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487830984", "body": "Below on line 364:\r\n```\r\n\r\nif (!effectiveValiditySetExplicitly) {\r\n```\r\nthe if is never entered. The only way the `effectiveValiditySetExplicitly` can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code. \r\n", "bodyText": "Below on line 364:\n\nif (!effectiveValiditySetExplicitly) {\n\nthe if is never entered. The only way the effectiveValiditySetExplicitly can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code.", "bodyHTML": "<p dir=\"auto\">Below on line 364:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\nif (!effectiveValiditySetExplicitly) {\"><pre><code>\nif (!effectiveValiditySetExplicitly) {\n</code></pre></div>\n<p dir=\"auto\">the if is never entered. The only way the <code>effectiveValiditySetExplicitly</code> can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:08:54Z", "path": "src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java", "diffHunk": "@@ -335,13 +343,20 @@ private TransitAlert handleAlert(PtSituationElement situation) {\n                                 effectiveValiditySetExplicitly = true;\n \n                             } else {\n-                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n-                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n-                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n \n-                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n-                                effectiveStartDate = serviceDate.getAsDate();\n-                                effectiveEndDate = serviceDate.next().getAsDate();\n+//                                Commented out for now\n+//\n+//                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n+//                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n+//                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n+//\n+//                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n+//                                effectiveStartDate = serviceDate.getAsDate();\n+//                                effectiveEndDate = serviceDate.next().getAsDate();\n+\n+                                effectiveStartDate = null;\n+                                effectiveEndDate = null;\n+", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "a534ac2546944ec6921f2131ced5d9325e5dd2dd", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex 7957f9fb85..618e5fb163 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -349,47 +329,23 @@ public class SiriAlertsUpdateHandler {\n //                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n //                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n //                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n-//\n-//                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n-//                                effectiveStartDate = serviceDate.getAsDate();\n-//                                effectiveEndDate = serviceDate.next().getAsDate();\n-\n-                                effectiveStartDate = null;\n-                                effectiveEndDate = null;\n-\n-\n                             }\n+\n                             for (FeedScopedId tripId : tripIds) {\n \n                                 if (!effectiveValiditySetExplicitly) {\n                                     // Effective validity is set based on ServiceDate - need to calculate correct validity based on departuretimes\n \n-                                    // Calculate validity based on actual, planned departure/arrival for trip\n-                                    int tripDepartureTime = siriFuzzyTripMatcher.getTripDepartureTime(tripId);\n-                                    int tripArrivalTime = siriFuzzyTripMatcher.getTripArrivalTime(tripId);\n-\n-                                    // ServiceJourneyId does NOT match - calculate validity based on serviceDate (calculated from originalAimedDepartureTime)\n-                                    effectiveStartDate = new Date(serviceDate.getAsDate().getTime() + tripDepartureTime * 1000);\n-\n-                                    // Appending 6 hours to end-validity in case of delays.\n-                                    effectiveEndDate = new Date(effectiveStartDate.getTime() + (tripArrivalTime - tripDepartureTime + 6 * 3600) * 1000);\n-\n-                                    // Verify that calculated validity does not exceed explicitly set validity\n-                                    if (effectiveStartDate.before(alert.getEffectiveStartDate())) {\n-                                        effectiveStartDate = alert.getEffectiveStartDate();\n-                                    }\n-                                    if (effectiveEndDate.after(alert.getEffectiveEndDate())) {\n-                                        effectiveEndDate = alert.getEffectiveEndDate();\n-                                    }\n+                                    final TimePeriod timePeriod = calculateTimePeriodForTrip(alert,\n+                                        tripId,\n+                                        serviceDate,\n+                                        startOfService, 6 * 3600\n+                                    );\n \n-                                    if (effectiveStartDate.after(effectiveEndDate) | effectiveStartDate.equals(effectiveEndDate)) {\n-                                        //Ignore this as situation is no longer valid\n-                                        continue;\n-                                    }\n-                                }\n-                                if (effectiveEndDate == null) {\n-                                    effectiveEndDate = new Date(Long.MAX_VALUE);\n+                                    // TODO: Make it possible to add time periods for trip selectors\n+                                    alert.setTimePeriods(Arrays.asList(timePeriod));\n                                 }\n+\n                                 if (! affectedStops.isEmpty()) {\n                                     for (AffectedStopPointStructure affectedStop : affectedStops) {\n                                         FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n", "next_change": {"commit": "f5c9762fe7366e40cb2f8c8c8029c2a146e4c5c5", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex 618e5fb163..f6c641cd79 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -333,19 +337,6 @@ public class SiriAlertsUpdateHandler {\n \n                             for (FeedScopedId tripId : tripIds) {\n \n-                                if (!effectiveValiditySetExplicitly) {\n-                                    // Effective validity is set based on ServiceDate - need to calculate correct validity based on departuretimes\n-\n-                                    final TimePeriod timePeriod = calculateTimePeriodForTrip(alert,\n-                                        tripId,\n-                                        serviceDate,\n-                                        startOfService, 6 * 3600\n-                                    );\n-\n-                                    // TODO: Make it possible to add time periods for trip selectors\n-                                    alert.setTimePeriods(Arrays.asList(timePeriod));\n-                                }\n-\n                                 if (! affectedStops.isEmpty()) {\n                                     for (AffectedStopPointStructure affectedStop : affectedStops) {\n                                         FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n", "next_change": {"commit": "1d2a5714c482158d08681551bc09f5fc3b94c69b", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex f6c641cd79..a5d488e965 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -314,25 +313,23 @@ public class SiriAlertsUpdateHandler {\n \n                             FeedScopedId tripIdFromVehicleJourney = siriFuzzyTripMatcher.getTripId(vehicleJourneyRef.getValue());\n \n-                            ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime();\n+                            ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime() != null\n+                                ? affectedVehicleJourney.getOriginAimedDepartureTime()\n+                                : ZonedDateTime.now();\n \n-                            ServiceDate serviceDate = null;\n-                            if (originAimedDepartureTime != null) {\n-                                serviceDate = new ServiceDate(DateMapper.asStartOfService(originAimedDepartureTime)\n-                                    .toLocalDate());\n-                            }\n+                            ZonedDateTime startOfService = DateMapper.asStartOfService(originAimedDepartureTime);\n \n-                            if (tripIdFromVehicleJourney != null) {\n+                            ServiceDate serviceDate = new ServiceDate(startOfService.toLocalDate());\n \n+                            if (tripIdFromVehicleJourney != null) {\n                                 tripIds.add(tripIdFromVehicleJourney);\n-\n                             } else {\n-\n-//                                Commented out for now\n-//\n-//                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n-//                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n-//                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n+                                tripIds = siriFuzzyTripMatcher.getTripIdForInternalPlanningCodeServiceDateAndMode(\n+                                    vehicleJourneyRef.getValue(),\n+                                    serviceDate,\n+                                    TransitMode.RAIL,\n+                                    \"railReplacementBus\"\n+                                );\n                             }\n \n                             for (FeedScopedId tripId : tripIds) {\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex a5d488e965..d9532ff71b 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -58,513 +58,532 @@ import uk.org.siri.siri20.WorkflowStatusEnumeration;\n  */\n public class SiriAlertsUpdateHandler {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(SiriAlertsUpdateHandler.class);\n-\n-    private TransitAlertService transitAlertService;\n-\n-    /** How long before the posted start of an event it should be displayed to users */\n-    private long earlyStart;\n-\n-    private SiriFuzzyTripMatcher siriFuzzyTripMatcher;\n+  private static final Logger LOG = LoggerFactory.getLogger(SiriAlertsUpdateHandler.class);\n+\n+  private TransitAlertService transitAlertService;\n+\n+  /** How long before the posted start of an event it should be displayed to users */\n+  private long earlyStart;\n+\n+  private SiriFuzzyTripMatcher siriFuzzyTripMatcher;\n+\n+  private final String feedId;\n+\n+  private final Graph graph;\n+\n+  private final Set<TransitAlert> alerts = new HashSet<>();\n+\n+  public SiriAlertsUpdateHandler(String feedId, Graph graph) {\n+    this.feedId = feedId;\n+    this.graph = graph;\n+  }\n+\n+  public void update(ServiceDelivery delivery) {\n+    for (SituationExchangeDeliveryStructure sxDelivery : delivery.getSituationExchangeDeliveries()) {\n+      SituationExchangeDeliveryStructure.Situations situations = sxDelivery.getSituations();\n+      if (situations != null) {\n+        long t1 = System.currentTimeMillis();\n+        int addedCounter = 0;\n+        int expiredCounter = 0;\n+        for (PtSituationElement sxElement : situations.getPtSituationElements()) {\n+          boolean expireSituation =\n+            (\n+              sxElement.getProgress() != null &&\n+              sxElement.getProgress().equals(WorkflowStatusEnumeration.CLOSED)\n+            );\n+\n+          String situationNumber;\n+          if (sxElement.getSituationNumber() != null) {\n+            situationNumber = sxElement.getSituationNumber().getValue();\n+          } else {\n+            situationNumber = null;\n+          }\n+\n+          if (expireSituation) {\n+            alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n+            expiredCounter++;\n+          } else {\n+            TransitAlert alert = handleAlert(sxElement);\n+            addedCounter++;\n+            if (alert != null) {\n+              alert.setId(situationNumber);\n+              if (alert.getEntities().isEmpty()) {\n+                LOG.info(\n+                  \"No match found for Alert - setting Unknown entity for situation with situationNumber {}\",\n+                  situationNumber\n+                );\n+                alert.addEntity(\n+                  new EntitySelector.Unknown(\"Alert had no entities that could be handled\")\n+                );\n+              }\n+              alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n+              alerts.add(alert);\n+            }\n+          }\n+        }\n \n-    private final String feedId;\n+        transitAlertService.setAlerts(alerts);\n+\n+        LOG.info(\n+          \"Added {} alerts, expired {} alerts based on {} situations, current alert-count: {}, elapsed time {}ms\",\n+          addedCounter,\n+          expiredCounter,\n+          situations.getPtSituationElements().size(),\n+          transitAlertService.getAllAlerts().size(),\n+          System.currentTimeMillis() - t1\n+        );\n+      }\n+    }\n+  }\n+\n+  private TransitAlert handleAlert(PtSituationElement situation) {\n+    TransitAlert alert = createAlertWithTexts(situation);\n+\n+    if (\n+      (alert.alertHeaderText == null || alert.alertHeaderText.toString().isEmpty()) &&\n+      (alert.alertDescriptionText == null || alert.alertDescriptionText.toString().isEmpty()) &&\n+      (alert.alertDetailText == null || alert.alertDetailText.toString().isEmpty())\n+    ) {\n+      LOG.debug(\n+        \"Empty Alert - ignoring situationNumber: {}\",\n+        situation.getSituationNumber() != null ? situation.getSituationNumber().getValue() : null\n+      );\n+      return null;\n+    }\n \n-    private final Graph graph;\n+    ArrayList<TimePeriod> periods = new ArrayList<>();\n+    if (situation.getValidityPeriods().size() > 0) {\n+      for (HalfOpenTimestampOutputRangeStructure activePeriod : situation.getValidityPeriods()) {\n+        final long realStart = activePeriod.getStartTime() != null\n+          ? getEpochSecond(activePeriod.getStartTime())\n+          : 0;\n+        final long start = activePeriod.getStartTime() != null ? realStart - earlyStart : 0;\n+\n+        final long realEnd = activePeriod.getEndTime() != null\n+          ? getEpochSecond(activePeriod.getEndTime())\n+          : TimePeriod.OPEN_ENDED;\n+        final long end = activePeriod.getEndTime() != null ? realEnd : TimePeriod.OPEN_ENDED;\n+\n+        periods.add(new TimePeriod(start, end));\n+      }\n+    } else {\n+      // Per the GTFS-rt spec, if an alert has no TimeRanges, than it should always be shown.\n+      periods.add(new TimePeriod(0, TimePeriod.OPEN_ENDED));\n+    }\n \n-    private final Set<TransitAlert> alerts = new HashSet<>();\n+    alert.setTimePeriods(periods);\n \n-    public SiriAlertsUpdateHandler(String feedId, Graph graph) {\n-        this.feedId = feedId;\n-        this.graph = graph;\n+    if (situation.getPriority() != null) {\n+      alert.priority = situation.getPriority().intValue();\n     }\n \n-    public void update(ServiceDelivery delivery) {\n-        for (SituationExchangeDeliveryStructure sxDelivery : delivery.getSituationExchangeDeliveries()) {\n-            SituationExchangeDeliveryStructure.Situations situations = sxDelivery.getSituations();\n-            if (situations != null) {\n-                long t1 = System.currentTimeMillis();\n-                int addedCounter = 0;\n-                int expiredCounter = 0;\n-                for (PtSituationElement sxElement : situations.getPtSituationElements()) {\n-                    boolean expireSituation = (sxElement.getProgress() != null &&\n-                        sxElement.getProgress().equals(WorkflowStatusEnumeration.CLOSED));\n-\n-                    String situationNumber;\n-                    if (sxElement.getSituationNumber() != null) {\n-                        situationNumber = sxElement.getSituationNumber().getValue();\n-                    } else {\n-                        situationNumber = null;\n-                    }\n+    AffectsScopeStructure affectsStructure = situation.getAffects();\n \n-                    if (expireSituation) {\n-                        alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n-                        expiredCounter++;\n-                    } else {\n-                        TransitAlert alert = handleAlert(sxElement);\n-                        addedCounter++;\n-                        if (alert != null) {\n-                            alert.setId(situationNumber);\n-                            alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n-                            alerts.add(alert);\n-                            if (alert.getEntities().isEmpty()) {\n-                                LOG.info(\"No match found for Alert - ignoring situation with situationNumber {}\", situationNumber);\n-                            }\n-                        }\n-                    }\n-                }\n+    if (affectsStructure != null) {\n+      AffectsScopeStructure.Operators operators = affectsStructure.getOperators();\n \n-                transitAlertService.setAlerts(alerts);\n+      if (operators != null && isNotEmpty(operators.getAffectedOperators())) {\n+        for (AffectedOperatorStructure affectedOperator : operators.getAffectedOperators()) {\n+          OperatorRefStructure operatorRef = affectedOperator.getOperatorRef();\n+          if (operatorRef == null || operatorRef.getValue() == null) {\n+            continue;\n+          }\n \n-                LOG.info(\"Added {} alerts, expired {} alerts based on {} situations, current alert-count: {}, elapsed time {}ms\",\n-                        addedCounter, expiredCounter, situations.getPtSituationElements().size(), transitAlertService.getAllAlerts().size(), System.currentTimeMillis()-t1);\n-            }\n-        }\n-    }\n+          // SIRI Operators are mapped to OTP Agency, this i probably wrong - but\n+          // I leave this for now.\n+          String agencyId = operatorRef.getValue();\n \n-    private TransitAlert handleAlert(PtSituationElement situation) {\n-\n-        TransitAlert alert = createAlertWithTexts(situation);\n-\n-        if ((alert.alertHeaderText == null      || alert.alertHeaderText.toString().isEmpty()) &&\n-            (alert.alertDescriptionText == null || alert.alertDescriptionText.toString().isEmpty()) &&\n-            (alert.alertDetailText == null      || alert.alertDetailText.toString().isEmpty())) {\n-            LOG.debug(\"Empty Alert - ignoring situationNumber: {}\", situation.getSituationNumber() != null ? situation.getSituationNumber().getValue():null);\n-            return null;\n+          alert.addEntity(new EntitySelector.Agency(new FeedScopedId(feedId, agencyId)));\n         }\n+      }\n \n-        ArrayList<TimePeriod> periods = new ArrayList<>();\n-        if(situation.getValidityPeriods().size() > 0) {\n-            for (HalfOpenTimestampOutputRangeStructure activePeriod : situation.getValidityPeriods()) {\n+      AffectsScopeStructure.StopPoints stopPoints = affectsStructure.getStopPoints();\n+      AffectsScopeStructure.StopPlaces stopPlaces = affectsStructure.getStopPlaces();\n \n-                final long realStart = activePeriod.getStartTime() != null ? getEpochSecond(activePeriod.getStartTime()) : 0;\n-                final long start = activePeriod.getStartTime() != null? realStart - earlyStart : 0;\n+      if (stopPoints != null && isNotEmpty(stopPoints.getAffectedStopPoints())) {\n+        for (AffectedStopPointStructure stopPoint : stopPoints.getAffectedStopPoints()) {\n+          StopPointRef stopPointRef = stopPoint.getStopPointRef();\n+          if (stopPointRef == null || stopPointRef.getValue() == null) {\n+            continue;\n+          }\n \n-                final long realEnd = activePeriod.getEndTime() != null ? getEpochSecond(activePeriod.getEndTime()) : TimePeriod.OPEN_ENDED;\n-                final long end = activePeriod.getEndTime() != null? realEnd  : TimePeriod.OPEN_ENDED;\n+          FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPointRef.getValue());\n \n-                periods.add(new TimePeriod(start, end));\n-            }\n-        } else {\n-            // Per the GTFS-rt spec, if an alert has no TimeRanges, than it should always be shown.\n-            periods.add(new TimePeriod(0, TimePeriod.OPEN_ENDED));\n-        }\n+          if (stopId == null) {\n+            stopId = new FeedScopedId(feedId, stopPointRef.getValue());\n+          }\n \n-        alert.setTimePeriods(periods);\n-\n-        if (situation.getPriority() != null) {\n-            alert.priority = situation.getPriority().intValue();\n+          alert.addEntity(new EntitySelector.Stop(stopId));\n+          // TODO: is this correct? Should the stop conditions be in the entity selector?\n+          updateStopConditions(alert, stopPoint.getStopConditions());\n         }\n+      } else if (stopPlaces != null && isNotEmpty(stopPlaces.getAffectedStopPlaces())) {\n+        for (AffectedStopPlaceStructure stopPoint : stopPlaces.getAffectedStopPlaces()) {\n+          StopPlaceRef stopPlace = stopPoint.getStopPlaceRef();\n+          if (stopPlace == null || stopPlace.getValue() == null) {\n+            continue;\n+          }\n \n-        AffectsScopeStructure affectsStructure = situation.getAffects();\n-\n-        if (affectsStructure != null) {\n-\n-            AffectsScopeStructure.Operators operators = affectsStructure.getOperators();\n+          FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPlace.getValue());\n \n-            if (operators != null && isNotEmpty(operators.getAffectedOperators())) {\n-                for (AffectedOperatorStructure affectedOperator : operators.getAffectedOperators()) {\n+          if (stopId == null) {\n+            stopId = new FeedScopedId(feedId, stopPlace.getValue());\n+          }\n \n-                    OperatorRefStructure operatorRef = affectedOperator.getOperatorRef();\n-                    if (operatorRef == null || operatorRef.getValue() == null) {\n-                        continue;\n+          alert.addEntity(new EntitySelector.Stop(stopId));\n+        }\n+      }\n+\n+      AffectsScopeStructure.Networks networks = affectsStructure.getNetworks();\n+      if (networks != null && isNotEmpty(networks.getAffectedNetworks())) {\n+        for (AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork : networks.getAffectedNetworks()) {\n+          List<AffectedLineStructure> affectedLines = affectedNetwork.getAffectedLines();\n+          if (isNotEmpty(affectedLines)) {\n+            for (AffectedLineStructure line : affectedLines) {\n+              LineRef lineRef = line.getLineRef();\n+\n+              if (lineRef == null || lineRef.getValue() == null) {\n+                continue;\n+              }\n+\n+              List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n+\n+              AffectedLineStructure.Routes routes = line.getRoutes();\n+\n+              // Resolve AffectedStop-ids\n+              if (routes != null) {\n+                for (AffectedRouteStructure route : routes.getAffectedRoutes()) {\n+                  if (route.getStopPoints() != null) {\n+                    List<Serializable> stopPointsList = route\n+                      .getStopPoints()\n+                      .getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n+                    for (Serializable serializable : stopPointsList) {\n+                      if (serializable instanceof AffectedStopPointStructure) {\n+                        AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n+                        affectedStops.add(stopPointStructure);\n+                      }\n                     }\n-\n-                    // SIRI Operators are mapped to OTP Agency, this i probably wrong - but\n-                    // I leave this for now.\n-                    String agencyId = operatorRef.getValue();\n-\n-                    alert.addEntity(new EntitySelector.Agency(new FeedScopedId(feedId, agencyId)));\n+                  }\n                 }\n+              }\n+              FeedScopedId affectedRoute = new FeedScopedId(feedId, lineRef.getValue());\n+\n+              if (!affectedStops.isEmpty()) {\n+                for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                  FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                    affectedStop.getStopPointRef().getValue()\n+                  );\n+                  if (stop == null) {\n+                    stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n+                  }\n+                  alert.addEntity(new EntitySelector.StopAndRoute(stop, affectedRoute));\n+                  // TODO: is this correct? Should the stop conditions be in the entity selector?\n+                  updateStopConditions(alert, affectedStop.getStopConditions());\n+                }\n+              } else {\n+                alert.addEntity(new EntitySelector.Route(affectedRoute));\n+              }\n             }\n-\n-            AffectsScopeStructure.StopPoints stopPoints = affectsStructure.getStopPoints();\n-            AffectsScopeStructure.StopPlaces stopPlaces = affectsStructure.getStopPlaces();\n-\n-            if (stopPoints != null && isNotEmpty(stopPoints.getAffectedStopPoints())) {\n-\n-                for (AffectedStopPointStructure stopPoint : stopPoints.getAffectedStopPoints()) {\n-                    StopPointRef stopPointRef = stopPoint.getStopPointRef();\n-                    if (stopPointRef == null || stopPointRef.getValue() == null) {\n-                        continue;\n-                    }\n-\n-                    FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPointRef.getValue());\n-\n-                    if (stopId == null) {\n-                        stopId = new FeedScopedId(feedId, stopPointRef.getValue());\n-                    }\n-\n-                    alert.addEntity(new EntitySelector.Stop(stopId));\n-                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                    updateStopConditions(alert, stopPoint.getStopConditions());\n+          } else {\n+            NetworkRefStructure networkRef = affectedNetwork.getNetworkRef();\n+            if (networkRef == null || networkRef.getValue() == null) {\n+              continue;\n+            }\n+            String networkId = networkRef.getValue();\n+            // TODO: What to do here?\n+          }\n+        }\n+      }\n+\n+      AffectsScopeStructure.VehicleJourneys vjs = affectsStructure.getVehicleJourneys();\n+      if (vjs != null && isNotEmpty(vjs.getAffectedVehicleJourneies())) {\n+        for (AffectedVehicleJourneyStructure affectedVehicleJourney : vjs.getAffectedVehicleJourneies()) {\n+          String lineRef = null;\n+          if (affectedVehicleJourney.getLineRef() != null) {\n+            lineRef = affectedVehicleJourney.getLineRef().getValue();\n+          }\n+\n+          List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n+\n+          List<AffectedRouteStructure> routes = affectedVehicleJourney.getRoutes();\n+          // Resolve AffectedStop-ids\n+          if (routes != null) {\n+            for (AffectedRouteStructure route : routes) {\n+              if (route.getStopPoints() != null) {\n+                List<Serializable> stopPointsList = route\n+                  .getStopPoints()\n+                  .getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n+                for (Serializable serializable : stopPointsList) {\n+                  if (serializable instanceof AffectedStopPointStructure) {\n+                    AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n+                    affectedStops.add(stopPointStructure);\n+                  }\n                 }\n-            } else if (stopPlaces != null && isNotEmpty(stopPlaces.getAffectedStopPlaces())) {\n-\n-                for (AffectedStopPlaceStructure stopPoint : stopPlaces.getAffectedStopPlaces()) {\n-                    StopPlaceRef stopPlace = stopPoint.getStopPlaceRef();\n-                    if (stopPlace == null || stopPlace.getValue() == null) {\n-                        continue;\n-                    }\n-\n-                    FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPlace.getValue());\n-\n-                    if (stopId == null) {\n-                        stopId = new FeedScopedId(feedId, stopPlace.getValue());\n+              }\n+            }\n+          }\n+\n+          List<VehicleJourneyRef> vehicleJourneyReves = affectedVehicleJourney.getVehicleJourneyReves();\n+\n+          if (isNotEmpty(vehicleJourneyReves)) {\n+            for (VehicleJourneyRef vehicleJourneyRef : vehicleJourneyReves) {\n+              List<FeedScopedId> tripIds = new ArrayList<>();\n+\n+              FeedScopedId tripIdFromVehicleJourney = siriFuzzyTripMatcher.getTripId(\n+                vehicleJourneyRef.getValue()\n+              );\n+\n+              ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime() !=\n+                null\n+                ? affectedVehicleJourney.getOriginAimedDepartureTime()\n+                : ZonedDateTime.now();\n+\n+              ZonedDateTime startOfService = DateMapper.asStartOfService(originAimedDepartureTime);\n+\n+              ServiceDate serviceDate = new ServiceDate(startOfService.toLocalDate());\n+\n+              if (tripIdFromVehicleJourney != null) {\n+                tripIds.add(tripIdFromVehicleJourney);\n+              } else {\n+                tripIds =\n+                  siriFuzzyTripMatcher.getTripIdForInternalPlanningCodeServiceDateAndMode(\n+                    vehicleJourneyRef.getValue(),\n+                    serviceDate,\n+                    TransitMode.RAIL,\n+                    \"railReplacementBus\"\n+                  );\n+              }\n+\n+              for (FeedScopedId tripId : tripIds) {\n+                if (!affectedStops.isEmpty()) {\n+                  for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                      affectedStop.getStopPointRef().getValue()\n+                    );\n+                    if (stop == null) {\n+                      stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n                     }\n+                    // Creating unique, deterministic id for the alert\n+                    alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n \n-                    alert.addEntity(new EntitySelector.Stop(stopId));\n+                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n+                    updateStopConditions(alert, affectedStop.getStopConditions());\n+                  }\n+                } else {\n+                  alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n                 }\n+              }\n             }\n-\n-            AffectsScopeStructure.Networks networks = affectsStructure.getNetworks();\n-            if (networks != null && isNotEmpty(networks.getAffectedNetworks())) {\n-\n-                for (AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork : networks.getAffectedNetworks()) {\n-                    List<AffectedLineStructure> affectedLines = affectedNetwork.getAffectedLines();\n-                    if (isNotEmpty(affectedLines)) {\n-                        for (AffectedLineStructure line : affectedLines) {\n-\n-                            LineRef lineRef = line.getLineRef();\n-\n-                            if (lineRef == null || lineRef.getValue() == null) {\n-                                continue;\n-                            }\n-\n-                            List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n-\n-                            AffectedLineStructure.Routes routes = line.getRoutes();\n-\n-                            // Resolve AffectedStop-ids\n-                            if (routes != null) {\n-                                for (AffectedRouteStructure route : routes.getAffectedRoutes()) {\n-                                    if (route.getStopPoints() != null) {\n-                                        List<Serializable> stopPointsList = route.getStopPoints().getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n-                                        for (Serializable serializable : stopPointsList) {\n-                                            if (serializable instanceof AffectedStopPointStructure) {\n-                                                AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n-                                                affectedStops.add(stopPointStructure);\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            FeedScopedId affectedRoute = new FeedScopedId(feedId, lineRef.getValue());\n-\n-                            if (! affectedStops.isEmpty()) {\n-                                for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n-                                    if (stop == null) {\n-                                        stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n-                                    }\n-                                    alert.addEntity(new EntitySelector.StopAndRoute(stop, affectedRoute));\n-                                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                                    updateStopConditions(alert, affectedStop.getStopConditions());\n-                                }\n-                            } else {\n-                                alert.addEntity(new EntitySelector.Route(affectedRoute));\n-                            }\n-                        }\n-                    } else {\n-                        NetworkRefStructure networkRef = affectedNetwork.getNetworkRef();\n-                        if (networkRef == null || networkRef.getValue() == null) {\n-                            continue;\n-                        }\n-                        String networkId = networkRef.getValue();\n-\n-                        // TODO: What to do here?\n-                    }\n+          }\n+\n+          final FramedVehicleJourneyRefStructure framedVehicleJourneyRef = affectedVehicleJourney.getFramedVehicleJourneyRef();\n+          if (framedVehicleJourneyRef != null) {\n+            final DataFrameRefStructure dataFrameRef = framedVehicleJourneyRef.getDataFrameRef();\n+            final String datedVehicleJourneyRef = framedVehicleJourneyRef.getDatedVehicleJourneyRef();\n+\n+            FeedScopedId tripId = siriFuzzyTripMatcher.getTripId(datedVehicleJourneyRef);\n+\n+            if (tripId != null) {\n+              ServiceDate serviceDate = null;\n+              if (dataFrameRef != null && dataFrameRef.getValue() != null) {\n+                ZonedDateTime startOfService = DateMapper.asStartOfService(\n+                  LocalDate.parse(dataFrameRef.getValue()),\n+                  graph.getTimeZone().toZoneId()\n+                );\n+\n+                serviceDate =\n+                  new ServiceDate(\n+                    startOfService.getYear(),\n+                    startOfService.getMonthValue(),\n+                    startOfService.getDayOfMonth()\n+                  );\n+              }\n+\n+              if (!affectedStops.isEmpty()) {\n+                for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                  FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                    affectedStop.getStopPointRef().getValue()\n+                  );\n+                  if (stop == null) {\n+                    stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n+                  }\n+\n+                  alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n                 }\n+              } else {\n+                alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n+              }\n             }\n-\n-            AffectsScopeStructure.VehicleJourneys vjs = affectsStructure.getVehicleJourneys();\n-            if (vjs != null && isNotEmpty(vjs.getAffectedVehicleJourneies())) {\n-\n-                for (AffectedVehicleJourneyStructure affectedVehicleJourney : vjs.getAffectedVehicleJourneies()) {\n-\n-                    String lineRef = null;\n-                    if (affectedVehicleJourney.getLineRef() != null) {\n-                        lineRef = affectedVehicleJourney.getLineRef().getValue();\n-                    }\n-\n-                    List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n-\n-                    List<AffectedRouteStructure> routes = affectedVehicleJourney.getRoutes();\n-                    // Resolve AffectedStop-ids\n-                    if (routes != null) {\n-                        for (AffectedRouteStructure route : routes) {\n-                            if (route.getStopPoints() != null) {\n-                                List<Serializable> stopPointsList = route.getStopPoints().getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n-                                for (Serializable serializable : stopPointsList) {\n-                                    if (serializable instanceof AffectedStopPointStructure) {\n-                                        AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n-                                        affectedStops.add(stopPointStructure);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    List<VehicleJourneyRef> vehicleJourneyReves = affectedVehicleJourney.getVehicleJourneyReves();\n-\n-                    if (isNotEmpty(vehicleJourneyReves)) {\n-                        for (VehicleJourneyRef vehicleJourneyRef : vehicleJourneyReves) {\n-\n-                            List<FeedScopedId> tripIds = new ArrayList<>();\n-\n-                            FeedScopedId tripIdFromVehicleJourney = siriFuzzyTripMatcher.getTripId(vehicleJourneyRef.getValue());\n-\n-                            ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime() != null\n-                                ? affectedVehicleJourney.getOriginAimedDepartureTime()\n-                                : ZonedDateTime.now();\n-\n-                            ZonedDateTime startOfService = DateMapper.asStartOfService(originAimedDepartureTime);\n-\n-                            ServiceDate serviceDate = new ServiceDate(startOfService.toLocalDate());\n-\n-                            if (tripIdFromVehicleJourney != null) {\n-                                tripIds.add(tripIdFromVehicleJourney);\n-                            } else {\n-                                tripIds = siriFuzzyTripMatcher.getTripIdForInternalPlanningCodeServiceDateAndMode(\n-                                    vehicleJourneyRef.getValue(),\n-                                    serviceDate,\n-                                    TransitMode.RAIL,\n-                                    \"railReplacementBus\"\n-                                );\n-                            }\n-\n-                            for (FeedScopedId tripId : tripIds) {\n-\n-                                if (! affectedStops.isEmpty()) {\n-                                    for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                        FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n-                                        if (stop == null) {\n-                                            stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n-                                        }\n-                                        // Creating unique, deterministic id for the alert\n-                                        alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n-\n-                                        // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                                        updateStopConditions(alert, affectedStop.getStopConditions());\n-\n-                                    }\n-                                } else {\n-                                    alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n-\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    final FramedVehicleJourneyRefStructure framedVehicleJourneyRef = affectedVehicleJourney.getFramedVehicleJourneyRef();\n-                    if (framedVehicleJourneyRef != null) {\n-                        final DataFrameRefStructure dataFrameRef = framedVehicleJourneyRef.getDataFrameRef();\n-                        final String datedVehicleJourneyRef = framedVehicleJourneyRef.getDatedVehicleJourneyRef();\n-\n-                        FeedScopedId tripId = siriFuzzyTripMatcher.getTripId(datedVehicleJourneyRef);\n-\n-                        if (tripId != null) {\n-                            ServiceDate serviceDate = null;\n-                            if (dataFrameRef != null && dataFrameRef.getValue() != null) {\n-                                ZonedDateTime startOfService = DateMapper.asStartOfService(LocalDate.parse(\n-                                    dataFrameRef.getValue()), graph.getTimeZone().toZoneId());\n-\n-                                serviceDate = new ServiceDate(startOfService.getYear(),\n-                                    startOfService.getMonthValue(),\n-                                    startOfService.getDayOfMonth()\n-                                );\n-\n-                            }\n-\n-                            if (!affectedStops.isEmpty()) {\n-                                for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop\n-                                        .getStopPointRef()\n-                                        .getValue());\n-                                    if (stop == null) {\n-                                        stop = new FeedScopedId(feedId,\n-                                            affectedStop.getStopPointRef().getValue()\n-                                        );\n-                                    }\n-\n-                                    alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n-                                }\n-                            }\n-                            else {\n-                                alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n-                            }\n-                        }\n-                    }\n-\n-                    if (lineRef != null) {\n-\n-                        Set<Route> affectedRoutes = siriFuzzyTripMatcher.getRoutes(lineRef);\n-                        if (affectedRoutes != null) {\n-                            for (Route route : affectedRoutes) {\n-                                alert.addEntity(new EntitySelector.Route(route.getId()));\n-                            }\n-                        }\n-                    }\n-                }\n+          }\n+\n+          if (lineRef != null) {\n+            Set<Route> affectedRoutes = siriFuzzyTripMatcher.getRoutes(lineRef);\n+            if (affectedRoutes != null) {\n+              for (Route route : affectedRoutes) {\n+                alert.addEntity(new EntitySelector.Route(route.getId()));\n+              }\n             }\n+          }\n         }\n-\n-        if (alert.getStopConditions().isEmpty()) {\n-            updateStopConditions(alert, null);\n-        }\n-\n-        alert.alertType = situation.getReportType();\n-\n-        alert.severity =\n-                SiriSeverityMapper.getAlertSeverityForSiriSeverity(situation.getSeverity());\n-\n-        if (situation.getParticipantRef() != null) {\n-            String codespace = situation.getParticipantRef().getValue();\n-            alert.setFeedId(codespace + \":Authority:\" + codespace); //TODO - SIRI: Should probably not assume this codespace -> authority rule\n-        }\n-\n-        return alert;\n+      }\n     }\n \n-    private long getEpochSecond(ZonedDateTime startTime) {\n-        return startTime.toEpochSecond();\n+    if (alert.getStopConditions().isEmpty()) {\n+      updateStopConditions(alert, null);\n     }\n \n+    alert.alertType = situation.getReportType();\n \n-    /*\n-     * Creates alert from PtSituation with all textual content\n-     */\n-    private TransitAlert createAlertWithTexts(PtSituationElement situation) {\n-        TransitAlert alert = new TransitAlert();\n-\n-        alert.alertDescriptionText = getTranslatedString(situation.getDescriptions());\n-        alert.alertDetailText = getTranslatedString(situation.getDetails());\n-        alert.alertAdviceText = getTranslatedString(situation.getAdvices());\n-        alert.alertHeaderText = getTranslatedString(situation.getSummaries());\n-        alert.alertUrl = getInfoLinkAsString(situation.getInfoLinks());\n-        alert.setAlertUrlList(getInfoLinks(situation.getInfoLinks()));\n+    alert.severity = SiriSeverityMapper.getAlertSeverityForSiriSeverity(situation.getSeverity());\n \n-        return alert;\n+    if (situation.getParticipantRef() != null) {\n+      String codespace = situation.getParticipantRef().getValue();\n+      alert.setFeedId(codespace + \":Authority:\" + codespace); //TODO - SIRI: Should probably not assume this codespace -> authority rule\n     }\n \n-    /*\n-     * Returns first InfoLink-uri as a String\n-     */\n-    private I18NString getInfoLinkAsString(PtSituationElement.InfoLinks infoLinks) {\n-        if (infoLinks != null) {\n-            if (isNotEmpty(infoLinks.getInfoLinks())) {\n-                InfoLinkStructure infoLinkStructure = infoLinks.getInfoLinks().get(0);\n-                if (infoLinkStructure != null && infoLinkStructure.getUri() != null) {\n-                    return new NonLocalizedString(infoLinkStructure.getUri());\n-                }\n-            }\n+    return alert;\n+  }\n+\n+  private long getEpochSecond(ZonedDateTime startTime) {\n+    return startTime.toEpochSecond();\n+  }\n+\n+  /*\n+   * Creates alert from PtSituation with all textual content\n+   */\n+  private TransitAlert createAlertWithTexts(PtSituationElement situation) {\n+    TransitAlert alert = new TransitAlert();\n+\n+    alert.alertDescriptionText = getTranslatedString(situation.getDescriptions());\n+    alert.alertDetailText = getTranslatedString(situation.getDetails());\n+    alert.alertAdviceText = getTranslatedString(situation.getAdvices());\n+    alert.alertHeaderText = getTranslatedString(situation.getSummaries());\n+    alert.alertUrl = getInfoLinkAsString(situation.getInfoLinks());\n+    alert.setAlertUrlList(getInfoLinks(situation.getInfoLinks()));\n+\n+    return alert;\n+  }\n+\n+  /*\n+   * Returns first InfoLink-uri as a String\n+   */\n+  private I18NString getInfoLinkAsString(PtSituationElement.InfoLinks infoLinks) {\n+    if (infoLinks != null) {\n+      if (isNotEmpty(infoLinks.getInfoLinks())) {\n+        InfoLinkStructure infoLinkStructure = infoLinks.getInfoLinks().get(0);\n+        if (infoLinkStructure != null && infoLinkStructure.getUri() != null) {\n+          return new NonLocalizedString(infoLinkStructure.getUri());\n         }\n-        return null;\n+      }\n     }\n-\n-    /*\n-     * Returns all InfoLinks\n-     */\n-    private List<AlertUrl> getInfoLinks(PtSituationElement.InfoLinks infoLinks) {\n-        List<AlertUrl> alertUrls = new ArrayList<>();\n-        if (infoLinks != null) {\n-            if (isNotEmpty(infoLinks.getInfoLinks())) {\n-                for (InfoLinkStructure infoLink : infoLinks.getInfoLinks()) {\n-                    AlertUrl alertUrl = new AlertUrl();\n-\n-                    List<NaturalLanguageStringStructure> labels = infoLink.getLabels();\n-                    if (labels != null && !labels.isEmpty()) {\n-                        NaturalLanguageStringStructure label = labels.get(0);\n-                        alertUrl.label = label.getValue();\n-                    }\n-\n-                    alertUrl.uri = infoLink.getUri();\n-                    alertUrls.add(alertUrl);\n-                }\n-            }\n+    return null;\n+  }\n+\n+  /*\n+   * Returns all InfoLinks\n+   */\n+  private List<AlertUrl> getInfoLinks(PtSituationElement.InfoLinks infoLinks) {\n+    List<AlertUrl> alertUrls = new ArrayList<>();\n+    if (infoLinks != null) {\n+      if (isNotEmpty(infoLinks.getInfoLinks())) {\n+        for (InfoLinkStructure infoLink : infoLinks.getInfoLinks()) {\n+          AlertUrl alertUrl = new AlertUrl();\n+\n+          List<NaturalLanguageStringStructure> labels = infoLink.getLabels();\n+          if (labels != null && !labels.isEmpty()) {\n+            NaturalLanguageStringStructure label = labels.get(0);\n+            alertUrl.label = label.getValue();\n+          }\n+\n+          alertUrl.uri = infoLink.getUri();\n+          alertUrls.add(alertUrl);\n         }\n-        return alertUrls;\n+      }\n     }\n-\n-    private void updateStopConditions(TransitAlert alertPatch, List<RoutePointTypeEnumeration> stopConditions) {\n-        Set<StopCondition> alertStopConditions = new HashSet<>();\n-        if (stopConditions != null) {\n-            for (RoutePointTypeEnumeration stopCondition : stopConditions) {\n-                switch (stopCondition) {\n-                    case EXCEPTIONAL_STOP:\n-                        alertStopConditions.add(StopCondition.EXCEPTIONAL_STOP);\n-                        break;\n-                    case DESTINATION:\n-                        alertStopConditions.add(StopCondition.DESTINATION);\n-                        break;\n-                    case NOT_STOPPING:\n-                        alertStopConditions.add(StopCondition.NOT_STOPPING);\n-                        break;\n-                    case REQUEST_STOP:\n-                        alertStopConditions.add(StopCondition.REQUEST_STOP);\n-                        break;\n-                    case START_POINT:\n-                        alertStopConditions.add(StopCondition.START_POINT);\n-                        break;\n-                }\n-            }\n-        }\n-        if (alertStopConditions.isEmpty()) {\n-            //No StopConditions are set - set default\n-            alertStopConditions.add(StopCondition.START_POINT);\n+    return alertUrls;\n+  }\n+\n+  private void updateStopConditions(\n+    TransitAlert alertPatch,\n+    List<RoutePointTypeEnumeration> stopConditions\n+  ) {\n+    Set<StopCondition> alertStopConditions = new HashSet<>();\n+    if (stopConditions != null) {\n+      for (RoutePointTypeEnumeration stopCondition : stopConditions) {\n+        switch (stopCondition) {\n+          case EXCEPTIONAL_STOP:\n+            alertStopConditions.add(StopCondition.EXCEPTIONAL_STOP);\n+            break;\n+          case DESTINATION:\n             alertStopConditions.add(StopCondition.DESTINATION);\n-\n+            break;\n+          case NOT_STOPPING:\n+            alertStopConditions.add(StopCondition.NOT_STOPPING);\n+            break;\n+          case REQUEST_STOP:\n+            alertStopConditions.add(StopCondition.REQUEST_STOP);\n+            break;\n+          case START_POINT:\n+            alertStopConditions.add(StopCondition.START_POINT);\n+            break;\n         }\n-        alertPatch.getStopConditions().addAll(alertStopConditions);\n+      }\n     }\n-\n-\n-    /**\n-     * @return True if list have at least one element. {@code false} is returned if the given list\n-     * is empty or {@code null}.\n-     */\n-    private boolean isNotEmpty(List<?> list) {\n-        return list != null && !list.isEmpty();\n+    if (alertStopConditions.isEmpty()) {\n+      //No StopConditions are set - set default\n+      alertStopConditions.add(StopCondition.START_POINT);\n+      alertStopConditions.add(StopCondition.DESTINATION);\n     }\n-\n-    /**\n-     * convert a SIRI DefaultedTextStructure to a OTP TranslatedString\n-     *\n-     * @return A TranslatedString containing the same information as the input\n-     */\n-    private I18NString getTranslatedString(List<DefaultedTextStructure> input) {\n-        Map<String, String> translations = new HashMap<>();\n-        if (input != null && input.size() > 0) {\n-            for (DefaultedTextStructure textStructure : input) {\n-                String language = \"\";\n-                String value = \"\";\n-                if (textStructure.getLang() != null) {\n-                    language = textStructure.getLang();\n-                }\n-                if (textStructure.getValue() != null) {\n-                    value = textStructure.getValue();\n-                }\n-                translations.put(language, value);\n-            }\n-        } else {\n-            translations.put(\"\", \"\");\n+    alertPatch.getStopConditions().addAll(alertStopConditions);\n+  }\n+\n+  /**\n+   * @return True if list have at least one element. {@code false} is returned if the given list\n+   * is empty or {@code null}.\n+   */\n+  private boolean isNotEmpty(List<?> list) {\n+    return list != null && !list.isEmpty();\n+  }\n+\n+  /**\n+   * convert a SIRI DefaultedTextStructure to a OTP TranslatedString\n+   *\n+   * @return A TranslatedString containing the same information as the input\n+   */\n+  private I18NString getTranslatedString(List<DefaultedTextStructure> input) {\n+    Map<String, String> translations = new HashMap<>();\n+    if (input != null && input.size() > 0) {\n+      for (DefaultedTextStructure textStructure : input) {\n+        String language = \"\";\n+        String value = \"\";\n+        if (textStructure.getLang() != null) {\n+          language = textStructure.getLang();\n         }\n-\n-        return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+        if (textStructure.getValue() != null) {\n+          value = textStructure.getValue();\n+        }\n+        translations.put(language, value);\n+      }\n+    } else {\n+      translations.put(\"\", \"\");\n     }\n \n-    public void setTransitAlertService(TransitAlertService transitAlertService) {\n-        this.transitAlertService = transitAlertService;\n-    }\n+    return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+  }\n \n-    public long getEarlyStart() {\n-        return earlyStart;\n-    }\n+  public void setTransitAlertService(TransitAlertService transitAlertService) {\n+    this.transitAlertService = transitAlertService;\n+  }\n \n-    public void setEarlyStart(long earlyStart) {\n-        this.earlyStart = earlyStart;\n-    }\n+  public long getEarlyStart() {\n+    return earlyStart;\n+  }\n \n-    public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n-        this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n-    }\n+  public void setEarlyStart(long earlyStart) {\n+    this.earlyStart = earlyStart;\n+  }\n+\n+  public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n+    this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex d9532ff71b..9846986b04 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -570,20 +580,4 @@ public class SiriAlertsUpdateHandler {\n \n     return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n   }\n-\n-  public void setTransitAlertService(TransitAlertService transitAlertService) {\n-    this.transitAlertService = transitAlertService;\n-  }\n-\n-  public long getEarlyStart() {\n-    return earlyStart;\n-  }\n-\n-  public void setEarlyStart(long earlyStart) {\n-    this.earlyStart = earlyStart;\n-  }\n-\n-  public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n-    this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n-  }\n }\n", "next_change": {"commit": "c7c3ccb43478aca72b92e413c5698b346261ae04", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex 9846986b04..e4dedf3ac8 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -578,6 +588,8 @@ public class SiriAlertsUpdateHandler {\n       translations.put(\"\", \"\");\n     }\n \n-    return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+    return translations.isEmpty()\n+      ? null\n+      : TranslatedString.getI18NString(translations, false, true);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex 618e5fb163..f6c641cd79 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -353,14 +344,14 @@ public class SiriAlertsUpdateHandler {\n                                             stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n                                         }\n                                         // Creating unique, deterministic id for the alert\n-                                        alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId));\n+                                        alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n \n                                         // TODO: is this correct? Should the stop conditions be in the entity selector?\n                                         updateStopConditions(alert, affectedStop.getStopConditions());\n \n                                     }\n                                 } else {\n-                                    alert.addEntity(new EntitySelector.Trip(tripId));\n+                                    alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n \n                                 }\n                             }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex f6c641cd79..d9532ff71b 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -59,519 +58,532 @@ import java.util.Set;\n  */\n public class SiriAlertsUpdateHandler {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(SiriAlertsUpdateHandler.class);\n-\n-    private TransitAlertService transitAlertService;\n-\n-    /** How long before the posted start of an event it should be displayed to users */\n-    private long earlyStart;\n-\n-    private SiriFuzzyTripMatcher siriFuzzyTripMatcher;\n-\n-    private final String feedId;\n-\n-    private final Graph graph;\n+  private static final Logger LOG = LoggerFactory.getLogger(SiriAlertsUpdateHandler.class);\n+\n+  private TransitAlertService transitAlertService;\n+\n+  /** How long before the posted start of an event it should be displayed to users */\n+  private long earlyStart;\n+\n+  private SiriFuzzyTripMatcher siriFuzzyTripMatcher;\n+\n+  private final String feedId;\n+\n+  private final Graph graph;\n+\n+  private final Set<TransitAlert> alerts = new HashSet<>();\n+\n+  public SiriAlertsUpdateHandler(String feedId, Graph graph) {\n+    this.feedId = feedId;\n+    this.graph = graph;\n+  }\n+\n+  public void update(ServiceDelivery delivery) {\n+    for (SituationExchangeDeliveryStructure sxDelivery : delivery.getSituationExchangeDeliveries()) {\n+      SituationExchangeDeliveryStructure.Situations situations = sxDelivery.getSituations();\n+      if (situations != null) {\n+        long t1 = System.currentTimeMillis();\n+        int addedCounter = 0;\n+        int expiredCounter = 0;\n+        for (PtSituationElement sxElement : situations.getPtSituationElements()) {\n+          boolean expireSituation =\n+            (\n+              sxElement.getProgress() != null &&\n+              sxElement.getProgress().equals(WorkflowStatusEnumeration.CLOSED)\n+            );\n+\n+          String situationNumber;\n+          if (sxElement.getSituationNumber() != null) {\n+            situationNumber = sxElement.getSituationNumber().getValue();\n+          } else {\n+            situationNumber = null;\n+          }\n+\n+          if (expireSituation) {\n+            alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n+            expiredCounter++;\n+          } else {\n+            TransitAlert alert = handleAlert(sxElement);\n+            addedCounter++;\n+            if (alert != null) {\n+              alert.setId(situationNumber);\n+              if (alert.getEntities().isEmpty()) {\n+                LOG.info(\n+                  \"No match found for Alert - setting Unknown entity for situation with situationNumber {}\",\n+                  situationNumber\n+                );\n+                alert.addEntity(\n+                  new EntitySelector.Unknown(\"Alert had no entities that could be handled\")\n+                );\n+              }\n+              alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n+              alerts.add(alert);\n+            }\n+          }\n+        }\n \n-    private final Set<TransitAlert> alerts = new HashSet<>();\n+        transitAlertService.setAlerts(alerts);\n+\n+        LOG.info(\n+          \"Added {} alerts, expired {} alerts based on {} situations, current alert-count: {}, elapsed time {}ms\",\n+          addedCounter,\n+          expiredCounter,\n+          situations.getPtSituationElements().size(),\n+          transitAlertService.getAllAlerts().size(),\n+          System.currentTimeMillis() - t1\n+        );\n+      }\n+    }\n+  }\n+\n+  private TransitAlert handleAlert(PtSituationElement situation) {\n+    TransitAlert alert = createAlertWithTexts(situation);\n+\n+    if (\n+      (alert.alertHeaderText == null || alert.alertHeaderText.toString().isEmpty()) &&\n+      (alert.alertDescriptionText == null || alert.alertDescriptionText.toString().isEmpty()) &&\n+      (alert.alertDetailText == null || alert.alertDetailText.toString().isEmpty())\n+    ) {\n+      LOG.debug(\n+        \"Empty Alert - ignoring situationNumber: {}\",\n+        situation.getSituationNumber() != null ? situation.getSituationNumber().getValue() : null\n+      );\n+      return null;\n+    }\n \n-    public SiriAlertsUpdateHandler(String feedId, Graph graph) {\n-        this.feedId = feedId;\n-        this.graph = graph;\n+    ArrayList<TimePeriod> periods = new ArrayList<>();\n+    if (situation.getValidityPeriods().size() > 0) {\n+      for (HalfOpenTimestampOutputRangeStructure activePeriod : situation.getValidityPeriods()) {\n+        final long realStart = activePeriod.getStartTime() != null\n+          ? getEpochSecond(activePeriod.getStartTime())\n+          : 0;\n+        final long start = activePeriod.getStartTime() != null ? realStart - earlyStart : 0;\n+\n+        final long realEnd = activePeriod.getEndTime() != null\n+          ? getEpochSecond(activePeriod.getEndTime())\n+          : TimePeriod.OPEN_ENDED;\n+        final long end = activePeriod.getEndTime() != null ? realEnd : TimePeriod.OPEN_ENDED;\n+\n+        periods.add(new TimePeriod(start, end));\n+      }\n+    } else {\n+      // Per the GTFS-rt spec, if an alert has no TimeRanges, than it should always be shown.\n+      periods.add(new TimePeriod(0, TimePeriod.OPEN_ENDED));\n     }\n \n-    public void update(ServiceDelivery delivery) {\n-        for (SituationExchangeDeliveryStructure sxDelivery : delivery.getSituationExchangeDeliveries()) {\n-            SituationExchangeDeliveryStructure.Situations situations = sxDelivery.getSituations();\n-            if (situations != null) {\n-                long t1 = System.currentTimeMillis();\n-                int addedCounter = 0;\n-                int expiredCounter = 0;\n-                for (PtSituationElement sxElement : situations.getPtSituationElements()) {\n-                    boolean expireSituation = (sxElement.getProgress() != null &&\n-                        sxElement.getProgress().equals(WorkflowStatusEnumeration.CLOSED));\n-\n-                    String situationNumber;\n-                    if (sxElement.getSituationNumber() != null) {\n-                        situationNumber = sxElement.getSituationNumber().getValue();\n-                    } else {\n-                        situationNumber = null;\n-                    }\n+    alert.setTimePeriods(periods);\n \n-                    if (expireSituation) {\n-                        alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n-                        expiredCounter++;\n-                    } else {\n-                        TransitAlert alert = handleAlert(sxElement);\n-                        addedCounter++;\n-                        if (alert != null) {\n-                            alert.setId(situationNumber);\n-                            alerts.removeIf(transitAlert -> transitAlert.getId().equals(situationNumber));\n-                            alerts.add(alert);\n-                            if (alert.getEntities().isEmpty()) {\n-                                LOG.info(\"No match found for Alert - ignoring situation with situationNumber {}\", situationNumber);\n-                            }\n-                        }\n-                    }\n-                }\n+    if (situation.getPriority() != null) {\n+      alert.priority = situation.getPriority().intValue();\n+    }\n \n-                transitAlertService.setAlerts(alerts);\n+    AffectsScopeStructure affectsStructure = situation.getAffects();\n \n-                LOG.info(\"Added {} alerts, expired {} alerts based on {} situations, current alert-count: {}, elapsed time {}ms\",\n-                        addedCounter, expiredCounter, situations.getPtSituationElements().size(), transitAlertService.getAllAlerts().size(), System.currentTimeMillis()-t1);\n-            }\n-        }\n-    }\n+    if (affectsStructure != null) {\n+      AffectsScopeStructure.Operators operators = affectsStructure.getOperators();\n \n-    private TransitAlert handleAlert(PtSituationElement situation) {\n+      if (operators != null && isNotEmpty(operators.getAffectedOperators())) {\n+        for (AffectedOperatorStructure affectedOperator : operators.getAffectedOperators()) {\n+          OperatorRefStructure operatorRef = affectedOperator.getOperatorRef();\n+          if (operatorRef == null || operatorRef.getValue() == null) {\n+            continue;\n+          }\n \n-        TransitAlert alert = createAlertWithTexts(situation);\n+          // SIRI Operators are mapped to OTP Agency, this i probably wrong - but\n+          // I leave this for now.\n+          String agencyId = operatorRef.getValue();\n \n-        if ((alert.alertHeaderText == null      || alert.alertHeaderText.toString().isEmpty()) &&\n-            (alert.alertDescriptionText == null || alert.alertDescriptionText.toString().isEmpty()) &&\n-            (alert.alertDetailText == null      || alert.alertDetailText.toString().isEmpty())) {\n-            LOG.debug(\"Empty Alert - ignoring situationNumber: {}\", situation.getSituationNumber() != null ? situation.getSituationNumber().getValue():null);\n-            return null;\n+          alert.addEntity(new EntitySelector.Agency(new FeedScopedId(feedId, agencyId)));\n         }\n+      }\n \n-        ArrayList<TimePeriod> periods = new ArrayList<>();\n-        if(situation.getValidityPeriods().size() > 0) {\n-            for (HalfOpenTimestampOutputRangeStructure activePeriod : situation.getValidityPeriods()) {\n-\n-                final long realStart = activePeriod.getStartTime() != null ? getEpochSecond(activePeriod.getStartTime()) : 0;\n-                final long start = activePeriod.getStartTime() != null? realStart - earlyStart : 0;\n+      AffectsScopeStructure.StopPoints stopPoints = affectsStructure.getStopPoints();\n+      AffectsScopeStructure.StopPlaces stopPlaces = affectsStructure.getStopPlaces();\n \n-                final long realEnd = activePeriod.getEndTime() != null ? getEpochSecond(activePeriod.getEndTime()) : TimePeriod.OPEN_ENDED;\n-                final long end = activePeriod.getEndTime() != null? realEnd  : TimePeriod.OPEN_ENDED;\n+      if (stopPoints != null && isNotEmpty(stopPoints.getAffectedStopPoints())) {\n+        for (AffectedStopPointStructure stopPoint : stopPoints.getAffectedStopPoints()) {\n+          StopPointRef stopPointRef = stopPoint.getStopPointRef();\n+          if (stopPointRef == null || stopPointRef.getValue() == null) {\n+            continue;\n+          }\n \n-                periods.add(new TimePeriod(start, end));\n-            }\n-        } else {\n-            // Per the GTFS-rt spec, if an alert has no TimeRanges, than it should always be shown.\n-            periods.add(new TimePeriod(0, TimePeriod.OPEN_ENDED));\n-        }\n+          FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPointRef.getValue());\n \n-        alert.setTimePeriods(periods);\n+          if (stopId == null) {\n+            stopId = new FeedScopedId(feedId, stopPointRef.getValue());\n+          }\n \n-        if (situation.getPriority() != null) {\n-            alert.priority = situation.getPriority().intValue();\n+          alert.addEntity(new EntitySelector.Stop(stopId));\n+          // TODO: is this correct? Should the stop conditions be in the entity selector?\n+          updateStopConditions(alert, stopPoint.getStopConditions());\n         }\n+      } else if (stopPlaces != null && isNotEmpty(stopPlaces.getAffectedStopPlaces())) {\n+        for (AffectedStopPlaceStructure stopPoint : stopPlaces.getAffectedStopPlaces()) {\n+          StopPlaceRef stopPlace = stopPoint.getStopPlaceRef();\n+          if (stopPlace == null || stopPlace.getValue() == null) {\n+            continue;\n+          }\n \n-        AffectsScopeStructure affectsStructure = situation.getAffects();\n-\n-        if (affectsStructure != null) {\n-\n-            AffectsScopeStructure.Operators operators = affectsStructure.getOperators();\n+          FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPlace.getValue());\n \n-            if (operators != null && isNotEmpty(operators.getAffectedOperators())) {\n-                for (AffectedOperatorStructure affectedOperator : operators.getAffectedOperators()) {\n+          if (stopId == null) {\n+            stopId = new FeedScopedId(feedId, stopPlace.getValue());\n+          }\n \n-                    OperatorRefStructure operatorRef = affectedOperator.getOperatorRef();\n-                    if (operatorRef == null || operatorRef.getValue() == null) {\n-                        continue;\n+          alert.addEntity(new EntitySelector.Stop(stopId));\n+        }\n+      }\n+\n+      AffectsScopeStructure.Networks networks = affectsStructure.getNetworks();\n+      if (networks != null && isNotEmpty(networks.getAffectedNetworks())) {\n+        for (AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork : networks.getAffectedNetworks()) {\n+          List<AffectedLineStructure> affectedLines = affectedNetwork.getAffectedLines();\n+          if (isNotEmpty(affectedLines)) {\n+            for (AffectedLineStructure line : affectedLines) {\n+              LineRef lineRef = line.getLineRef();\n+\n+              if (lineRef == null || lineRef.getValue() == null) {\n+                continue;\n+              }\n+\n+              List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n+\n+              AffectedLineStructure.Routes routes = line.getRoutes();\n+\n+              // Resolve AffectedStop-ids\n+              if (routes != null) {\n+                for (AffectedRouteStructure route : routes.getAffectedRoutes()) {\n+                  if (route.getStopPoints() != null) {\n+                    List<Serializable> stopPointsList = route\n+                      .getStopPoints()\n+                      .getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n+                    for (Serializable serializable : stopPointsList) {\n+                      if (serializable instanceof AffectedStopPointStructure) {\n+                        AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n+                        affectedStops.add(stopPointStructure);\n+                      }\n                     }\n-\n-                    // SIRI Operators are mapped to OTP Agency, this i probably wrong - but\n-                    // I leave this for now.\n-                    String agencyId = operatorRef.getValue();\n-\n-                    alert.addEntity(new EntitySelector.Agency(new FeedScopedId(feedId, agencyId)));\n+                  }\n+                }\n+              }\n+              FeedScopedId affectedRoute = new FeedScopedId(feedId, lineRef.getValue());\n+\n+              if (!affectedStops.isEmpty()) {\n+                for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                  FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                    affectedStop.getStopPointRef().getValue()\n+                  );\n+                  if (stop == null) {\n+                    stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n+                  }\n+                  alert.addEntity(new EntitySelector.StopAndRoute(stop, affectedRoute));\n+                  // TODO: is this correct? Should the stop conditions be in the entity selector?\n+                  updateStopConditions(alert, affectedStop.getStopConditions());\n                 }\n+              } else {\n+                alert.addEntity(new EntitySelector.Route(affectedRoute));\n+              }\n             }\n-\n-            AffectsScopeStructure.StopPoints stopPoints = affectsStructure.getStopPoints();\n-            AffectsScopeStructure.StopPlaces stopPlaces = affectsStructure.getStopPlaces();\n-\n-            if (stopPoints != null && isNotEmpty(stopPoints.getAffectedStopPoints())) {\n-\n-                for (AffectedStopPointStructure stopPoint : stopPoints.getAffectedStopPoints()) {\n-                    StopPointRef stopPointRef = stopPoint.getStopPointRef();\n-                    if (stopPointRef == null || stopPointRef.getValue() == null) {\n-                        continue;\n-                    }\n-\n-                    FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPointRef.getValue());\n-\n-                    if (stopId == null) {\n-                        stopId = new FeedScopedId(feedId, stopPointRef.getValue());\n-                    }\n-\n-                    alert.addEntity(new EntitySelector.Stop(stopId));\n-                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                    updateStopConditions(alert, stopPoint.getStopConditions());\n+          } else {\n+            NetworkRefStructure networkRef = affectedNetwork.getNetworkRef();\n+            if (networkRef == null || networkRef.getValue() == null) {\n+              continue;\n+            }\n+            String networkId = networkRef.getValue();\n+            // TODO: What to do here?\n+          }\n+        }\n+      }\n+\n+      AffectsScopeStructure.VehicleJourneys vjs = affectsStructure.getVehicleJourneys();\n+      if (vjs != null && isNotEmpty(vjs.getAffectedVehicleJourneies())) {\n+        for (AffectedVehicleJourneyStructure affectedVehicleJourney : vjs.getAffectedVehicleJourneies()) {\n+          String lineRef = null;\n+          if (affectedVehicleJourney.getLineRef() != null) {\n+            lineRef = affectedVehicleJourney.getLineRef().getValue();\n+          }\n+\n+          List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n+\n+          List<AffectedRouteStructure> routes = affectedVehicleJourney.getRoutes();\n+          // Resolve AffectedStop-ids\n+          if (routes != null) {\n+            for (AffectedRouteStructure route : routes) {\n+              if (route.getStopPoints() != null) {\n+                List<Serializable> stopPointsList = route\n+                  .getStopPoints()\n+                  .getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n+                for (Serializable serializable : stopPointsList) {\n+                  if (serializable instanceof AffectedStopPointStructure) {\n+                    AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n+                    affectedStops.add(stopPointStructure);\n+                  }\n                 }\n-            } else if (stopPlaces != null && isNotEmpty(stopPlaces.getAffectedStopPlaces())) {\n-\n-                for (AffectedStopPlaceStructure stopPoint : stopPlaces.getAffectedStopPlaces()) {\n-                    StopPlaceRef stopPlace = stopPoint.getStopPlaceRef();\n-                    if (stopPlace == null || stopPlace.getValue() == null) {\n-                        continue;\n-                    }\n-\n-                    FeedScopedId stopId = siriFuzzyTripMatcher.getStop(stopPlace.getValue());\n-\n-                    if (stopId == null) {\n-                        stopId = new FeedScopedId(feedId, stopPlace.getValue());\n+              }\n+            }\n+          }\n+\n+          List<VehicleJourneyRef> vehicleJourneyReves = affectedVehicleJourney.getVehicleJourneyReves();\n+\n+          if (isNotEmpty(vehicleJourneyReves)) {\n+            for (VehicleJourneyRef vehicleJourneyRef : vehicleJourneyReves) {\n+              List<FeedScopedId> tripIds = new ArrayList<>();\n+\n+              FeedScopedId tripIdFromVehicleJourney = siriFuzzyTripMatcher.getTripId(\n+                vehicleJourneyRef.getValue()\n+              );\n+\n+              ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime() !=\n+                null\n+                ? affectedVehicleJourney.getOriginAimedDepartureTime()\n+                : ZonedDateTime.now();\n+\n+              ZonedDateTime startOfService = DateMapper.asStartOfService(originAimedDepartureTime);\n+\n+              ServiceDate serviceDate = new ServiceDate(startOfService.toLocalDate());\n+\n+              if (tripIdFromVehicleJourney != null) {\n+                tripIds.add(tripIdFromVehicleJourney);\n+              } else {\n+                tripIds =\n+                  siriFuzzyTripMatcher.getTripIdForInternalPlanningCodeServiceDateAndMode(\n+                    vehicleJourneyRef.getValue(),\n+                    serviceDate,\n+                    TransitMode.RAIL,\n+                    \"railReplacementBus\"\n+                  );\n+              }\n+\n+              for (FeedScopedId tripId : tripIds) {\n+                if (!affectedStops.isEmpty()) {\n+                  for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                      affectedStop.getStopPointRef().getValue()\n+                    );\n+                    if (stop == null) {\n+                      stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n                     }\n+                    // Creating unique, deterministic id for the alert\n+                    alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n \n-                    alert.addEntity(new EntitySelector.Stop(stopId));\n+                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n+                    updateStopConditions(alert, affectedStop.getStopConditions());\n+                  }\n+                } else {\n+                  alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n                 }\n+              }\n             }\n-\n-            AffectsScopeStructure.Networks networks = affectsStructure.getNetworks();\n-            if (networks != null && isNotEmpty(networks.getAffectedNetworks())) {\n-\n-                for (AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork : networks.getAffectedNetworks()) {\n-                    List<AffectedLineStructure> affectedLines = affectedNetwork.getAffectedLines();\n-                    if (isNotEmpty(affectedLines)) {\n-                        for (AffectedLineStructure line : affectedLines) {\n-\n-                            LineRef lineRef = line.getLineRef();\n-\n-                            if (lineRef == null || lineRef.getValue() == null) {\n-                                continue;\n-                            }\n-\n-                            List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n-\n-                            AffectedLineStructure.Routes routes = line.getRoutes();\n-\n-                            // Resolve AffectedStop-ids\n-                            if (routes != null) {\n-                                for (AffectedRouteStructure route : routes.getAffectedRoutes()) {\n-                                    if (route.getStopPoints() != null) {\n-                                        List<Serializable> stopPointsList = route.getStopPoints().getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n-                                        for (Serializable serializable : stopPointsList) {\n-                                            if (serializable instanceof AffectedStopPointStructure) {\n-                                                AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n-                                                affectedStops.add(stopPointStructure);\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            FeedScopedId affectedRoute = new FeedScopedId(feedId, lineRef.getValue());\n-\n-                            if (! affectedStops.isEmpty()) {\n-                                for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n-                                    if (stop == null) {\n-                                        stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n-                                    }\n-                                    alert.addEntity(new EntitySelector.StopAndRoute(stop, affectedRoute));\n-                                    // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                                    updateStopConditions(alert, affectedStop.getStopConditions());\n-                                }\n-                            } else {\n-                                alert.addEntity(new EntitySelector.Route(affectedRoute));\n-                            }\n-                        }\n-                    } else {\n-                        NetworkRefStructure networkRef = affectedNetwork.getNetworkRef();\n-                        if (networkRef == null || networkRef.getValue() == null) {\n-                            continue;\n-                        }\n-                        String networkId = networkRef.getValue();\n-\n-                        // TODO: What to do here?\n-                    }\n+          }\n+\n+          final FramedVehicleJourneyRefStructure framedVehicleJourneyRef = affectedVehicleJourney.getFramedVehicleJourneyRef();\n+          if (framedVehicleJourneyRef != null) {\n+            final DataFrameRefStructure dataFrameRef = framedVehicleJourneyRef.getDataFrameRef();\n+            final String datedVehicleJourneyRef = framedVehicleJourneyRef.getDatedVehicleJourneyRef();\n+\n+            FeedScopedId tripId = siriFuzzyTripMatcher.getTripId(datedVehicleJourneyRef);\n+\n+            if (tripId != null) {\n+              ServiceDate serviceDate = null;\n+              if (dataFrameRef != null && dataFrameRef.getValue() != null) {\n+                ZonedDateTime startOfService = DateMapper.asStartOfService(\n+                  LocalDate.parse(dataFrameRef.getValue()),\n+                  graph.getTimeZone().toZoneId()\n+                );\n+\n+                serviceDate =\n+                  new ServiceDate(\n+                    startOfService.getYear(),\n+                    startOfService.getMonthValue(),\n+                    startOfService.getDayOfMonth()\n+                  );\n+              }\n+\n+              if (!affectedStops.isEmpty()) {\n+                for (AffectedStopPointStructure affectedStop : affectedStops) {\n+                  FeedScopedId stop = siriFuzzyTripMatcher.getStop(\n+                    affectedStop.getStopPointRef().getValue()\n+                  );\n+                  if (stop == null) {\n+                    stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n+                  }\n+\n+                  alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n                 }\n+              } else {\n+                alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n+              }\n             }\n-\n-            AffectsScopeStructure.VehicleJourneys vjs = affectsStructure.getVehicleJourneys();\n-            if (vjs != null && isNotEmpty(vjs.getAffectedVehicleJourneies())) {\n-\n-                for (AffectedVehicleJourneyStructure affectedVehicleJourney : vjs.getAffectedVehicleJourneies()) {\n-\n-                    String lineRef = null;\n-                    if (affectedVehicleJourney.getLineRef() != null) {\n-                        lineRef = affectedVehicleJourney.getLineRef().getValue();\n-                    }\n-\n-                    List<AffectedStopPointStructure> affectedStops = new ArrayList<>();\n-\n-                    List<AffectedRouteStructure> routes = affectedVehicleJourney.getRoutes();\n-                    // Resolve AffectedStop-ids\n-                    if (routes != null) {\n-                        for (AffectedRouteStructure route : routes) {\n-                            if (route.getStopPoints() != null) {\n-                                List<Serializable> stopPointsList = route.getStopPoints().getAffectedStopPointsAndLinkProjectionToNextStopPoints();\n-                                for (Serializable serializable : stopPointsList) {\n-                                    if (serializable instanceof AffectedStopPointStructure) {\n-                                        AffectedStopPointStructure stopPointStructure = (AffectedStopPointStructure) serializable;\n-                                        affectedStops.add(stopPointStructure);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    List<VehicleJourneyRef> vehicleJourneyReves = affectedVehicleJourney.getVehicleJourneyReves();\n-\n-                    if (isNotEmpty(vehicleJourneyReves)) {\n-                        for (VehicleJourneyRef vehicleJourneyRef : vehicleJourneyReves) {\n-\n-                            List<FeedScopedId> tripIds = new ArrayList<>();\n-\n-                            FeedScopedId tripIdFromVehicleJourney = siriFuzzyTripMatcher.getTripId(vehicleJourneyRef.getValue());\n-\n-                            ZonedDateTime originAimedDepartureTime = affectedVehicleJourney.getOriginAimedDepartureTime();\n-\n-                            ServiceDate serviceDate = null;\n-                            if (originAimedDepartureTime != null) {\n-                                serviceDate = new ServiceDate(DateMapper.asStartOfService(originAimedDepartureTime)\n-                                    .toLocalDate());\n-                            }\n-\n-                            if (tripIdFromVehicleJourney != null) {\n-\n-                                tripIds.add(tripIdFromVehicleJourney);\n-\n-                            } else {\n-\n-//                                Commented out for now\n-//\n-//                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n-//                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n-//                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n-                            }\n-\n-                            for (FeedScopedId tripId : tripIds) {\n-\n-                                if (! affectedStops.isEmpty()) {\n-                                    for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                        FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop.getStopPointRef().getValue());\n-                                        if (stop == null) {\n-                                            stop = new FeedScopedId(feedId, affectedStop.getStopPointRef().getValue());\n-                                        }\n-                                        // Creating unique, deterministic id for the alert\n-                                        alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n-\n-                                        // TODO: is this correct? Should the stop conditions be in the entity selector?\n-                                        updateStopConditions(alert, affectedStop.getStopConditions());\n-\n-                                    }\n-                                } else {\n-                                    alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n-\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    final FramedVehicleJourneyRefStructure framedVehicleJourneyRef = affectedVehicleJourney.getFramedVehicleJourneyRef();\n-                    if (framedVehicleJourneyRef != null) {\n-                        final DataFrameRefStructure dataFrameRef = framedVehicleJourneyRef.getDataFrameRef();\n-                        final String datedVehicleJourneyRef = framedVehicleJourneyRef.getDatedVehicleJourneyRef();\n-\n-                        FeedScopedId tripId = siriFuzzyTripMatcher.getTripId(datedVehicleJourneyRef);\n-\n-                        if (tripId != null) {\n-                            ServiceDate serviceDate = null;\n-                            if (dataFrameRef != null && dataFrameRef.getValue() != null) {\n-                                ZonedDateTime startOfService = DateMapper.asStartOfService(LocalDate.parse(\n-                                    dataFrameRef.getValue()), graph.getTimeZone().toZoneId());\n-\n-                                serviceDate = new ServiceDate(startOfService.getYear(),\n-                                    startOfService.getMonthValue(),\n-                                    startOfService.getDayOfMonth()\n-                                );\n-\n-                            }\n-\n-                            if (!affectedStops.isEmpty()) {\n-                                for (AffectedStopPointStructure affectedStop : affectedStops) {\n-                                    FeedScopedId stop = siriFuzzyTripMatcher.getStop(affectedStop\n-                                        .getStopPointRef()\n-                                        .getValue());\n-                                    if (stop == null) {\n-                                        stop = new FeedScopedId(feedId,\n-                                            affectedStop.getStopPointRef().getValue()\n-                                        );\n-                                    }\n-\n-                                    alert.addEntity(new EntitySelector.StopAndTrip(stop, tripId, serviceDate));\n-                                }\n-                            }\n-                            else {\n-                                alert.addEntity(new EntitySelector.Trip(tripId, serviceDate));\n-                            }\n-                        }\n-                    }\n-\n-                    if (lineRef != null) {\n-\n-                        Set<Route> affectedRoutes = siriFuzzyTripMatcher.getRoutes(lineRef);\n-                        if (affectedRoutes != null) {\n-                            for (Route route : affectedRoutes) {\n-                                alert.addEntity(new EntitySelector.Route(route.getId()));\n-                            }\n-                        }\n-                    }\n-                }\n+          }\n+\n+          if (lineRef != null) {\n+            Set<Route> affectedRoutes = siriFuzzyTripMatcher.getRoutes(lineRef);\n+            if (affectedRoutes != null) {\n+              for (Route route : affectedRoutes) {\n+                alert.addEntity(new EntitySelector.Route(route.getId()));\n+              }\n             }\n+          }\n         }\n-\n-        if (alert.getStopConditions().isEmpty()) {\n-            updateStopConditions(alert, null);\n-        }\n-\n-        alert.alertType = situation.getReportType();\n-\n-        if (situation.getSeverity() != null) {\n-            alert.severity = situation.getSeverity().value();\n-        } else {\n-            // When severity is not set - use default\n-            alert.severity = SeverityEnumeration.NORMAL.value();\n-        }\n-\n-        if (situation.getParticipantRef() != null) {\n-            String codespace = situation.getParticipantRef().getValue();\n-            alert.setFeedId(codespace + \":Authority:\" + codespace); //TODO - SIRI: Should probably not assume this codespace -> authority rule\n-        }\n-\n-        return alert;\n+      }\n     }\n \n-    private long getEpochSecond(ZonedDateTime startTime) {\n-        return startTime.toEpochSecond();\n+    if (alert.getStopConditions().isEmpty()) {\n+      updateStopConditions(alert, null);\n     }\n \n+    alert.alertType = situation.getReportType();\n \n-    /*\n-     * Creates alert from PtSituation with all textual content\n-     */\n-    private TransitAlert createAlertWithTexts(PtSituationElement situation) {\n-        TransitAlert alert = new TransitAlert();\n-\n-        alert.alertDescriptionText = getTranslatedString(situation.getDescriptions());\n-        alert.alertDetailText = getTranslatedString(situation.getDetails());\n-        alert.alertAdviceText = getTranslatedString(situation.getAdvices());\n-        alert.alertHeaderText = getTranslatedString(situation.getSummaries());\n-        alert.alertUrl = getInfoLinkAsString(situation.getInfoLinks());\n-        alert.setAlertUrlList(getInfoLinks(situation.getInfoLinks()));\n+    alert.severity = SiriSeverityMapper.getAlertSeverityForSiriSeverity(situation.getSeverity());\n \n-        return alert;\n+    if (situation.getParticipantRef() != null) {\n+      String codespace = situation.getParticipantRef().getValue();\n+      alert.setFeedId(codespace + \":Authority:\" + codespace); //TODO - SIRI: Should probably not assume this codespace -> authority rule\n     }\n \n-    /*\n-     * Returns first InfoLink-uri as a String\n-     */\n-    private I18NString getInfoLinkAsString(PtSituationElement.InfoLinks infoLinks) {\n-        if (infoLinks != null) {\n-            if (isNotEmpty(infoLinks.getInfoLinks())) {\n-                InfoLinkStructure infoLinkStructure = infoLinks.getInfoLinks().get(0);\n-                if (infoLinkStructure != null && infoLinkStructure.getUri() != null) {\n-                    return new NonLocalizedString(infoLinkStructure.getUri());\n-                }\n-            }\n+    return alert;\n+  }\n+\n+  private long getEpochSecond(ZonedDateTime startTime) {\n+    return startTime.toEpochSecond();\n+  }\n+\n+  /*\n+   * Creates alert from PtSituation with all textual content\n+   */\n+  private TransitAlert createAlertWithTexts(PtSituationElement situation) {\n+    TransitAlert alert = new TransitAlert();\n+\n+    alert.alertDescriptionText = getTranslatedString(situation.getDescriptions());\n+    alert.alertDetailText = getTranslatedString(situation.getDetails());\n+    alert.alertAdviceText = getTranslatedString(situation.getAdvices());\n+    alert.alertHeaderText = getTranslatedString(situation.getSummaries());\n+    alert.alertUrl = getInfoLinkAsString(situation.getInfoLinks());\n+    alert.setAlertUrlList(getInfoLinks(situation.getInfoLinks()));\n+\n+    return alert;\n+  }\n+\n+  /*\n+   * Returns first InfoLink-uri as a String\n+   */\n+  private I18NString getInfoLinkAsString(PtSituationElement.InfoLinks infoLinks) {\n+    if (infoLinks != null) {\n+      if (isNotEmpty(infoLinks.getInfoLinks())) {\n+        InfoLinkStructure infoLinkStructure = infoLinks.getInfoLinks().get(0);\n+        if (infoLinkStructure != null && infoLinkStructure.getUri() != null) {\n+          return new NonLocalizedString(infoLinkStructure.getUri());\n         }\n-        return null;\n+      }\n     }\n-\n-    /*\n-     * Returns all InfoLinks\n-     */\n-    private List<AlertUrl> getInfoLinks(PtSituationElement.InfoLinks infoLinks) {\n-        List<AlertUrl> alertUrls = new ArrayList<>();\n-        if (infoLinks != null) {\n-            if (isNotEmpty(infoLinks.getInfoLinks())) {\n-                for (InfoLinkStructure infoLink : infoLinks.getInfoLinks()) {\n-                    AlertUrl alertUrl = new AlertUrl();\n-\n-                    List<NaturalLanguageStringStructure> labels = infoLink.getLabels();\n-                    if (labels != null && !labels.isEmpty()) {\n-                        NaturalLanguageStringStructure label = labels.get(0);\n-                        alertUrl.label = label.getValue();\n-                    }\n-\n-                    alertUrl.uri = infoLink.getUri();\n-                    alertUrls.add(alertUrl);\n-                }\n-            }\n+    return null;\n+  }\n+\n+  /*\n+   * Returns all InfoLinks\n+   */\n+  private List<AlertUrl> getInfoLinks(PtSituationElement.InfoLinks infoLinks) {\n+    List<AlertUrl> alertUrls = new ArrayList<>();\n+    if (infoLinks != null) {\n+      if (isNotEmpty(infoLinks.getInfoLinks())) {\n+        for (InfoLinkStructure infoLink : infoLinks.getInfoLinks()) {\n+          AlertUrl alertUrl = new AlertUrl();\n+\n+          List<NaturalLanguageStringStructure> labels = infoLink.getLabels();\n+          if (labels != null && !labels.isEmpty()) {\n+            NaturalLanguageStringStructure label = labels.get(0);\n+            alertUrl.label = label.getValue();\n+          }\n+\n+          alertUrl.uri = infoLink.getUri();\n+          alertUrls.add(alertUrl);\n         }\n-        return alertUrls;\n+      }\n     }\n-\n-    private void updateStopConditions(TransitAlert alertPatch, List<RoutePointTypeEnumeration> stopConditions) {\n-        Set<StopCondition> alertStopConditions = new HashSet<>();\n-        if (stopConditions != null) {\n-            for (RoutePointTypeEnumeration stopCondition : stopConditions) {\n-                switch (stopCondition) {\n-                    case EXCEPTIONAL_STOP:\n-                        alertStopConditions.add(StopCondition.EXCEPTIONAL_STOP);\n-                        break;\n-                    case DESTINATION:\n-                        alertStopConditions.add(StopCondition.DESTINATION);\n-                        break;\n-                    case NOT_STOPPING:\n-                        alertStopConditions.add(StopCondition.NOT_STOPPING);\n-                        break;\n-                    case REQUEST_STOP:\n-                        alertStopConditions.add(StopCondition.REQUEST_STOP);\n-                        break;\n-                    case START_POINT:\n-                        alertStopConditions.add(StopCondition.START_POINT);\n-                        break;\n-                }\n-            }\n-        }\n-        if (alertStopConditions.isEmpty()) {\n-            //No StopConditions are set - set default\n-            alertStopConditions.add(StopCondition.START_POINT);\n+    return alertUrls;\n+  }\n+\n+  private void updateStopConditions(\n+    TransitAlert alertPatch,\n+    List<RoutePointTypeEnumeration> stopConditions\n+  ) {\n+    Set<StopCondition> alertStopConditions = new HashSet<>();\n+    if (stopConditions != null) {\n+      for (RoutePointTypeEnumeration stopCondition : stopConditions) {\n+        switch (stopCondition) {\n+          case EXCEPTIONAL_STOP:\n+            alertStopConditions.add(StopCondition.EXCEPTIONAL_STOP);\n+            break;\n+          case DESTINATION:\n             alertStopConditions.add(StopCondition.DESTINATION);\n-\n+            break;\n+          case NOT_STOPPING:\n+            alertStopConditions.add(StopCondition.NOT_STOPPING);\n+            break;\n+          case REQUEST_STOP:\n+            alertStopConditions.add(StopCondition.REQUEST_STOP);\n+            break;\n+          case START_POINT:\n+            alertStopConditions.add(StopCondition.START_POINT);\n+            break;\n         }\n-        alertPatch.getStopConditions().addAll(alertStopConditions);\n+      }\n     }\n-\n-\n-    /**\n-     * @return True if list have at least one element. {@code false} is returned if the given list\n-     * is empty or {@code null}.\n-     */\n-    private boolean isNotEmpty(List<?> list) {\n-        return list != null && !list.isEmpty();\n+    if (alertStopConditions.isEmpty()) {\n+      //No StopConditions are set - set default\n+      alertStopConditions.add(StopCondition.START_POINT);\n+      alertStopConditions.add(StopCondition.DESTINATION);\n     }\n-\n-    /**\n-     * convert a SIRI DefaultedTextStructure to a OTP TranslatedString\n-     *\n-     * @return A TranslatedString containing the same information as the input\n-     */\n-    private I18NString getTranslatedString(List<DefaultedTextStructure> input) {\n-        Map<String, String> translations = new HashMap<>();\n-        if (input != null && input.size() > 0) {\n-            for (DefaultedTextStructure textStructure : input) {\n-                String language = \"\";\n-                String value = \"\";\n-                if (textStructure.getLang() != null) {\n-                    language = textStructure.getLang();\n-                }\n-                if (textStructure.getValue() != null) {\n-                    value = textStructure.getValue();\n-                }\n-                translations.put(language, value);\n-            }\n-        } else {\n-            translations.put(\"\", \"\");\n+    alertPatch.getStopConditions().addAll(alertStopConditions);\n+  }\n+\n+  /**\n+   * @return True if list have at least one element. {@code false} is returned if the given list\n+   * is empty or {@code null}.\n+   */\n+  private boolean isNotEmpty(List<?> list) {\n+    return list != null && !list.isEmpty();\n+  }\n+\n+  /**\n+   * convert a SIRI DefaultedTextStructure to a OTP TranslatedString\n+   *\n+   * @return A TranslatedString containing the same information as the input\n+   */\n+  private I18NString getTranslatedString(List<DefaultedTextStructure> input) {\n+    Map<String, String> translations = new HashMap<>();\n+    if (input != null && input.size() > 0) {\n+      for (DefaultedTextStructure textStructure : input) {\n+        String language = \"\";\n+        String value = \"\";\n+        if (textStructure.getLang() != null) {\n+          language = textStructure.getLang();\n         }\n-\n-        return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+        if (textStructure.getValue() != null) {\n+          value = textStructure.getValue();\n+        }\n+        translations.put(language, value);\n+      }\n+    } else {\n+      translations.put(\"\", \"\");\n     }\n \n-    public void setTransitAlertService(TransitAlertService transitAlertService) {\n-        this.transitAlertService = transitAlertService;\n-    }\n+    return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+  }\n \n-    public long getEarlyStart() {\n-        return earlyStart;\n-    }\n+  public void setTransitAlertService(TransitAlertService transitAlertService) {\n+    this.transitAlertService = transitAlertService;\n+  }\n \n-    public void setEarlyStart(long earlyStart) {\n-        this.earlyStart = earlyStart;\n-    }\n+  public long getEarlyStart() {\n+    return earlyStart;\n+  }\n \n-    public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n-        this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n-    }\n+  public void setEarlyStart(long earlyStart) {\n+    this.earlyStart = earlyStart;\n+  }\n+\n+  public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n+    this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex d9532ff71b..9846986b04 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -570,20 +580,4 @@ public class SiriAlertsUpdateHandler {\n \n     return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n   }\n-\n-  public void setTransitAlertService(TransitAlertService transitAlertService) {\n-    this.transitAlertService = transitAlertService;\n-  }\n-\n-  public long getEarlyStart() {\n-    return earlyStart;\n-  }\n-\n-  public void setEarlyStart(long earlyStart) {\n-    this.earlyStart = earlyStart;\n-  }\n-\n-  public void setSiriFuzzyTripMatcher(SiriFuzzyTripMatcher siriFuzzyTripMatcher) {\n-    this.siriFuzzyTripMatcher = siriFuzzyTripMatcher;\n-  }\n }\n", "next_change": {"commit": "c7c3ccb43478aca72b92e413c5698b346261ae04", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\nindex 9846986b04..e4dedf3ac8 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java\n", "chunk": "@@ -578,6 +588,8 @@ public class SiriAlertsUpdateHandler {\n       translations.put(\"\", \"\");\n     }\n \n-    return translations.isEmpty() ? null : TranslatedString.getI18NString(translations);\n+    return translations.isEmpty()\n+      ? null\n+      : TranslatedString.getI18NString(translations, false, true);\n   }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "a534ac2546944ec6921f2131ced5d9325e5dd2dd", "committedDate": "2020-11-12 12:10:31 +0100", "message": "Taking graph timezone into account when calculating alert validity"}, {"oid": "c2059b3587aea1f566fd628a4aba8b18d673c72d", "committedDate": "2021-01-07 12:21:44 +0100", "message": "Adding constant to indicate open-ended validity"}, {"oid": "ce50530270499592c782f624a7d0da5f4887c445", "committedDate": "2021-01-08 15:41:01 +0100", "message": "Adding checks for NPE for when fuzzymatching is unsuccessful"}, {"oid": "9636fd319216349950a5e79d4f293d713921f02c", "committedDate": "2021-01-14 11:09:23 +0100", "message": "Merge pull request #3306 from entur/otp2_fix_validity_for_open_ended_alerts"}, {"oid": "f5c9762fe7366e40cb2f8c8c8029c2a146e4c5c5", "committedDate": "2021-07-28 14:36:00 +0200", "message": "Alerts tagged on trip for specific dates now rely on ServiceDate, not generated validity"}, {"oid": "a227ff212df1c0f808615b33e3da3e20210903eb", "committedDate": "2021-11-13 22:18:57 +0200", "message": "Refactor transit alert's severity"}, {"oid": "9b8bb16f5baf831ad256710b9ba4010f3ce1dfc3", "committedDate": "2021-11-30 16:49:00 +0200", "message": "Include alerts with no or unhandled entities"}, {"oid": "3fb6009bbe39ca7ae88f62db8a178dd40e35c982", "committedDate": "2021-11-30 16:49:00 +0200", "message": "Refactor Unknown selector to include description"}, {"oid": "daa133377a80aa5f1a12a78fccae2aa2088c4b3f", "committedDate": "2021-12-13 16:55:55 +0200", "message": "Don't always add Unknown entity to siri alerts and update tests"}, {"oid": "1d2a5714c482158d08681551bc09f5fc3b94c69b", "committedDate": "2021-12-17 16:03:13 +0200", "message": "Added fuzzy-matching of privateCode/date to trip for trips of type rail/railReplacementBus"}, {"oid": "a0472211d2b8b18ba573826ee3cd670e3388229d", "committedDate": "2022-01-18 12:55:06 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into alert-entity-updates"}, {"oid": "7ee3df5e8f00cd39608ebf34a1591c0478fb05ea", "committedDate": "2022-02-21 17:36:10 +0100", "message": "Reanme package `raptor` to `raptoradapter`"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "a07385a8c278ab90542a0d9e65f7e74544ddca1b", "committedDate": "2022-04-11 16:18:19 +0200", "message": "Allow single SIRI-situations to fail without affecting others"}, {"oid": "f3c35edfbf006a84f76729d231ba79ca5fd10535", "committedDate": "2022-04-12 15:27:18 +0200", "message": "Removed feedId loops"}, {"oid": "330d95618b9bba6dd9ba8f98e768833593b84ca5", "committedDate": "2022-04-12 17:52:24 +0300", "message": "Merge pull request #4075 from opentripplanner/DSJ_siri_matcher"}, {"oid": "c7c3ccb43478aca72b92e413c5698b346261ae04", "committedDate": "2022-04-26 15:25:35 +0300", "message": "Preserve language in SIRI/GTFS-RT alert messages"}, {"oid": "1b6191d04db34a43e7303a625a8e796c6638e649", "committedDate": "2022-05-06 16:16:47 +0200", "message": "Solve bug in SiriAlertsUpdateHandler [changelog skip] (#4144)"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "fa8a6b88525379e17830d4d539882ff449a3dfcb", "committedDate": "2022-05-12 15:06:09 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_transit_model"}, {"oid": "5b2c4d18588bdf5a7de7d93418e0b3ebc68279a6", "committedDate": "2022-05-19 18:22:44 +0200", "message": "refactor: Move BikeAccess, GroupOfRoutes, Route and TransitMode"}, {"oid": "87e177d3c84fe4e2d526fdc7cc342861585070bb", "committedDate": "2022-06-01 15:14:17 +0200", "message": "@WIP: Moving StopConditions from TransitAlert to EntitySelector"}, {"oid": "f8f232ad48ed87efd67d9bc7ea528b7f04c2a76a", "committedDate": "2022-06-02 14:20:02 +0200", "message": "feature: Make SubMode a type"}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "287283d19dcb8be174a9e88a954b5af67df6a44d", "committedDate": "2022-06-16 12:34:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "committedDate": "2022-06-30 14:00:01 +0300", "message": "Convert java.util to java.time classes"}, {"oid": "104c707a268e954ea21e61645ce2f93b6c1acadc", "committedDate": "2022-07-05 17:40:24 +0300", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_convert_legacy_times"}, {"oid": "d88723210fe6ecc4d8619b5424528334980319ad", "committedDate": "2022-07-06 14:57:50 +0300", "message": "Move and rename DateMapper as ServiceDateUtils"}, {"oid": "95ebdf26498025f5cb470f3cb7360135538e9ee6", "committedDate": "2022-07-06 15:08:13 +0300", "message": "Convert Alerts to use LocalDate"}, {"oid": "3b4316833886ff242325e031fa13264850b5317e", "committedDate": "2022-07-19 15:48:45 +0200", "message": "refactor: Move Transit- and Sub- Mode to basic"}, {"oid": "cac1ac6444918c6d21045a934c58844eb089b0f4", "committedDate": "2022-07-19 17:13:25 +0200", "message": "refactor: Move I18NString classes to transit model."}, {"oid": "6d466b74a304f7798a2203d92f510ff4254cdc90", "committedDate": "2022-07-28 09:53:32 +0200", "message": "Explicitly pass feedId to SiriFuzzyTripMatcher instead of guessing"}, {"oid": "92a463205ffbc01ef7a7bdea1591f06a34d95691", "committedDate": "2022-10-03 16:03:57 +0300", "message": "Make SiriAlertsUpdateHandler work without a SiriFuzzyTripMatcher"}, {"oid": "54febd2708c2a263e6b2241c42ce70ec017da9d8", "committedDate": "2022-10-21 13:30:15 +0200", "message": "Merge branch 'dev-2.x' into refactor_siri_stopconditions"}, {"oid": "72801c7aa875a39447fa1debd542be46c8474617", "committedDate": "2022-10-25 21:50:50 +0300", "message": "Extract separate EntityKey"}, {"oid": "2bb2a351b493721b06a48223e83ea2f9c5d9e04d", "committedDate": "2022-11-04 14:16:22 +0200", "message": "Merge remote-tracking branch 'origin/dev-2.x' into refactor_siri_stopconditions"}, {"oid": "07b4cd665feb524df0d8e788a17e9816bada6eb5", "committedDate": "2022-11-07 11:16:10 +0200", "message": "Simplify SiriFuzzyTripMatcher"}, {"oid": "dedae413ca350bb4e8ca722f5b07cd7269aefb4f", "committedDate": "2022-11-23 16:41:16 +0100", "message": "refactor: Move o.o.util.time to o.o.framework.time"}, {"oid": "c03463d753720a62874b7e5ab14a0ad4a2906150", "committedDate": "2022-12-07 17:54:25 +0200", "message": "Move I18NString to new framework package"}, {"oid": "afd02a7e74cf1d7795756815fa1520247a2992be", "committedDate": "2023-01-20 11:18:14 +0200", "message": "refactor: Make TransitAlert a TransitEntity"}, {"oid": "c4438abf9b9cb005e221114b2a10991864c9ff83", "committedDate": "2023-01-20 13:21:57 +0200", "message": "feat: read created and updated time and codespace from SIRI message"}, {"oid": "f8ea03240f72d884d73c53ddb348cf194d77f42a", "committedDate": "2023-01-20 15:28:55 +0200", "message": "Extract AffectsMapper"}, {"oid": "87dbd091b87b19c6f02778f9974c9606c992939f", "committedDate": "2023-02-22 11:53:56 +0200", "message": "Move mappers to own package"}, {"oid": "5900d238481b6b0674a4e55d3eb89ba0a8abb104", "committedDate": "2023-06-06 16:07:28 +0200", "message": "refactor: Apply code review"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNTc0Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487835747", "body": "Below on line 227:\r\n```\r\nif (tripPattern != null &&\r\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\r\n```\r\nthe `tripPattern.getMode()` return type is `TransitMode`, not `TraverseMode` so the if branch is never entered.", "bodyText": "Below on line 227:\nif (tripPattern != null &&\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\n\nthe tripPattern.getMode() return type is TransitMode, not TraverseMode so the if branch is never entered.", "bodyHTML": "<p dir=\"auto\">Below on line 227:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (tripPattern != null &amp;&amp;\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\"><pre><code>if (tripPattern != null &amp;&amp;\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\n</code></pre></div>\n<p dir=\"auto\">the <code>tripPattern.getMode()</code> return type is <code>TransitMode</code>, not <code>TraverseMode</code> so the if branch is never entered.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:18:30Z", "path": "src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java", "diffHunk": "@@ -129,12 +131,27 @@ private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n             }\n         }\n         if (trips == null || trips.isEmpty()) {\n-            List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n-            EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n \n-            String lastStopPoint = lastStop.getStopPointRef().getValue();\n+            String lastStopPoint = null;\n+            ZonedDateTime arrivalTime = null;\n \n-            ZonedDateTime arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            if (journey.getEstimatedCalls() != null && journey.getEstimatedCalls().getEstimatedCalls() != null\n+                    && !journey.getEstimatedCalls().getEstimatedCalls().isEmpty()) { // Pick last stop from EstimatedCalls\n+                List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n+                EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+\n+            } else if (journey.getRecordedCalls() != null && journey.getRecordedCalls().getRecordedCalls() != null\n+                    && !journey.getRecordedCalls().getRecordedCalls().isEmpty()) { // No EstimatedCalls exist - pick last RecordedCall\n+\n+                List<RecordedCall> recordedCalls = journey.getRecordedCalls().getRecordedCalls();\n+                final RecordedCall lastStop = recordedCalls.get(recordedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\nindex 0a23ecf8d8..250cb31098 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n", "chunk": "@@ -42,343 +39,405 @@ import java.util.Set;\n  * contribution we are maintaining this implementation.\n  */\n public class SiriFuzzyTripMatcher {\n-    private static final Logger LOG = LoggerFactory.getLogger(SiriFuzzyTripMatcher.class);\n-\n-    private RoutingService routingService;\n-\n-    private static Map<String, Set<Trip>> mappedTripsCache = new HashMap<>();\n-    private static Map<String, Set<Trip>> mappedVehicleRefCache = new HashMap<>();\n-    private static Map<String, Set<Route>> mappedRoutesCache = new HashMap<>();\n-    private static Map<String, Set<Trip>> start_stop_tripCache = new HashMap<>();\n-\n-    private static Map<String, Trip> vehicleJourneyTripCache = new HashMap<>();\n-\n-    private static Set<String> nonExistingStops = new HashSet<>();\n-\n-    public SiriFuzzyTripMatcher(RoutingService routingService) {\n-        this.routingService = routingService;\n-        initCache(this.routingService);\n-    }\n \n-    /**\n-     * Matches VehicleActivity to a set of possible Trips based on tripId\n-     */\n-    public Set<Trip> match(VehicleActivityStructure activity) {\n-        VehicleActivityStructure.MonitoredVehicleJourney monitoredVehicleJourney = activity.getMonitoredVehicleJourney();\n-        Set<Trip> trips = new HashSet<>();\n-        if (monitoredVehicleJourney != null) {\n-\n-            String datedVehicleRef = null;\n-            if (monitoredVehicleJourney.getFramedVehicleJourneyRef() != null) {\n-                datedVehicleRef = monitoredVehicleJourney.getFramedVehicleJourneyRef().getDatedVehicleJourneyRef();\n-                if (datedVehicleRef != null) {\n-                    trips = mappedTripsCache.get(datedVehicleRef);\n-                }\n-            }\n-            if (monitoredVehicleJourney.getDestinationRef() != null) {\n-\n-                String destinationRef = monitoredVehicleJourney.getDestinationRef().getValue();\n-                ZonedDateTime arrivalTime = monitoredVehicleJourney.getDestinationAimedArrivalTime();\n-\n-                if (arrivalTime != null) {\n-                    trips = getMatchingTripsOnStopOrSiblings(destinationRef, arrivalTime);\n-                }\n-            }\n+  private static final Logger LOG = LoggerFactory.getLogger(SiriFuzzyTripMatcher.class);\n+\n+  private final RoutingService routingService;\n+\n+  private static final Map<String, Set<Trip>> mappedTripsCache = new HashMap<>();\n+  private static final Map<String, Set<Trip>> mappedVehicleRefCache = new HashMap<>();\n+  private static final Map<String, Set<Route>> mappedRoutesCache = new HashMap<>();\n+  private static final Map<String, Set<Trip>> start_stop_tripCache = new HashMap<>();\n+\n+  private static final Map<String, Trip> vehicleJourneyTripCache = new HashMap<>();\n+\n+  private static final Set<String> nonExistingStops = new HashSet<>();\n+\n+  public SiriFuzzyTripMatcher(RoutingService routingService) {\n+    this.routingService = routingService;\n+    initCache(this.routingService);\n+  }\n+\n+  /**\n+   * Matches VehicleActivity to a set of possible Trips based on tripId\n+   */\n+  public Set<Trip> match(VehicleActivityStructure activity) {\n+    VehicleActivityStructure.MonitoredVehicleJourney monitoredVehicleJourney = activity.getMonitoredVehicleJourney();\n+    Set<Trip> trips = new HashSet<>();\n+    if (monitoredVehicleJourney != null) {\n+      String datedVehicleRef = null;\n+      if (monitoredVehicleJourney.getFramedVehicleJourneyRef() != null) {\n+        datedVehicleRef =\n+          monitoredVehicleJourney.getFramedVehicleJourneyRef().getDatedVehicleJourneyRef();\n+        if (datedVehicleRef != null) {\n+          trips = mappedTripsCache.get(datedVehicleRef);\n         }\n+      }\n+      if (monitoredVehicleJourney.getDestinationRef() != null) {\n+        String destinationRef = monitoredVehicleJourney.getDestinationRef().getValue();\n+        ZonedDateTime arrivalTime = monitoredVehicleJourney.getDestinationAimedArrivalTime();\n \n-        return trips;\n-    }\n-\n-    Trip findTripByDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n-        String serviceJourneyId = resolveDatedVehicleJourneyRef(journey);\n-        if (serviceJourneyId != null) {\n-            for (String feedId : routingService.getFeedIds()) {\n-                Trip trip = routingService\n-                    .getTripForId().get(new FeedScopedId(feedId, serviceJourneyId));\n-                if (trip != null) {\n-                    return trip;\n-                }\n-            }\n+        if (arrivalTime != null) {\n+          trips = getMatchingTripsOnStopOrSiblings(destinationRef, arrivalTime);\n         }\n-        return null;\n+      }\n     }\n \n-    private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n+    return trips;\n+  }\n \n-        if (journey.getFramedVehicleJourneyRef() != null) {\n-            return journey.getFramedVehicleJourneyRef().getDatedVehicleJourneyRef();\n-        } else if (journey.getDatedVehicleJourneyRef() != null) {\n-            return journey.getDatedVehicleJourneyRef().getValue();\n+  Trip findTripByDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n+    String serviceJourneyId = resolveDatedVehicleJourneyRef(journey);\n+    if (serviceJourneyId != null) {\n+      for (String feedId : routingService.getFeedIds()) {\n+        Trip trip = routingService.getTripForId().get(new FeedScopedId(feedId, serviceJourneyId));\n+        if (trip != null) {\n+          return trip;\n         }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n+    if (journey.getFramedVehicleJourneyRef() != null) {\n+      return journey.getFramedVehicleJourneyRef().getDatedVehicleJourneyRef();\n+    } else if (journey.getDatedVehicleJourneyRef() != null) {\n+      return journey.getDatedVehicleJourneyRef().getValue();\n+    }\n \n-        return null;\n+    return null;\n+  }\n+\n+  /**\n+   * Matches EstimatedVehicleJourney to a set of possible Trips based on tripId\n+   */\n+  public Set<Trip> match(EstimatedVehicleJourney journey) {\n+    Set<Trip> trips = null;\n+    if (\n+      journey.getVehicleRef() != null &&\n+      (\n+        journey.getVehicleModes() != null &&\n+        journey.getVehicleModes().contains(VehicleModesEnumeration.RAIL)\n+      )\n+    ) {\n+      trips = getCachedTripsByVehicleRef(journey.getVehicleRef().getValue());\n     }\n \n-    /**\n-     * Matches EstimatedVehicleJourney to a set of possible Trips based on tripId\n-     */\n-    public Set<Trip> match(EstimatedVehicleJourney journey) {\n-        Set<Trip> trips = null;\n-        if (journey.getVehicleRef() != null &&\n-                (journey.getVehicleModes() != null && journey.getVehicleModes().contains(VehicleModesEnumeration.RAIL))) {\n-            trips = getCachedTripsByVehicleRef(journey.getVehicleRef().getValue());\n-        }\n+    if (trips == null || trips.isEmpty()) {\n+      String serviceJourneyId = resolveDatedVehicleJourneyRef(journey);\n+      if (serviceJourneyId != null) {\n+        trips = getCachedTripsBySiriId(serviceJourneyId);\n+      }\n+    }\n+    if (trips == null || trips.isEmpty()) {\n+      String lastStopPoint = null;\n+      ZonedDateTime arrivalTime = null;\n+\n+      if (\n+        journey.getEstimatedCalls() != null &&\n+        journey.getEstimatedCalls().getEstimatedCalls() != null &&\n+        !journey.getEstimatedCalls().getEstimatedCalls().isEmpty()\n+      ) { // Pick last stop from EstimatedCalls\n+        List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n+        EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n+\n+        lastStopPoint = lastStop.getStopPointRef().getValue();\n+        arrivalTime =\n+          lastStop.getAimedArrivalTime() != null\n+            ? lastStop.getAimedArrivalTime()\n+            : lastStop.getAimedDepartureTime();\n+      } else if (\n+        journey.getRecordedCalls() != null &&\n+        journey.getRecordedCalls().getRecordedCalls() != null &&\n+        !journey.getRecordedCalls().getRecordedCalls().isEmpty()\n+      ) { // No EstimatedCalls exist - pick last RecordedCall\n+        List<RecordedCall> recordedCalls = journey.getRecordedCalls().getRecordedCalls();\n+        final RecordedCall lastStop = recordedCalls.get(recordedCalls.size() - 1);\n+\n+        lastStopPoint = lastStop.getStopPointRef().getValue();\n+        arrivalTime =\n+          lastStop.getAimedArrivalTime() != null\n+            ? lastStop.getAimedArrivalTime()\n+            : lastStop.getAimedDepartureTime();\n+      }\n+\n+      if (arrivalTime != null) {\n+        trips = getMatchingTripsOnStopOrSiblings(lastStopPoint, arrivalTime);\n+      }\n+    }\n+    return trips;\n+  }\n+\n+  private Set<Trip> getMatchingTripsOnStopOrSiblings(\n+    String lastStopPoint,\n+    ZonedDateTime arrivalTime\n+  ) {\n+    int secondsSinceMidnight = DateMapper.secondsSinceStartOfService(\n+      arrivalTime,\n+      arrivalTime,\n+      routingService.getTimeZone().toZoneId()\n+    );\n+    int secondsSinceMidnightYesterday = DateMapper.secondsSinceStartOfService(\n+      arrivalTime.minusDays(1),\n+      arrivalTime,\n+      routingService.getTimeZone().toZoneId()\n+    );\n+\n+    Set<Trip> trips = start_stop_tripCache.get(\n+      createStartStopKey(lastStopPoint, secondsSinceMidnight)\n+    );\n+    if (trips == null) {\n+      //Attempt to fetch trips that started yesterday - i.e. add 24 hours to arrival-time\n+      trips =\n+        start_stop_tripCache.get(createStartStopKey(lastStopPoint, secondsSinceMidnightYesterday));\n+    }\n \n-        if (trips == null || trips.isEmpty()) {\n-            String serviceJourneyId = resolveDatedVehicleJourneyRef(journey);\n-            if (serviceJourneyId != null) {\n-                trips = getCachedTripsBySiriId(serviceJourneyId);\n+    if (trips == null || trips.isEmpty()) {\n+      //SIRI-data may report other platform, but still on the same Parent-stop\n+      String feedId = routingService.getFeedIds().iterator().next();\n+      var stop = routingService.getStopForId(new FeedScopedId(feedId, lastStopPoint));\n+      if (stop != null && stop.isPartOfStation()) {\n+        // TODO OTP2 resolve stop-station split\n+        var allQuays = stop.getParentStation().getChildStops();\n+        for (var quay : allQuays) {\n+          Set<Trip> tripSet = start_stop_tripCache.get(\n+            createStartStopKey(quay.getId().getId(), secondsSinceMidnight)\n+          );\n+          if (tripSet != null) {\n+            if (trips == null) {\n+              trips = tripSet;\n+            } else {\n+              trips.addAll(tripSet);\n             }\n+          }\n         }\n-        if (trips == null || trips.isEmpty()) {\n-\n-            String lastStopPoint = null;\n-            ZonedDateTime arrivalTime = null;\n+      }\n+    }\n+    return trips;\n+  }\n \n-            if (journey.getEstimatedCalls() != null && journey.getEstimatedCalls().getEstimatedCalls() != null\n-                    && !journey.getEstimatedCalls().getEstimatedCalls().isEmpty()) { // Pick last stop from EstimatedCalls\n-                List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n-                EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n+  private Set<Trip> getCachedTripsByVehicleRef(String vehicleRef) {\n+    if (vehicleRef == null) {\n+      return null;\n+    }\n+    return mappedVehicleRefCache.getOrDefault(vehicleRef, new HashSet<>());\n+  }\n \n-                lastStopPoint = lastStop.getStopPointRef().getValue();\n-                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+  private Set<Trip> getCachedTripsBySiriId(String tripId) {\n+    if (tripId == null) {\n+      return null;\n+    }\n+    return mappedTripsCache.getOrDefault(tripId, new HashSet<>());\n+  }\n \n-            } else if (journey.getRecordedCalls() != null && journey.getRecordedCalls().getRecordedCalls() != null\n-                    && !journey.getRecordedCalls().getRecordedCalls().isEmpty()) { // No EstimatedCalls exist - pick last RecordedCall\n+  private static void initCache(RoutingService index) {\n+    if (mappedTripsCache.isEmpty()) {\n+      Set<Trip> trips = index.getPatternForTrip().keySet();\n+      for (Trip trip : trips) {\n+        TripPattern tripPattern = index.getPatternForTrip().get(trip);\n \n-                List<RecordedCall> recordedCalls = journey.getRecordedCalls().getRecordedCalls();\n-                final RecordedCall lastStop = recordedCalls.get(recordedCalls.size() - 1);\n+        String currentTripId = getUnpaddedTripId(trip.getId().getId());\n \n-                lastStopPoint = lastStop.getStopPointRef().getValue();\n-                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n-            }\n+        if (mappedTripsCache.containsKey(currentTripId)) {\n+          mappedTripsCache.get(currentTripId).add(trip);\n+        } else {\n+          Set<Trip> initialSet = new HashSet<>();\n+          initialSet.add(trip);\n+          mappedTripsCache.put(currentTripId, initialSet);\n+        }\n \n-            if (arrivalTime != null) {\n-                trips = getMatchingTripsOnStopOrSiblings(lastStopPoint, arrivalTime);\n+        if (\n+          tripPattern != null &&\n+          tripPattern.matchesModeOrSubMode(TransitMode.RAIL, \"railReplacementBus\")\n+        ) {\n+          if (trip.getInternalPlanningCode() != null) {\n+            String internalPlanningCode = trip.getInternalPlanningCode();\n+            if (mappedVehicleRefCache.containsKey(internalPlanningCode)) {\n+              mappedVehicleRefCache.get(internalPlanningCode).add(trip);\n+            } else {\n+              Set<Trip> initialSet = new HashSet<>();\n+              initialSet.add(trip);\n+              mappedVehicleRefCache.put(internalPlanningCode, initialSet);\n             }\n+          }\n         }\n-        return trips;\n-    }\n-\n-    private Set<Trip> getMatchingTripsOnStopOrSiblings(String lastStopPoint, ZonedDateTime arrivalTime) {\n-\n-        Set<Trip> trips = start_stop_tripCache.get(createStartStopKey(lastStopPoint, arrivalTime.toLocalTime().toSecondOfDay()));\n-        if (trips == null) {\n-            //Attempt to fetch trips that started yesterday - i.e. add 24 hours to arrival-time\n-            int lastStopArrivalTime = arrivalTime.toLocalTime().toSecondOfDay() + (24 * 60 * 60);\n-            trips = start_stop_tripCache.get(createStartStopKey(lastStopPoint, lastStopArrivalTime));\n+        String lastStopId = tripPattern.lastStop().getId().getId();\n+\n+        TripTimes tripTimes = tripPattern.getScheduledTimetable().getTripTimes(trip);\n+        if (tripTimes != null) {\n+          int arrivalTime = tripTimes.getArrivalTime(tripTimes.getNumStops() - 1);\n+\n+          String key = createStartStopKey(lastStopId, arrivalTime);\n+          if (start_stop_tripCache.containsKey(key)) {\n+            start_stop_tripCache.get(key).add(trip);\n+          } else {\n+            Set<Trip> initialSet = new HashSet<>();\n+            initialSet.add(trip);\n+            start_stop_tripCache.put(key, initialSet);\n+          }\n         }\n-\n-        if (trips == null || trips.isEmpty()) {\n-            //SIRI-data may report other platform, but still on the same Parent-stop\n-            String feedId = routingService.getFeedIds().iterator().next();\n-            Stop stop = routingService.getStopForId(new FeedScopedId(feedId, lastStopPoint));\n-            if (stop != null && stop.isPartOfStation()) {\n-                // TODO OTP2 resolve stop-station split\n-                Collection<Stop> allQuays = stop.getParentStation().getChildStops();\n-                for (Stop quay : allQuays) {\n-                    Set<Trip> tripSet = start_stop_tripCache.get(createStartStopKey(quay.getId().getId(), arrivalTime.toLocalTime().toSecondOfDay()));\n-                    if (tripSet != null) {\n-                        if (trips == null) {\n-                            trips = tripSet;\n-                        } else {\n-                            trips.addAll(tripSet);\n-                        }\n-                    }\n-                }\n-            }\n+      }\n+      Set<Route> routes = index.getPatternsForRoute().keySet();\n+      for (Route route : routes) {\n+        String currentRouteId = getUnpaddedTripId(route.getId().getId());\n+        if (mappedRoutesCache.containsKey(currentRouteId)) {\n+          mappedRoutesCache.get(currentRouteId).add(route);\n+        } else {\n+          Set<Route> initialSet = new HashSet<>();\n+          initialSet.add(route);\n+          mappedRoutesCache.put(currentRouteId, initialSet);\n         }\n-        return trips;\n-    }\n+      }\n \n-    private Set<Trip> getCachedTripsByVehicleRef(String vehicleRef) {\n-        if (vehicleRef == null) {return null;}\n-        return mappedVehicleRefCache.getOrDefault(vehicleRef, new HashSet<>());\n+      LOG.info(\"Built route-cache [{}].\", mappedRoutesCache.size());\n+      LOG.info(\"Built vehicleRef-cache [{}].\", mappedVehicleRefCache.size());\n+      LOG.info(\"Built trips-cache [{}].\", mappedTripsCache.size());\n+      LOG.info(\"Built start-stop-cache [{}].\", start_stop_tripCache.size());\n     }\n \n-    private Set<Trip> getCachedTripsBySiriId(String tripId) {\n-        if (tripId == null) {return null;}\n-        return mappedTripsCache.getOrDefault(tripId, new HashSet<>());\n+    if (vehicleJourneyTripCache.isEmpty()) {\n+      index\n+        .getTripForId()\n+        .values()\n+        .forEach(trip -> vehicleJourneyTripCache.put(trip.getId().getId(), trip));\n     }\n+  }\n \n-    private static void initCache(RoutingService index) {\n-        if (mappedTripsCache.isEmpty()) {\n-\n-            Set<Trip> trips = index.getPatternForTrip().keySet();\n-            for (Trip trip : trips) {\n-\n-                TripPattern tripPattern = index.getPatternForTrip().get(trip);\n-\n-                    String currentTripId = getUnpaddedTripId(trip.getId().getId());\n-\n-                    if (mappedTripsCache.containsKey(currentTripId)) {\n-                        mappedTripsCache.get(currentTripId).add(trip);\n-                    } else {\n-                        Set<Trip> initialSet = new HashSet<>();\n-                        initialSet.add(trip);\n-                        mappedTripsCache.put(currentTripId, initialSet);\n-                    }\n-\n-                if (tripPattern != null &&\n-                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\n-                                                    (trip.getTransportSubmode() != null &&\n-                                                            trip.getTransportSubmode().equals(TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS))*/)) {\n-                    // TODO - SIRI: Add support for submode\n-                    if (trip.getTripShortName() != null) {\n-                        String tripShortName = trip.getTripShortName();\n-                        if (mappedVehicleRefCache.containsKey(tripShortName)) {\n-                            mappedVehicleRefCache.get(tripShortName).add(trip);\n-                        } else {\n-                            Set<Trip> initialSet = new HashSet<>();\n-                            initialSet.add(trip);\n-                            mappedVehicleRefCache.put(tripShortName, initialSet);\n-                        }\n-                    }\n-                }\n-                String lastStopId = tripPattern.getStops().get(tripPattern.getStops().size()-1).getId().getId();\n-\n-                TripTimes tripTimes = tripPattern.scheduledTimetable.getTripTimes(trip);\n-                if (tripTimes != null) {\n-                    int arrivalTime = tripTimes.getArrivalTime(tripTimes.getNumStops() - 1);\n-\n-                    String key = createStartStopKey(lastStopId, arrivalTime);\n-                    if (start_stop_tripCache.containsKey(key)) {\n-                        start_stop_tripCache.get(key).add(trip);\n-                    } else {\n-                        Set<Trip> initialSet = new HashSet<>();\n-                        initialSet.add(trip);\n-                        start_stop_tripCache.put(key, initialSet);\n-                    }\n-                }\n-            }\n-            Set<Route> routes = index.getPatternsForRoute().keySet();\n-            for (Route route : routes) {\n-\n-                String currentRouteId = getUnpaddedTripId(route.getId().getId());\n-                if (mappedRoutesCache.containsKey(currentRouteId)) {\n-                    mappedRoutesCache.get(currentRouteId).add(route);\n-                } else {\n-                    Set<Route> initialSet = new HashSet<>();\n-                    initialSet.add(route);\n-                    mappedRoutesCache.put(currentRouteId, initialSet);\n-                }\n-            }\n-\n-            LOG.info(\"Built route-cache [{}].\", mappedRoutesCache.size());\n-            LOG.info(\"Built vehicleRef-cache [{}].\", mappedVehicleRefCache.size());\n-            LOG.info(\"Built trips-cache [{}].\", mappedTripsCache.size());\n-            LOG.info(\"Built start-stop-cache [{}].\", start_stop_tripCache.size());\n-        }\n+  private static String createStartStopKey(String lastStopId, int lastStopArrivalTime) {\n+    return lastStopId + \":\" + lastStopArrivalTime;\n+  }\n \n-        if (vehicleJourneyTripCache.isEmpty()) {\n-            index\n-                .getTripForId()\n-                .values().forEach(trip -> vehicleJourneyTripCache.put(trip.getId().getId(), trip));\n-        }\n+  private static String getUnpaddedTripId(String id) {\n+    if (id.indexOf(\"-\") > 0) {\n+      return id.substring(0, id.indexOf(\"-\"));\n+    } else {\n+      return id;\n     }\n+  }\n \n-    private static String createStartStopKey(String lastStopId, int lastStopArrivalTime) {\n-        return lastStopId + \":\" + lastStopArrivalTime;\n-    }\n+  public Set<Route> getRoutesForStop(FeedScopedId siriStopId) {\n+    var stop = routingService.getStopForId(siriStopId);\n+    return routingService.getRoutesForStop(stop);\n+  }\n \n-    private static String getUnpaddedTripId(String id) {\n-        if (id.indexOf(\"-\") > 0) {\n-            return id.substring(0, id.indexOf(\"-\"));\n-        } else {\n-            return id;\n-        }\n+  public FeedScopedId getStop(String siriStopId) {\n+    if (nonExistingStops.contains(siriStopId)) {\n+      return null;\n     }\n \n-    public Set<Route> getRoutesForStop(FeedScopedId siriStopId) {\n-        Stop stop = routingService.getStopForId(siriStopId);\n-        return routingService.getRoutesForStop(stop);\n-    }\n+    // TODO OTP2 #2838 - Guessing on the feedId is not a deterministic way to find a stop.\n \n-    public FeedScopedId getStop(String siriStopId) {\n+    //First, assume same agency\n \n-        if (nonExistingStops.contains(siriStopId)) {\n-            return null;\n-        }\n+    var firstStop = routingService.getAllStops().stream().findFirst().get();\n+    FeedScopedId id = new FeedScopedId(firstStop.getId().getFeedId(), siriStopId);\n+    if (routingService.getStopForId(id) != null) {\n+      return id;\n+    } else if (routingService.getStationById(id) != null) {\n+      return id;\n+    }\n \n-        // TODO OTP2 #2838 - Guessing on the feedId is not a deterministic way to find a stop.\n+    //Not same agency - loop through all stops/Stations\n+    var stops = routingService.getAllStops();\n+    for (var stop : stops) {\n+      if (stop.getId().getId().equals(siriStopId)) {\n+        return stop.getId();\n+      }\n+    }\n+    //No match found in quays - check parent-stops (stopplace)\n+    for (Station station : routingService.getStations()) {\n+      if (station.getId().getId().equals(siriStopId)) {\n+        return station.getId();\n+      }\n+    }\n \n-        //First, assume same agency\n+    nonExistingStops.add(siriStopId);\n+    return null;\n+  }\n \n-        Stop firstStop = routingService.getAllStops().stream().findFirst().get();\n-        FeedScopedId id = new FeedScopedId(firstStop.getId().getFeedId(), siriStopId);\n-        if (routingService.getStopForId(id) != null) {\n-            return id;\n-        }\n-        else if (routingService.getStationById(id) != null) {\n-            return id;\n-        }\n-\n-        //Not same agency - loop through all stops/Stations\n-        Collection<Stop> stops = routingService.getAllStops();\n-        for (Stop stop : stops) {\n-            if (stop.getId().getId().equals(siriStopId)) {\n-                return stop.getId();\n-            }\n-        }\n-        //No match found in quays - check parent-stops (stopplace)\n-        for (Station station : routingService.getStations()) {\n-            if (station.getId().getId().equals(siriStopId)) {\n-                return station.getId();\n-            }\n-        }\n+  public Set<Route> getRoutes(String lineRefValue) {\n+    return mappedRoutesCache.getOrDefault(lineRefValue, new HashSet<>());\n+  }\n \n-        nonExistingStops.add(siriStopId);\n-        return null;\n+  public FeedScopedId getTripId(String vehicleJourney) {\n+    Trip trip = vehicleJourneyTripCache.get(vehicleJourney);\n+    if (trip != null) {\n+      return trip.getId();\n     }\n-\n-    public Set<Route> getRoutes(String lineRefValue) {\n-        return mappedRoutesCache.getOrDefault(lineRefValue, new HashSet<>());\n+    //Fallback to handle extrajourneys\n+    for (String feedId : routingService.getFeedIds()) {\n+      trip = routingService.getTripForId().get(new FeedScopedId(feedId, vehicleJourney));\n+      if (trip != null) {\n+        vehicleJourneyTripCache.put(vehicleJourney, trip);\n+        return trip.getId();\n+      }\n     }\n-\n-    public FeedScopedId getTripId(String vehicleJourney) {\n-        Trip trip = vehicleJourneyTripCache.get(vehicleJourney);\n-        if (trip != null) {\n-            return trip.getId();\n-        }\n-        //Fallback to handle extrajourneys\n-        for (String feedId : routingService.getFeedIds()) {\n-            trip = routingService.getTripForId().get(new FeedScopedId(feedId, vehicleJourney));\n-            if (trip != null) {\n-                vehicleJourneyTripCache.put(vehicleJourney, trip);\n-                return trip.getId();\n-            }\n+    return null;\n+  }\n+\n+  public int getTripDepartureTime(FeedScopedId tripId) {\n+    Trip trip = routingService.getTripForId().get(tripId);\n+    {\n+      TripPattern tripPattern = routingService.getPatternForTrip().get(trip);\n+\n+      if (tripPattern != null) {\n+        TripTimes tripTimes = tripPattern.getScheduledTimetable().getTripTimes(trip);\n+        if (tripTimes != null) {\n+          return tripTimes.getArrivalTime(0);\n         }\n-        return null;\n+      }\n     }\n-\n-\n-    public int getTripDepartureTime(FeedScopedId tripId) {\n-        Trip trip = routingService.getTripForId().get(tripId);\n-        {\n-            TripPattern tripPattern = routingService.getPatternForTrip().get(trip);\n-\n-            if (tripPattern != null) {\n-                TripTimes tripTimes = tripPattern.scheduledTimetable.getTripTimes(trip);\n-                if (tripTimes != null) {\n-                    return tripTimes.getArrivalTime(0);\n-\n-                }\n-            }\n+    return -1;\n+  }\n+\n+  public int getTripArrivalTime(FeedScopedId tripId) {\n+    Trip trip = routingService.getTripForId().get(tripId);\n+    {\n+      TripPattern tripPattern = routingService.getPatternForTrip().get(trip);\n+\n+      if (tripPattern != null) {\n+        TripTimes tripTimes = tripPattern.getScheduledTimetable().getTripTimes(trip);\n+        if (tripTimes != null) {\n+          return tripTimes.getArrivalTime(tripTimes.getNumStops() - 1);\n         }\n-        return -1;\n+      }\n     }\n-    public int getTripArrivalTime(FeedScopedId tripId) {\n-        Trip trip = routingService.getTripForId().get(tripId);\n-        {\n-            TripPattern tripPattern = routingService.getPatternForTrip().get(trip);\n-\n-            if (tripPattern != null) {\n-                TripTimes tripTimes = tripPattern.scheduledTimetable.getTripTimes(trip);\n-                if (tripTimes != null) {\n-                    return tripTimes.getArrivalTime(tripTimes.getNumStops()-1);\n-                }\n-            }\n+    return -1;\n+  }\n+\n+  /**\n+   * Returns a match of tripIds that match the provided values.\n+   */\n+  public List<FeedScopedId> getTripIdForInternalPlanningCodeServiceDateAndMode(\n+    String internalPlanningCode,\n+    ServiceDate serviceDate,\n+    TransitMode mode,\n+    String transportSubmode\n+  ) {\n+    Set<Trip> cachedTripsBySiriId = getCachedTripsBySiriId(internalPlanningCode);\n+\n+    if (cachedTripsBySiriId.isEmpty()) {\n+      cachedTripsBySiriId = getCachedTripsByVehicleRef(internalPlanningCode);\n+    }\n+\n+    List<FeedScopedId> matches = new ArrayList<>();\n+    for (Trip trip : cachedTripsBySiriId) {\n+      final TripPattern tripPattern = routingService.getPatternForTrip().get(trip);\n+      if (tripPattern.matchesModeOrSubMode(mode, transportSubmode)) {\n+        Set<ServiceDate> serviceDates = routingService\n+          .getCalendarService()\n+          .getServiceDatesForServiceId(trip.getServiceId());\n+        if (\n+          serviceDates.contains(serviceDate) &&\n+          trip.getInternalPlanningCode() != null &&\n+          trip.getInternalPlanningCode().equals(internalPlanningCode)\n+        ) {\n+          matches.add(trip.getId());\n         }\n-        return -1;\n+      }\n     }\n+\n+    return matches;\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\nindex 250cb31098..4f46a4d4ed 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n", "chunk": "@@ -440,4 +267,174 @@ public class SiriFuzzyTripMatcher {\n \n     return matches;\n   }\n+\n+  Trip findTripByDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n+    String serviceJourneyId = resolveDatedVehicleJourneyRef(journey);\n+    if (serviceJourneyId != null) {\n+      for (String feedId : routingService.getFeedIds()) {\n+        Trip trip = routingService.getTripForId().get(new FeedScopedId(feedId, serviceJourneyId));\n+        if (trip != null) {\n+          return trip;\n+        }\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static void initCache(RoutingService index) {\n+    if (mappedTripsCache.isEmpty()) {\n+      Set<Trip> trips = index.getPatternForTrip().keySet();\n+      for (Trip trip : trips) {\n+        TripPattern tripPattern = index.getPatternForTrip().get(trip);\n+\n+        String currentTripId = getUnpaddedTripId(trip.getId().getId());\n+\n+        if (mappedTripsCache.containsKey(currentTripId)) {\n+          mappedTripsCache.get(currentTripId).add(trip);\n+        } else {\n+          Set<Trip> initialSet = new HashSet<>();\n+          initialSet.add(trip);\n+          mappedTripsCache.put(currentTripId, initialSet);\n+        }\n+\n+        if (\n+          tripPattern != null &&\n+          tripPattern.matchesModeOrSubMode(TransitMode.RAIL, \"railReplacementBus\")\n+        ) {\n+          if (trip.getInternalPlanningCode() != null) {\n+            String internalPlanningCode = trip.getInternalPlanningCode();\n+            if (mappedVehicleRefCache.containsKey(internalPlanningCode)) {\n+              mappedVehicleRefCache.get(internalPlanningCode).add(trip);\n+            } else {\n+              Set<Trip> initialSet = new HashSet<>();\n+              initialSet.add(trip);\n+              mappedVehicleRefCache.put(internalPlanningCode, initialSet);\n+            }\n+          }\n+        }\n+        String lastStopId = tripPattern.lastStop().getId().getId();\n+\n+        TripTimes tripTimes = tripPattern.getScheduledTimetable().getTripTimes(trip);\n+        if (tripTimes != null) {\n+          int arrivalTime = tripTimes.getArrivalTime(tripTimes.getNumStops() - 1);\n+\n+          String key = createStartStopKey(lastStopId, arrivalTime);\n+          if (start_stop_tripCache.containsKey(key)) {\n+            start_stop_tripCache.get(key).add(trip);\n+          } else {\n+            Set<Trip> initialSet = new HashSet<>();\n+            initialSet.add(trip);\n+            start_stop_tripCache.put(key, initialSet);\n+          }\n+        }\n+      }\n+      Set<Route> routes = index.getPatternsForRoute().keySet();\n+      for (Route route : routes) {\n+        String currentRouteId = getUnpaddedTripId(route.getId().getId());\n+        if (mappedRoutesCache.containsKey(currentRouteId)) {\n+          mappedRoutesCache.get(currentRouteId).add(route);\n+        } else {\n+          Set<Route> initialSet = new HashSet<>();\n+          initialSet.add(route);\n+          mappedRoutesCache.put(currentRouteId, initialSet);\n+        }\n+      }\n+\n+      LOG.info(\"Built route-cache [{}].\", mappedRoutesCache.size());\n+      LOG.info(\"Built vehicleRef-cache [{}].\", mappedVehicleRefCache.size());\n+      LOG.info(\"Built trips-cache [{}].\", mappedTripsCache.size());\n+      LOG.info(\"Built start-stop-cache [{}].\", start_stop_tripCache.size());\n+    }\n+\n+    if (vehicleJourneyTripCache.isEmpty()) {\n+      index\n+        .getTripForId()\n+        .values()\n+        .forEach(trip -> vehicleJourneyTripCache.put(trip.getId().getId(), trip));\n+    }\n+  }\n+\n+  private static String createStartStopKey(String lastStopId, int lastStopArrivalTime) {\n+    return lastStopId + \":\" + lastStopArrivalTime;\n+  }\n+\n+  private static String getUnpaddedTripId(String id) {\n+    if (id.indexOf(\"-\") > 0) {\n+      return id.substring(0, id.indexOf(\"-\"));\n+    } else {\n+      return id;\n+    }\n+  }\n+\n+  private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n+    if (journey.getFramedVehicleJourneyRef() != null) {\n+      return journey.getFramedVehicleJourneyRef().getDatedVehicleJourneyRef();\n+    } else if (journey.getDatedVehicleJourneyRef() != null) {\n+      return journey.getDatedVehicleJourneyRef().getValue();\n+    }\n+\n+    return null;\n+  }\n+\n+  private Set<Trip> getMatchingTripsOnStopOrSiblings(\n+    String lastStopPoint,\n+    ZonedDateTime arrivalTime\n+  ) {\n+    int secondsSinceMidnight = DateMapper.secondsSinceStartOfService(\n+      arrivalTime,\n+      arrivalTime,\n+      routingService.getTimeZone().toZoneId()\n+    );\n+    int secondsSinceMidnightYesterday = DateMapper.secondsSinceStartOfService(\n+      arrivalTime.minusDays(1),\n+      arrivalTime,\n+      routingService.getTimeZone().toZoneId()\n+    );\n+\n+    Set<Trip> trips = start_stop_tripCache.get(\n+      createStartStopKey(lastStopPoint, secondsSinceMidnight)\n+    );\n+    if (trips == null) {\n+      //Attempt to fetch trips that started yesterday - i.e. add 24 hours to arrival-time\n+      trips =\n+        start_stop_tripCache.get(createStartStopKey(lastStopPoint, secondsSinceMidnightYesterday));\n+    }\n+\n+    if (trips == null || trips.isEmpty()) {\n+      //SIRI-data may report other platform, but still on the same Parent-stop\n+      String feedId = routingService.getFeedIds().iterator().next();\n+      var stop = routingService.getStopForId(new FeedScopedId(feedId, lastStopPoint));\n+      if (stop != null && stop.isPartOfStation()) {\n+        // TODO OTP2 resolve stop-station split\n+        var allQuays = stop.getParentStation().getChildStops();\n+        for (var quay : allQuays) {\n+          Set<Trip> tripSet = start_stop_tripCache.get(\n+            createStartStopKey(quay.getId().getId(), secondsSinceMidnight)\n+          );\n+          if (tripSet != null) {\n+            if (trips == null) {\n+              trips = tripSet;\n+            } else {\n+              trips.addAll(tripSet);\n+            }\n+          }\n+        }\n+      }\n+    }\n+    return trips;\n+  }\n+\n+  private Set<Trip> getCachedTripsByVehicleRef(String vehicleRef) {\n+    if (vehicleRef == null) {\n+      return null;\n+    }\n+    return mappedVehicleRefCache.getOrDefault(vehicleRef, new HashSet<>());\n+  }\n+\n+  private Set<Trip> getCachedTripsBySiriId(String tripId) {\n+    if (tripId == null) {\n+      return null;\n+    }\n+    return mappedTripsCache.getOrDefault(tripId, new HashSet<>());\n+  }\n }\n", "next_change": {"commit": "cd774bbdeebe4edadee86dcc66644955820aa135", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\nindex 4f46a4d4ed..244dcecda7 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n", "chunk": "@@ -424,17 +348,10 @@ public class SiriFuzzyTripMatcher {\n     return trips;\n   }\n \n-  private Set<Trip> getCachedTripsByVehicleRef(String vehicleRef) {\n+  private Set<Trip> getCachedTripsByInternalPlanningCode(String vehicleRef) {\n     if (vehicleRef == null) {\n       return null;\n     }\n-    return mappedVehicleRefCache.getOrDefault(vehicleRef, new HashSet<>());\n-  }\n-\n-  private Set<Trip> getCachedTripsBySiriId(String tripId) {\n-    if (tripId == null) {\n-      return null;\n-    }\n-    return mappedTripsCache.getOrDefault(tripId, new HashSet<>());\n+    return internalPlanningCodeCache.getOrDefault(vehicleRef, new HashSet<>());\n   }\n }\n", "next_change": {"commit": "07b4cd665feb524df0d8e788a17e9816bada6eb5", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\nindex 244dcecda7..406653b346 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n", "chunk": "@@ -348,10 +297,10 @@ public class SiriFuzzyTripMatcher {\n     return trips;\n   }\n \n-  private Set<Trip> getCachedTripsByInternalPlanningCode(String vehicleRef) {\n-    if (vehicleRef == null) {\n+  private Set<Trip> getCachedTripsByInternalPlanningCode(String internalPlanningCode) {\n+    if (internalPlanningCode == null) {\n       return null;\n     }\n-    return internalPlanningCodeCache.getOrDefault(vehicleRef, new HashSet<>());\n+    return internalPlanningCodeCache.getOrDefault(internalPlanningCode, new HashSet<>());\n   }\n }\n", "next_change": {"commit": "04f9c0c0ffcdfc8fa5e9c4993fb98f23a8d7782f", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\nindex 406653b346..896bd467b2 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java\n", "chunk": "@@ -303,4 +261,155 @@ public class SiriFuzzyTripMatcher {\n     }\n     return internalPlanningCodeCache.getOrDefault(internalPlanningCode, new HashSet<>());\n   }\n+\n+  /**\n+   * Finds the correct trip based on OTP-ServiceDate and SIRI-DepartureTime\n+   */\n+  private Set<Trip> getTripForJourney(\n+    Set<Trip> trips,\n+    EstimatedVehicleJourney journey,\n+    BiFunction<TripPattern, LocalDate, Timetable> getCurrentTimetable\n+  ) {\n+    List<RecordedCall> recordedCalls =\n+      (\n+        journey.getRecordedCalls() != null\n+          ? journey.getRecordedCalls().getRecordedCalls()\n+          : new ArrayList<>()\n+      );\n+    List<EstimatedCall> estimatedCalls =\n+      (\n+        journey.getEstimatedCalls() != null ? journey.getEstimatedCalls().getEstimatedCalls() : null\n+      );\n+\n+    ZonedDateTime date;\n+    int stopNumber = 1;\n+    String firstStopId;\n+    if (recordedCalls != null && !recordedCalls.isEmpty()) {\n+      RecordedCall recordedCall = recordedCalls.get(0);\n+      date = recordedCall.getAimedDepartureTime();\n+      firstStopId = recordedCall.getStopPointRef().getValue();\n+    } else if (estimatedCalls != null && !estimatedCalls.isEmpty()) {\n+      EstimatedCall estimatedCall = estimatedCalls.get(0);\n+      if (estimatedCall.getOrder() != null) {\n+        stopNumber = estimatedCall.getOrder().intValue();\n+      } else if (estimatedCall.getVisitNumber() != null) {\n+        stopNumber = estimatedCall.getVisitNumber().intValue();\n+      }\n+      firstStopId = estimatedCall.getStopPointRef().getValue();\n+      date = estimatedCall.getAimedDepartureTime();\n+    } else {\n+      return null;\n+    }\n+\n+    if (date == null) {\n+      //If no date is set - assume Realtime-data is reported for 'today'.\n+      date = ZonedDateTime.now(transitService.getTimeZone());\n+    }\n+    LocalDate serviceDate = date.toLocalDate();\n+\n+    int departureInSecondsSinceMidnight = ServiceDateUtils.secondsSinceStartOfService(\n+      date,\n+      date,\n+      transitService.getTimeZone()\n+    );\n+    Set<Trip> result = new HashSet<>();\n+    for (Trip trip : trips) {\n+      Set<LocalDate> serviceDatesForServiceId = transitService\n+        .getCalendarService()\n+        .getServiceDatesForServiceId(trip.getServiceId());\n+      if (serviceDatesForServiceId.contains(serviceDate)) {\n+        TripPattern pattern = transitService.getPatternForTrip(trip);\n+\n+        if (stopNumber < pattern.numberOfStops()) {\n+          boolean firstReportedStopIsFound = false;\n+          var stop = pattern.getStop(stopNumber - 1);\n+          if (firstStopId.equals(stop.getId().getId())) {\n+            firstReportedStopIsFound = true;\n+          } else {\n+            if (stop.isPartOfStation()) {\n+              var alternativeStop = transitService.getRegularStop(\n+                new FeedScopedId(stop.getId().getFeedId(), firstStopId)\n+              );\n+              if (alternativeStop != null && stop.isPartOfSameStationAs(alternativeStop)) {\n+                firstReportedStopIsFound = true;\n+              }\n+            }\n+          }\n+          if (firstReportedStopIsFound) {\n+            for (TripTimes times : getCurrentTimetable.apply(pattern, serviceDate).getTripTimes()) {\n+              if (\n+                times.getScheduledDepartureTime(stopNumber - 1) == departureInSecondsSinceMidnight\n+              ) {\n+                if (\n+                  transitService\n+                    .getCalendarService()\n+                    .getServiceDatesForServiceId(times.getTrip().getServiceId())\n+                    .contains(serviceDate)\n+                ) {\n+                  result.add(times.getTrip());\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    if (result.size() >= 1) {\n+      return result;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Finds the correct trip based on OTP-ServiceDate and SIRI-DepartureTime\n+   */\n+  private Trip getTripForJourney(\n+    Set<Trip> trips,\n+    MonitoredVehicleJourneyStructure monitoredVehicleJourney\n+  ) {\n+    ZonedDateTime date = monitoredVehicleJourney.getOriginAimedDepartureTime();\n+    if (date == null) {\n+      //If no date is set - assume Realtime-data is reported for 'today'.\n+      date = ZonedDateTime.now();\n+    }\n+    LocalDate serviceDate = date.toLocalDate();\n+\n+    List<Trip> results = new ArrayList<>();\n+    for (Trip trip : trips) {\n+      Set<LocalDate> serviceDatesForServiceId = transitService\n+        .getCalendarService()\n+        .getServiceDatesForServiceId(trip.getServiceId());\n+\n+      for (LocalDate next : serviceDatesForServiceId) {\n+        if (next.equals(serviceDate)) {\n+          results.add(trip);\n+        }\n+      }\n+    }\n+\n+    if (results.size() == 1) {\n+      return results.get(0);\n+    } else if (results.size() > 1) {\n+      // Multiple possible matches - check if lineRef/routeId matches\n+      if (\n+        monitoredVehicleJourney.getLineRef() != null &&\n+        monitoredVehicleJourney.getLineRef().getValue() != null\n+      ) {\n+        String lineRef = monitoredVehicleJourney.getLineRef().getValue();\n+        for (Trip trip : results) {\n+          if (lineRef.equals(trip.getRoute().getId().getId())) {\n+            // Return first trip where the lineRef matches routeId\n+            return trip;\n+          }\n+        }\n+      }\n+\n+      // Line does not match any routeId - return first result.\n+      return results.get(0);\n+    }\n+\n+    return null;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "f1472d40a5fe21464ae4857f7b7710d15718fb48", "committedDate": "2020-11-06 14:46:36 +0100", "message": "Move siri stoptime calculation to DateMapper and take graph timezone into account"}, {"oid": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "committedDate": "2021-07-23 15:25:47 +0200", "message": "Encapsulate fields in TripPattern"}, {"oid": "acf334d3ee4956c41586785ceba398104a8e43c4", "committedDate": "2021-12-10 12:51:40 +0100", "message": "Replace Stop with StopLocation in internal logic"}, {"oid": "1d2a5714c482158d08681551bc09f5fc3b94c69b", "committedDate": "2021-12-17 16:03:13 +0200", "message": "Added fuzzy-matching of privateCode/date to trip for trips of type rail/railReplacementBus"}, {"oid": "907a752feb3be63a700b4fd18ad20be30f3d7556", "committedDate": "2022-01-06 23:11:51 +0200", "message": "Apply suggestions from code review"}, {"oid": "594f8f4b4825bfc1e8513df756fbc20f499c9e26", "committedDate": "2022-01-07 16:44:53 +0100", "message": "refactor: Encapsulate StopPattern in TripPattern"}, {"oid": "768117c09e4a1d2845f3db933b53a0cf6448455a", "committedDate": "2022-01-14 11:31:21 +0100", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_not_allowed_transfers"}, {"oid": "7ee3df5e8f00cd39608ebf34a1591c0478fb05ea", "committedDate": "2022-02-21 17:36:10 +0100", "message": "Reanme package `raptor` to `raptoradapter`"}, {"oid": "54b5e623ca717ee4de5957bc674dfe0bfd07bcb6", "committedDate": "2022-03-21 19:46:05 +0100", "message": "refactor: Make fields final"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "24cf2b0519911fa081ad9b243217e1191b5c6b1d", "committedDate": "2022-04-06 23:58:03 +0200", "message": "Added SIRI trip matching for DatedServiceJourneyId"}, {"oid": "f3c35edfbf006a84f76729d231ba79ca5fd10535", "committedDate": "2022-04-12 15:27:18 +0200", "message": "Removed feedId loops"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "7ce752f502a67389c67fbac3ce35e68f4fce7b0b", "committedDate": "2022-05-11 11:50:22 +0300", "message": "Add todo"}, {"oid": "5b2c4d18588bdf5a7de7d93418e0b3ebc68279a6", "committedDate": "2022-05-19 18:22:44 +0200", "message": "refactor: Move BikeAccess, GroupOfRoutes, Route and TransitMode"}, {"oid": "9191db53ea40f1c8f5fbac1c0ffa67b6be41a950", "committedDate": "2022-05-25 10:18:42 +0300", "message": "Merge pull request #4155 from entur/otp2_timetable_helper_test"}, {"oid": "b68ea1a5bccbcfc98d46ebac6490056a69c44550", "committedDate": "2022-05-25 15:44:44 +0200", "message": "refactor: Move Trip to new location."}, {"oid": "123eb90ab3514c6838947bf1eac91a155ee57add", "committedDate": "2022-05-25 15:44:48 +0200", "message": "refactor: Cleanup Trip"}, {"oid": "f8f232ad48ed87efd67d9bc7ea528b7f04c2a76a", "committedDate": "2022-06-02 14:20:02 +0200", "message": "feature: Make SubMode a type"}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b0c367119fc2b637823337923b5504444eb45a52", "committedDate": "2022-06-13 17:38:22 +0200", "message": "refactor: Move Stop related classes into package site"}, {"oid": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "committedDate": "2022-06-15 13:49:47 +0200", "message": "Introduce TransitService"}, {"oid": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "committedDate": "2022-06-15 16:35:25 +0200", "message": "Migrate methods from RoutingService to TransitService"}, {"oid": "287283d19dcb8be174a9e88a954b5af67df6a44d", "committedDate": "2022-06-16 12:34:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "69408e579c9da646b396d2d2e28377b1e598d7b7", "committedDate": "2022-06-16 14:53:52 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_refactor_transit_service"}, {"oid": "accc4a5ff8b0ea06456d0995e17b3075a7f7bd0c", "committedDate": "2022-06-17 10:56:49 +0200", "message": "Merge branch 'dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "committedDate": "2022-06-30 14:00:01 +0300", "message": "Convert java.util to java.time classes"}, {"oid": "d88723210fe6ecc4d8619b5424528334980319ad", "committedDate": "2022-07-06 14:57:50 +0300", "message": "Move and rename DateMapper as ServiceDateUtils"}, {"oid": "95ebdf26498025f5cb470f3cb7360135538e9ee6", "committedDate": "2022-07-06 15:08:13 +0300", "message": "Convert Alerts to use LocalDate"}, {"oid": "c859f113deb7fe849738378c314e9b8d92bdbfac", "committedDate": "2022-07-06 15:08:16 +0300", "message": "Migrate rest of ServiceDate"}, {"oid": "3b4316833886ff242325e031fa13264850b5317e", "committedDate": "2022-07-19 15:48:45 +0200", "message": "refactor: Move Transit- and Sub- Mode to basic"}, {"oid": "a9a481a11accd25c83e422497e3b507cf313b4e7", "committedDate": "2022-07-25 16:53:07 +0200", "message": "Encapsulate StopModelIndex"}, {"oid": "b10f9f409887b9c17c38d8c778a2c58453c0e208", "committedDate": "2022-07-27 11:13:19 +0200", "message": "Move TripPattern and StopPattern to network package"}, {"oid": "704be03cc12f728e534046a149b6fa4abd7628cf", "committedDate": "2022-07-27 15:08:27 +0200", "message": "Encapsulate maps in TransitService"}, {"oid": "87f15c0428dceaad93dbfc2c6e0d59d8708edaa8", "committedDate": "2022-07-27 17:07:22 +0200", "message": "Merge branch 'dev-2.x' into otp2_migrate_remaining_transit_entities_to_new_model"}, {"oid": "81b484f907c8732c1fea4f230bf70c6e8385948f", "committedDate": "2022-07-28 09:52:21 +0200", "message": "Move TripTimes to timetable package"}, {"oid": "6d466b74a304f7798a2203d92f510ff4254cdc90", "committedDate": "2022-07-28 09:53:32 +0200", "message": "Explicitly pass feedId to SiriFuzzyTripMatcher instead of guessing"}, {"oid": "afb40f73aca6c485503f0c2e27700fc3c65f761e", "committedDate": "2022-07-28 16:45:22 +0200", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_make_siri_feed_id_explicit"}, {"oid": "f37e38d6fe51b21bd2999a217adcaa946fc481d4", "committedDate": "2022-08-08 14:16:44 +0200", "message": "Convert TripOnServiceDate to TransitEntity2  (#4331)"}, {"oid": "e432663a0dbe2be1ea452c4cb6b414d50c7f802b", "committedDate": "2022-08-10 13:27:09 +0300", "message": "Do not crash on empty trip patterns"}, {"oid": "b5ecba56b7e330eca9cbbed6c778cd518c12c0f5", "committedDate": "2022-08-18 02:46:11 +0200", "message": "refactor: Rename getRegularTransitStopById to getRegularStop"}, {"oid": "1e78dbfb2082be5402528b325a54c4cf1b9ca23c", "committedDate": "2022-08-24 20:02:59 +0200", "message": "refactor: Keep the fuzzyTripMatcher in updaters, allow for customizations."}, {"oid": "9de0b7c9ad31daaa3f80861f38c9635f7f77ee84", "committedDate": "2022-08-29 13:38:22 +0200", "message": "Update src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java"}, {"oid": "1cd07bc62ff7ea6c0215b73df911c8960830d00f", "committedDate": "2022-10-03 14:24:43 +0300", "message": "Rename variables to match usage"}, {"oid": "7950c6b61bfa1246bc9fcabc3eab114d00e4cc3c", "committedDate": "2022-10-03 14:25:57 +0300", "message": "Remove unused code"}, {"oid": "cd774bbdeebe4edadee86dcc66644955820aa135", "committedDate": "2022-10-03 15:21:12 +0300", "message": "Remove unneeded caches"}, {"oid": "810f555369ca038cdd0314c67872989a9c84655a", "committedDate": "2022-10-03 15:38:25 +0300", "message": "Create the fuzzyTripMatcher only if fuzzyTripMatching is set in config"}, {"oid": "92a463205ffbc01ef7a7bdea1591f06a34d95691", "committedDate": "2022-10-03 16:03:57 +0300", "message": "Make SiriAlertsUpdateHandler work without a SiriFuzzyTripMatcher"}, {"oid": "45c42ee7cb20e6e16dc773d1d0b838d1c8b74f08", "committedDate": "2022-11-07 10:48:27 +0200", "message": "Simplify cache initialization"}, {"oid": "07b4cd665feb524df0d8e788a17e9816bada6eb5", "committedDate": "2022-11-07 11:16:10 +0200", "message": "Simplify SiriFuzzyTripMatcher"}, {"oid": "dedae413ca350bb4e8ca722f5b07cd7269aefb4f", "committedDate": "2022-11-23 16:41:16 +0100", "message": "refactor: Move o.o.util.time to o.o.framework.time"}, {"oid": "25df6b5afbc4ad20e8c3768cb5b8b5bb367303d0", "committedDate": "2023-01-11 14:26:09 +0200", "message": "Clarify usage of DatedVehicleJourneyRef"}, {"oid": "c01b1d3a203170061fcc0de2c4ec28fdc00c5376", "committedDate": "2023-01-11 15:36:12 +0200", "message": "Extract EntityResolver from SiriFuzzyTripMatcher"}, {"oid": "04f9c0c0ffcdfc8fa5e9c4993fb98f23a8d7782f", "committedDate": "2023-01-11 16:51:10 +0200", "message": "Do filtering of matching trips inside SiriFuzzyTripMatcher"}, {"oid": "da5decda8f84336fd6a90dc4ec45312d16f15919", "committedDate": "2023-01-12 13:02:13 +0200", "message": "Guard against unmatched trips"}, {"oid": "b9edaf1f655c5a6bc24676f9f9136eac9b4fc2f9", "committedDate": "2023-02-22 12:06:44 +0200", "message": "Allow only one trip to be updated from fuzzy matcher"}, {"oid": "c07436ebb63dd4383e53b2b0c184adee5fdb06b3", "committedDate": "2023-02-22 12:06:46 +0200", "message": "Remove duplicate work and use CallWrapper in SIRI fuzzy trip matcher"}, {"oid": "2cb192de5eb16cc9c5d6107805d4197926fa9dfb", "committedDate": "2023-02-22 12:09:09 +0200", "message": "Add filtering by line, if it can be found in scheduled data"}, {"oid": "3249969e4694d0e85566c23cb9919502fc9daf04", "committedDate": "2023-02-22 18:33:50 +0200", "message": "Compare only matched trip times, not all for pattern"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NDk5MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487844990", "body": "Call to 'Thread.sleep()' in a loop, probably busy-waiting.", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting.", "bodyHTML": "<p dir=\"auto\">Call to 'Thread.sleep()' in a loop, probably busy-waiting.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:37:13Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);\n+                } catch (InterruptedException interruptedException) {\n+                    //Ignore\n+                }\n+            }\n+        }\n+\n+        Subscriber subscriber = null;\n+        while (true) {\n+            try {\n+                subscriber = Subscriber.newBuilder(subscription.getName(), receiver).build();\n+                subscriber.startAsync().awaitRunning();\n+\n+                subscriber.awaitTerminated();\n+            } catch (IllegalStateException e) {\n+\n+                if (subscriber != null) {\n+                    subscriber.stopAsync();\n+                }\n+            }\n+            try {\n+                Thread.sleep(reconnectPeriodSec * 1000);", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NTE2NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487845164", "body": "Call to 'Thread.sleep()' in a loop, probably busy-waiting \r\n Inspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting\nInspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.", "bodyHTML": "<p dir=\"auto\">Call to 'Thread.sleep()' in a loop, probably busy-waiting<br>\nInspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:37:36Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MDk0MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487870941", "body": "You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat `InterruptedException` and as mention above the `Thread.sleep` blockes.", "bodyText": "You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat InterruptedException and as mention above the Thread.sleep blockes.", "bodyHTML": "<p dir=\"auto\">You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat <code>InterruptedException</code> and as mention above the <code>Thread.sleep</code> blockes.</p>", "author": "t2gran", "createdAt": "2020-09-14T12:26:11Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java", "diffHunk": "@@ -94,25 +103,44 @@ public void setup(Graph graph) {\n \n     @Override\n     protected void runPolling() {\n-        boolean moreData = false;\n-        do {\n-            Siri updates = getUpdates();\n-            if (updates != null) {\n-                ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                final boolean markPrimed = !moreData;\n-                if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                    updaterManager.execute(graph -> {\n-                        updateHandler.update(serviceDelivery);\n-                        if (markPrimed) primed = true;\n-                    });\n+        try {\n+            boolean moreData = false;\n+            do {\n+                Siri updates = getUpdates();\n+                if (updates != null) {\n+                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+                    final boolean markPrimed = !moreData;\n+                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+                        updaterManager.execute(graph -> {\n+                            updateHandler.update(serviceDelivery);\n+                            if (markPrimed) primed = true;\n+                        });\n+                    }\n                 }\n+            } while (moreData);\n+        } catch (IOException e) {\n+\n+            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+\n+            retryCount++;\n+\n+            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException ex) {\n+                //Ignore\n             }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "7f368f13888d0064861bfbd762aa81da2bc98ed9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\nindex dd19ea73ff..3bfec11d41 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n", "chunk": "@@ -103,44 +84,25 @@ public class SiriSXUpdater extends PollingGraphUpdater {\n \n     @Override\n     protected void runPolling() {\n-        try {\n-            boolean moreData = false;\n-            do {\n-                Siri updates = getUpdates();\n-                if (updates != null) {\n-                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                    final boolean markPrimed = !moreData;\n-                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                        updaterManager.execute(graph -> {\n-                            updateHandler.update(serviceDelivery);\n-                            if (markPrimed) primed = true;\n-                        });\n-                    }\n+        boolean moreData = false;\n+        do {\n+            Siri updates = getUpdates();\n+            if (updates != null) {\n+                ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+                // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+                moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+                final boolean markPrimed = !moreData;\n+                if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+                    updaterManager.execute(graph -> {\n+                        updateHandler.update(serviceDelivery);\n+                        if (markPrimed) primed = true;\n+                    });\n                 }\n-            } while (moreData);\n-        } catch (IOException e) {\n-\n-            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n-\n-            retryCount++;\n-\n-            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n-\n-            try {\n-                Thread.sleep(sleepTime);\n-            } catch (InterruptedException ex) {\n-                //Ignore\n             }\n-\n-            // Creating new requestorRef so all data is refreshed\n-            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n-            runPolling();\n-        }\n+        } while (moreData);\n     }\n \n-    private Siri getUpdates() throws IOException {\n+    private Siri getUpdates() {\n \n         long t1 = System.currentTimeMillis();\n         long creating = 0;\n", "next_change": {"commit": "9cd28885f3514bc725578dc1e1c893dfec8bf0a4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\nindex 3bfec11d41..30f9be38bc 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n", "chunk": "@@ -84,25 +97,44 @@ public class SiriSXUpdater extends PollingGraphUpdater {\n \n     @Override\n     protected void runPolling() {\n-        boolean moreData = false;\n-        do {\n-            Siri updates = getUpdates();\n-            if (updates != null) {\n-                ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                final boolean markPrimed = !moreData;\n-                if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                    updaterManager.execute(graph -> {\n-                        updateHandler.update(serviceDelivery);\n-                        if (markPrimed) primed = true;\n-                    });\n+        try {\n+            boolean moreData = false;\n+            do {\n+                Siri updates = getUpdates();\n+                if (updates != null) {\n+                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+                    final boolean markPrimed = !moreData;\n+                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+                        updaterManager.execute(graph -> {\n+                            updateHandler.update(serviceDelivery);\n+                            if (markPrimed) primed = true;\n+                        });\n+                    }\n                 }\n+            } while (moreData);\n+        } catch (IOException e) {\n+\n+            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n+\n+            retryCount++;\n+\n+            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException ex) {\n+                //Ignore\n             }\n-        } while (moreData);\n+\n+            // Creating new requestorRef so all data is refreshed\n+            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n+            runPolling();\n+        }\n     }\n \n-    private Siri getUpdates() {\n+    private Siri getUpdates() throws IOException {\n \n         long t1 = System.currentTimeMillis();\n         long creating = 0;\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\nindex 30f9be38bc..b4ee644ecc 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n", "chunk": "@@ -8,190 +12,184 @@ import org.opentripplanner.routing.RoutingService;\n import org.opentripplanner.routing.graph.Graph;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.routing.services.TransitAlertService;\n-import org.opentripplanner.updater.GraphUpdaterManager;\n import org.opentripplanner.updater.PollingGraphUpdater;\n+import org.opentripplanner.updater.WriteToGraphCallback;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import uk.org.siri.siri20.ServiceDelivery;\n import uk.org.siri.siri20.Siri;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.time.ZonedDateTime;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.UUID;\n-\n public class SiriSXUpdater extends PollingGraphUpdater {\n-    private static final Logger LOG = LoggerFactory.getLogger(SiriSXUpdater.class);\n-    private static final long RETRY_INTERVAL_MILLIS = 5000;\n \n-    private GraphUpdaterManager updaterManager;\n+  private static final Logger LOG = LoggerFactory.getLogger(SiriSXUpdater.class);\n+  private static final long RETRY_INTERVAL_MILLIS = 5000;\n \n-    private ZonedDateTime lastTimestamp = ZonedDateTime.now().minusWeeks(1);\n+  private WriteToGraphCallback saveResultOnGraph;\n \n-    private final String url;\n+  private ZonedDateTime lastTimestamp = ZonedDateTime.now().minusWeeks(1);\n \n-    private final String feedId;\n+  private final String url;\n \n-    private TransitAlertService transitAlertService;\n+  private final String feedId;\n \n-    private final long earlyStart;\n+  private TransitAlertService transitAlertService;\n \n-    private SiriAlertsUpdateHandler updateHandler = null;\n+  private final long earlyStart;\n \n-    private String requestorRef;\n+  private SiriAlertsUpdateHandler updateHandler = null;\n \n-    private int timeout;\n+  private String requestorRef;\n \n-    private static final Map<String, String> requestHeaders = new HashMap<>();\n+  private int timeout;\n \n+  private int retryCount = 0;\n+  private final String originalRequestorRef;\n \n-    private int retryCount = 0;\n-    private final String originalRequestorRef;\n+  public SiriSXUpdater(SiriSXUpdaterParameters config) {\n+    super(config);\n+    // TODO: add options to choose different patch services\n+    this.url = config.getUrl();\n+    this.requestorRef = config.getRequestorRef();\n+    this.earlyStart = config.getEarlyStartSec();\n+    this.feedId = config.getFeedId();\n \n-    public SiriSXUpdater(SiriSXUpdaterParameters config) {\n-        super(config);\n-        // TODO: add options to choose different patch services\n-        this.url = config.getUrl();\n-        this.requestorRef = config.getRequestorRef();\n-        this.earlyStart = config.getEarlyStartSec();\n-        this.feedId = config.getFeedId();\n-\n-        if (requestorRef == null || requestorRef.isEmpty()) {\n-            requestorRef = \"otp-\" + UUID.randomUUID().toString();\n-        }\n-\n-        //Keeping original requestorRef use as base for updated requestorRef to be used in retries\n-        this.originalRequestorRef = requestorRef;\n-\n-        int timeoutSec = config.getTimeoutSec();\n-        if (timeoutSec > 0) {\n-            this.timeout = 1000 * timeoutSec;\n-        }\n-\n-        blockReadinessUntilInitialized = config.blockReadinessUntilInitialized();\n+    if (requestorRef == null || requestorRef.isEmpty()) {\n+      requestorRef = \"otp-\" + UUID.randomUUID().toString();\n+    }\n \n-        requestHeaders.put(\"ET-Client-Name\", SiriHttpUtils.getUniqueETClientName(\"-SX\"));\n+    //Keeping original requestorRef use as base for updated requestorRef to be used in retries\n+    this.originalRequestorRef = requestorRef;\n \n-        LOG.info(\"Creating real-time alert updater (SIRI SX) running every {} seconds : {}\", pollingPeriodSeconds, url);\n+    int timeoutSec = config.getTimeoutSec();\n+    if (timeoutSec > 0) {\n+      this.timeout = 1000 * timeoutSec;\n     }\n \n-    @Override\n-    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n-        this.updaterManager = updaterManager;\n+    blockReadinessUntilInitialized = config.blockReadinessUntilInitialized();\n+\n+    LOG.info(\n+      \"Creating real-time alert updater (SIRI SX) running every {} seconds : {}\",\n+      pollingPeriodSeconds,\n+      url\n+    );\n+  }\n+\n+  @Override\n+  public void setGraphUpdaterManager(WriteToGraphCallback saveResultOnGraph) {\n+    this.saveResultOnGraph = saveResultOnGraph;\n+  }\n+\n+  @Override\n+  public void setup(Graph graph) {\n+    this.transitAlertService = new TransitAlertServiceImpl(graph);\n+    SiriFuzzyTripMatcher fuzzyTripMatcher = new SiriFuzzyTripMatcher(new RoutingService(graph));\n+    if (updateHandler == null) {\n+      updateHandler = new SiriAlertsUpdateHandler(feedId, graph);\n     }\n-\n-    @Override\n-    public void setup(Graph graph) {\n-        this.transitAlertService = new TransitAlertServiceImpl(graph);\n-        SiriFuzzyTripMatcher fuzzyTripMatcher = new SiriFuzzyTripMatcher(new RoutingService(graph));\n-        if (updateHandler == null) {\n-            updateHandler = new SiriAlertsUpdateHandler(feedId);\n+    updateHandler.setEarlyStart(earlyStart);\n+    updateHandler.setTransitAlertService(transitAlertService);\n+    updateHandler.setSiriFuzzyTripMatcher(fuzzyTripMatcher);\n+  }\n+\n+  @Override\n+  protected void runPolling() {\n+    try {\n+      boolean moreData = false;\n+      do {\n+        Siri updates = getUpdates();\n+        if (updates != null) {\n+          ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+          // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+          moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+          final boolean markPrimed = !moreData;\n+          if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+            saveResultOnGraph.execute(graph -> {\n+              updateHandler.update(serviceDelivery);\n+              if (markPrimed) primed = true;\n+            });\n+          }\n         }\n-        updateHandler.setEarlyStart(earlyStart);\n-        updateHandler.setTransitAlertService(transitAlertService);\n-        updateHandler.setSiriFuzzyTripMatcher(fuzzyTripMatcher);\n+      } while (moreData);\n+    } catch (IOException e) {\n+      final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n \n-    }\n+      retryCount++;\n \n-    @Override\n-    protected void runPolling() {\n-        try {\n-            boolean moreData = false;\n-            do {\n-                Siri updates = getUpdates();\n-                if (updates != null) {\n-                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                    final boolean markPrimed = !moreData;\n-                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                        updaterManager.execute(graph -> {\n-                            updateHandler.update(serviceDelivery);\n-                            if (markPrimed) primed = true;\n-                        });\n-                    }\n-                }\n-            } while (moreData);\n-        } catch (IOException e) {\n-\n-            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n-\n-            retryCount++;\n-\n-            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n-\n-            try {\n-                Thread.sleep(sleepTime);\n-            } catch (InterruptedException ex) {\n-                //Ignore\n-            }\n-\n-            // Creating new requestorRef so all data is refreshed\n-            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n-            runPolling();\n-        }\n-    }\n+      LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n \n-    private Siri getUpdates() throws IOException {\n-\n-        long t1 = System.currentTimeMillis();\n-        long creating = 0;\n-        long fetching = 0;\n-        long unmarshalling = 0;\n-        try {\n-            String sxServiceRequest = SiriHelper.createSXServiceRequestAsXml(requestorRef);\n-            creating = System.currentTimeMillis()-t1;\n-            t1 = System.currentTimeMillis();\n-\n-            InputStream is = SiriHttpUtils.postData(url, sxServiceRequest, timeout, requestHeaders);\n-\n-            fetching = System.currentTimeMillis()-t1;\n-            t1 = System.currentTimeMillis();\n-\n-            Siri siri = SiriHelper.unmarshal(is);\n-\n-            unmarshalling = System.currentTimeMillis()-t1;\n-            if (siri == null) {\n-                throw new RuntimeException(\"Failed to get data from url \" + url);\n-            }\n-            ServiceDelivery serviceDelivery = siri.getServiceDelivery();\n-            if (serviceDelivery == null) {\n-                throw new RuntimeException(\"Failed to get serviceDelivery \" + url);\n-            }\n-\n-            ZonedDateTime responseTimestamp = serviceDelivery.getResponseTimestamp();\n-            if (responseTimestamp.isBefore(lastTimestamp)) {\n-                LOG.info(\"Ignoring feed with an old timestamp.\");\n-                return null;\n-            }\n-\n-            lastTimestamp = responseTimestamp;\n-            return siri;\n-        } catch (IOException e) {\n-            LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n-            LOG.error(\"Error reading SIRI feed from \" + url, e);\n-            throw e;\n-        } catch (Exception e) {\n-            LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n-            LOG.error(\"Error reading SIRI feed from \" + url, e);\n-        } finally {\n-            LOG.info(\"Updating SX [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\", requestorRef, creating, fetching, unmarshalling);\n-        }\n-        return null;\n-    }\n+      try {\n+        Thread.sleep(sleepTime);\n+      } catch (InterruptedException ex) {\n+        //Ignore\n+      }\n \n-    @Override\n-    public void teardown() {\n+      // Creating new requestorRef so all data is refreshed\n+      requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n+      runPolling();\n     }\n-\n-    public TransitAlertService getTransitAlertService() {\n-        return transitAlertService;\n+  }\n+\n+  private Siri getUpdates() throws IOException {\n+    long t1 = System.currentTimeMillis();\n+    long creating = 0;\n+    long fetching = 0;\n+    long unmarshalling = 0;\n+    try {\n+      String sxServiceRequest = SiriHelper.createSXServiceRequestAsXml(requestorRef);\n+      creating = System.currentTimeMillis() - t1;\n+      t1 = System.currentTimeMillis();\n+\n+      InputStream is = SiriHttpUtils.postData(url, sxServiceRequest, timeout);\n+\n+      fetching = System.currentTimeMillis() - t1;\n+      t1 = System.currentTimeMillis();\n+\n+      Siri siri = SiriHelper.unmarshal(is);\n+\n+      unmarshalling = System.currentTimeMillis() - t1;\n+      if (siri == null) {\n+        throw new RuntimeException(\"Failed to get data from url \" + url);\n+      }\n+      ServiceDelivery serviceDelivery = siri.getServiceDelivery();\n+      if (serviceDelivery == null) {\n+        throw new RuntimeException(\"Failed to get serviceDelivery \" + url);\n+      }\n+\n+      ZonedDateTime responseTimestamp = serviceDelivery.getResponseTimestamp();\n+      if (responseTimestamp.isBefore(lastTimestamp)) {\n+        LOG.info(\"Ignoring feed with an old timestamp.\");\n+        return null;\n+      }\n+\n+      lastTimestamp = responseTimestamp;\n+      return siri;\n+    } catch (IOException e) {\n+      LOG.info(\"Failed after {} ms\", (System.currentTimeMillis() - t1));\n+      LOG.error(\"Error reading SIRI feed from \" + url, e);\n+      throw e;\n+    } catch (Exception e) {\n+      LOG.info(\"Failed after {} ms\", (System.currentTimeMillis() - t1));\n+      LOG.error(\"Error reading SIRI feed from \" + url, e);\n+    } finally {\n+      LOG.info(\n+        \"Updating SX [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\",\n+        requestorRef,\n+        creating,\n+        fetching,\n+        unmarshalling\n+      );\n     }\n+    return null;\n+  }\n \n-    public String toString() {\n-        return \"SiriSXUpdater (\" + url + \")\";\n-    }\n+  @Override\n+  public void teardown() {}\n+\n+  public TransitAlertService getTransitAlertService() {\n+    return transitAlertService;\n+  }\n \n+  public String toString() {\n+    return \"SiriSXUpdater (\" + url + \")\";\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\nindex b4ee644ecc..0865ef0de6 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java\n", "chunk": "@@ -181,15 +182,4 @@ public class SiriSXUpdater extends PollingGraphUpdater {\n     }\n     return null;\n   }\n-\n-  @Override\n-  public void teardown() {}\n-\n-  public TransitAlertService getTransitAlertService() {\n-    return transitAlertService;\n-  }\n-\n-  public String toString() {\n-    return \"SiriSXUpdater (\" + url + \")\";\n-  }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "7f368f13888d0064861bfbd762aa81da2bc98ed9", "committedDate": "2020-09-30 18:36:43 +0200", "message": "Clean code: Cleanup SiriSXUpdater configuration."}, {"oid": "ca979c809c8d6fb87f6681616377c43b50075ac2", "committedDate": "2020-09-30 18:36:43 +0200", "message": "Clean code: Cleanup SiriETUpdater configuration."}, {"oid": "9cd28885f3514bc725578dc1e1c893dfec8bf0a4", "committedDate": "2020-10-06 15:20:48 +0200", "message": "Merge remote-tracking branch 'otp/2.0-rc' into dev-2.x"}, {"oid": "a534ac2546944ec6921f2131ced5d9325e5dd2dd", "committedDate": "2020-11-12 12:10:31 +0100", "message": "Taking graph timezone into account when calculating alert validity"}, {"oid": "06b33ca2b8a7f3ec48c675d99c85ecf62c53e2ca", "committedDate": "2021-11-11 14:43:07 +0100", "message": "refactor: Remove dependency from updaters to GraphUpdaterManager"}, {"oid": "d3115bd53d016bd0ac140139f9800b17435cfe57", "committedDate": "2022-03-22 00:27:48 +0100", "message": "refactor: Remove unused method variables + fix tests"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "f3bc2d34cfa00ed37ea54e609d43d42e34c923c7", "committedDate": "2022-05-05 15:22:08 +0200", "message": "Siri updaters for Azure ServiceBus (#4106)"}, {"oid": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "committedDate": "2022-06-15 13:49:47 +0200", "message": "Introduce TransitService"}, {"oid": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "committedDate": "2022-06-15 16:35:25 +0200", "message": "Migrate methods from RoutingService to TransitService"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "7a1d07491d5096ef036fb1a5510585022796f019", "committedDate": "2022-08-10 13:27:09 +0300", "message": "Always pass requestHeaders in SIRI post requests"}, {"oid": "df906794b6a00de52887aff207eee0674836def9", "committedDate": "2022-08-10 14:02:14 +0300", "message": "Apply suggestions from code review"}, {"oid": "1e78dbfb2082be5402528b325a54c4cf1b9ca23c", "committedDate": "2022-08-24 20:02:59 +0200", "message": "refactor: Keep the fuzzyTripMatcher in updaters, allow for customizations."}, {"oid": "89aa0fafc82a536074e2a1cef54aa67db0d41ee0", "committedDate": "2022-08-25 13:24:31 +0200", "message": "refactor: Move logFrequency, maxSnapshotFrequency, purgeExpiredData to timetableUpdates in config"}, {"oid": "923da2de3a07e5529b7b669af99088061f1d5a4a", "committedDate": "2022-08-25 19:13:43 +0200", "message": "refactor: Move Updater setup content into constructor."}, {"oid": "424fa1beaf5aa636baa7bf61a7487316baf27365", "committedDate": "2022-10-06 15:42:04 +0200", "message": "Use singluar in updater package name"}, {"oid": "f8ea03240f72d884d73c53ddb348cf194d77f42a", "committedDate": "2023-01-20 15:28:55 +0200", "message": "Extract AffectsMapper"}, {"oid": "ee9cc8f3c8e5fa83fe08971680ff7ee9921710c2", "committedDate": "2023-02-14 17:26:06 +0200", "message": "Inline BooleanUtils.isTrue"}, {"oid": "c583e923363ed4eb91c9fbd69fd13bebb2ee5349", "committedDate": "2023-03-29 14:24:33 +0200", "message": "refactor: Create updater spi package"}, {"oid": "05c7abb588e23420978aa863618d78996beeb739", "committedDate": "2023-03-29 17:13:30 +0200", "message": "feature: Encapsulate http-headers for updaters and enable environment variable substitution"}, {"oid": "419bce2a6fd74fc913edc4e28e17ad94aff34a28", "committedDate": "2023-04-11 11:37:15 +0200", "message": "Add reusable headers type for GTFS-RT"}, {"oid": "1a659b8c5612249a09211271aa98116c04f798f2", "committedDate": "2023-04-26 15:35:24 +0200", "message": "Document Siri-SX updaters"}, {"oid": "539b94aa8b26fc050703bab5790b88ed81391184", "committedDate": "2023-05-04 10:33:58 +0200", "message": "Fix updater interruption when OTP shuts down"}, {"oid": "eaac0c7d1ac7cf0cd45802ed42c52d72f78feb7c", "committedDate": "2023-05-30 22:54:25 +0200", "message": "Make update frequency a Duration"}, {"oid": "5900d238481b6b0674a4e55d3eb89ba0a8abb104", "committedDate": "2023-06-06 16:07:28 +0200", "message": "refactor: Apply code review"}, {"oid": "08d565f8fa5a5203ea5b0863af9680371b006ad3", "committedDate": "2023-06-06 16:29:28 +0200", "message": "refactor: Make `SiriSXUpdaterParameters#timeout` a Duration"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTYxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487875617", "body": "Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better. ", "bodyText": "Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better.", "bodyHTML": "<p dir=\"auto\">Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better.</p>", "author": "t2gran", "createdAt": "2020-09-14T12:33:47Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java", "diffHunk": "@@ -90,6 +97,24 @@ public Siri getUpdates() {\n         } catch (Exception e) {", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjM1OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972358", "bodyText": "I fixed this.", "author": "t2gran", "createdAt": "2020-09-14T14:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex 6e88313a6c..ee003a07b6 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -94,11 +98,11 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n                 return siri;\n \n             }\n-        } catch (Exception e) {\n+        } catch (IOException | JAXBException | XMLStreamException e) {\n             LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n             LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n \n-            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n \n             retryCount++;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex 6e88313a6c..ee003a07b6 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -94,11 +98,11 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n                 return siri;\n \n             }\n-        } catch (Exception e) {\n+        } catch (IOException | JAXBException | XMLStreamException e) {\n             LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n             LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n \n-            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n \n             retryCount++;\n \n", "next_change": {"commit": "90d24a848034a2fe92c4c9a0f36ff4b136049c5c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex ee003a07b6..971afb3e9c 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -98,27 +77,9 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n                 return siri;\n \n             }\n-        } catch (IOException | JAXBException | XMLStreamException e) {\n+        } catch (Exception e) {\n             LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n             LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n-\n-            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n-\n-            retryCount++;\n-\n-            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n-\n-            try {\n-                Thread.sleep(sleepTime);\n-            } catch (InterruptedException ex) {\n-                // Ignore\n-            }\n-\n-            // Creating new requestorRef so all data is refreshed\n-            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n-\n-            return getUpdates();\n-\n         } finally {\n             LOG.info(\"Updating VM [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\", requestorRef, creating, fetching, unmarshalling);\n         }\n", "next_change": {"commit": "9cd28885f3514bc725578dc1e1c893dfec8bf0a4", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex 971afb3e9c..bb27ff0b17 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -77,9 +92,27 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n                 return siri;\n \n             }\n-        } catch (Exception e) {\n+        } catch (IOException | JAXBException | XMLStreamException e) {\n             LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n             LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n+\n+            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n+\n+            retryCount++;\n+\n+            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException ex) {\n+                // Ignore\n+            }\n+\n+            // Creating new requestorRef so all data is refreshed\n+            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n+\n+            return getUpdates();\n+\n         } finally {\n             LOG.info(\"Updating VM [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\", requestorRef, creating, fetching, unmarshalling);\n         }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex bb27ff0b17..43d90819fc 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -1,142 +1,138 @@\n package org.opentripplanner.ext.siri.updater;\n \n-import org.opentripplanner.ext.siri.SiriHttpUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import uk.org.siri.siri20.Siri;\n-\n-import javax.xml.bind.JAXBException;\n-import javax.xml.stream.XMLStreamException;\n import java.io.IOException;\n import java.io.InputStream;\n import java.time.ZonedDateTime;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.util.UUID;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.stream.XMLStreamException;\n+import org.opentripplanner.ext.siri.SiriHttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.Siri;\n \n public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n-    private static final Logger LOG = LoggerFactory.getLogger(SiriVMHttpTripUpdateSource.class);\n-\n-    private final static long RETRY_INTERVAL_MILLIS = 5000;\n-\n-    private static final Map<String, String> requestHeaders = new HashMap<>();\n-\n-    /**\n-     * True iff the last list with updates represent all updates that are active right now, i.e. all\n-     * previous updates should be disregarded\n-     */\n-    private boolean fullDataset = true;\n-\n-    /**\n-     * Feed id that is used to match trip ids in the TripUpdates\n-     */\n-    private final String feedId;\n-\n-    private final String url;\n-\n-    private ZonedDateTime lastTimestamp = ZonedDateTime.now().minusMonths(1);\n-\n-    private String requestorRef;\n-    private int timeout;\n-    private int retryCount = 0;\n-    private final String originalRequestorRef;\n \n+  private static final Logger LOG = LoggerFactory.getLogger(SiriVMHttpTripUpdateSource.class);\n \n+  private static final long RETRY_INTERVAL_MILLIS = 5000;\n \n-    public SiriVMHttpTripUpdateSource(Parameters parameters) {\n-        this.url = parameters.getUrl();\n-        this.requestorRef = parameters.getRequestorRef();\n-        if (requestorRef == null || requestorRef.isEmpty()) {\n-            requestorRef = \"otp-\" + UUID.randomUUID().toString();\n-        }\n-\n-        originalRequestorRef = this.requestorRef;\n-\n-        this.feedId = parameters.getFeedId();\n-\n-        int timeoutSec = parameters.getTimeoutSec();\n-        if (timeoutSec > 0) {\n-            this.timeout = 1000 * timeoutSec;\n-        }\n-\n-        requestHeaders.put(\"ET-Client-Name\", SiriHttpUtils.getUniqueETClientName(\"-VM\"));\n-    }\n-\n-    @Override\n-    public Siri getUpdates() {\n-        long t1 = System.currentTimeMillis();\n-        long creating = 0;\n-        long fetching = 0;\n-        long unmarshalling = 0;\n-\n-        fullDataset = false;\n-        try {\n-            String vmServiceRequest = SiriHelper.createVMServiceRequestAsXml(requestorRef);\n-            creating = System.currentTimeMillis()-t1;\n-            t1 = System.currentTimeMillis();\n-\n-            InputStream is = SiriHttpUtils.postData(url, vmServiceRequest, timeout, requestHeaders);\n-            if (is != null) {\n-                // Decode message\n-                fetching = System.currentTimeMillis()-t1;\n-                t1 = System.currentTimeMillis();\n-                Siri siri = SiriHelper.unmarshal(is);\n-                unmarshalling = System.currentTimeMillis()-t1;\n+  /**\n+   * True iff the last list with updates represent all updates that are active right now, i.e. all\n+   * previous updates should be disregarded\n+   */\n+  private boolean fullDataset = true;\n \n-                if (siri.getServiceDelivery().getResponseTimestamp().isBefore(lastTimestamp)) {\n-                    LOG.info(\"Newer data has already been processed\");\n-                    return null;\n-                }\n-                lastTimestamp = siri.getServiceDelivery().getResponseTimestamp();\n+  /**\n+   * Feed id that is used to match trip ids in the TripUpdates\n+   */\n+  private final String feedId;\n \n-                return siri;\n+  private final String url;\n \n-            }\n-        } catch (IOException | JAXBException | XMLStreamException e) {\n-            LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n-            LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n+  private ZonedDateTime lastTimestamp = ZonedDateTime.now().minusMonths(1);\n \n-            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n+  private String requestorRef;\n+  private int timeout;\n+  private int retryCount = 0;\n+  private final String originalRequestorRef;\n \n-            retryCount++;\n-\n-            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n-\n-            try {\n-                Thread.sleep(sleepTime);\n-            } catch (InterruptedException ex) {\n-                // Ignore\n-            }\n-\n-            // Creating new requestorRef so all data is refreshed\n-            requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n-\n-            return getUpdates();\n-\n-        } finally {\n-            LOG.info(\"Updating VM [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\", requestorRef, creating, fetching, unmarshalling);\n-        }\n-        return null;\n+  public SiriVMHttpTripUpdateSource(Parameters parameters) {\n+    this.url = parameters.getUrl();\n+    this.requestorRef = parameters.getRequestorRef();\n+    if (requestorRef == null || requestorRef.isEmpty()) {\n+      requestorRef = \"otp-\" + UUID.randomUUID();\n     }\n \n-    @Override\n-    public boolean getFullDatasetValueOfLastUpdates() {\n-        return fullDataset;\n-    }\n+    originalRequestorRef = this.requestorRef;\n \n-    public String toString() {\n-        return \"SiriVMHttpTripUpdateSource(\" + url + \")\";\n-    }\n+    this.feedId = parameters.getFeedId();\n \n-    @Override\n-    public String getFeedId() {\n-        return this.feedId;\n+    int timeoutSec = parameters.getTimeoutSec();\n+    if (timeoutSec > 0) {\n+      this.timeout = 1000 * timeoutSec;\n     }\n-\n-    interface Parameters {\n-        String getUrl();\n-        String getRequestorRef();\n-        String getFeedId();\n-        int getTimeoutSec();\n+  }\n+\n+  @Override\n+  public Siri getUpdates() {\n+    long t1 = System.currentTimeMillis();\n+    long creating = 0;\n+    long fetching = 0;\n+    long unmarshalling = 0;\n+\n+    fullDataset = false;\n+    try {\n+      String vmServiceRequest = SiriHelper.createVMServiceRequestAsXml(requestorRef);\n+      creating = System.currentTimeMillis() - t1;\n+      t1 = System.currentTimeMillis();\n+\n+      InputStream is = SiriHttpUtils.postData(url, vmServiceRequest, timeout);\n+      if (is != null) {\n+        // Decode message\n+        fetching = System.currentTimeMillis() - t1;\n+        t1 = System.currentTimeMillis();\n+        Siri siri = SiriHelper.unmarshal(is);\n+        unmarshalling = System.currentTimeMillis() - t1;\n+\n+        if (siri.getServiceDelivery().getResponseTimestamp().isBefore(lastTimestamp)) {\n+          LOG.info(\"Newer data has already been processed\");\n+          return null;\n+        }\n+        lastTimestamp = siri.getServiceDelivery().getResponseTimestamp();\n+\n+        return siri;\n+      }\n+    } catch (IOException | JAXBException | XMLStreamException e) {\n+      LOG.info(\"Failed after {} ms\", (System.currentTimeMillis() - t1));\n+      LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n+\n+      final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n+\n+      retryCount++;\n+\n+      LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+      try {\n+        Thread.sleep(sleepTime);\n+      } catch (InterruptedException ex) {\n+        // Ignore\n+      }\n+\n+      // Creating new requestorRef so all data is refreshed\n+      requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n+\n+      return getUpdates();\n+    } finally {\n+      LOG.info(\n+        \"Updating VM [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\",\n+        requestorRef,\n+        creating,\n+        fetching,\n+        unmarshalling\n+      );\n     }\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean getFullDatasetValueOfLastUpdates() {\n+    return fullDataset;\n+  }\n+\n+  public String toString() {\n+    return \"SiriVMHttpTripUpdateSource(\" + url + \")\";\n+  }\n+\n+  @Override\n+  public String getFeedId() {\n+    return this.feedId;\n+  }\n+\n+  interface Parameters {\n+    String getUrl();\n+    String getRequestorRef();\n+    String getFeedId();\n+    int getTimeoutSec();\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex 43d90819fc..8637358c04 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -120,19 +115,22 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n     return fullDataset;\n   }\n \n-  public String toString() {\n-    return \"SiriVMHttpTripUpdateSource(\" + url + \")\";\n-  }\n-\n   @Override\n   public String getFeedId() {\n     return this.feedId;\n   }\n \n+  public String toString() {\n+    return \"SiriVMHttpTripUpdateSource(\" + url + \")\";\n+  }\n+\n   interface Parameters {\n     String getUrl();\n+\n     String getRequestorRef();\n+\n     String getFeedId();\n+\n     int getTimeoutSec();\n   }\n }\n", "next_change": {"commit": "f722146b977930ffcae9226a04dce80fbad5e445", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\ndeleted file mode 100644\nindex 8637358c04..0000000000\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ /dev/null\n", "chunk": "@@ -1,136 +0,0 @@\n-package org.opentripplanner.ext.siri.updater;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.time.ZonedDateTime;\n-import java.util.UUID;\n-import javax.xml.bind.JAXBException;\n-import javax.xml.stream.XMLStreamException;\n-import org.opentripplanner.ext.siri.SiriHttpUtils;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import uk.org.siri.siri20.Siri;\n-\n-public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n-\n-  private static final Logger LOG = LoggerFactory.getLogger(SiriVMHttpTripUpdateSource.class);\n-\n-  private static final long RETRY_INTERVAL_MILLIS = 5000;\n-  /**\n-   * Feed id that is used to match trip ids in the TripUpdates\n-   */\n-  private final String feedId;\n-  private final String url;\n-  private final String originalRequestorRef;\n-  /**\n-   * True iff the last list with updates represent all updates that are active right now, i.e. all\n-   * previous updates should be disregarded\n-   */\n-  private boolean fullDataset = true;\n-  private ZonedDateTime lastTimestamp = ZonedDateTime.now().minusMonths(1);\n-  private String requestorRef;\n-  private int timeout;\n-  private int retryCount = 0;\n-\n-  public SiriVMHttpTripUpdateSource(Parameters parameters) {\n-    this.url = parameters.getUrl();\n-    this.requestorRef = parameters.getRequestorRef();\n-    if (requestorRef == null || requestorRef.isEmpty()) {\n-      requestorRef = \"otp-\" + UUID.randomUUID();\n-    }\n-\n-    originalRequestorRef = this.requestorRef;\n-\n-    this.feedId = parameters.getFeedId();\n-\n-    int timeoutSec = parameters.getTimeoutSec();\n-    if (timeoutSec > 0) {\n-      this.timeout = 1000 * timeoutSec;\n-    }\n-  }\n-\n-  @Override\n-  public Siri getUpdates() {\n-    long t1 = System.currentTimeMillis();\n-    long creating = 0;\n-    long fetching = 0;\n-    long unmarshalling = 0;\n-\n-    fullDataset = false;\n-    try {\n-      String vmServiceRequest = SiriHelper.createVMServiceRequestAsXml(requestorRef);\n-      creating = System.currentTimeMillis() - t1;\n-      t1 = System.currentTimeMillis();\n-\n-      InputStream is = SiriHttpUtils.postData(url, vmServiceRequest, timeout);\n-      if (is != null) {\n-        // Decode message\n-        fetching = System.currentTimeMillis() - t1;\n-        t1 = System.currentTimeMillis();\n-        Siri siri = SiriHelper.unmarshal(is);\n-        unmarshalling = System.currentTimeMillis() - t1;\n-\n-        if (siri.getServiceDelivery().getResponseTimestamp().isBefore(lastTimestamp)) {\n-          LOG.info(\"Newer data has already been processed\");\n-          return null;\n-        }\n-        lastTimestamp = siri.getServiceDelivery().getResponseTimestamp();\n-\n-        return siri;\n-      }\n-    } catch (IOException | JAXBException | XMLStreamException e) {\n-      LOG.info(\"Failed after {} ms\", (System.currentTimeMillis() - t1));\n-      LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n-\n-      final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n-\n-      retryCount++;\n-\n-      LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n-\n-      try {\n-        Thread.sleep(sleepTime);\n-      } catch (InterruptedException ex) {\n-        // Ignore\n-      }\n-\n-      // Creating new requestorRef so all data is refreshed\n-      requestorRef = originalRequestorRef + \"-retry-\" + retryCount;\n-\n-      return getUpdates();\n-    } finally {\n-      LOG.info(\n-        \"Updating VM [{}]: Create req: {}, Fetching data: {}, Unmarshalling: {}\",\n-        requestorRef,\n-        creating,\n-        fetching,\n-        unmarshalling\n-      );\n-    }\n-    return null;\n-  }\n-\n-  @Override\n-  public boolean getFullDatasetValueOfLastUpdates() {\n-    return fullDataset;\n-  }\n-\n-  @Override\n-  public String getFeedId() {\n-    return this.feedId;\n-  }\n-\n-  public String toString() {\n-    return \"SiriVMHttpTripUpdateSource(\" + url + \")\";\n-  }\n-\n-  interface Parameters {\n-    String getUrl();\n-\n-    String getRequestorRef();\n-\n-    String getFeedId();\n-\n-    int getTimeoutSec();\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "90d24a848034a2fe92c4c9a0f36ff4b136049c5c", "committedDate": "2020-09-30 18:36:43 +0200", "message": "Clean code: Cleanup SiriVMUpdater configuration."}, {"oid": "9cd28885f3514bc725578dc1e1c893dfec8bf0a4", "committedDate": "2020-10-06 15:20:48 +0200", "message": "Merge remote-tracking branch 'otp/2.0-rc' into dev-2.x"}, {"oid": "d3115bd53d016bd0ac140139f9800b17435cfe57", "committedDate": "2022-03-22 00:27:48 +0100", "message": "refactor: Remove unused method variables + fix tests"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "7a1d07491d5096ef036fb1a5510585022796f019", "committedDate": "2022-08-10 13:27:09 +0300", "message": "Always pass requestHeaders in SIRI post requests"}, {"oid": "df906794b6a00de52887aff207eee0674836def9", "committedDate": "2022-08-10 14:02:14 +0300", "message": "Apply suggestions from code review"}, {"oid": "94a84ffe37cb417e0a6b6e0738195937bb85eb2e", "committedDate": "2022-09-21 16:12:24 +0200", "message": "Use placeholders in logger messages"}, {"oid": "7ce72cf554e6cf469d683869db5684eae3ce86f8", "committedDate": "2023-01-11 15:07:24 +0100", "message": "Migrate Jakarta packages"}, {"oid": "f722146b977930ffcae9226a04dce80fbad5e445", "committedDate": "2023-02-22 12:06:08 +0200", "message": "Remove unused SIRI-VM updaters"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MzQ1MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487893451", "body": "This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an `TransitEntity` or that the id is made uniq in all contexts it exist.\r\n\r\nIn OTP the `TransitEntity.equals` means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a `TripPattern`?", "bodyText": "This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an TransitEntity or that the id is made uniq in all contexts it exist.\nIn OTP the TransitEntity.equals means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a TripPattern?", "bodyHTML": "<p dir=\"auto\">This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an <code>TransitEntity</code> or that the id is made uniq in all contexts it exist.</p>\n<p dir=\"auto\">In OTP the <code>TransitEntity.equals</code> means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a <code>TripPattern</code>?</p>", "author": "t2gran", "createdAt": "2020-09-14T13:01:27Z", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        TripPattern that = (TripPattern) o;\n+        return directionId == that.directionId &&\n+                Objects.equal(id, that.id) &&\n+                Objects.equal(name, that.name) &&\n+                Objects.equal(route, that.route) &&\n+                Objects.equal(stopPattern, that.stopPattern) &&\n+                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equal(trips, that.trips) &&\n+                Objects.equal(hopGeometries, that.hopGeometries) &&\n+                Objects.equal(perStopFlags, that.perStopFlags) &&\n+                Objects.equal(services, that.services);\n+    }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4OTQ4NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494989484", "bodyText": "The TripPattern is used as a Key in a Set in quite a few places. RegExp Search for (Map|Set)<TripPattern.  This make it difficult to wrap it to \"extend\" the hashCode/equals method - so it might not be easy to remove the above method.\nWe should check witch fields we can remove from the equals method, at least the hopGeometries should be removed?\nIf we keep the equals method, then we need to add documentation why and add a hashCode. We will discuss this next Tuesday  in the OTP developer meeting.", "author": "t2gran", "createdAt": "2020-09-25T13:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MzQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbfa..890dc1c7ed 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -655,14 +678,27 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         }\n         TripPattern that = (TripPattern) o;\n         return directionId == that.directionId &&\n-                Objects.equal(id, that.id) &&\n-                Objects.equal(name, that.name) &&\n-                Objects.equal(route, that.route) &&\n-                Objects.equal(stopPattern, that.stopPattern) &&\n-                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n-                Objects.equal(trips, that.trips) &&\n-                Objects.equal(hopGeometries, that.hopGeometries) &&\n-                Objects.equal(perStopFlags, that.perStopFlags) &&\n-                Objects.equal(services, that.services);\n+                Objects.equals(id, that.id) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(route, that.route) &&\n+                Objects.equals(stopPattern, that.stopPattern) &&\n+                Objects.equals(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equals(trips, that.trips) &&\n+                Objects.equals(services, that.services) &&\n+                Arrays.equals(perStopFlags, that.perStopFlags);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 31 * Objects.hash(\n+            id,\n+            name,\n+            route,\n+            directionId,\n+            stopPattern,\n+            scheduledTimetable,\n+            trips,\n+            services\n+        ) + Arrays.hashCode(perStopFlags);\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbfa..890dc1c7ed 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -655,14 +678,27 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         }\n         TripPattern that = (TripPattern) o;\n         return directionId == that.directionId &&\n-                Objects.equal(id, that.id) &&\n-                Objects.equal(name, that.name) &&\n-                Objects.equal(route, that.route) &&\n-                Objects.equal(stopPattern, that.stopPattern) &&\n-                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n-                Objects.equal(trips, that.trips) &&\n-                Objects.equal(hopGeometries, that.hopGeometries) &&\n-                Objects.equal(perStopFlags, that.perStopFlags) &&\n-                Objects.equal(services, that.services);\n+                Objects.equals(id, that.id) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(route, that.route) &&\n+                Objects.equals(stopPattern, that.stopPattern) &&\n+                Objects.equals(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equals(trips, that.trips) &&\n+                Objects.equals(services, that.services) &&\n+                Arrays.equals(perStopFlags, that.perStopFlags);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 31 * Objects.hash(\n+            id,\n+            name,\n+            route,\n+            directionId,\n+            stopPattern,\n+            scheduledTimetable,\n+            trips,\n+            services\n+        ) + Arrays.hashCode(perStopFlags);\n     }\n }\n", "next_change": {"commit": "d8afd66107af2c11641b13cdfa0c02841c11ed7f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 890dc1c7ed..9610aaf372 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,64 +653,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n \n-    /**\n-     * Need an equals() since trips in a pattern are no longer necessarily running on the same\n-     * service ID.\n-     * <p>\n-     * A TransitEntity SHOULD not implement hashCode/equals. We make an EXCEPTION to this for\n-     * TripPattern, because the alternative is worse. Since TripPatterns are cloned and changed by\n-     * realtime updates and exist in a \"global\" space in Sets/Maps, the equals and hash code\n-     * need to include all elements that can be changed. We could make a wrapper type and implement\n-     * hc/eq for that and use that in all Set/Maps, but that would also ve quite messy. The REAL\n-     * fix to this problem is to make TripPattern unique within the context it live. This is a\n-     * larger task and should be addressed when implementing the issue:\n-     * https://github.com/opentripplanner/OpenTripPlanner/issues/3030\n-     * <p>\n-     * The TripPattern is used as a <em>key</em> in a Set/Map in quite a few places. Use a reg-exp\n-     * search for \"(Map|Set)<TripPattern\") to find the places where it is used.\n-     * <p>\n-     * Note! Classes that have mutable fields that are part of eq/hc are vulnerable. If added to a\n-     * Set/Map the set/map MUST be re-indexed it the object is mutated. When mutating TripPattens\n-     * make sure the object is NOT part of an existing Set/Map.\n-     * <p>\n-     * {@code hopGeometries}  is NOT part of the equals/hashCode methods to avoid costly\n-     * computations. Hence; It is not allowed to ONLY change the hopGeometries, but at least one\n-     * other field must be changed.\n-     */\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        if (!super.equals(o)) {\n-            return false;\n-        }\n-        TripPattern that = (TripPattern) o;\n-        return directionId == that.directionId &&\n-                Objects.equals(id, that.id) &&\n-                Objects.equals(name, that.name) &&\n-                Objects.equals(route, that.route) &&\n-                Objects.equals(stopPattern, that.stopPattern) &&\n-                Objects.equals(scheduledTimetable, that.scheduledTimetable) &&\n-                Objects.equals(trips, that.trips) &&\n-                Objects.equals(services, that.services) &&\n-                Arrays.equals(perStopFlags, that.perStopFlags);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return 31 * Objects.hash(\n-            id,\n-            name,\n-            route,\n-            directionId,\n-            stopPattern,\n-            scheduledTimetable,\n-            trips,\n-            services\n-        ) + Arrays.hashCode(perStopFlags);\n-    }\n }\n", "next_change": {"commit": "7fdcfaf8104e8b2fa94ef78591c7471399dad484", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 9610aaf372..83329f8610 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -652,5 +641,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "d57c16470beca49f137f0c7b8f7097482e4a9137", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 83329f8610..4b7fa7e328 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,4 +665,5 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n }\n", "next_change": {"commit": "945184168355309126bbeb74919f6d3df1d37fa6", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 4b7fa7e328..94a91c45b8 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -665,5 +643,4 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "be23b905919c899bb3ec790669334ba5b3a84619", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 94a91c45b8..07625c72a6 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -643,4 +667,5 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n }\n", "next_change": {"commit": "58ae629e67912dd4f984dd6300e3e1397806e09c", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 07625c72a6..b6c23dd4fd 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -667,5 +645,4 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n }\n", "next_change": {"commit": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex b6c23dd4fd..884b6c2512 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -639,7 +608,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n      */\n     public String getFeedId() {\n         // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return route.getId().getFeedId();\n+        return getRoute().getId().getFeedId();\n     }\n \n     private static Coordinate coordinate(Stop s) {\n", "next_change": {"commit": "55c7116430720c1c91c2673787cb9593f64d658f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 884b6c2512..45de28a851 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -608,7 +604,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n      */\n     public String getFeedId() {\n         // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return getRoute().getId().getFeedId();\n+        return route.getId().getFeedId();\n     }\n \n     private static Coordinate coordinate(Stop s) {\n", "next_change": {"commit": "acf334d3ee4956c41586785ceba398104a8e43c4", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 45de28a851..d6e020e01e 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -607,7 +607,7 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n         return route.getId().getFeedId();\n     }\n \n-    private static Coordinate coordinate(Stop s) {\n+    private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n }\n", "next_change": {"commit": "594f8f4b4825bfc1e8513df756fbc20f499c9e26", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex d6e020e01e..d9004abe4a 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -607,6 +619,14 @@ public class TripPattern extends TransitEntity implements Cloneable, Serializabl\n         return route.getId().getFeedId();\n     }\n \n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        // The serialized graph contains cyclic references TripPattern <--> Timetable.\n+        // The Timetable must be indexed from here (rather than in its own readObject method)\n+        // to ensure that the stops field it uses in TripPattern is already deserialized.\n+        scheduledTimetable.finish();\n+    }\n+\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n", "next_change": {"commit": "848c857db3f9b6c71b6aab429c7b0e4326b2b566", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex d9004abe4a..83e75aac7c 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -630,4 +684,24 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    public void removeVehiclePositionIf(Predicate<String> predicate) {\n+        vehiclePositions.keySet().removeIf(predicate);\n+        if(vehiclePositions.isEmpty()) {\n+            // saves a bit of memory for patterns that no longer have positions\n+            vehiclePositions = Map.of();\n+        }\n+    }\n+\n+    public Map<String, RealtimeVehiclePosition> getVehiclePositions() {\n+        return Map.copyOf(vehiclePositions);\n+    }\n+\n+    public void addVehiclePosition(String tripId, RealtimeVehiclePosition vehiclePositions) {\n+        // the default value is Map.of() which saves memory but is immutable\n+        if(this.vehiclePositions.isEmpty()) {\n+            this.vehiclePositions = new HashMap<>();\n+        }\n+        this.vehiclePositions.put(tripId, vehiclePositions);\n+    }\n }\n", "next_change": {"commit": "a01a41d0d979f959a0c9a712db8a7c9d91970ecf", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 83e75aac7c..115d5937af 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -684,24 +677,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     private static Coordinate coordinate(StopLocation s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n-\n-    public void removeVehiclePositionIf(Predicate<String> predicate) {\n-        vehiclePositions.keySet().removeIf(predicate);\n-        if(vehiclePositions.isEmpty()) {\n-            // saves a bit of memory for patterns that no longer have positions\n-            vehiclePositions = Map.of();\n-        }\n-    }\n-\n-    public Map<String, RealtimeVehiclePosition> getVehiclePositions() {\n-        return Map.copyOf(vehiclePositions);\n-    }\n-\n-    public void addVehiclePosition(String tripId, RealtimeVehiclePosition vehiclePositions) {\n-        // the default value is Map.of() which saves memory but is immutable\n-        if(this.vehiclePositions.isEmpty()) {\n-            this.vehiclePositions = new HashMap<>();\n-        }\n-        this.vehiclePositions.put(tripId, vehiclePositions);\n-    }\n }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 115d5937af..f6cc4bd6e9 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -46,635 +47,698 @@ import org.slf4j.LoggerFactory;\n  */\n public final class TripPattern extends TransitEntity implements Cloneable, Serializable {\n \n-    private static final Logger LOG = LoggerFactory.getLogger(TripPattern.class);\n-\n-    private static final long serialVersionUID = 1;\n-\n-    private String name;\n-\n-    private final Route route;\n-\n-    /**\n-     * The stop-pattern help us reuse the same stops in several trip-patterns; Hence\n-     * saving memory. The field should not be accessible outside the class, and all access\n-     * is done through method delegation, like the {@link #numberOfStops()} and\n-     * {@link #canBoard(int)} methods.\n-     */\n-    private final StopPattern stopPattern;\n-\n-    private final Timetable scheduledTimetable = new Timetable(this);\n-\n-    /**\n-     * Geometries of each inter-stop segment of the tripPattern.\n-     */\n-    private byte[][] hopGeometries = null;\n-\n-    /**\n-     * The original TripPattern this replaces at least for one modified trip.\n-     */\n-    private TripPattern originalTripPattern = null;\n-\n-    /**\n-     * Has the TripPattern been created by a real-time update.\n-     */\n-    private boolean createdByRealtimeUpdater = false;\n-\n-    // TODO MOVE codes INTO Timetable or TripTimes\n-    private BitSet services;\n-\n-    public TripPattern(FeedScopedId id, Route route, StopPattern stopPattern) {\n-        super(id);\n-        this.route = route;\n-        this.stopPattern = stopPattern;\n-    }\n-\n-    /** The human-readable, unique name for this trip pattern. */\n-    public String getName() {\n-        return name;\n-    }\n-\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    /**\n-     * The GTFS Route of all trips in this pattern.\n-     */\n-    public Route getRoute() {\n-        return route;\n-    }\n-\n-    /**\n-     * Convenience method to get the route traverse mode, the mode for all trips in this pattern.\n-     */\n-    public TransitMode getMode() {\n-        return route.getMode();\n+  private static final Logger LOG = LoggerFactory.getLogger(TripPattern.class);\n+\n+  private static final long serialVersionUID = 1;\n+\n+  private String name;\n+\n+  private final Route route;\n+\n+  /**\n+   * The stop-pattern help us reuse the same stops in several trip-patterns; Hence\n+   * saving memory. The field should not be accessible outside the class, and all access\n+   * is done through method delegation, like the {@link #numberOfStops()} and\n+   * {@link #canBoard(int)} methods.\n+   */\n+  private final StopPattern stopPattern;\n+\n+  private final Timetable scheduledTimetable = new Timetable(this);\n+\n+  /**\n+   * Geometries of each inter-stop segment of the tripPattern.\n+   */\n+  private byte[][] hopGeometries = null;\n+\n+  /**\n+   * The original TripPattern this replaces at least for one modified trip.\n+   */\n+  private TripPattern originalTripPattern = null;\n+\n+  /**\n+   * Has the TripPattern been created by a real-time update.\n+   */\n+  private boolean createdByRealtimeUpdater = false;\n+\n+  // TODO MOVE codes INTO Timetable or TripTimes\n+  private BitSet services;\n+\n+  public TripPattern(FeedScopedId id, Route route, StopPattern stopPattern) {\n+    super(id);\n+    this.route = route;\n+    this.stopPattern = stopPattern;\n+  }\n+\n+  /** The human-readable, unique name for this trip pattern. */\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public void setName(String name) {\n+    this.name = name;\n+  }\n+\n+  /**\n+   * The GTFS Route of all trips in this pattern.\n+   */\n+  public Route getRoute() {\n+    return route;\n+  }\n+\n+  /**\n+   * Convenience method to get the route traverse mode, the mode for all trips in this pattern.\n+   */\n+  public TransitMode getMode() {\n+    return route.getMode();\n+  }\n+\n+  public String getNetexSubmode() {\n+    return route.getNetexSubmode();\n+  }\n+\n+  public LineString getHopGeometry(int stopPosInPattern) {\n+    if (hopGeometries != null) {\n+      return CompactLineString.uncompactLineString(hopGeometries[stopPosInPattern], false);\n+    } else {\n+      return GeometryUtils\n+        .getGeometryFactory()\n+        .createLineString(\n+          new Coordinate[] {\n+            coordinate(stopPattern.getStop(stopPosInPattern)),\n+            coordinate(stopPattern.getStop(stopPosInPattern + 1)),\n+          }\n+        );\n     }\n+  }\n+\n+  public StopPattern getStopPattern() {\n+    return stopPattern;\n+  }\n+\n+  public void setHopGeometries(LineString[] hopGeometries) {\n+    this.hopGeometries = new byte[hopGeometries.length][];\n+\n+    for (int i = 0; i < hopGeometries.length; i++) {\n+      setHopGeometry(i, hopGeometries[i]);\n+    }\n+  }\n+\n+  public void setHopGeometry(int i, LineString hopGeometry) {\n+    this.hopGeometries[i] = CompactLineString.compactLineString(hopGeometry, false);\n+  }\n+\n+  /**\n+   * This will copy the geometry from another TripPattern to this one. It checks if each hop is\n+   * between the same stops before copying that hop geometry. If the stops are different but lie\n+   * within same station, old geometry will be used with overwrite on first and last point\n+   * (to match new stop places). Otherwise, it will default to straight lines between hops.\n+   *\n+   * @param other TripPattern to copy geometry from\n+   */\n+  public void setHopGeometriesFromPattern(TripPattern other) {\n+    this.hopGeometries = new byte[numberOfStops() - 1][];\n+\n+    // This accounts for the new TripPattern provided by a real-time update and the one that is\n+    // being replaced having a different number of stops. In that case the geometry will be\n+    // preserved up until the first mismatching stop, and a straight line will be used for\n+    // all segments after that.\n+    int sizeOfShortestPattern = Math.min(numberOfStops(), other.numberOfStops());\n+\n+    for (int i = 0; i < sizeOfShortestPattern - 1; i++) {\n+      final StopLocation oldOriginStop = this.getStop(i);\n+      final StopLocation oldDestinationStop = this.getStop(i + 1);\n+      final Station oldOriginStation = this.getStop(i).getParentStation();\n+      final Station oldDestinationStation = this.getStop(i + 1).getParentStation();\n+\n+      final StopLocation newOriginStop = other.getStop(i);\n+      final StopLocation newDestinationStop = other.getStop(i + 1);\n+      final Station newOriginStation = other.getStop(i).getParentStation();\n+      final Station newDestinationStation = other.getStop(i + 1).getParentStation();\n+\n+      boolean stopsAreSame =\n+        oldOriginStop.equals(newOriginStop) && oldDestinationStop.equals(newDestinationStop);\n+      boolean parentStationsAreSame =\n+        Objects.equals(oldOriginStation, newOriginStation) &&\n+        Objects.equals(oldDestinationStation, newDestinationStation);\n+\n+      LineString hopGeometry = other.getHopGeometry(i);\n+\n+      if (hopGeometry != null && stopsAreSame) {\n+        // Copy hop geometry from previous pattern\n+        this.setHopGeometry(i, other.getHopGeometry(i));\n+      } else if (hopGeometry != null && parentStationsAreSame) {\n+        // Use old geometry but patch first and last point with new stops\n+        Coordinate newStart = new Coordinate(\n+          other.getStop(i).getCoordinate().longitude(),\n+          other.getStop(i).getCoordinate().latitude()\n+        );\n \n-    public String getNetexSubmode() {\n-        return route.getNetexSubmode();\n-    }\n+        Coordinate newEnd = new Coordinate(\n+          other.getStop(i + 1).getCoordinate().longitude(),\n+          other.getStop(i + 1).getCoordinate().latitude()\n+        );\n \n-    public LineString getHopGeometry(int stopPosInPattern) {\n-        if (hopGeometries != null) {\n-            return CompactLineString.uncompactLineString(\n-                    hopGeometries[stopPosInPattern],\n-                    false\n-            );\n-        } else {\n-            return GeometryUtils.getGeometryFactory().createLineString(\n-                    new Coordinate[]{\n-                            coordinate(stopPattern.getStop(stopPosInPattern)),\n-                            coordinate(stopPattern.getStop(stopPosInPattern + 1))\n-                    }\n-            );\n+        Coordinate[] coordinates = other.getHopGeometry(i).getCoordinates().clone();\n+        coordinates[0].setCoordinate(newStart);\n+        coordinates[coordinates.length - 1].setCoordinate(newEnd);\n+\n+        this.setHopGeometry(i, GeometryUtils.getGeometryFactory().createLineString(coordinates));\n+      } else {\n+        // Create new straight-line geometry for hop\n+        this.setHopGeometry(\n+            i,\n+            GeometryUtils\n+              .getGeometryFactory()\n+              .createLineString(\n+                new Coordinate[] {\n+                  coordinate(stopPattern.getStop(i)),\n+                  coordinate(stopPattern.getStop(i + 1)),\n+                }\n+              )\n+          );\n+      }\n+    }\n+  }\n+\n+  public LineString getGeometry() {\n+    if (hopGeometries == null || hopGeometries.length == 0) {\n+      return null;\n+    }\n+\n+    List<LineString> lineStrings = new ArrayList<>();\n+    for (int i = 0; i < hopGeometries.length; i++) {\n+      lineStrings.add(getHopGeometry(i));\n+    }\n+    return GeometryUtils.concatenateLineStrings(lineStrings);\n+  }\n+\n+  public int numHopGeometries() {\n+    return hopGeometries.length;\n+  }\n+\n+  public int numberOfStops() {\n+    return stopPattern.getSize();\n+  }\n+\n+  public StopLocation getStop(int stopPosInPattern) {\n+    return stopPattern.getStop(stopPosInPattern);\n+  }\n+\n+  public StopLocation firstStop() {\n+    return getStop(0);\n+  }\n+\n+  public StopLocation lastStop() {\n+    return getStop(stopPattern.getSize() - 1);\n+  }\n+\n+  /** Read only list of stops */\n+  public List<StopLocation> getStops() {\n+    return stopPattern.getStops();\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop}. The search start at\n+   * position {@code 0}. Return a negative number if not found. Use {@link\n+   * #findAlightStopPositionInPattern(StopLocation)} or {@link #findBoardingStopPositionInPattern(StopLocation)}\n+   * if possible.\n+   */\n+  public int findStopPosition(StopLocation stop) {\n+    return stopPattern.findStopPosition(stop);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code station} where it is\n+   * allowed to board. The search start at position {@code 0}. Return a negative number if not\n+   * found.\n+   */\n+  public int findBoardingStopPositionInPattern(Station station) {\n+    return stopPattern.findBoardingPosition(station);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code station} where it is\n+   * allowed to alight. The search start at position {@code 1}. Return a negative number if not\n+   * found.\n+   */\n+  public int findAlightStopPositionInPattern(Station station) {\n+    return stopPattern.findAlightPosition(station);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n+   * to board. The search start at position {@code 0}. Return a negative number if not found.\n+   */\n+  public int findBoardingStopPositionInPattern(StopLocation stop) {\n+    return stopPattern.findBoardingPosition(stop);\n+  }\n+\n+  /**\n+   * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n+   * to alight. The search start at position {@code 1}. Return a negative number if not found.\n+   */\n+  public int findAlightStopPositionInPattern(StopLocation stop) {\n+    return stopPattern.findAlightPosition(stop);\n+  }\n+\n+  /** Returns whether passengers can alight at a given stop */\n+  public boolean canAlight(int stopIndex) {\n+    return stopPattern.canAlight(stopIndex);\n+  }\n+\n+  /** Returns whether passengers can board at a given stop */\n+  public boolean canBoard(int stopIndex) {\n+    return stopPattern.canBoard(stopIndex);\n+  }\n+\n+  /**\n+   * Returns whether passengers can board at a given stop.\n+   * This is an inefficient method iterating over the stops, do not use it in routing.\n+   */\n+  public boolean canBoard(StopLocation stop) {\n+    return stopPattern.canBoard(stop);\n+  }\n+\n+  /** Returns whether a given stop is wheelchair-accessible. */\n+  public boolean wheelchairAccessible(int stopIndex) {\n+    return stopPattern.getStop(stopIndex).getWheelchairBoarding() == WheelChairBoarding.POSSIBLE;\n+  }\n+\n+  public PickDrop getAlightType(int stopIndex) {\n+    return stopPattern.getDropoff(stopIndex);\n+  }\n+\n+  public PickDrop getBoardType(int stopIndex) {\n+    return stopPattern.getPickup(stopIndex);\n+  }\n+\n+  public boolean isBoardAndAlightAt(int stopIndex, PickDrop value) {\n+    return getBoardType(stopIndex).is(value) && getAlightType(stopIndex).is(value);\n+  }\n+\n+  public boolean stopPatternIsEqual(TripPattern other) {\n+    return stopPattern.equals(other.stopPattern);\n+  }\n+\n+  public Trip getTrip(int tripIndex) {\n+    return scheduledTimetable.getTripTimes(tripIndex).getTrip();\n+  }\n+\n+  /* METHODS THAT DELEGATE TO THE SCHEDULED TIMETABLE */\n+\n+  // TODO: These should probably be deprecated. That would require grabbing the scheduled timetable,\n+  // and would avoid mistakes where real-time updates are accidentally not taken into account.\n+\n+  /**\n+   * Add the given tripTimes to this pattern's scheduled timetable, recording the corresponding\n+   * trip as one of the scheduled trips on this pattern.\n+   */\n+  public void add(TripTimes tt) {\n+    // Only scheduled trips (added at graph build time, rather than directly to the timetable\n+    // via updates) are in this list.\n+    scheduledTimetable.addTripTimes(tt);\n+\n+    // Check that all trips added to this pattern are on the initially declared route.\n+    // Identity equality is valid on GTFS entity objects.\n+    if (this.route != tt.getTrip().getRoute()) {\n+      LOG.warn(\n+        \"The trip {} is on route {} but its stop pattern is on route {}.\",\n+        tt.getTrip(),\n+        tt.getTrip().getRoute(),\n+        route\n+      );\n+    }\n+  }\n+\n+  /**\n+   * Add the given FrequencyEntry to this pattern's scheduled timetable, recording the corresponding\n+   * trip as one of the scheduled trips on this pattern.\n+   * TODO possible improvements: combine freq entries and TripTimes. Do not keep trips list in TripPattern\n+   * since it is redundant.\n+   */\n+  public void add(FrequencyEntry freq) {\n+    scheduledTimetable.addFrequencyEntry(freq);\n+    if (this.getRoute() != freq.tripTimes.getTrip().getRoute()) {\n+      LOG.warn(\n+        \"The trip {} is on a different route than its stop pattern, which is on {}.\",\n+        freq.tripTimes.getTrip(),\n+        route\n+      );\n+    }\n+  }\n+\n+  /**\n+   * Remove all trips matching the given predicate.\n+   * @param removeTrip it the predicate returns true\n+   */\n+  public void removeTrips(Predicate<Trip> removeTrip) {\n+    scheduledTimetable.getTripTimes().removeIf(tt -> removeTrip.test(tt.getTrip()));\n+  }\n+\n+  public void setOriginalTripPattern(TripPattern originalTripPattern) {\n+    this.originalTripPattern = originalTripPattern;\n+  }\n+\n+  /**\n+   * The direction for all the trips in this pattern.\n+   */\n+  public Direction getDirection() {\n+    return scheduledTimetable.getDirection();\n+  }\n+\n+  /**\n+   * This pattern may have multiple Timetable objects, but they should all contain TripTimes\n+   * for the same trips, in the same order (that of the scheduled Timetable). An exception to\n+   * this rule may arise if unscheduled trips are added to a Timetable. For that case we need\n+   * to search for trips/TripIds in the Timetable rather than the enclosing TripPattern.\n+   */\n+  public Stream<Trip> scheduledTripsAsStream() {\n+    return scheduledTimetable.getTripTimes().stream().map(TripTimes::getTrip).distinct();\n+  }\n+\n+  /**\n+   * This is the \"original\" timetable holding the scheduled stop times from GTFS, with no\n+   * realtime updates applied. If realtime stoptime updates are applied, next/previous departure\n+   * searches will be conducted using a different, updated timetable in a snapshot.\n+   */\n+  public Timetable getScheduledTimetable() {\n+    return scheduledTimetable;\n+  }\n+\n+  /**\n+   * Has the TripPattern been created by a real-time update.\n+   */\n+  public boolean isCreatedByRealtimeUpdater() {\n+    return createdByRealtimeUpdater;\n+  }\n+\n+  public void setCreatedByRealtimeUpdater() {\n+    createdByRealtimeUpdater = true;\n+  }\n+\n+  private static String stopNameAndId(StopLocation stop) {\n+    return stop.getName() + \" (\" + stop.getId().toString() + \")\";\n+  }\n+\n+  /**\n+   * Static method that creates unique human-readable names for a collection of TableTripPatterns.\n+   * Perhaps this should be in TripPattern, and apply to Frequency patterns as well. TODO: resolve\n+   * this question: can a frequency and table pattern have the same stoppattern? If so should they\n+   * have the same \"unique\" name?\n+   *\n+   * The names should be dataset unique, not just route-unique?\n+   *\n+   * A TripPattern groups all trips visiting a particular pattern of stops on a particular route.\n+   * GFTS Route names are intended for very general customer information, but sometimes there is a\n+   * need to know where a particular trip actually goes. For example, the New York City N train\n+   * has at least four different variants: express (over the Manhattan bridge) and local (via\n+   * lower Manhattan and the tunnel), in two directions (to Astoria or to Coney Island). During\n+   * construction, a fifth variant sometimes appears: trains use the D line to Coney Island after\n+   * 59th St (or from Coney Island to 59th in the opposite direction).\n+   *\n+   * TripPattern names are machine-generated on a best-effort basis. They are guaranteed to be\n+   * unique (among TripPatterns for a single Route) but not stable across graph builds, especially\n+   * when different versions of GTFS inputs are used. For instance, if a variant is the only\n+   * variant of the N that ends at Coney Island, the name will be \"N to Coney Island\". But if\n+   * multiple variants end at Coney Island (but have different stops elsewhere), that name would\n+   * not be chosen. OTP also tries start and intermediate stations (\"from Coney Island\", or \"via\n+   * Whitehall\", or even combinations (\"from Coney Island via Whitehall\"). But if there is no way\n+   * to create a unique name from start/end/intermediate stops, then the best we can do is to\n+   * create a \"like [trip id]\" name, which at least tells you where in the GTFS you can find a\n+   * related trip.\n+   */\n+  // TODO: pass in a transit index that contains a Multimap<Route, TripPattern> and derive all TableTripPatterns\n+  // TODO: use headsigns before attempting to machine-generate names\n+  // TODO: combine from/to and via in a single name. this could be accomplished by grouping the trips by destination,\n+  // then disambiguating in groups of size greater than 1.\n+  /*\n+   * Another possible approach: for each route, determine the necessity of each field (which\n+   * combination will create unique names). from, to, via, express. Then concatenate all necessary\n+   * fields. Express should really be determined from number of stops and/or run time of trips.\n+   */\n+  public static void generateUniqueNames(\n+    Collection<TripPattern> tableTripPatterns,\n+    DataImportIssueStore issueStore\n+  ) {\n+    LOG.info(\"Generating unique names for stop patterns on each route.\");\n+    Set<String> usedRouteNames = Sets.newHashSet();\n+    Map<Route, String> uniqueRouteNames = Maps.newHashMap();\n+\n+    /* Group TripPatterns by Route */\n+    Multimap<Route, TripPattern> patternsByRoute = ArrayListMultimap.create();\n+    for (TripPattern ttp : tableTripPatterns) {\n+      patternsByRoute.put(ttp.route, ttp);\n+    }\n+\n+    /* Ensure we have a unique name for every Route */\n+    for (Route route : patternsByRoute.keySet()) {\n+      String routeName = route.getName();\n+      if (usedRouteNames.contains(routeName)) {\n+        int i = 2;\n+        String generatedRouteName;\n+        do generatedRouteName = routeName + \" \" + (i++); while (\n+          usedRouteNames.contains(generatedRouteName)\n+        );\n+        issueStore.add(new NonUniqueRouteName(generatedRouteName));\n+        routeName = generatedRouteName;\n+      }\n+      usedRouteNames.add(routeName);\n+      uniqueRouteNames.put(route, routeName);\n+    }\n+\n+    /* Iterate over all routes, giving the patterns within each route unique names. */\n+    ROUTE:for (Route route : patternsByRoute.keySet()) {\n+      Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n+      String routeName = uniqueRouteNames.get(route);\n+\n+      /* Simplest case: there's only one route variant, so we'll just give it the route's name. */\n+      if (routeTripPatterns.size() == 1) {\n+        routeTripPatterns.iterator().next().setName(routeName);\n+        continue;\n+      }\n+\n+      /* Do the patterns within this Route have a unique start, end, or via Stop? */\n+      Multimap<String, TripPattern> signs = ArrayListMultimap.create(); // prefer headsigns\n+      Multimap<StopLocation, TripPattern> starts = ArrayListMultimap.create();\n+      Multimap<StopLocation, TripPattern> ends = ArrayListMultimap.create();\n+      Multimap<StopLocation, TripPattern> vias = ArrayListMultimap.create();\n+\n+      for (TripPattern pattern : routeTripPatterns) {\n+        StopLocation start = pattern.firstStop();\n+        StopLocation end = pattern.lastStop();\n+        starts.put(start, pattern);\n+        ends.put(end, pattern);\n+        for (StopLocation stop : pattern.getStops()) {\n+          vias.put(stop, pattern);\n         }\n-    }\n-\n-    public void setHopGeometries(LineString[] hopGeometries) {\n-        this.hopGeometries = new byte[hopGeometries.length][];\n-\n-        for (int i = 0; i < hopGeometries.length; i++) {\n-            setHopGeometry(i, hopGeometries[i]);\n+      }\n+      PATTERN:for (TripPattern pattern : routeTripPatterns) {\n+        StringBuilder sb = new StringBuilder(routeName);\n+\n+        /* First try to name with destination. */\n+        var end = pattern.lastStop();\n+        sb.append(\" to \" + stopNameAndId(end));\n+        if (ends.get(end).size() == 1) {\n+          pattern.setName(sb.toString());\n+          continue PATTERN; // only pattern with this last stop\n         }\n-    }\n-\n-    public void setHopGeometry(int i, LineString hopGeometry) {\n-        this.hopGeometries[i] = CompactLineString.compactLineString(hopGeometry,false);\n-    }\n \n-    /**\n-     * This will copy the geometry from another TripPattern to this one. It checks if each hop is\n-     * between the same stops before copying that hop geometry. If the stops are different, a\n-     * straight-line hop-geometry will be used instead.\n-     *\n-     * @param other TripPattern to copy geometry from\n-     */\n-    public void setHopGeometriesFromPattern(TripPattern other) {\n-        this.hopGeometries = new byte[numberOfStops() - 1][];\n-\n-        // This accounts for the new TripPattern provided by a real-time update and the one that is\n-        // being replaced having a different number of stops. In that case the geometry will be\n-        // preserved up until the first mismatching stop, and a straight line will be used for\n-        // all segments after that.\n-        int sizeOfShortestPattern = Math.min(numberOfStops(), other.numberOfStops());\n-\n-        for (int i = 0; i < sizeOfShortestPattern - 1; i++) {\n-            if (other.getHopGeometry(i) != null\n-                && other.getStop(i).equals(this.getStop(i))\n-                && other.getStop(i + 1).equals(this.getStop(i + 1))) {\n-                // Copy hop geometry from previous pattern\n-                this.setHopGeometry(i, other.getHopGeometry(i));\n-            } else {\n-                // Create new straight-line geometry for hop\n-                this.setHopGeometry(i,\n-                    GeometryUtils.getGeometryFactory().createLineString(\n-                        new Coordinate[]{\n-                            coordinate(stopPattern.getStop(i)),\n-                            coordinate(stopPattern.getStop(i + 1))\n-                        }\n-                    )\n-                );\n-            }\n+        /* Then try to name with origin. */\n+        var start = pattern.firstStop();\n+        sb.append(\" from \" + stopNameAndId(start));\n+        if (starts.get(start).size() == 1) {\n+          pattern.setName((sb.toString()));\n+          continue PATTERN; // only pattern with this first stop\n         }\n-    }\n-\n-    public LineString getGeometry() {\n-        if(hopGeometries == null || hopGeometries.length==0) { return null; }\n \n-        List<LineString> lineStrings = new ArrayList<>();\n-        for (int i = 0; i < hopGeometries.length; i++) {\n-            lineStrings.add(getHopGeometry(i));\n+        /* Check whether (end, start) is unique. */\n+        Collection<TripPattern> tripPatterns = starts.get(start);\n+        Set<TripPattern> remainingPatterns = new HashSet<>(tripPatterns);\n+        remainingPatterns.retainAll(ends.get(end)); // set intersection\n+        if (remainingPatterns.size() == 1) {\n+          pattern.setName((sb.toString()));\n+          continue PATTERN;\n         }\n-        return GeometryUtils.concatenateLineStrings(lineStrings);\n-    }\n \n-    public int numHopGeometries() {\n-        return hopGeometries.length;\n-    }\n-\n-    public int numberOfStops() {\n-        return stopPattern.getSize();\n-    }\n-\n-    public StopLocation getStop(int stopPosInPattern) {\n-        return stopPattern.getStop(stopPosInPattern);\n-    }\n-\n-    public StopLocation firstStop() {\n-        return getStop(0);\n-    }\n-\n-    public StopLocation lastStop() {\n-        return getStop(stopPattern.getSize()-1);\n-    }\n-\n-    /** Read only list of stops */\n-    public List<StopLocation> getStops() {\n-        return stopPattern.getStops();\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop}. The search start at\n-     * position {@code 0}. Return a negative number if not found. Use {@link\n-     * #findAlightStopPositionInPattern(StopLocation)} or {@link #findBoardingStopPositionInPattern(StopLocation)}\n-     * if possible.\n-     */\n-    public int findStopPosition(StopLocation stop) {\n-        return stopPattern.findStopPosition(stop);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code station} where it is\n-     * allowed to board. The search start at position {@code 0}. Return a negative number if not\n-     * found.\n-     */\n-    public int findBoardingStopPositionInPattern(Station station) {\n-        return stopPattern.findBoardingPosition(station);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code station} where it is\n-     * allowed to alight. The search start at position {@code 1}. Return a negative number if not\n-     * found.\n-     */\n-    public int findAlightStopPositionInPattern(Station station) {\n-        return stopPattern.findAlightPosition(station);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n-     * to board. The search start at position {@code 0}. Return a negative number if not found.\n-     */\n-    public int findBoardingStopPositionInPattern(StopLocation stop) {\n-        return stopPattern.findBoardingPosition(stop);\n-    }\n-\n-    /**\n-     * Find the first stop position in pattern matching the given {@code stop} where it is allowed\n-     * to alight. The search start at position {@code 1}. Return a negative number if not found.\n-     */\n-    public int findAlightStopPositionInPattern(StopLocation stop) {\n-        return stopPattern.findAlightPosition(stop);\n-    }\n-\n-    /** Returns whether passengers can alight at a given stop */\n-    public boolean canAlight(int stopIndex) {\n-        return stopPattern.canAlight(stopIndex);\n-    }\n-\n-    /** Returns whether passengers can board at a given stop */\n-    public boolean canBoard(int stopIndex) {\n-        return stopPattern.canBoard(stopIndex);\n-    }\n-\n-    /**\n-     * Returns whether passengers can board at a given stop.\n-     * This is an inefficient method iterating over the stops, do not use it in routing.\n-     */\n-    public boolean canBoard(StopLocation stop) {\n-        return stopPattern.canBoard(stop);\n-    }\n-\n-    /** Returns whether a given stop is wheelchair-accessible. */\n-    public boolean wheelchairAccessible(int stopIndex) {\n-        return stopPattern.getStop(stopIndex).getWheelchairBoarding() == WheelChairBoarding.POSSIBLE;\n-    }\n-\n-    public PickDrop getAlightType(int stopIndex) {\n-        return stopPattern.getDropoff(stopIndex);\n-    }\n-\n-    public PickDrop getBoardType(int stopIndex) {\n-        return stopPattern.getPickup(stopIndex);\n-    }\n-\n-    public boolean isBoardAndAlightAt(int stopIndex, PickDrop value) {\n-        return getBoardType(stopIndex).is(value) && getAlightType(stopIndex).is(value);\n-    }\n-\n-    public boolean stopPatternIsEqual(TripPattern other) {\n-        return stopPattern.equals(other.stopPattern);\n-    }\n-\n-    public Trip getTrip(int tripIndex) {\n-        return scheduledTimetable.getTripTimes(tripIndex).getTrip();\n-    }\n-\n-    /* METHODS THAT DELEGATE TO THE SCHEDULED TIMETABLE */\n-\n-    // TODO: These should probably be deprecated. That would require grabbing the scheduled timetable,\n-    // and would avoid mistakes where real-time updates are accidentally not taken into account.\n-\n-    /**\n-     * Add the given tripTimes to this pattern's scheduled timetable, recording the corresponding\n-     * trip as one of the scheduled trips on this pattern.\n-     */\n-    public void add(TripTimes tt) {\n-        // Only scheduled trips (added at graph build time, rather than directly to the timetable\n-        // via updates) are in this list.\n-        scheduledTimetable.addTripTimes(tt);\n-\n-        // Check that all trips added to this pattern are on the initially declared route.\n-        // Identity equality is valid on GTFS entity objects.\n-        if (this.route != tt.getTrip().getRoute()) {\n-            LOG.warn(\"The trip {} is on route {} but its stop pattern is on route {}.\",\n-                tt.getTrip(), tt.getTrip().getRoute(),\n-                route\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Add the given FrequencyEntry to this pattern's scheduled timetable, recording the corresponding\n-     * trip as one of the scheduled trips on this pattern.\n-     * TODO possible improvements: combine freq entries and TripTimes. Do not keep trips list in TripPattern\n-     * since it is redundant.\n-     */\n-    public void add(FrequencyEntry freq) {\n-        scheduledTimetable.addFrequencyEntry(freq);\n-        if (this.getRoute() != freq.tripTimes.getTrip().getRoute()) {\n-            LOG.warn(\"The trip {} is on a different route than its stop pattern, which is on {}.\",\n-                freq.tripTimes.getTrip(),\n-                route\n-            );\n-        }\n-    }\n-\n-    /**\n-     * Remove all trips matching the given predicate.\n-     * @param removeTrip it the predicate returns true\n-     */\n-    public void removeTrips(Predicate<Trip> removeTrip) {\n-        scheduledTimetable.getTripTimes().removeIf(tt -> removeTrip.test(tt.getTrip()));\n-    }\n-\n-    public void setOriginalTripPattern(TripPattern originalTripPattern) {\n-        this.originalTripPattern = originalTripPattern;\n-    }\n-\n-    /**\n-     * The direction for all the trips in this pattern.\n-     */\n-    public Direction getDirection() {\n-        return scheduledTimetable.getDirection();\n-    }\n-\n-    /**\n-     * This pattern may have multiple Timetable objects, but they should all contain TripTimes\n-     * for the same trips, in the same order (that of the scheduled Timetable). An exception to\n-     * this rule may arise if unscheduled trips are added to a Timetable. For that case we need\n-     * to search for trips/TripIds in the Timetable rather than the enclosing TripPattern.\n-     */\n-    public Stream<Trip> scheduledTripsAsStream() {\n-        return scheduledTimetable.getTripTimes().stream().map(TripTimes::getTrip).distinct();\n-    }\n-\n-    /**\n-     * This is the \"original\" timetable holding the scheduled stop times from GTFS, with no\n-     * realtime updates applied. If realtime stoptime updates are applied, next/previous departure\n-     * searches will be conducted using a different, updated timetable in a snapshot.\n-     */\n-    public Timetable getScheduledTimetable() {\n-        return scheduledTimetable;\n-    }\n-\n-    /**\n-     * Has the TripPattern been created by a real-time update.\n-     */\n-    public boolean isCreatedByRealtimeUpdater() {\n-        return createdByRealtimeUpdater;\n-    }\n-\n-    public void setCreatedByRealtimeUpdater() {\n-        createdByRealtimeUpdater = true;\n-    }\n-\n-    private static String stopNameAndId (StopLocation stop) {\n-        return stop.getName() + \" (\" + stop.getId().toString() + \")\";\n-    }\n-\n-    /**\n-     * Static method that creates unique human-readable names for a collection of TableTripPatterns.\n-     * Perhaps this should be in TripPattern, and apply to Frequency patterns as well. TODO: resolve\n-     * this question: can a frequency and table pattern have the same stoppattern? If so should they\n-     * have the same \"unique\" name?\n-     *\n-     * The names should be dataset unique, not just route-unique?\n-     *\n-     * A TripPattern groups all trips visiting a particular pattern of stops on a particular route.\n-     * GFTS Route names are intended for very general customer information, but sometimes there is a\n-     * need to know where a particular trip actually goes. For example, the New York City N train\n-     * has at least four different variants: express (over the Manhattan bridge) and local (via\n-     * lower Manhattan and the tunnel), in two directions (to Astoria or to Coney Island). During\n-     * construction, a fifth variant sometimes appears: trains use the D line to Coney Island after\n-     * 59th St (or from Coney Island to 59th in the opposite direction).\n-     *\n-     * TripPattern names are machine-generated on a best-effort basis. They are guaranteed to be\n-     * unique (among TripPatterns for a single Route) but not stable across graph builds, especially\n-     * when different versions of GTFS inputs are used. For instance, if a variant is the only\n-     * variant of the N that ends at Coney Island, the name will be \"N to Coney Island\". But if\n-     * multiple variants end at Coney Island (but have different stops elsewhere), that name would\n-     * not be chosen. OTP also tries start and intermediate stations (\"from Coney Island\", or \"via\n-     * Whitehall\", or even combinations (\"from Coney Island via Whitehall\"). But if there is no way\n-     * to create a unique name from start/end/intermediate stops, then the best we can do is to\n-     * create a \"like [trip id]\" name, which at least tells you where in the GTFS you can find a\n-     * related trip.\n-     */\n-    // TODO: pass in a transit index that contains a Multimap<Route, TripPattern> and derive all TableTripPatterns\n-    // TODO: use headsigns before attempting to machine-generate names\n-    // TODO: combine from/to and via in a single name. this could be accomplished by grouping the trips by destination,\n-    // then disambiguating in groups of size greater than 1.\n-    /*\n-     * Another possible approach: for each route, determine the necessity of each field (which\n-     * combination will create unique names). from, to, via, express. Then concatenate all necessary\n-     * fields. Express should really be determined from number of stops and/or run time of trips.\n-     */\n-    public static void generateUniqueNames (\n-            Collection<TripPattern> tableTripPatterns,\n-            DataImportIssueStore issueStore\n-    ) {\n-        LOG.info(\"Generating unique names for stop patterns on each route.\");\n-        Set<String> usedRouteNames = Sets.newHashSet();\n-        Map<Route, String> uniqueRouteNames = Maps.newHashMap();\n-\n-        /* Group TripPatterns by Route */\n-        Multimap<Route, TripPattern> patternsByRoute = ArrayListMultimap.create();\n-        for (TripPattern ttp : tableTripPatterns) {\n-            patternsByRoute.put(ttp.route, ttp);\n-        }\n-\n-        /* Ensure we have a unique name for every Route */\n-        for (Route route : patternsByRoute.keySet()) {\n-            String routeName = route.getName();\n-            if (usedRouteNames.contains(routeName)) {\n-                int i = 2;\n-                String generatedRouteName;\n-                do generatedRouteName = routeName + \" \" + (i++);\n-                while (usedRouteNames.contains(generatedRouteName));\n-                issueStore.add(new NonUniqueRouteName(generatedRouteName));\n-                routeName = generatedRouteName;\n-            }\n-            usedRouteNames.add(routeName);\n-            uniqueRouteNames.put(route, routeName);\n+        /* Still not unique; try (end, start, via) for each via. */\n+        for (var via : pattern.getStops()) {\n+          if (via.equals(start) || via.equals(end)) continue;\n+          Set<TripPattern> intersection = new HashSet<>();\n+          intersection.addAll(remainingPatterns);\n+          intersection.retainAll(vias.get(via));\n+          if (intersection.size() == 1) {\n+            sb.append(\" via \" + stopNameAndId(via));\n+            pattern.setName((sb.toString()));\n+            continue PATTERN;\n+          }\n         }\n \n-        /* Iterate over all routes, giving the patterns within each route unique names. */\n-        ROUTE : for (Route route : patternsByRoute.keySet()) {\n-            Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n-            String routeName = uniqueRouteNames.get(route);\n-\n-            /* Simplest case: there's only one route variant, so we'll just give it the route's name. */\n-            if (routeTripPatterns.size() == 1) {\n-                routeTripPatterns.iterator().next().setName(routeName);\n-                continue;\n-            }\n-\n-            /* Do the patterns within this Route have a unique start, end, or via Stop? */\n-            Multimap<String, TripPattern> signs   = ArrayListMultimap.create(); // prefer headsigns\n-            Multimap<StopLocation, TripPattern> starts  = ArrayListMultimap.create();\n-            Multimap<StopLocation, TripPattern> ends    = ArrayListMultimap.create();\n-            Multimap<StopLocation, TripPattern> vias    = ArrayListMultimap.create();\n-\n-            for (TripPattern pattern : routeTripPatterns) {\n-                StopLocation start = pattern.firstStop();\n-                StopLocation end   = pattern.lastStop();\n-                starts.put(start, pattern);\n-                ends.put(end, pattern);\n-                for (StopLocation stop : pattern.getStops()) {\n-                    vias.put(stop, pattern);\n-                }\n-            }\n-            PATTERN : for (TripPattern pattern : routeTripPatterns) {\n-                StringBuilder sb = new StringBuilder(routeName);\n-\n-                /* First try to name with destination. */\n-                var end = pattern.lastStop();\n-                sb.append(\" to \" + stopNameAndId(end));\n-                if (ends.get(end).size() == 1) {\n-                    pattern.setName(sb.toString());\n-                    continue PATTERN; // only pattern with this last stop\n-                }\n-\n-                /* Then try to name with origin. */\n-                var start = pattern.firstStop();\n-                sb.append(\" from \" + stopNameAndId(start));\n-                if (starts.get(start).size() == 1) {\n-                    pattern.setName((sb.toString()));\n-                    continue PATTERN; // only pattern with this first stop\n-                }\n-\n-                /* Check whether (end, start) is unique. */\n-                Collection<TripPattern> tripPatterns = starts.get(start);\n-                Set<TripPattern> remainingPatterns = new HashSet<>(tripPatterns);\n-                remainingPatterns.retainAll(ends.get(end)); // set intersection\n-                if (remainingPatterns.size() == 1) {\n-                    pattern.setName((sb.toString()));\n-                    continue PATTERN;\n-                }\n-\n-                /* Still not unique; try (end, start, via) for each via. */\n-                for (var via : pattern.getStops()) {\n-                    if (via.equals(start) || via.equals(end)) continue;\n-                    Set<TripPattern> intersection = new HashSet<>();\n-                    intersection.addAll(remainingPatterns);\n-                    intersection.retainAll(vias.get(via));\n-                    if (intersection.size() == 1) {\n-                        sb.append(\" via \" + stopNameAndId(via));\n-                        pattern.setName((sb.toString()));\n-                        continue PATTERN;\n-                    }\n-                }\n-\n-                /* Still not unique; check for express. */\n-                if (remainingPatterns.size() == 2) {\n-                    // There are exactly two patterns sharing this start/end.\n-                    // The current one must be a subset of the other, because it has no unique via.\n-                    // Therefore we call it the express.\n-                    sb.append(\" express\");\n-                } else {\n-                    // The final fallback: reference a specific trip ID.\n-                    Trip trip = null;\n-                    if (!pattern.scheduledTimetable.getTripTimes().isEmpty()) {\n-                        trip = pattern.scheduledTimetable.getTripTimes().get(0).getTrip();\n-                    } else if (!pattern.scheduledTimetable.getFrequencyEntries().isEmpty()) {\n-                        trip = pattern.scheduledTimetable.getFrequencyEntries().get(0).tripTimes.getTrip();\n-                    }\n-\n-                    if (trip != null) {\n-                        sb.append(\" like trip \").append(trip.getId());\n-                    }\n-\n-                }\n-                pattern.setName((sb.toString()));\n-            } // END foreach PATTERN\n-        } // END foreach ROUTE\n-\n-        if (LOG.isDebugEnabled()) {\n-            LOG.debug(\"Done generating unique names for stop patterns on each route.\");\n-            for (Route route : patternsByRoute.keySet()) {\n-                Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n-                LOG.debug(\"Named {} patterns in route {}\", routeTripPatterns.size(), uniqueRouteNames.get(route));\n-                for (TripPattern pattern : routeTripPatterns) {\n-                    LOG.debug(\"    {} ({} stops)\", pattern.name, pattern.stopPattern.getSize());\n-                }\n-            }\n+        /* Still not unique; check for express. */\n+        if (remainingPatterns.size() == 2) {\n+          // There are exactly two patterns sharing this start/end.\n+          // The current one must be a subset of the other, because it has no unique via.\n+          // Therefore we call it the express.\n+          sb.append(\" express\");\n+        } else {\n+          // The final fallback: reference a specific trip ID.\n+          Trip trip = null;\n+          if (!pattern.scheduledTimetable.getTripTimes().isEmpty()) {\n+            trip = pattern.scheduledTimetable.getTripTimes().get(0).getTrip();\n+          } else if (!pattern.scheduledTimetable.getFrequencyEntries().isEmpty()) {\n+            trip = pattern.scheduledTimetable.getFrequencyEntries().get(0).tripTimes.getTrip();\n+          }\n+\n+          if (trip != null) {\n+            sb.append(\" like trip \").append(trip.getId());\n+          }\n         }\n-    }\n-\n-    /**\n-     * A bit of a strange place to set service codes all at once when TripTimes are already added,\n-     * but we need a reference to the Graph or at least the codes map. This could also be\n-     * placed in the hop factory itself.\n-     */\n-    public void setServiceCodes (Map<FeedScopedId, Integer> serviceCodes) {\n-        setServices(new BitSet());\n-        scheduledTripsAsStream().forEach (trip -> {\n-            FeedScopedId serviceId = trip.getServiceId();\n-            if (serviceCodes.containsKey(serviceId)) {\n-                services.set(serviceCodes.get(serviceId));\n-            }\n-            else {\n-                LOG.warn(\"Service \" + serviceId + \" not found in service codes not found.\");\n-            }\n-        });\n-        scheduledTimetable.setServiceCodes (serviceCodes);\n-    }\n-\n-    /**\n-     * A set of serviceIds with at least one trip in this pattern.\n-     * Trips in a pattern are no longer necessarily running on the same service ID.\n-     */ /**\n-     * @return bitset of service codes\n-     */\n-    public BitSet getServices() {\n-        return services;\n-    }\n-\n-    /**\n-     * @param services bitset of service codes\n-     */\n-    public void setServices(BitSet services) {\n-        this.services = services;\n-    }\n-\n-    public String getTripHeadsign() {\n-        return scheduledTimetable.getTripTimes(0).getTrip().getTripHeadsign();\n-    }\n-\n-    public static boolean idsAreUniqueAndNotNull(Collection<TripPattern> tripPatterns) {\n-        Set<FeedScopedId> seen = new HashSet<>();\n-        return tripPatterns.stream()\n-            .map(TransitEntity::getId)\n-            .allMatch(t -> t != null && seen.add(t));\n-    }\n-\n-    public boolean matchesModeOrSubMode(TransitMode mode, String transportSubmode) {\n-        return getMode().equals(mode) || (\n-                getNetexSubmode() != null && getNetexSubmode().equals(transportSubmode)\n+        pattern.setName((sb.toString()));\n+      } // END foreach PATTERN\n+    } // END foreach ROUTE\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(\"Done generating unique names for stop patterns on each route.\");\n+      for (Route route : patternsByRoute.keySet()) {\n+        Collection<TripPattern> routeTripPatterns = patternsByRoute.get(route);\n+        LOG.debug(\n+          \"Named {} patterns in route {}\",\n+          routeTripPatterns.size(),\n+          uniqueRouteNames.get(route)\n         );\n-    }\n-\n-    public String toString () {\n-        return String.format(\"<TripPattern %s>\", this.getId());\n-    }\n-\n-    /**\n-     * In most cases we want to use identity equality for Trips.\n-     * However, in some cases we want a way to consistently identify trips across versions of a GTFS feed, when the\n-     * feed publisher cannot ensure stable trip IDs. Therefore we define some additional hash functions.\n-     * Hash collisions are theoretically possible, so these identifiers should only be used to detect when two\n-     * trips are the same with a high degree of probability.\n-     * An example application is avoiding double-booking of a particular bus trip for school field trips.\n-     * Using Murmur hash function. see http://programmers.stackexchange.com/a/145633 for comparison.\n-     *\n-     * @param trip a trip object within this pattern, or null to hash the pattern itself independent any specific trip.\n-     * @return the semantic hash of a Trip in this pattern as a printable String.\n-     *\n-     * TODO deal with frequency-based trips\n-     */\n-    public String semanticHashString(Trip trip) {\n-        HashFunction murmur = Hashing.murmur3_32();\n-        BaseEncoding encoder = BaseEncoding.base64Url().omitPadding();\n-        StringBuilder sb = new StringBuilder(50);\n-        sb.append(encoder.encode(stopPattern.semanticHash(murmur).asBytes()));\n-        if (trip != null) {\n-            TripTimes tripTimes = scheduledTimetable.getTripTimes(trip);\n-            if (tripTimes == null) { return null; }\n-            sb.append(':');\n-            sb.append(encoder.encode(tripTimes.semanticHash(murmur).asBytes()));\n+        for (TripPattern pattern : routeTripPatterns) {\n+          LOG.debug(\"    {} ({} stops)\", pattern.name, pattern.stopPattern.getSize());\n         }\n-        return sb.toString();\n-    }\n-\n-    public TripPattern clone () {\n-        try {\n-            return (TripPattern) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            /* cannot happen */\n-            throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * A bit of a strange place to set service codes all at once when TripTimes are already added,\n+   * but we need a reference to the Graph or at least the codes map. This could also be\n+   * placed in the hop factory itself.\n+   */\n+  public void setServiceCodes(Map<FeedScopedId, Integer> serviceCodes) {\n+    setServices(new BitSet());\n+    scheduledTripsAsStream()\n+      .forEach(trip -> {\n+        FeedScopedId serviceId = trip.getServiceId();\n+        if (serviceCodes.containsKey(serviceId)) {\n+          services.set(serviceCodes.get(serviceId));\n+        } else {\n+          LOG.warn(\"Service \" + serviceId + \" not found in service codes not found.\");\n         }\n-    }\n-\n-    /**\n-     * Get the feed id this trip pattern belongs to.\n-     *\n-     * @return feed id for this trip pattern\n-     */\n-    public String getFeedId() {\n-        // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n-        return route.getId().getFeedId();\n-    }\n-\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        // The serialized graph contains cyclic references TripPattern <--> Timetable.\n-        // The Timetable must be indexed from here (rather than in its own readObject method)\n-        // to ensure that the stops field it uses in TripPattern is already deserialized.\n-        scheduledTimetable.finish();\n-    }\n-\n-    private static Coordinate coordinate(StopLocation s) {\n-        return new Coordinate(s.getLon(), s.getLat());\n-    }\n+      });\n+    scheduledTimetable.setServiceCodes(serviceCodes);\n+  }\n+\n+  /**\n+   * Sets service code for pattern if it's not already set\n+   *\n+   * @param serviceCode service code that needs to be set\n+   */\n+  public void setServiceCode(int serviceCode) {\n+    if (!getServices().get(serviceCode)) {\n+      final BitSet services = (BitSet) getServices().clone();\n+      services.set(serviceCode);\n+      setServices(services);\n+    }\n+  }\n+\n+  /**\n+   * A set of serviceIds with at least one trip in this pattern.\n+   * Trips in a pattern are no longer necessarily running on the same service ID.\n+   *\n+   * @return bitset of service codes\n+   */\n+  public BitSet getServices() {\n+    return services;\n+  }\n+\n+  /**\n+   * @param services bitset of service codes\n+   */\n+  public void setServices(BitSet services) {\n+    this.services = services;\n+  }\n+\n+  public String getTripHeadsign() {\n+    return scheduledTimetable.getTripTimes(0).getTrip().getTripHeadsign();\n+  }\n+\n+  public static boolean idsAreUniqueAndNotNull(Collection<TripPattern> tripPatterns) {\n+    Set<FeedScopedId> seen = new HashSet<>();\n+    return tripPatterns.stream().map(TransitEntity::getId).allMatch(t -> t != null && seen.add(t));\n+  }\n+\n+  public boolean matchesModeOrSubMode(TransitMode mode, String transportSubmode) {\n+    return (\n+      getMode().equals(mode) ||\n+      (getNetexSubmode() != null && getNetexSubmode().equals(transportSubmode))\n+    );\n+  }\n+\n+  public String toString() {\n+    return String.format(\"<TripPattern %s>\", this.getId());\n+  }\n+\n+  /**\n+   * In most cases we want to use identity equality for Trips.\n+   * However, in some cases we want a way to consistently identify trips across versions of a GTFS feed, when the\n+   * feed publisher cannot ensure stable trip IDs. Therefore we define some additional hash functions.\n+   * Hash collisions are theoretically possible, so these identifiers should only be used to detect when two\n+   * trips are the same with a high degree of probability.\n+   * An example application is avoiding double-booking of a particular bus trip for school field trips.\n+   * Using Murmur hash function. see http://programmers.stackexchange.com/a/145633 for comparison.\n+   *\n+   * @param trip a trip object within this pattern, or null to hash the pattern itself independent any specific trip.\n+   * @return the semantic hash of a Trip in this pattern as a printable String.\n+   *\n+   * TODO deal with frequency-based trips\n+   */\n+  public String semanticHashString(Trip trip) {\n+    HashFunction murmur = Hashing.murmur3_32();\n+    BaseEncoding encoder = BaseEncoding.base64Url().omitPadding();\n+    StringBuilder sb = new StringBuilder(50);\n+    sb.append(encoder.encode(stopPattern.semanticHash(murmur).asBytes()));\n+    if (trip != null) {\n+      TripTimes tripTimes = scheduledTimetable.getTripTimes(trip);\n+      if (tripTimes == null) {\n+        return null;\n+      }\n+      sb.append(':');\n+      sb.append(encoder.encode(tripTimes.semanticHash(murmur).asBytes()));\n+    }\n+    return sb.toString();\n+  }\n+\n+  public TripPattern clone() {\n+    try {\n+      return (TripPattern) super.clone();\n+    } catch (CloneNotSupportedException e) {\n+      /* cannot happen */\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  /**\n+   * Get the feed id this trip pattern belongs to.\n+   *\n+   * @return feed id for this trip pattern\n+   */\n+  public String getFeedId() {\n+    // The feed id is the same as the agency id on the route, this allows us to obtain it from there.\n+    return route.getId().getFeedId();\n+  }\n+\n+  private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+    in.defaultReadObject();\n+    // The serialized graph contains cyclic references TripPattern <--> Timetable.\n+    // The Timetable must be indexed from here (rather than in its own readObject method)\n+    // to ensure that the stops field it uses in TripPattern is already deserialized.\n+    scheduledTimetable.finish();\n+  }\n+\n+  private static Coordinate coordinate(StopLocation s) {\n+    return new Coordinate(s.getLon(), s.getLat());\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex f6cc4bd6e9..542ad1888c 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -737,8 +734,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n-\n-  private static Coordinate coordinate(StopLocation s) {\n-    return new Coordinate(s.getLon(), s.getLat());\n-  }\n }\n", "next_change": {"commit": "299e099bb81dfcc2564362b514941aa063a2ad3e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 542ad1888c..3eb453f3d1 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -734,4 +718,41 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n+\n+  /**\n+   * Check if given stop and next stop on this trip pattern and other are equal.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if stop and next stop are equal on bouth trip patterns, else false\n+   */\n+  private boolean sameStops(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index);\n+    var otherDestination = other.getStop(index + 1);\n+    var origin = getStop(index);\n+    var destination = getStop(index + 1);\n+\n+    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n+  }\n+\n+  /**\n+   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if the stops have the same stations, else false. If any station is null then\n+   * false.\n+   */\n+  private boolean sameStations(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index).getParentStation();\n+    var otherDestination = other.getStop(index + 1).getParentStation();\n+    var origin = getStop(index).getParentStation();\n+    var destionation = getStop(index + 1).getParentStation();\n+\n+    if (origin == null || destionation == null) {\n+      return false;\n+    }\n+\n+    return origin.equals(otherOrigin) && destionation.equals(otherDestination);\n+  }\n }\n", "next_change": {"commit": "58d46b727f471f87a358bb475fa135b3459be11d", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 3eb453f3d1..dfa76dcf46 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -718,41 +741,4 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n-\n-  /**\n-   * Check if given stop and next stop on this trip pattern and other are equal.\n-   *\n-   * @param other Other instance of trip pattern with list of stops. May not be null.\n-   * @param index Given index for stop\n-   * @return true if stop and next stop are equal on bouth trip patterns, else false\n-   */\n-  private boolean sameStops(TripPattern other, int index) {\n-    var otherOrigin = other.getStop(index);\n-    var otherDestination = other.getStop(index + 1);\n-    var origin = getStop(index);\n-    var destination = getStop(index + 1);\n-\n-    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n-  }\n-\n-  /**\n-   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n-   *\n-   * @param other Other instance of trip pattern with list of stops. May not be null.\n-   * @param index Given index for stop\n-   * @return true if the stops have the same stations, else false. If any station is null then\n-   * false.\n-   */\n-  private boolean sameStations(TripPattern other, int index) {\n-    var otherOrigin = other.getStop(index).getParentStation();\n-    var otherDestination = other.getStop(index + 1).getParentStation();\n-    var origin = getStop(index).getParentStation();\n-    var destionation = getStop(index + 1).getParentStation();\n-\n-    if (origin == null || destionation == null) {\n-      return false;\n-    }\n-\n-    return origin.equals(otherOrigin) && destionation.equals(otherDestination);\n-  }\n }\n", "next_change": {"commit": "ec4cc70876ec8faae730c7000d1c5d5634527428", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex dfa76dcf46..1fab7bd926 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -741,4 +718,47 @@ public final class TripPattern extends TransitEntity implements Cloneable, Seria\n     // to ensure that the stops field it uses in TripPattern is already deserialized.\n     scheduledTimetable.finish();\n   }\n+\n+  /**\n+   * Check if given stop and next stop on this trip pattern and other are equal.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if stop and next stop are equal on bouth trip patterns, else false\n+   */\n+  private boolean sameStops(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index);\n+    var otherDestination = other.getStop(index + 1);\n+    var origin = getStop(index);\n+    var destination = getStop(index + 1);\n+\n+    return origin.equals(otherOrigin) && destination.equals(otherDestination);\n+  }\n+\n+  /**\n+   * Check if Station is equal on given stop and next stop for this trip pattern and other.\n+   *\n+   * @param other Other instance of trip pattern with list of stops. May not be null.\n+   * @param index Given index for stop\n+   * @return true if the stops have the same stations, else false. If any station is null then\n+   * false.\n+   */\n+  private boolean sameStations(TripPattern other, int index) {\n+    var otherOrigin = other.getStop(index).getParentStation();\n+    var otherDestination = other.getStop(index + 1).getParentStation();\n+    var origin = getStop(index).getParentStation();\n+    var destionation = getStop(index + 1).getParentStation();\n+\n+    var sameOrigin = Optional\n+      .ofNullable(origin)\n+      .map(o -> o.equals(otherOrigin))\n+      .orElse(getStop(index).equals(other.getStop(index)));\n+\n+    var sameDestination = Optional\n+      .ofNullable(destionation)\n+      .map(o -> o.equals(otherDestination))\n+      .orElse(getStop(index + 1).equals(other.getStop(index + 1)));\n+\n+    return sameOrigin && sameDestination;\n+  }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "16c031b5ff80729111eb04c8f015276abfc59128", "committedDate": "2020-10-05 10:23:48 +0300", "message": "Add patterns to patternsForStop only if they are coming from real-time updates"}, {"oid": "d8afd66107af2c11641b13cdfa0c02841c11ed7f", "committedDate": "2020-10-05 11:31:50 +0300", "message": "Make TransitEntity equals and hashcode non-extendable"}, {"oid": "e2fa33c192e6af4b6d9ca4bcd99d74a1528ed6ce", "committedDate": "2020-10-06 12:35:54 +0300", "message": "Add setCreatedByRealtimeUpdater"}, {"oid": "7fdcfaf8104e8b2fa94ef78591c7471399dad484", "committedDate": "2020-10-08 19:17:30 +0200", "message": "Fix issue #3195 - Build and load GTFS files for San Francisco Bay Area.  - Make `StopLevel` Serializable.  - The `TripPattern#getGeometry()` should return null, not fail with a NPE when there is no geometry - no matter the cause."}, {"oid": "d57c16470beca49f137f0c7b8f7097482e4a9137", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Remove generic type argument from TransitEntity, the 'id' is now a FeedScopedId."}, {"oid": "236c05560fabc07658d98c2b68345c83ade4446f", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Encapsulate id as \"read-only\" in TransitEntity. This require some refactorings, like generating the TripPattern id at the time it is created, not as a post processing step. It also require all sub-classes of transit entity to have a constructor with the id as a parameter. THIS COMMIT COMPILES, BUT TESTS FAILS BECAUSE GENERATING TRIP PATTERN IDS IS LEFT TO THE NEXT COMMIT."}, {"oid": "945184168355309126bbeb74919f6d3df1d37fa6", "committedDate": "2020-10-09 01:28:55 +0200", "message": "Clean code: Generate TripPattern id BEFORE creating new pattern to be able to make the `TripPattern.id` read-only."}, {"oid": "be23b905919c899bb3ec790669334ba5b3a84619", "committedDate": "2020-10-09 11:55:38 +0200", "message": "Merge remote-tracking branch 'otp/2.0-rc' into dev-2.x"}, {"oid": "58ae629e67912dd4f984dd6300e3e1397806e09c", "committedDate": "2020-10-12 11:10:18 +0200", "message": "Merge branch 'dev-2.x' into otp2_cleanup_TransitEntity"}, {"oid": "9d68c276f351e37f3a56e6e278bf6f9e5e71e038", "committedDate": "2020-12-16 11:41:06 +0200", "message": "Fix geometry response to contain full data up to last stop"}, {"oid": "6591b59ff43d57d4e46537bc064e66a8a7017bc8", "committedDate": "2021-02-02 13:56:03 +0100", "message": "Add Direction enum to OTP model and add Netex mapping"}, {"oid": "f6dd7393d91fb897fae7a4d632f0de0cc11efa4a", "committedDate": "2021-02-04 16:39:46 +0100", "message": "Changes based on comments"}, {"oid": "16170f340345dd3c68e8ce7a8d56067dc0be7367", "committedDate": "2021-03-24 17:55:51 +0100", "message": "Clean code - make sure if is followed by `{}`."}, {"oid": "a4238b9e374d6c4ac17885244ac9791b638e2b4e", "committedDate": "2021-07-23 14:55:38 +0200", "message": "Add PickDrop enum and simplify StopPattern"}, {"oid": "fd9fe2a3391bda1eb10acf101f338ea0651620c4", "committedDate": "2021-07-23 15:05:03 +0200", "message": "Remove perStopFlags from TripPattern"}, {"oid": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "committedDate": "2021-07-23 15:25:47 +0200", "message": "Encapsulate fields in TripPattern"}, {"oid": "69dd76a878fd365e2bb4755b60c9c7be30041c14", "committedDate": "2021-07-23 15:29:06 +0200", "message": "Remove trips from TripPattern - refer to TripTimes instead"}, {"oid": "a86208e0283a6d191a35d33e09b3ab7922130fd0", "committedDate": "2021-07-23 15:54:11 +0200", "message": "Encapsulate fields in TripTimes"}, {"oid": "55c7116430720c1c91c2673787cb9593f64d658f", "committedDate": "2021-07-27 12:42:52 +0200", "message": "Remove getters for fields in same class"}, {"oid": "0ba64706337946bcd989f09377f12b076e892769", "committedDate": "2021-07-27 14:05:27 +0200", "message": "Encapsulate fields in Timetable"}, {"oid": "acf334d3ee4956c41586785ceba398104a8e43c4", "committedDate": "2021-12-10 12:51:40 +0100", "message": "Replace Stop with StopLocation in internal logic"}, {"oid": "c35a6f125a95433e737adfa103070b07ee8df888", "committedDate": "2021-12-10 12:51:40 +0100", "message": "Disallow getting on or off at flex stops during transit search"}, {"oid": "3ad7cc19099a2c29d59b5609b7e2e56167364b37", "committedDate": "2021-12-10 12:51:42 +0100", "message": "Raptor pickup/dropoff permissions during instanciation"}, {"oid": "9a599ab0cf4c0ea7e0e51677a96245236c71e73e", "committedDate": "2021-12-17 13:50:40 +0200", "message": "feat: Read in and expose Netex submode in Transmodel API"}, {"oid": "539bf9a3cbca42512b6d65085e91133d1e4205ee", "committedDate": "2021-12-20 12:06:18 +0100", "message": "refactor: cleanup TripPattern"}, {"oid": "907a752feb3be63a700b4fd18ad20be30f3d7556", "committedDate": "2022-01-06 23:11:51 +0200", "message": "Apply suggestions from code review"}, {"oid": "594f8f4b4825bfc1e8513df756fbc20f499c9e26", "committedDate": "2022-01-07 16:44:53 +0100", "message": "refactor: Encapsulate StopPattern in TripPattern"}, {"oid": "1390922298386f03152d6696caf1a6ff3dcc24f5", "committedDate": "2022-01-11 02:08:01 +0100", "message": "feat: Support for GTFS Trip, Route, Stop & Station Transfers"}, {"oid": "768117c09e4a1d2845f3db933b53a0cf6448455a", "committedDate": "2022-01-14 11:31:21 +0100", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_not_allowed_transfers"}, {"oid": "bab6818d9fec41ca2b415526350df5515f5911cb", "committedDate": "2022-02-09 11:12:01 +0200", "message": "Add javadoc"}, {"oid": "8405e27b47553745872554e94bb59faf94a8ebe4", "committedDate": "2022-02-09 16:08:22 +0200", "message": "Add constrained transfers to patterns generated by realtime updates"}, {"oid": "b67507f8179ccdddc0bb0d2e583dfad8abfe0def", "committedDate": "2022-02-10 15:47:52 +0200", "message": "Add documentation"}, {"oid": "289e69198016bf152890f6f8fa0f11621a031d0a", "committedDate": "2022-02-11 15:55:42 +0200", "message": "Merge pull request #3878 from entur/otp2_realtime_constrained_transfers"}, {"oid": "461ba982285aa33774e97923b2bb8124b0b13a82", "committedDate": "2022-02-18 15:10:18 +0200", "message": "feat: Add support for frequency trips"}, {"oid": "fefb82d270a81315a545df863de31218eb43b4f9", "committedDate": "2022-02-21 13:30:59 +0100", "message": "refactor: Convert TripPattern.getTrips() to scheduledTripsAsStream()."}, {"oid": "48847620e316e41540c98d315c05a6c41e2817ea", "committedDate": "2022-03-10 19:50:36 +0200", "message": "Create new pattern if there are skipped stops so routing ignores the stops"}, {"oid": "59fbd011f0ba0fc4addabbd8ea7567f551519fdd", "committedDate": "2022-03-11 16:10:03 +0100", "message": "First initial port of IBI code"}, {"oid": "848c857db3f9b6c71b6aab429c7b0e4326b2b566", "committedDate": "2022-03-11 16:10:03 +0100", "message": "Encapsulate positions logic"}, {"oid": "d23d1c99424b76fd55ca23d60176cbc82d5a8144", "committedDate": "2022-03-11 16:10:04 +0100", "message": "Introduce vehicle positions to GraphQL API"}, {"oid": "a01a41d0d979f959a0c9a712db8a7c9d91970ecf", "committedDate": "2022-03-11 16:10:04 +0100", "message": "Move position updates into service"}, {"oid": "7e60e473f9d460d9549b20765f922f87a143b823", "committedDate": "2022-03-15 14:39:58 +0100", "message": "10924 journey pattern geometries"}, {"oid": "1409738aa90fe5cd798f2837709d8d24af9b1e9a", "committedDate": "2022-03-18 10:52:40 +0100", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into vehicle-positions"}, {"oid": "e014badc5571fd0adbfa7ce2c23e835bc03b1fd0", "committedDate": "2022-03-21 16:08:44 +0100", "message": "refactor: Fix Javadoc comments that don't belong to any class, method or field"}, {"oid": "aa06e31d0739586374cd8fca1219c1dc5e5e9c69", "committedDate": "2022-03-22 12:08:47 +0100", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into vehicle-positions"}, {"oid": "7526b175afaced0ef7d4ee63a18cc2046673e4a7", "committedDate": "2022-03-24 09:58:03 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into gtfsrt-cancelled-stops"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "269afb6d3c6604cd86fc8643c3d43d24661786f2", "committedDate": "2022-04-24 10:49:28 +0300", "message": "Switch from internal jcommander implementation usage to guava"}, {"oid": "3a4d2f2827fe3d812f78eb464c779b6dbedd40da", "committedDate": "2022-04-28 13:33:33 +0300", "message": "Extract and use getRepresentativeTripTimes"}, {"oid": "299e099bb81dfcc2564362b514941aa063a2ad3e", "committedDate": "2022-04-29 11:04:13 +0200", "message": "Bugfix on setHopGemometriesFromPattern"}, {"oid": "58d46b727f471f87a358bb475fa135b3459be11d", "committedDate": "2022-04-29 14:51:13 +0200", "message": "Rename 'WheelChairBoarding' to 'WheelchairBoarding'"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "d484f45f4d6f87f6c490a392c2dbe2daad69e29c", "committedDate": "2022-05-09 14:10:26 +0200", "message": "refactor: Move some core model classes"}, {"oid": "ec4cc70876ec8faae730c7000d1c5d5634527428", "committedDate": "2022-05-10 14:51:05 +0200", "message": "Consider null stations for comparing stations on stops"}, {"oid": "e36df475d9251f6f7dd98a4d8d0dc99ba186bcf7", "committedDate": "2022-05-10 15:43:33 +0200", "message": "Merge branch 'dev-2.x' into trippattern_geometries_fix"}, {"oid": "fa8a6b88525379e17830d4d539882ff449a3dfcb", "committedDate": "2022-05-12 15:06:09 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_transit_model"}, {"oid": "5b2c4d18588bdf5a7de7d93418e0b3ebc68279a6", "committedDate": "2022-05-19 18:22:44 +0200", "message": "refactor: Move BikeAccess, GroupOfRoutes, Route and TransitMode"}, {"oid": "ca18067621142a2383434caa048c3dc1767e2fdc", "committedDate": "2022-05-20 16:06:50 +0200", "message": "Rename WheelchairBoarding to WheelchairAccessibility"}, {"oid": "c434eced011a749c6fdb6afd55fb21b9331211f7", "committedDate": "2022-05-24 11:26:15 +0200", "message": "Rename variables and methods from 'wheelchairBoarding' to 'wheelchairAccessibility'"}, {"oid": "688a57b608d36473a608dbf8e8967cdc3e4b46dd", "committedDate": "2022-05-24 14:15:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_transit_model_p2"}, {"oid": "b68ea1a5bccbcfc98d46ebac6490056a69c44550", "committedDate": "2022-05-25 15:44:44 +0200", "message": "refactor: Move Trip to new location."}, {"oid": "123eb90ab3514c6838947bf1eac91a155ee57add", "committedDate": "2022-05-25 15:44:48 +0200", "message": "refactor: Cleanup Trip"}, {"oid": "f8f232ad48ed87efd67d9bc7ea528b7f04c2a76a", "committedDate": "2022-06-02 14:20:02 +0200", "message": "feature: Make SubMode a type"}, {"oid": "7e1ad0d6e1f8ee191e2e4ae0bd8ef404cea162d3", "committedDate": "2022-06-10 23:11:40 +0200", "message": "Include frequency trips"}, {"oid": "86436740190ee2c11bdd5470aeef4bde3c562f26", "committedDate": "2022-06-13 17:16:30 +0200", "message": "refactor: Cleanup model framework and prepare for adding context."}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b0c367119fc2b637823337923b5504444eb45a52", "committedDate": "2022-06-13 17:38:22 +0200", "message": "refactor: Move Stop related classes into package site"}, {"oid": "6e2067aa11bc9a443b1e643845e23128108e4bfc", "committedDate": "2022-06-13 18:49:32 +0200", "message": "Code cleanup"}, {"oid": "287283d19dcb8be174a9e88a954b5af67df6a44d", "committedDate": "2022-06-16 12:34:08 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "7b7e4c14963355cebf9b23ad0a07622933f94d9f", "committedDate": "2022-06-21 11:11:11 +0200", "message": "Merge pull request #4214 from leonardehrenfried/fix-frequency-geometries"}, {"oid": "557f4b1e06f2feeaa6e47a04e7e359d67b1f54a4", "committedDate": "2022-06-21 13:58:28 +0200", "message": "Merge branch 'dev-2.x' into otp2_simplify_AllowedTransitModes"}, {"oid": "10ab8f909703b183f1f1086f6baa8776481a21f8", "committedDate": "2022-07-06 15:06:50 +0300", "message": "Remove unused code"}, {"oid": "181b1791d29c18d7c9515d7c3643457442ed395e", "committedDate": "2022-07-09 19:36:37 +0300", "message": "Do not require route names to be unique"}, {"oid": "87142f78193dde8932cffc31cbf3db1442667bf1", "committedDate": "2022-07-09 19:41:44 +0300", "message": "Utilize headsign for generating unique pattern names"}, {"oid": "73b5281528cddc2e60e3456d975ce11468bf2334", "committedDate": "2022-07-19 15:15:16 +0200", "message": "refactor: Move direction to new transit model"}, {"oid": "3b4316833886ff242325e031fa13264850b5317e", "committedDate": "2022-07-19 15:48:45 +0200", "message": "refactor: Move Transit- and Sub- Mode to basic"}, {"oid": "b10f9f409887b9c17c38d8c778a2c58453c0e208", "committedDate": "2022-07-27 11:13:19 +0200", "message": "Move TripPattern and StopPattern to network package"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjkxMA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487906910", "body": "This should be documented or inlined, since the usage is limited inlineing is probably the best.", "bodyText": "This should be documented or inlined, since the usage is limited inlineing is probably the best.", "bodyHTML": "<p dir=\"auto\">This should be documented or inlined, since the usage is limited inlineing is probably the best.</p>", "author": "t2gran", "createdAt": "2020-09-14T13:21:36Z", "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -79,9 +80,15 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n                 startTime,\n                 timeRange,\n                 numberOfDepartures,\n-                omitNonPickups\n+                omitNonPickups,\n+                includeCancelledTrips\n         );\n     }\n+    public List<StopTimesInPattern> stopTimesForStop(\n+            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n+    ) {\n+        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n+    }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjE5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972196", "bodyText": "I did inline this one.", "author": "t2gran", "createdAt": "2020-09-14T14:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex a76a28847d..c948d2042e 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -84,11 +84,6 @@ public class RoutingService {\n                 includeCancelledTrips\n         );\n     }\n-    public List<StopTimesInPattern> stopTimesForStop(\n-            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n-    ) {\n-        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n-    }\n \n     /**\n      * Get a list of all trips that pass through a stop during a single ServiceDate. Useful when\n", "next_change": null}]}, "revised_code_in_main": {"commit": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex a76a28847d..c948d2042e 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -84,11 +84,6 @@ public class RoutingService {\n                 includeCancelledTrips\n         );\n     }\n-    public List<StopTimesInPattern> stopTimesForStop(\n-            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n-    ) {\n-        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n-    }\n \n     /**\n      * Get a list of all trips that pass through a stop during a single ServiceDate. Useful when\n", "next_change": {"commit": "4e4722d93448020a8b5c16c994bf9d121f189380", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex c948d2042e..f958067002 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -80,7 +81,7 @@ public class RoutingService {\n                 startTime,\n                 timeRange,\n                 numberOfDepartures,\n-                omitNonPickups,\n+                arrivalDeparture,\n                 includeCancelledTrips\n         );\n     }\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex f958067002..7a690d2904 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -29,143 +83,740 @@ import org.opentripplanner.standalone.server.Router;\n  */\n public class RoutingService {\n \n-    @Delegate(types = Graph.class)\n-    private final Graph graph;\n+  private final Graph graph;\n \n-    @Delegate(types = GraphIndex.class)\n-    private final GraphIndex graphIndex;\n+  private final GraphIndex graphIndex;\n \n-    @Delegate(types = GraphFinder.class)\n-    private final GraphFinder graphFinder;\n+  private final GraphFinder graphFinder;\n \n-    /**\n-     * This should only be accessed through the getTimetableSnapshot method.\n-     */\n-    private TimetableSnapshot timetableSnapshot;\n+  /**\n+   * This should only be accessed through the getTimetableSnapshot method.\n+   */\n+  private TimetableSnapshot timetableSnapshot;\n \n-    public RoutingService(Graph graph) {\n-        this.graph = graph;\n-        this.graphIndex = graph.index;\n-        this.graphFinder = GraphFinder.getInstance(graph);\n-    }\n+  public RoutingService(Graph graph) {\n+    this.graph = graph;\n+    this.graphIndex = graph.index;\n+    this.graphFinder = GraphFinder.getInstance(graph);\n+  }\n \n-    // TODO We should probably not have the Router as a parameter here\n-    public RoutingResponse route(RoutingRequest request, Router router) {\n-        RoutingWorker worker = new RoutingWorker(router.raptorConfig, request);\n-        return worker.route(router);\n-    }\n+  // TODO We should probably not have the Router as a parameter here\n+  public RoutingResponse route(RoutingRequest request, Router router) {\n+    var zoneId = graph.getTimeZone().toZoneId();\n+    RoutingWorker worker = new RoutingWorker(router, request, zoneId);\n+    return worker.route();\n+  }\n \n-    /**\n-     * Fetch upcoming vehicle departures from a stop. It goes though all patterns passing the stop\n-     * for the previous, current and next service date. It uses a priority queue to keep track of\n-     * the next departures. The queue is shared between all dates, as services from the previous\n-     * service date can visit the stop later than the current service date's services. This happens\n-     * eg. with sleeper trains.\n-     * <p>\n-     * TODO: Add frequency based trips\n-     *\n-     * @param stop                  Stop object to perform the search for\n-     * @param startTime             Start time for the search. Seconds from UNIX epoch\n-     * @param timeRange             Searches forward for timeRange seconds from startTime\n-     * @param numberOfDepartures    Number of departures to fetch per pattern\n-     * @param arrivalDeparture      Filter by arrivals, departures, or both\n-     * @param includeCancelledTrips If true, cancelled trips will also be included in result.\n-     */\n-    public List<StopTimesInPattern> stopTimesForStop(\n-            Stop stop, long startTime, int timeRange, int numberOfDepartures, ArrivalDeparture arrivalDeparture, boolean includeCancelledTrips\n-    ) {\n-        return StopTimesHelper.stopTimesForStop(\n-                this,\n-                lazyGetTimeTableSnapShot(),\n-                stop,\n-                startTime,\n-                timeRange,\n-                numberOfDepartures,\n-                arrivalDeparture,\n-                includeCancelledTrips\n-        );\n-    }\n+  /**\n+   * Fetch upcoming vehicle departures from a stop. It goes though all patterns passing the stop\n+   * for the previous, current and next service date. It uses a priority queue to keep track of\n+   * the next departures. The queue is shared between all dates, as services from the previous\n+   * service date can visit the stop later than the current service date's services. This happens\n+   * eg. with sleeper trains.\n+   * <p>\n+   * TODO: Add frequency based trips\n+   *\n+   * @param stop                  Stop object to perform the search for\n+   * @param startTime             Start time for the search. Seconds from UNIX epoch\n+   * @param timeRange             Searches forward for timeRange seconds from startTime\n+   * @param numberOfDepartures    Number of departures to fetch per pattern\n+   * @param arrivalDeparture      Filter by arrivals, departures, or both\n+   * @param includeCancelledTrips If true, cancelled trips will also be included in result.\n+   */\n+  public List<StopTimesInPattern> stopTimesForStop(\n+    StopLocation stop,\n+    long startTime,\n+    int timeRange,\n+    int numberOfDepartures,\n+    ArrivalDeparture arrivalDeparture,\n+    boolean includeCancelledTrips\n+  ) {\n+    return StopTimesHelper.stopTimesForStop(\n+      this,\n+      lazyGetTimeTableSnapShot(),\n+      stop,\n+      startTime,\n+      timeRange,\n+      numberOfDepartures,\n+      arrivalDeparture,\n+      includeCancelledTrips\n+    );\n+  }\n \n-    /**\n-     * Get a list of all trips that pass through a stop during a single ServiceDate. Useful when\n-     * creating complete stop timetables for a single day.\n-     *\n-     * @param stop        Stop object to perform the search for\n-     * @param serviceDate Return all departures for the specified date\n-     */\n-    public List<StopTimesInPattern> getStopTimesForStop(\n-            Stop stop, ServiceDate serviceDate, ArrivalDeparture arrivalDeparture\n-    ) {\n-        return StopTimesHelper.stopTimesForStop(this, stop, serviceDate, arrivalDeparture);\n-    }\n+  /**\n+   * Get a list of all trips that pass through a stop during a single ServiceDate. Useful when\n+   * creating complete stop timetables for a single day.\n+   *\n+   * @param stop        Stop object to perform the search for\n+   * @param serviceDate Return all departures for the specified date\n+   */\n+  public List<StopTimesInPattern> getStopTimesForStop(\n+    StopLocation stop,\n+    ServiceDate serviceDate,\n+    ArrivalDeparture arrivalDeparture\n+  ) {\n+    return StopTimesHelper.stopTimesForStop(this, stop, serviceDate, arrivalDeparture);\n+  }\n \n+  /**\n+   * Fetch upcoming vehicle departures from a stop for a specific pattern, passing the stop\n+   * for the previous, current and next service date. It uses a priority queue to keep track of\n+   * the next departures. The queue is shared between all dates, as services from the previous\n+   * service date can visit the stop later than the current service date's services.\n+   * <p>\n+   * TODO: Add frequency based trips\n+   *\n+   * @param stop               Stop object to perform the search for\n+   * @param pattern            Pattern object to perform the search for\n+   * @param startTime          Start time for the search. Seconds from UNIX epoch\n+   * @param timeRange          Searches forward for timeRange seconds from startTime\n+   * @param numberOfDepartures Number of departures to fetch per pattern\n+   * @param arrivalDeparture   Filter by arrivals, departures, or both\n+   */\n+  public List<TripTimeOnDate> stopTimesForPatternAtStop(\n+    StopLocation stop,\n+    TripPattern pattern,\n+    long startTime,\n+    int timeRange,\n+    int numberOfDepartures,\n+    ArrivalDeparture arrivalDeparture\n+  ) {\n+    return StopTimesHelper.stopTimesForPatternAtStop(\n+      this,\n+      lazyGetTimeTableSnapShot(),\n+      stop,\n+      pattern,\n+      startTime,\n+      timeRange,\n+      numberOfDepartures,\n+      arrivalDeparture\n+    );\n+  }\n \n-    /**\n-     * Fetch upcoming vehicle departures from a stop for a specific pattern, passing the stop\n-     * for the previous, current and next service date. It uses a priority queue to keep track of\n-     * the next departures. The queue is shared between all dates, as services from the previous\n-     * service date can visit the stop later than the current service date's services.\n-     * <p>\n-     * TODO: Add frequency based trips\n-     *\n-     * @param stop               Stop object to perform the search for\n-     * @param pattern            Pattern object to perform the search for\n-     * @param startTime          Start time for the search. Seconds from UNIX epoch\n-     * @param timeRange          Searches forward for timeRange seconds from startTime\n-     * @param numberOfDepartures Number of departures to fetch per pattern\n-     * @param arrivalDeparture   Filter by arrivals, departures, or both\n-     */\n-    public List<TripTimeOnDate> stopTimesForPatternAtStop(\n-            Stop stop, TripPattern pattern, long startTime, int timeRange, int numberOfDepartures, ArrivalDeparture arrivalDeparture\n-    ) {\n-        return StopTimesHelper.stopTimesForPatternAtStop(\n-                this,\n-                lazyGetTimeTableSnapShot(),\n-                stop,\n-                pattern,\n-                startTime,\n-                timeRange,\n-                numberOfDepartures,\n-                arrivalDeparture\n-        );\n-    }\n+  /**\n+   * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n+   * added by realtime updates are added to the collection.\n+   */\n+  public Collection<TripPattern> getPatternsForStop(\n+    StopLocation stop,\n+    boolean includeRealtimeUpdates\n+  ) {\n+    return graph.index.getPatternsForStop(\n+      stop,\n+      includeRealtimeUpdates ? lazyGetTimeTableSnapShot() : null\n+    );\n+  }\n \n-    /**\n-     * Returns all the patterns for a specific stop. If includeRealtimeUpdates is set, new patterns\n-     * added by realtime updates are added to the collection.\n-     */\n-    public Collection<TripPattern> getPatternsForStop(Stop stop, boolean includeRealtimeUpdates) {\n-        return graph.index.getPatternsForStop(stop,\n-                includeRealtimeUpdates ? lazyGetTimeTableSnapShot() : null\n-        );\n-    }\n+  /**\n+   * Get the most up-to-date timetable for the given TripPattern, as of right now. There should\n+   * probably be a less awkward way to do this that just gets the latest entry from the resolver\n+   * without making a fake routing request.\n+   */\n+  public Timetable getTimetableForTripPattern(TripPattern tripPattern, ServiceDate serviceDate) {\n+    TimetableSnapshot timetableSnapshot = lazyGetTimeTableSnapShot();\n+    return timetableSnapshot != null\n+      ? timetableSnapshot.resolve(\n+        tripPattern,\n+        serviceDate == null ? new ServiceDate(Calendar.getInstance().getTime()) : serviceDate\n+      )\n+      : tripPattern.getScheduledTimetable();\n+  }\n \n-    /**\n-     * Get the most up-to-date timetable for the given TripPattern, as of right now. There should\n-     * probably be a less awkward way to do this that just gets the latest entry from the resolver\n-     * without making a fake routing request.\n-     */\n-    public Timetable getTimetableForTripPattern(TripPattern tripPattern) {\n-        TimetableSnapshot timetableSnapshot = lazyGetTimeTableSnapShot();\n-        return timetableSnapshot != null ? timetableSnapshot.resolve(\n-                tripPattern,\n-                new ServiceDate(Calendar.getInstance().getTime())\n-        ) : tripPattern.getScheduledTimetable();\n-    }\n+  public List<TripTimeOnDate> getTripTimesShort(Trip trip, ServiceDate serviceDate) {\n+    return TripTimesShortHelper.getTripTimesShort(this, trip, serviceDate);\n+  }\n \n-    public List<TripTimeOnDate> getTripTimesShort(Trip trip, ServiceDate serviceDate) {\n-        return TripTimesShortHelper.getTripTimesShort(this, trip, serviceDate);\n-    }\n+  /** {@link Graph#getTimetableSnapshot()} */\n+  public TimetableSnapshot getTimetableSnapshot() {\n+    return this.graph.getTimetableSnapshot();\n+  }\n+\n+  /** {@link Graph#getOrSetupTimetableSnapshotProvider(Function)} */\n+  public <T extends TimetableSnapshotProvider> T getOrSetupTimetableSnapshotProvider(\n+    Function<Graph, T> creator\n+  ) {\n+    return this.graph.getOrSetupTimetableSnapshotProvider(creator);\n+  }\n+\n+  /** {@link Graph#addVertex(Vertex)} */\n+  public void addVertex(Vertex v) {\n+    this.graph.addVertex(v);\n+  }\n+\n+  /** {@link Graph#removeEdge(Edge)} */\n+  public void removeEdge(Edge e) {\n+    this.graph.removeEdge(e);\n+  }\n+\n+  /** {@link Graph#getVertex(String)} */\n+  public Vertex getVertex(String label) {\n+    return this.graph.getVertex(label);\n+  }\n+\n+  /** {@link Graph#getVertices()} */\n+  public Collection<Vertex> getVertices() {\n+    return this.graph.getVertices();\n+  }\n+\n+  /** {@link Graph#getVerticesOfType(Class)} */\n+  public <T extends Vertex> List<T> getVerticesOfType(Class<T> cls) {\n+    return this.graph.getVerticesOfType(cls);\n+  }\n+\n+  /** {@link Graph#getEdges()} */\n+  public Collection<Edge> getEdges() {\n+    return this.graph.getEdges();\n+  }\n+\n+  /** {@link Graph#getEdgesOfType(Class)} */\n+  public <T extends Edge> List<T> getEdgesOfType(Class<T> cls) {\n+    return this.graph.getEdgesOfType(cls);\n+  }\n+\n+  /** {@link Graph#getStreetEdges()} */\n+  public Collection<StreetEdge> getStreetEdges() {\n+    return this.graph.getStreetEdges();\n+  }\n+\n+  /** {@link Graph#getTransitLayer()} */\n+  public TransitLayer getTransitLayer() {\n+    return this.graph.getTransitLayer();\n+  }\n+\n+  /** {@link Graph#setTransitLayer(TransitLayer)} */\n+  public void setTransitLayer(TransitLayer transitLayer) {\n+    this.graph.setTransitLayer(transitLayer);\n+  }\n+\n+  /** {@link Graph#getRealtimeTransitLayer()} */\n+  public TransitLayer getRealtimeTransitLayer() {\n+    return this.graph.getRealtimeTransitLayer();\n+  }\n+\n+  /** {@link Graph#hasRealtimeTransitLayer()} */\n+  public boolean hasRealtimeTransitLayer() {\n+    return this.graph.hasRealtimeTransitLayer();\n+  }\n+\n+  /** {@link Graph#setRealtimeTransitLayer(TransitLayer)} */\n+  public void setRealtimeTransitLayer(TransitLayer realtimeTransitLayer) {\n+    this.graph.setRealtimeTransitLayer(realtimeTransitLayer);\n+  }\n+\n+  /** {@link Graph#containsVertex(Vertex)} */\n+  public boolean containsVertex(Vertex v) {\n+    return this.graph.containsVertex(v);\n+  }\n+\n+  /** {@link Graph#putService(Class, Serializable)} */\n+  public <T extends Serializable> T putService(Class<T> serviceType, T service) {\n+    return this.graph.putService(serviceType, service);\n+  }\n+\n+  /** {@link Graph#hasService(Class)} */\n+  public boolean hasService(Class<? extends Serializable> serviceType) {\n+    return this.graph.hasService(serviceType);\n+  }\n+\n+  /** {@link Graph#getService(Class)} */\n+  public <T extends Serializable> T getService(Class<T> serviceType) {\n+    return this.graph.getService(serviceType);\n+  }\n+\n+  /** {@link Graph#getService(Class, boolean)} */\n+  public <T extends Serializable> T getService(Class<T> serviceType, boolean autoCreate) {\n+    return this.graph.getService(serviceType, autoCreate);\n+  }\n+\n+  /** {@link Graph#remove(Vertex)} */\n+  public void remove(Vertex vertex) {\n+    this.graph.remove(vertex);\n+  }\n+\n+  /** {@link Graph#removeIfUnconnected(Vertex)} */\n+  public void removeIfUnconnected(Vertex v) {\n+    this.graph.removeIfUnconnected(v);\n+  }\n+\n+  /** {@link Graph#getExtent()} */\n+  public Envelope getExtent() {\n+    return this.graph.getExtent();\n+  }\n+\n+  /** {@link Graph#getTransferService()} */\n+  public TransferService getTransferService() {\n+    return this.graph.getTransferService();\n+  }\n+\n+  /** {@link Graph#updateTransitFeedValidity(CalendarServiceData, DataImportIssueStore)} */\n+  public void updateTransitFeedValidity(CalendarServiceData data, DataImportIssueStore issueStore) {\n+    this.graph.updateTransitFeedValidity(data, issueStore);\n+  }\n+\n+  /** {@link Graph#transitFeedCovers(Instant)} */\n+  public boolean transitFeedCovers(Instant time) {\n+    return this.graph.transitFeedCovers(time);\n+  }\n+\n+  /** {@link Graph#getBundle()} */\n+  public GraphBundle getBundle() {\n+    return this.graph.getBundle();\n+  }\n+\n+  /** {@link Graph#setBundle(GraphBundle)} */\n+  public void setBundle(GraphBundle bundle) {\n+    this.graph.setBundle(bundle);\n+  }\n+\n+  /** {@link Graph#countVertices()} */\n+  public int countVertices() {\n+    return this.graph.countVertices();\n+  }\n+\n+  /** {@link Graph#countEdges()} */\n+  public int countEdges() {\n+    return this.graph.countEdges();\n+  }\n+\n+  /** {@link Graph#addTransitMode(TransitMode)} */\n+  public void addTransitMode(TransitMode mode) {\n+    this.graph.addTransitMode(mode);\n+  }\n+\n+  /** {@link Graph#getTransitModes()} */\n+  public HashSet<TransitMode> getTransitModes() {\n+    return this.graph.getTransitModes();\n+  }\n+\n+  // /** {@link Graph#index()} */\n+  // public void index() {this.graph.index();}\n+\n+  /** {@link Graph#getCalendarService()} */\n+  public CalendarService getCalendarService() {\n+    return this.graph.getCalendarService();\n+  }\n+\n+  /** {@link Graph#getCalendarDataService()} */\n+  public CalendarServiceData getCalendarDataService() {\n+    return this.graph.getCalendarDataService();\n+  }\n+\n+  /** {@link Graph#clearCachedCalenderService()} */\n+  public void clearCachedCalenderService() {\n+    this.graph.clearCachedCalenderService();\n+  }\n+\n+  /** {@link Graph#getStreetIndex()} */\n+  public StreetVertexIndex getStreetIndex() {\n+    return this.graph.getStreetIndex();\n+  }\n+\n+  /** {@link Graph#getLinker()} */\n+  public VertexLinker getLinker() {\n+    return this.graph.getLinker();\n+  }\n+\n+  /** {@link Graph#getOrCreateServiceIdForDate(ServiceDate)} */\n+  public FeedScopedId getOrCreateServiceIdForDate(ServiceDate serviceDate) {\n+    return this.graph.getOrCreateServiceIdForDate(serviceDate);\n+  }\n+\n+  /** {@link Graph#removeEdgelessVertices()} */\n+  public int removeEdgelessVertices() {\n+    return this.graph.removeEdgelessVertices();\n+  }\n+\n+  /** {@link Graph#getFeedIds()} */\n+  public Collection<String> getFeedIds() {\n+    return this.graph.getFeedIds();\n+  }\n+\n+  /** {@link Graph#getAgencies()} */\n+  public Collection<Agency> getAgencies() {\n+    return this.graph.getAgencies();\n+  }\n+\n+  /** {@link Graph#getFeedInfo(String)} ()} */\n+  public FeedInfo getFeedInfo(String feedId) {\n+    return this.graph.getFeedInfo(feedId);\n+  }\n+\n+  /** {@link Graph#addAgency(String, Agency)} */\n+  public void addAgency(String feedId, Agency agency) {\n+    this.graph.addAgency(feedId, agency);\n+  }\n+\n+  /** {@link Graph#addFeedInfo(FeedInfo)} */\n+  public void addFeedInfo(FeedInfo info) {\n+    this.graph.addFeedInfo(info);\n+  }\n+\n+  /** {@link Graph#getTimeZone()} */\n+  public TimeZone getTimeZone() {\n+    return this.graph.getTimeZone();\n+  }\n+\n+  /** {@link Graph#getOperators()} */\n+  public Collection<Operator> getOperators() {\n+    return this.graph.getOperators();\n+  }\n+\n+  /** {@link Graph#clearTimeZone()} */\n+  public void clearTimeZone() {\n+    this.graph.clearTimeZone();\n+  }\n+\n+  /** {@link Graph#calculateEnvelope()} */\n+  public void calculateEnvelope() {\n+    this.graph.calculateEnvelope();\n+  }\n+\n+  /** {@link Graph#calculateConvexHull()} */\n+  public void calculateConvexHull() {\n+    this.graph.calculateConvexHull();\n+  }\n+\n+  /** {@link Graph#getConvexHull()} */\n+  public Geometry getConvexHull() {\n+    return this.graph.getConvexHull();\n+  }\n+\n+  /** {@link Graph#expandToInclude(double, double)} ()} */\n+  public void expandToInclude(double x, double y) {\n+    this.graph.expandToInclude(x, y);\n+  }\n \n-    /**\n-     * Lazy-initialization of TimetableSnapshot\n-     *\n-     * @return The same TimetableSnapshot is returned throughout the lifecycle of this object.\n-     */\n-    private TimetableSnapshot lazyGetTimeTableSnapShot() {\n-        if (this.timetableSnapshot == null) {\n-            timetableSnapshot = graph.getTimetableSnapshot();\n-        }\n-        return this.timetableSnapshot;\n+  /** {@link Graph#getEnvelope()} */\n+  public WorldEnvelope getEnvelope() {\n+    return this.graph.getEnvelope();\n+  }\n+\n+  /** {@link Graph#calculateTransitCenter()} */\n+  public void calculateTransitCenter() {\n+    this.graph.calculateTransitCenter();\n+  }\n+\n+  /** {@link Graph#getCenter()} */\n+  public Optional<Coordinate> getCenter() {\n+    return this.graph.getCenter();\n+  }\n+\n+  /** {@link Graph#getTransitServiceStarts()} */\n+  public long getTransitServiceStarts() {\n+    return this.graph.getTransitServiceStarts();\n+  }\n+\n+  /** {@link Graph#getTransitServiceEnds()} */\n+  public long getTransitServiceEnds() {\n+    return this.graph.getTransitServiceEnds();\n+  }\n+\n+  /** {@link Graph#getNoticesByElement()} */\n+  public Multimap<TransitEntity, Notice> getNoticesByElement() {\n+    return this.graph.getNoticesByElement();\n+  }\n+\n+  /** {@link Graph#addNoticeAssignments(Multimap)} */\n+  public void addNoticeAssignments(Multimap<TransitEntity, Notice> noticesByElement) {\n+    this.graph.addNoticeAssignments(noticesByElement);\n+  }\n+\n+  /** {@link Graph#getDistanceBetweenElevationSamples()} */\n+  public double getDistanceBetweenElevationSamples() {\n+    return this.graph.getDistanceBetweenElevationSamples();\n+  }\n+\n+  /** {@link Graph#setDistanceBetweenElevationSamples(double)} */\n+  public void setDistanceBetweenElevationSamples(double distanceBetweenElevationSamples) {\n+    this.graph.setDistanceBetweenElevationSamples(distanceBetweenElevationSamples);\n+  }\n+\n+  /** {@link Graph#getTransitAlertService()} */\n+  public TransitAlertService getTransitAlertService() {\n+    return this.graph.getTransitAlertService();\n+  }\n+\n+  public RealtimeVehiclePositionService getVehiclePositionService() {\n+    return this.graph.getVehiclePositionService();\n+  }\n+\n+  /** {@link Graph#getStopVerticesById(FeedScopedId)} */\n+  public Set<Vertex> getStopVerticesById(FeedScopedId id) {\n+    return this.graph.getStopVerticesById(id);\n+  }\n+\n+  /** {@link Graph#getServicesRunningForDate(ServiceDate)} */\n+  public BitSet getServicesRunningForDate(ServiceDate date) {\n+    return this.graph.getServicesRunningForDate(date);\n+  }\n+\n+  /** {@link Graph#getVehicleRentalStationService()} */\n+  public VehicleRentalStationService getVehicleRentalStationService() {\n+    return this.graph.getVehicleRentalStationService();\n+  }\n+\n+  /** {@link Graph#getVehicleParkingService()} */\n+  public VehicleParkingService getVehicleParkingService() {\n+    return this.graph.getVehicleParkingService();\n+  }\n+\n+  /** {@link Graph#getNoticesByEntity(TransitEntity)} */\n+  public Collection<Notice> getNoticesByEntity(TransitEntity entity) {\n+    return this.graph.getNoticesByEntity(entity);\n+  }\n+\n+  /** {@link Graph#getTripPatternForId(FeedScopedId)} */\n+  public TripPattern getTripPatternForId(FeedScopedId id) {\n+    return this.graph.getTripPatternForId(id);\n+  }\n+\n+  /** {@link Graph#getTripPatterns()} */\n+  public Collection<TripPattern> getTripPatterns() {\n+    return this.graph.getTripPatterns();\n+  }\n+\n+  /** {@link Graph#getNotices()} */\n+  public Collection<Notice> getNotices() {\n+    return this.graph.getNotices();\n+  }\n+\n+  /** {@link Graph#getStopsByBoundingBox(double, double, double, double)} */\n+  public Collection<StopLocation> getStopsByBoundingBox(\n+    double minLat,\n+    double minLon,\n+    double maxLat,\n+    double maxLon\n+  ) {\n+    return this.graph.getStopsByBoundingBox(minLat, minLon, maxLat, maxLon);\n+  }\n+\n+  /** {@link Graph#getStopsInRadius(WgsCoordinate, double)} */\n+  public List<T2<Stop, Double>> getStopsInRadius(WgsCoordinate center, double radius) {\n+    return this.graph.getStopsInRadius(center, radius);\n+  }\n+\n+  /** {@link Graph#getStationById(FeedScopedId)} */\n+  public Station getStationById(FeedScopedId id) {\n+    return this.graph.getStationById(id);\n+  }\n+\n+  /** {@link Graph#getMultiModalStation(FeedScopedId)} */\n+  public MultiModalStation getMultiModalStation(FeedScopedId id) {\n+    return this.graph.getMultiModalStation(id);\n+  }\n+\n+  /** {@link Graph#getStations()} */\n+  public Collection<Station> getStations() {\n+    return this.graph.getStations();\n+  }\n+\n+  /** {@link Graph#getServiceCodes()} */\n+  public Map<FeedScopedId, Integer> getServiceCodes() {\n+    return this.graph.getServiceCodes();\n+  }\n+\n+  /** {@link Graph#getTransfersByStop(StopLocation)} */\n+  public Collection<PathTransfer> getTransfersByStop(StopLocation stop) {\n+    return this.graph.getTransfersByStop(stop);\n+  }\n+\n+  /** {@link Graph#getDrivingDirection()} */\n+  public DrivingDirection getDrivingDirection() {\n+    return this.graph.getDrivingDirection();\n+  }\n+\n+  /** {@link Graph#setDrivingDirection(DrivingDirection)} */\n+  public void setDrivingDirection(DrivingDirection drivingDirection) {\n+    this.graph.setDrivingDirection(drivingDirection);\n+  }\n+\n+  /** {@link Graph#getIntersectionTraversalModel()} */\n+  public IntersectionTraversalCostModel getIntersectionTraversalModel() {\n+    return this.graph.getIntersectionTraversalModel();\n+  }\n+\n+  /** {@link Graph#setIntersectionTraversalCostModel(IntersectionTraversalCostModel)} */\n+  public void setIntersectionTraversalCostModel(\n+    IntersectionTraversalCostModel intersectionTraversalCostModel\n+  ) {\n+    this.graph.setIntersectionTraversalCostModel(intersectionTraversalCostModel);\n+  }\n+\n+  /** {@link Graph#getLocationById(FeedScopedId)} */\n+  public FlexStopLocation getLocationById(FeedScopedId id) {\n+    return this.graph.getLocationById(id);\n+  }\n+\n+  /** {@link Graph#getAllFlexStopsFlat()} */\n+  public Set<StopLocation> getAllFlexStopsFlat() {\n+    return this.graph.getAllFlexStopsFlat();\n+  }\n+\n+  /** {@link GraphIndex#getAgencyForId(FeedScopedId)} */\n+  public Agency getAgencyForId(FeedScopedId id) {\n+    return this.graphIndex.getAgencyForId(id);\n+  }\n+\n+  /** {@link GraphIndex#getStopForId(FeedScopedId)} */\n+  public StopLocation getStopForId(FeedScopedId id) {\n+    return this.graphIndex.getStopForId(id);\n+  }\n+\n+  /** {@link GraphIndex#getRouteForId(FeedScopedId)} */\n+  public Route getRouteForId(FeedScopedId id) {\n+    return this.graphIndex.getRouteForId(id);\n+  }\n+\n+  /** {@link GraphIndex#addRoutes(Route)} */\n+  public void addRoutes(Route route) {\n+    this.graphIndex.addRoutes(route);\n+  }\n+\n+  /** {@link GraphIndex#getRoutesForStop(StopLocation)} */\n+  public Set<Route> getRoutesForStop(StopLocation stop) {\n+    return this.graphIndex.getRoutesForStop(stop);\n+  }\n+\n+  /** {@link GraphIndex#getPatternsForStop(StopLocation)} */\n+  public Collection<TripPattern> getPatternsForStop(StopLocation stop) {\n+    return this.graphIndex.getPatternsForStop(stop);\n+  }\n+\n+  /** {@link GraphIndex#getPatternsForStop(StopLocation, TimetableSnapshot)} */\n+  public Collection<TripPattern> getPatternsForStop(\n+    StopLocation stop,\n+    TimetableSnapshot timetableSnapshot\n+  ) {\n+    return this.graphIndex.getPatternsForStop(stop, timetableSnapshot);\n+  }\n+\n+  /** {@link GraphIndex#getAllOperators()} */\n+  public Collection<Operator> getAllOperators() {\n+    return this.graphIndex.getAllOperators();\n+  }\n+\n+  /** {@link GraphIndex#getOperatorForId()} */\n+  public Map<FeedScopedId, Operator> getOperatorForId() {\n+    return this.graphIndex.getOperatorForId();\n+  }\n+\n+  /** {@link GraphIndex#getAllStops()} */\n+  public Collection<StopLocation> getAllStops() {\n+    return this.graphIndex.getAllStops();\n+  }\n+\n+  /** {@link GraphIndex#getTripForId()} */\n+  public Map<FeedScopedId, Trip> getTripForId() {\n+    return this.graphIndex.getTripForId();\n+  }\n+\n+  /** {@link GraphIndex#getAllRoutes()} */\n+  public Collection<Route> getAllRoutes() {\n+    return this.graphIndex.getAllRoutes();\n+  }\n+\n+  /** {@link GraphIndex#getStopVertexForStop()} */\n+  public Map<Stop, TransitStopVertex> getStopVertexForStop() {\n+    return this.graphIndex.getStopVertexForStop();\n+  }\n+\n+  /** {@link GraphIndex#getPatternForTrip()} */\n+  public Map<Trip, TripPattern> getPatternForTrip() {\n+    return this.graphIndex.getPatternForTrip();\n+  }\n+\n+  /** {@link GraphIndex#getPatternsForFeedId()} */\n+  public Multimap<String, TripPattern> getPatternsForFeedId() {\n+    return this.graphIndex.getPatternsForFeedId();\n+  }\n+\n+  /** {@link GraphIndex#getPatternsForRoute()} */\n+  public Multimap<Route, TripPattern> getPatternsForRoute() {\n+    return this.graphIndex.getPatternsForRoute();\n+  }\n+\n+  /** {@link GraphIndex#getMultiModalStationForStations()} */\n+  public Map<Station, MultiModalStation> getMultiModalStationForStations() {\n+    return this.graphIndex.getMultiModalStationForStations();\n+  }\n+\n+  /** {@link GraphIndex#getStopSpatialIndex()} */\n+  public HashGridSpatialIndex<TransitStopVertex> getStopSpatialIndex() {\n+    return this.graphIndex.getStopSpatialIndex();\n+  }\n+\n+  /** {@link GraphIndex#getServiceCodesRunningForDate()} */\n+  public Map<ServiceDate, TIntSet> getServiceCodesRunningForDate() {\n+    return this.graphIndex.getServiceCodesRunningForDate();\n+  }\n+\n+  /** {@link GraphIndex#getFlexIndex()} */\n+  public FlexIndex getFlexIndex() {\n+    return this.graphIndex.getFlexIndex();\n+  }\n+\n+  /** {@link GraphFinder#findClosestStops(double, double, double)} */\n+  public List<NearbyStop> findClosestStops(double lat, double lon, double radiusMeters) {\n+    return this.graphFinder.findClosestStops(lat, lon, radiusMeters);\n+  }\n+\n+  /** {@link GraphFinder#findClosestPlaces(double, double, double, int, List, List, List, List, List, RoutingService)} */\n+  public List<PlaceAtDistance> findClosestPlaces(\n+    double lat,\n+    double lon,\n+    double radiusMeters,\n+    int maxResults,\n+    List<TransitMode> filterByModes,\n+    List<PlaceType> filterByPlaceTypes,\n+    List<FeedScopedId> filterByStops,\n+    List<FeedScopedId> filterByRoutes,\n+    List<String> filterByBikeRentalStations,\n+    List<String> filterByBikeParks,\n+    List<String> filterByCarParks,\n+    RoutingService routingService\n+  ) {\n+    return this.graphFinder.findClosestPlaces(\n+        lat,\n+        lon,\n+        radiusMeters,\n+        maxResults,\n+        filterByModes,\n+        filterByPlaceTypes,\n+        filterByStops,\n+        filterByRoutes,\n+        filterByBikeRentalStations,\n+        routingService\n+      );\n+  }\n+\n+  /**\n+   * Lazy-initialization of TimetableSnapshot\n+   *\n+   * @return The same TimetableSnapshot is returned throughout the lifecycle of this object.\n+   */\n+  private TimetableSnapshot lazyGetTimeTableSnapShot() {\n+    if (this.timetableSnapshot == null) {\n+      timetableSnapshot = graph.getTimetableSnapshot();\n     }\n+    return this.timetableSnapshot;\n+  }\n+\n+  public TripOnServiceDate getTripOnServiceDateForTripAndDay(\n+    FeedScopedId tripId,\n+    ServiceDate serviceDate\n+  ) {\n+    return DatedServiceJourneyHelper.getTripOnServiceDate(this, tripId, serviceDate);\n+  }\n+\n+  public TripOnServiceDate getTripOnServiceDateById(FeedScopedId datedServiceJourneyId) {\n+    return DatedServiceJourneyHelper.getTripOnServiceDate(this, datedServiceJourneyId);\n+  }\n+\n+  public Map<T2<FeedScopedId, ServiceDate>, TripOnServiceDate> getTripOnServiceDateForTripAndDay() {\n+    return graphIndex.getTripOnServiceDateForTripAndDay();\n+  }\n+\n+  public Map<FeedScopedId, TripOnServiceDate> getTripOnServiceDateById() {\n+    return graphIndex.getTripOnServiceDateById();\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex 7a690d2904..906746c245 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -819,4 +810,16 @@ public class RoutingService {\n   public Map<FeedScopedId, TripOnServiceDate> getTripOnServiceDateById() {\n     return graphIndex.getTripOnServiceDateById();\n   }\n+\n+  /**\n+   * Lazy-initialization of TimetableSnapshot\n+   *\n+   * @return The same TimetableSnapshot is returned throughout the lifecycle of this object.\n+   */\n+  private TimetableSnapshot lazyGetTimeTableSnapShot() {\n+    if (this.timetableSnapshot == null) {\n+      timetableSnapshot = graph.getTimetableSnapshot();\n+    }\n+    return this.timetableSnapshot;\n+  }\n }\n", "next_change": {"commit": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex 906746c245..48f47ebd04 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -788,38 +408,8 @@ public class RoutingService {\n         filterByStops,\n         filterByRoutes,\n         filterByBikeRentalStations,\n-        routingService\n+        routingService,\n+        transitService\n       );\n   }\n-\n-  public TripOnServiceDate getTripOnServiceDateForTripAndDay(\n-    FeedScopedId tripId,\n-    ServiceDate serviceDate\n-  ) {\n-    return DatedServiceJourneyHelper.getTripOnServiceDate(this, tripId, serviceDate);\n-  }\n-\n-  public TripOnServiceDate getTripOnServiceDateById(FeedScopedId datedServiceJourneyId) {\n-    return DatedServiceJourneyHelper.getTripOnServiceDate(this, datedServiceJourneyId);\n-  }\n-\n-  public Map<T2<FeedScopedId, ServiceDate>, TripOnServiceDate> getTripOnServiceDateForTripAndDay() {\n-    return graphIndex.getTripOnServiceDateForTripAndDay();\n-  }\n-\n-  public Map<FeedScopedId, TripOnServiceDate> getTripOnServiceDateById() {\n-    return graphIndex.getTripOnServiceDateById();\n-  }\n-\n-  /**\n-   * Lazy-initialization of TimetableSnapshot\n-   *\n-   * @return The same TimetableSnapshot is returned throughout the lifecycle of this object.\n-   */\n-  private TimetableSnapshot lazyGetTimeTableSnapShot() {\n-    if (this.timetableSnapshot == null) {\n-      timetableSnapshot = graph.getTimetableSnapshot();\n-    }\n-    return this.timetableSnapshot;\n-  }\n }\n", "next_change": {"commit": "49e5f98805c30177a666b405dc9c24907d103cf4", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex 48f47ebd04..458a04a93f 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -412,4 +289,19 @@ public class RoutingService {\n         transitService\n       );\n   }\n+\n+  /** {@link Graph#getStopsByBoundingBox(double, double, double, double)} */\n+  public Collection<StopLocation> getStopsByBoundingBox(\n+    double minLat,\n+    double minLon,\n+    double maxLat,\n+    double maxLon\n+  ) {\n+    return this.graph.getStopsByBoundingBox(minLat, minLon, maxLat, maxLon);\n+  }\n+\n+  /** {@link Graph#getStopsInRadius(WgsCoordinate, double)} */\n+  public List<T2<Stop, Double>> getStopsInRadius(WgsCoordinate center, double radius) {\n+    return this.graph.getStopsInRadius(center, radius);\n+  }\n }\n", "next_change": {"commit": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex 458a04a93f..ecc425076a 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -289,19 +409,4 @@ public class RoutingService {\n         transitService\n       );\n   }\n-\n-  /** {@link Graph#getStopsByBoundingBox(double, double, double, double)} */\n-  public Collection<StopLocation> getStopsByBoundingBox(\n-    double minLat,\n-    double minLon,\n-    double maxLat,\n-    double maxLon\n-  ) {\n-    return this.graph.getStopsByBoundingBox(minLat, minLon, maxLat, maxLon);\n-  }\n-\n-  /** {@link Graph#getStopsInRadius(WgsCoordinate, double)} */\n-  public List<T2<Stop, Double>> getStopsInRadius(WgsCoordinate center, double radius) {\n-    return this.graph.getStopsInRadius(center, radius);\n-  }\n }\n", "next_change": {"commit": "104c707a268e954ea21e61645ce2f93b6c1acadc", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex ecc425076a..569dacefc1 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -409,4 +288,19 @@ public class RoutingService {\n         transitService\n       );\n   }\n+\n+  /** {@link Graph#getStopsByBoundingBox(double, double, double, double)} */\n+  public Collection<StopLocation> getStopsByBoundingBox(\n+    double minLat,\n+    double minLon,\n+    double maxLat,\n+    double maxLon\n+  ) {\n+    return this.graph.getStopsByBoundingBox(minLat, minLon, maxLat, maxLon);\n+  }\n+\n+  /** {@link Graph#getStopsInRadius(WgsCoordinate, double)} */\n+  public List<T2<Stop, Double>> getStopsInRadius(WgsCoordinate center, double radius) {\n+    return this.graph.getStopsInRadius(center, radius);\n+  }\n }\n", "next_change": {"commit": "05547a0b5891ecec375b5213b2a14968dd5c99b6", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex 569dacefc1..55508089f2 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -284,23 +182,7 @@ public class RoutingService {\n         filterByStops,\n         filterByRoutes,\n         filterByBikeRentalStations,\n-        routingService,\n         transitService\n       );\n   }\n-\n-  /** {@link Graph#getStopsByBoundingBox(double, double, double, double)} */\n-  public Collection<StopLocation> getStopsByBoundingBox(\n-    double minLat,\n-    double minLon,\n-    double maxLat,\n-    double maxLon\n-  ) {\n-    return this.graph.getStopsByBoundingBox(minLat, minLon, maxLat, maxLon);\n-  }\n-\n-  /** {@link Graph#getStopsInRadius(WgsCoordinate, double)} */\n-  public List<T2<Stop, Double>> getStopsInRadius(WgsCoordinate center, double radius) {\n-    return this.graph.getStopsInRadius(center, radius);\n-  }\n }\n", "next_change": {"commit": "61318ff296e6e8b3b7c2364aef7dd09b5e4480fd", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\ndeleted file mode 100644\nindex 55508089f2..0000000000\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ /dev/null\n", "chunk": "@@ -1,188 +0,0 @@\n-package org.opentripplanner.routing;\n-\n-import java.time.ZoneId;\n-import java.util.Collection;\n-import java.util.List;\n-import org.locationtech.jts.geom.Envelope;\n-import org.locationtech.jts.geom.Geometry;\n-import org.opentripplanner.common.model.T2;\n-import org.opentripplanner.graph_builder.module.osm.WayPropertySetSource.DrivingDirection;\n-import org.opentripplanner.routing.algorithm.RoutingWorker;\n-import org.opentripplanner.routing.api.request.RoutingRequest;\n-import org.opentripplanner.routing.api.response.RoutingResponse;\n-import org.opentripplanner.routing.core.intersection_model.IntersectionTraversalCostModel;\n-import org.opentripplanner.routing.edgetype.StreetEdge;\n-import org.opentripplanner.routing.graph.Edge;\n-import org.opentripplanner.routing.graph.Graph;\n-import org.opentripplanner.routing.graph.Vertex;\n-import org.opentripplanner.routing.graphfinder.GraphFinder;\n-import org.opentripplanner.routing.graphfinder.NearbyStop;\n-import org.opentripplanner.routing.graphfinder.PlaceAtDistance;\n-import org.opentripplanner.routing.graphfinder.PlaceType;\n-import org.opentripplanner.routing.impl.StreetVertexIndex;\n-import org.opentripplanner.routing.services.RealtimeVehiclePositionService;\n-import org.opentripplanner.routing.vehicle_parking.VehicleParkingService;\n-import org.opentripplanner.routing.vehicle_rental.VehicleRentalStationService;\n-import org.opentripplanner.standalone.api.OtpServerContext;\n-import org.opentripplanner.transit.model.basic.TransitMode;\n-import org.opentripplanner.transit.model.basic.WgsCoordinate;\n-import org.opentripplanner.transit.model.framework.FeedScopedId;\n-import org.opentripplanner.transit.model.site.Stop;\n-import org.opentripplanner.transit.model.site.StopLocation;\n-import org.opentripplanner.transit.service.TransitService;\n-import org.opentripplanner.util.WorldEnvelope;\n-\n-/**\n- * Entry point for requests towards the routing API.\n- */\n-public class RoutingService {\n-\n-  private final OtpServerContext serverContext;\n-  private final Graph graph;\n-\n-  private final ZoneId timeZone;\n-\n-  private final GraphFinder graphFinder;\n-\n-  public RoutingService(OtpServerContext serverContext) {\n-    this.serverContext = serverContext;\n-    this.graph = serverContext.graph();\n-    this.timeZone = serverContext.transitService().getTimeZone();\n-    this.graphFinder = GraphFinder.getInstance(graph);\n-  }\n-\n-  public RoutingResponse route(RoutingRequest request) {\n-    RoutingWorker worker = new RoutingWorker(serverContext, request, timeZone);\n-    return worker.route();\n-  }\n-\n-  /** {@link Graph#getVertex(String)} */\n-  public Vertex getVertex(String label) {\n-    return this.graph.getVertex(label);\n-  }\n-\n-  /** {@link Graph#getVertices()} */\n-  public Collection<Vertex> getVertices() {\n-    return this.graph.getVertices();\n-  }\n-\n-  /** {@link Graph#getVerticesOfType(Class)} */\n-  public <T extends Vertex> List<T> getVerticesOfType(Class<T> cls) {\n-    return this.graph.getVerticesOfType(cls);\n-  }\n-\n-  /** {@link Graph#getEdges()} */\n-  public Collection<Edge> getEdges() {\n-    return this.graph.getEdges();\n-  }\n-\n-  /** {@link Graph#getEdgesOfType(Class)} */\n-  public <T extends Edge> List<T> getEdgesOfType(Class<T> cls) {\n-    return this.graph.getEdgesOfType(cls);\n-  }\n-\n-  /** {@link Graph#getStreetEdges()} */\n-  public Collection<StreetEdge> getStreetEdges() {\n-    return this.graph.getStreetEdges();\n-  }\n-\n-  /** {@link Graph#containsVertex(Vertex)} */\n-  public boolean containsVertex(Vertex v) {\n-    return this.graph.containsVertex(v);\n-  }\n-\n-  /** {@link Graph#getExtent()} */\n-  public Envelope getExtent() {\n-    return this.graph.getExtent();\n-  }\n-\n-  /** {@link Graph#countVertices()} */\n-  public int countVertices() {\n-    return this.graph.countVertices();\n-  }\n-\n-  /** {@link Graph#countEdges()} */\n-  public int countEdges() {\n-    return this.graph.countEdges();\n-  }\n-\n-  /** {@link Graph#getStreetIndex()} */\n-  public StreetVertexIndex getStreetIndex() {\n-    return this.graph.getStreetIndex();\n-  }\n-\n-  /** {@link Graph#getConvexHull()} */\n-  public Geometry getConvexHull() {\n-    return this.graph.getConvexHull();\n-  }\n-\n-  /** {@link Graph#getEnvelope()} */\n-  public WorldEnvelope getEnvelope() {\n-    return this.graph.getEnvelope();\n-  }\n-\n-  /** {@link Graph#getDistanceBetweenElevationSamples()} */\n-  public double getDistanceBetweenElevationSamples() {\n-    return this.graph.getDistanceBetweenElevationSamples();\n-  }\n-\n-  public RealtimeVehiclePositionService getVehiclePositionService() {\n-    return this.graph.getVehiclePositionService();\n-  }\n-\n-  /** {@link Graph#getVehicleRentalStationService()} */\n-  public VehicleRentalStationService getVehicleRentalStationService() {\n-    return this.graph.getVehicleRentalStationService();\n-  }\n-\n-  /** {@link Graph#getVehicleParkingService()} */\n-  public VehicleParkingService getVehicleParkingService() {\n-    return this.graph.getVehicleParkingService();\n-  }\n-\n-  /** {@link Graph#getDrivingDirection()} */\n-  public DrivingDirection getDrivingDirection() {\n-    return this.graph.getDrivingDirection();\n-  }\n-\n-  /** {@link Graph#getIntersectionTraversalModel()} */\n-  public IntersectionTraversalCostModel getIntersectionTraversalModel() {\n-    return this.graph.getIntersectionTraversalModel();\n-  }\n-\n-  /** {@link GraphFinder#findClosestStops(double, double, double)} */\n-  public List<NearbyStop> findClosestStops(double lat, double lon, double radiusMeters) {\n-    return this.graphFinder.findClosestStops(lat, lon, radiusMeters);\n-  }\n-\n-  /**\n-   * {@link GraphFinder#findClosestPlaces(double, double, double, int, List, List, List, List, List, TransitService)}\n-   */\n-  public List<PlaceAtDistance> findClosestPlaces(\n-    double lat,\n-    double lon,\n-    double radiusMeters,\n-    int maxResults,\n-    List<TransitMode> filterByModes,\n-    List<PlaceType> filterByPlaceTypes,\n-    List<FeedScopedId> filterByStops,\n-    List<FeedScopedId> filterByRoutes,\n-    List<String> filterByBikeRentalStations,\n-    List<String> filterByBikeParks,\n-    List<String> filterByCarParks,\n-    TransitService transitService\n-  ) {\n-    return this.graphFinder.findClosestPlaces(\n-        lat,\n-        lon,\n-        radiusMeters,\n-        maxResults,\n-        filterByModes,\n-        filterByPlaceTypes,\n-        filterByStops,\n-        filterByRoutes,\n-        filterByBikeRentalStations,\n-        transitService\n-      );\n-  }\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "81d657fff46a5d9ab212d04e0a60814a26ba168e", "message": "Merge commit", "committedDate": null}, {"oid": "40579c34c80bed176021d9e825f83d656d689607", "committedDate": "2021-03-03 14:39:09 +0100", "message": "Handle request cleanup within the routing service"}, {"oid": "414bc6f38c3b4ccda9a021a97382c8fb3a23060b", "committedDate": "2021-03-15 13:39:21 +0100", "message": "Do not destroy previous RoutingContext when resetting context. Call request cleanup in RoutingService instead."}, {"oid": "95103bcb3e0762171ba93908a7e6979b0522d43e", "committedDate": "2021-04-28 13:42:39 +0200", "message": "refactor: Add/fix toString() and code style"}, {"oid": "e40333a74b5aeffb95fddb296801826551928be8", "committedDate": "2021-05-05 10:44:48 +0200", "message": "Create separate requests for each sub-request"}, {"oid": "ab3d510782dc80ee2629005b9cd7210fe39d69f9", "committedDate": "2021-05-05 19:39:06 +0200", "message": "Merge pull request #3430 from entur/otp2_transfers_priority_part_2"}, {"oid": "38837612637105e1f5f3b29a6ccb90d24da8c1f9", "committedDate": "2021-07-23 15:25:47 +0200", "message": "Encapsulate fields in TripPattern"}, {"oid": "58b429176933dbd5629a52e945a141089bd9c4e9", "committedDate": "2021-07-27 12:19:34 +0200", "message": "Rename TripTimeShort to TripTimeOnDate"}, {"oid": "f1d0c27f09631d491270cc11d04856b261fccdf0", "committedDate": "2021-08-03 14:20:53 +0200", "message": "Move StopTimesHelper to its own package"}, {"oid": "4e4722d93448020a8b5c16c994bf9d121f189380", "committedDate": "2021-08-03 15:04:40 +0200", "message": "Change omitNonPickups to ArrivalDeparture and change Transmodel API accordingly"}, {"oid": "966f756cbf016be6629c9bab63b3108ac4548f02", "committedDate": "2021-10-05 10:37:40 +0200", "message": "Parallelize trip planning calculations"}, {"oid": "38feda70197d9533b52a0352002a7aea3c52cf0c", "committedDate": "2021-11-29 20:12:14 +0100", "message": "fix: do proper cleanup"}, {"oid": "f09af69e6800fb40d53b7da2855e4d6948811fe6", "committedDate": "2021-11-29 21:17:59 +0100", "message": "refactor: date handling in RoutingWorker"}, {"oid": "caebd030892736472859794501fbd14b8a224258", "committedDate": "2021-12-10 12:51:39 +0100", "message": "Return StopLocation in LegacyGraphQLApi"}, {"oid": "444e81ba1d1ce977c605ba4761be184f66f1a50d", "committedDate": "2021-12-16 12:39:59 +0200", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_cusor_based_scrolling"}, {"oid": "f4e4e50bf6aa8665a38b4d42c1a14a68fb3e599c", "committedDate": "2021-12-16 12:47:07 +0200", "message": "Apply suggestions from code review"}, {"oid": "3ddf4620766898d4e3e5c41aaa244fdbdb7233cb", "committedDate": "2021-12-16 12:47:28 +0200", "message": "Merge remote-tracking branch 'entur/otp2_cusor_based_scrolling' into otp2_cusor_based_scrolling"}, {"oid": "bcdc8dcddcce1f04650b2ef6ad2f09123fe54f5b", "committedDate": "2022-01-07 15:44:42 +0100", "message": "Default to GMT if there is no transit layer."}, {"oid": "a4e34622cdceae9b3808d05e1053e8ce476c9aeb", "committedDate": "2022-02-04 10:45:13 +0100", "message": "refactor: Remove all usage of lombok"}, {"oid": "82b849a61b103cbd379fd623c893852696f01307", "committedDate": "2022-02-14 11:00:50 +0100", "message": "Move turn restrictions into edge"}, {"oid": "7ee3df5e8f00cd39608ebf34a1591c0478fb05ea", "committedDate": "2022-02-21 17:36:10 +0100", "message": "Reanme package `raptor` to `raptoradapter`"}, {"oid": "61019413052ceb04da1ce5c6e16960bf125d9b7d", "committedDate": "2022-02-23 11:08:35 +0200", "message": "Merge branch 'dev-2.x' into otp2_frequencies"}, {"oid": "24bd287aa9f15c5054c31b0b2d7e8b85eed93b63", "committedDate": "2022-03-10 19:51:55 +0200", "message": "Take realtime changed patterns into account in legacy trip impl"}, {"oid": "546ab215992df6ae4fa5ce46056c066c01fa289b", "committedDate": "2022-03-11 16:10:04 +0100", "message": "Store vehicle position in service"}, {"oid": "5a006958cce564e94473336efa8fcbe9a1436da3", "committedDate": "2022-03-15 17:44:39 +0100", "message": "Apply review feedback"}, {"oid": "e014badc5571fd0adbfa7ce2c23e835bc03b1fd0", "committedDate": "2022-03-21 16:08:44 +0100", "message": "refactor: Fix Javadoc comments that don't belong to any class, method or field"}, {"oid": "d3115bd53d016bd0ac140139f9800b17435cfe57", "committedDate": "2022-03-22 00:27:48 +0100", "message": "refactor: Remove unused method variables + fix tests"}, {"oid": "aa06e31d0739586374cd8fca1219c1dc5e5e9c69", "committedDate": "2022-03-22 12:08:47 +0100", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into vehicle-positions"}, {"oid": "7526b175afaced0ef7d4ee63a18cc2046673e4a7", "committedDate": "2022-03-24 09:58:03 +0200", "message": "Merge remote-tracking branch 'upstream/dev-2.x' into gtfsrt-cancelled-stops"}, {"oid": "d3de5c8b39d4a14c3093bc8263364920c984e9b8", "committedDate": "2022-03-25 15:11:37 +0100", "message": "Mapping and graphQL endpoint for DatedServiceJourney"}, {"oid": "a09fda5a2a7b905f0db792e3feffcc835dd36dfd", "committedDate": "2022-03-29 12:29:15 +0300", "message": "Merge pull request #3960 from HSLdevcom/gtfsrt-cancelled-stops"}, {"oid": "eaf3a05afa0912a14cc1b3db0f2988442070ffb6", "committedDate": "2022-03-31 18:38:52 +0300", "message": "Remove RoutingContext from RoutingRequest and extract TemporaryVerticesContainer"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "7d29407fbca79a791d0de9a6398effda6de1d73c", "committedDate": "2022-04-28 15:12:18 +0300", "message": "Use TripIdAndServiceDate instead of T2<>"}, {"oid": "d733bf8fba8623745c7a5b92da4fbe4bd2747710", "committedDate": "2022-04-28 17:01:11 +0300", "message": "Fix default date on ServiceJourney estimatedCalls in Transmodel API"}, {"oid": "a68537768eec52aa67f88e780e7a716b7709e8d4", "committedDate": "2022-05-06 17:04:23 +0200", "message": "refactor: Move Agency and make it immutable"}, {"oid": "e155f2947ef787489068175171416c132434207a", "committedDate": "2022-05-06 19:11:16 +0200", "message": "refactor: Move Operator and make it immutable"}, {"oid": "471198817d0a1017ec2314fb1143f4d0f1bac3d9", "committedDate": "2022-05-06 19:20:12 +0200", "message": "refactor: Move FeedScopeId into package 'org.opentripplanner.transit.model.basic'"}, {"oid": "d484f45f4d6f87f6c490a392c2dbe2daad69e29c", "committedDate": "2022-05-09 14:10:26 +0200", "message": "refactor: Move some core model classes"}, {"oid": "5b2c4d18588bdf5a7de7d93418e0b3ebc68279a6", "committedDate": "2022-05-19 18:22:44 +0200", "message": "refactor: Move BikeAccess, GroupOfRoutes, Route and TransitMode"}, {"oid": "b68ea1a5bccbcfc98d46ebac6490056a69c44550", "committedDate": "2022-05-25 15:44:44 +0200", "message": "refactor: Move Trip to new location."}, {"oid": "20d1043872ba181abe73930a5fb3dd01feecef59", "committedDate": "2022-06-13 17:19:52 +0200", "message": "refactor: Rename transit model package to framework from basic"}, {"oid": "b0c367119fc2b637823337923b5504444eb45a52", "committedDate": "2022-06-13 17:38:22 +0200", "message": "refactor: Move Stop related classes into package site"}, {"oid": "6e2067aa11bc9a443b1e643845e23128108e4bfc", "committedDate": "2022-06-13 18:49:32 +0200", "message": "Code cleanup"}, {"oid": "b8180ad63d9513566b4e61c99b7fc03e46ad5455", "committedDate": "2022-06-15 13:49:47 +0200", "message": "Introduce TransitService"}, {"oid": "bf91694090e2b2cae1016b1e2ec56581eab2bcdc", "committedDate": "2022-06-15 16:35:25 +0200", "message": "Migrate methods from RoutingService to TransitService"}, {"oid": "074e8213ea13dda1ef82465c4f2be845f11b188d", "committedDate": "2022-06-16 09:53:48 +0200", "message": "Added Javadoc"}, {"oid": "69408e579c9da646b396d2d2e28377b1e598d7b7", "committedDate": "2022-06-16 14:53:52 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_refactor_transit_service"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "43b676a9a9d7998264c3bb5bc732d8fd5db7f848", "committedDate": "2022-06-30 14:00:01 +0300", "message": "Convert java.util to java.time classes"}, {"oid": "104c707a268e954ea21e61645ce2f93b6c1acadc", "committedDate": "2022-07-05 17:40:24 +0300", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_convert_legacy_times"}, {"oid": "3b4316833886ff242325e031fa13264850b5317e", "committedDate": "2022-07-19 15:48:45 +0200", "message": "refactor: Move Transit- and Sub- Mode to basic"}, {"oid": "722543e8a775457e893267b3b6688fd135447fc4", "committedDate": "2022-07-22 15:19:50 +0200", "message": "refactor: Restrict API Resource assess by introducing OtpServerContext"}, {"oid": "e5475ab4184dd451716c7273991ffa4fbb3d97ec", "committedDate": "2022-07-26 18:30:44 +0200", "message": "Migrate RoutingService to using TransitService"}, {"oid": "d3aabaad07fe3ffee488dbf9a8206883a665fb57", "committedDate": "2022-07-27 09:59:58 +0200", "message": "Remove unused GraphBundle"}, {"oid": "47ca66a2bfc62234257d23f63d3d323fba23e329", "committedDate": "2022-07-27 09:59:58 +0200", "message": "Remove edit methods from RoutingService"}, {"oid": "b277b5d0ffd303c26f9b9ad80131f1b7e1e2d78b", "committedDate": "2022-07-27 10:21:24 +0200", "message": "Clean up usage of RoutingService"}, {"oid": "05547a0b5891ecec375b5213b2a14968dd5c99b6", "committedDate": "2022-07-28 16:40:09 +0200", "message": "Remove duplicate stop index from Graph"}, {"oid": "458e10cea54a83a9300c8d57732e101f5e710e1b", "committedDate": "2022-07-28 22:18:29 +0200", "message": "Merge remote-tracking branch 'otp/dev-2.x' into otp2_di_graph_builder"}, {"oid": "b34dacd560703eaa268f5a88e160e5eb0818da56", "committedDate": "2022-08-11 12:03:00 +0200", "message": "refactor: Rename OtpServerContext to OtpServerRequestContext"}, {"oid": "a808bb46983845a37ff98b8ad0dd2ba6dcf9da7f", "committedDate": "2022-08-16 22:37:00 +0200", "message": "refactor: Remove dependency to graph in DirectGraphFinder."}, {"oid": "2ac519ded15f7fe80ef63be487582bed1bbc0fd4", "committedDate": "2022-09-05 08:24:08 +0300", "message": "refactor: Rename RoutingRequest to RouteRequest"}, {"oid": "2828d605f422f3de09f667949589fc43ed9cac79", "committedDate": "2022-09-12 16:30:06 +0300", "message": "Routing request refactor - VIA search part A (#4392)"}, {"oid": "f0c56fd15b147f5c0636956b14e0736282321aa8", "committedDate": "2022-09-13 20:38:23 +0300", "message": "Rename IntersectionTraversalCostModel IntersectionTraversalCalculator"}, {"oid": "e6b806a72a0cc87f4c6e7ff9e2d54ac0f8cee26c", "committedDate": "2022-09-13 20:38:23 +0300", "message": "Move IntersectionTraversalCalculator into StreetPreferences"}, {"oid": "44093e61337f9821842933d2e7c4929c73651157", "committedDate": "2022-09-15 12:00:04 +0300", "message": "Merge remote-tracking branch 'origin/dev-2.x' into otp2_move_intersection_cost_model"}, {"oid": "3ce7ae521bbd15936f3419522761ca648c364e1e", "committedDate": "2022-10-27 13:43:32 +0200", "message": "Issue #4494Via search - Pard D"}, {"oid": "9868495f0e42e3a6185bf8a9d0c55543cb6ea485", "committedDate": "2022-10-27 15:52:39 +0300", "message": "Do some coordinate refactoring"}, {"oid": "266d62dbba1a976dd173781c36662fe5f38f6643", "committedDate": "2022-11-04 09:05:16 +0100", "message": "Merge branch 'dev-2.x' into 4494_via_search_part_d"}, {"oid": "58ccef65ba72a7d8fbce80395d3c500fe7685960", "committedDate": "2022-11-04 11:29:14 +0100", "message": "Rename VehicleRentalStationService and PollingStoptimeUpdaterConfig"}, {"oid": "d031bc2a2a9f5c1209fd6341da978726082f7ab2", "committedDate": "2022-11-04 11:35:39 +0100", "message": "Rename another method"}, {"oid": "2599a0620c1c3b58a6ea965fff0fc5f6b9262f20", "committedDate": "2022-11-07 13:21:19 +0200", "message": "Move graph indices into own package"}, {"oid": "5daa8b6096f0f1101310605c01327755cfcf36a5", "committedDate": "2022-11-07 13:27:11 +0200", "message": "Merge edge indices"}, {"oid": "3ae5bb4b0a51aeba05e27ea5fbfefdec2e9865e2", "committedDate": "2022-11-10 13:38:15 +0100", "message": "Issue #4494 Minor code review fixes"}, {"oid": "f177e2e6c1b87446954d15ee75c2f29e667bf8a3", "committedDate": "2022-11-10 13:38:58 +0100", "message": "Merge branch 'dev-2.x' into 4494_via_search_part_d"}, {"oid": "eb911bd86c16ea3418225178b47ec6689ca1c64e", "committedDate": "2022-11-10 15:44:09 +0100", "message": "Merge branch 'dev-2.x' into otp2_graph_index"}, {"oid": "2665d8e01fb2b7c0c979bee926f53353c4040cc1", "committedDate": "2022-11-16 14:38:47 +0100", "message": "Merge branch 'dev-2.x' into 4494_via_search_part_d"}, {"oid": "759d43b71b8fc5a8ea51819bb6a211eff74bff0e", "committedDate": "2022-11-23 15:03:45 +0100", "message": "Move Edge and Vertex to AStar"}, {"oid": "be30fe2b71c7f34435152e7f299eef48812a6848", "committedDate": "2022-11-23 15:24:11 +0100", "message": "Move Edges to street model"}, {"oid": "c208535bef8d577b01a09b073d2da5c74ab56708", "committedDate": "2022-11-23 17:30:21 +0100", "message": "Remove unused RoutingService"}, {"oid": "61318ff296e6e8b3b7c2364aef7dd09b5e4480fd", "committedDate": "2023-01-27 13:34:57 +0100", "message": "Remove vehicle services from routing service"}]}, {"oid": "afa16eb606da23d6c30b6a7288e08d0e7a04b878", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/afa16eb606da23d6c30b6a7288e08d0e7a04b878", "message": "Removed custom alerts-handling where \"route OR stop\" was treated as \"route AND stop\"", "committedDate": "2020-09-18T14:11:44Z", "type": "commit"}, {"oid": "e76de7b7f1b8d041941b9ea357c50ce9671bf402", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e76de7b7f1b8d041941b9ea357c50ce9671bf402", "message": "Including open-ended alerts when calculating valid display-times", "committedDate": "2020-09-24T13:15:55Z", "type": "commit"}, {"oid": "27c2a63e660df962344672dd8a909c94f3618989", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/27c2a63e660df962344672dd8a909c94f3618989", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-25T08:21:09Z", "type": "commit"}, {"oid": "7fdbcea712bab20251082750842d0c5c7f0d4f49", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/7fdbcea712bab20251082750842d0c5c7f0d4f49", "message": "Removed license-information", "committedDate": "2020-09-25T11:48:55Z", "type": "commit"}, {"oid": "655f5c816d61de60833f95a73006669ca9963d4f", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/655f5c816d61de60833f95a73006669ca9963d4f", "message": "Added comment as javadoc", "committedDate": "2020-09-25T11:48:55Z", "type": "commit"}, {"oid": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "message": "clean code: Reformatted SiriAlertsUpdateHandlerTest.java", "committedDate": "2020-09-25T14:23:50Z", "type": "commit"}, {"oid": "30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-30T08:54:07Z", "type": "commit"}, {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "message": "Add HashCode to TripPattern and document the eq/hc hack.", "committedDate": "2020-09-30T09:33:13Z", "type": "commit"}, {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "message": "Add HashCode to TripPattern and document the eq/hc hack.", "committedDate": "2020-09-30T09:33:13Z", "type": "forcePushed"}]}