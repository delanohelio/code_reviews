{"pr_number": 3166, "pr_title": "Re-implementation of SIRI support", "pr_author": "lassetyr", "pr_createdAt": "2020-08-28T07:18:50Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166", "timeline": [{"oid": "5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5fe18dec15cf6e5144bfd8d2cd8008a73bee5909", "message": "Initial commit of SIRI-reimplementation from OTP1", "committedDate": "2020-08-07T08:18:26Z", "type": "commit"}, {"oid": "61802f4468da112388c9c31121ce5e52d58cf063", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/61802f4468da112388c9c31121ce5e52d58cf063", "message": "Merge branch 'kyyticom-remove-alert-patcher' into siri-realtime", "committedDate": "2020-08-10T12:44:55Z", "type": "commit"}, {"oid": "5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/5b64fb0079a3cbaa6a340112a8fbdb0afd8d9a86", "message": "Updating SIRI-implementation to changes from PR #3134", "committedDate": "2020-08-11T06:53:51Z", "type": "commit"}, {"oid": "49880da748519e1e260413636efa6fe77c20d1ba", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/49880da748519e1e260413636efa6fe77c20d1ba", "message": "Avoiding NPE when setting id on alert", "committedDate": "2020-08-11T11:04:37Z", "type": "commit"}, {"oid": "d87862c309aa01e515406a6597c2cc0bd1a7c263", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d87862c309aa01e515406a6597c2cc0bd1a7c263", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-08-27T10:32:53Z", "type": "commit"}, {"oid": "2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2c40ff2f0505bb0d6c7ebe49397123fd335fe787", "message": "Returning decoded id as SituationNumber", "committedDate": "2020-08-27T14:05:40Z", "type": "commit"}, {"oid": "ab89d17d5a1626a02986591efc97c43bae82cc24", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ab89d17d5a1626a02986591efc97c43bae82cc24", "message": "Added GraphQL-field for severity", "committedDate": "2020-08-27T14:06:37Z", "type": "commit"}, {"oid": "363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/363e782ddde17fb6aef87e6f9bea56aa5ae64e52", "message": "Also checking for sibling-matches when applying TransitAlerts to Leg", "committedDate": "2020-08-27T14:07:37Z", "type": "commit"}, {"oid": "af2f6dbce50f6d74369692095008d63c40d145db", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/af2f6dbce50f6d74369692095008d63c40d145db", "message": "Handling SIRI ET-updates with only RecordedCalls", "committedDate": "2020-08-27T14:09:24Z", "type": "commit"}, {"oid": "98ae088441b9ff37eea34c67d5417be2d11833c4", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/98ae088441b9ff37eea34c67d5417be2d11833c4", "message": "Added simple retry-functionality for when the SIRI-request times out.", "committedDate": "2020-08-27T14:27:12Z", "type": "commit"}, {"oid": "ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ff6c346b67aec964dee5f2c6e3eac20e11e49ef0", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-04T08:18:45Z", "type": "commit"}, {"oid": "9c24322f269177b9cdf4f381fbc8a2b36d462d13", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9c24322f269177b9cdf4f381fbc8a2b36d462d13", "message": "Updating siri-protobuf-mapper to public version", "committedDate": "2020-09-09T13:37:26Z", "type": "commit"}, {"oid": "1853a44ae4cac535aad915f92e24aff2912056b3", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1853a44ae4cac535aad915f92e24aff2912056b3", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-09T14:52:06Z", "type": "commit"}, {"oid": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/abe0d21c32aca02da5acae76ea4595cdfc3895ae", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-14T10:48:39Z", "type": "commit"}, {"oid": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "message": "Clean code\n  - Avoid adding new methods just because there is one extra argument.\n  - Remove unused code.\n  - Make a few things final.\n  - catch typed exceptions(IOException|JAXBException|XMLStreamException) not just the generic Exception - avoid entering a infinite loop on NPE.\n  - Remove obsolete null checks.\n  - Remove empty JavaDoc tags.", "committedDate": "2020-09-14T14:06:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzkzNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487717934", "body": "Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.", "bodyText": "Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.", "bodyHTML": "<p dir=\"auto\">Remove this - The licence for the code is maintained in one place, and unless this code have a different licence it should not include anything about the licence at all. If the code is coped from some other project with a different licence then that licence needs to be added to the documentation and referenced from here.</p>", "author": "t2gran", "createdAt": "2020-09-14T07:52:08Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDI4NQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494990285", "bodyText": "Done", "author": "lassetyr", "createdAt": "2020-09-25T13:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNzkzNA=="}], "type": "inlineReview", "revised_code": {"commit": "7fdbcea712bab20251082750842d0c5c7f0d4f49", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\nindex 7eb79d356..aa7eb35f0 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java\n", "chunk": "@@ -1,16 +1,3 @@\n-/* This program is free software: you can redistribute it and/or\n- modify it under the terms of the GNU Lesser General Public License\n- as published by the Free Software Foundation, either version 3 of\n- the License, or (at your option) any later version.\n-\n- This program is distributed in the hope that it will be useful,\n- but WITHOUT ANY WARRANTY; without even the implied warranty of\n- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n- GNU General Public License for more details.\n-\n- You should have received a copy of the GNU General Public License\n- along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n-\n package org.opentripplanner.ext.siri.updater;\n \n import com.google.cloud.pubsub.v1.AckReplyConsumer;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDQwNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487720406", "body": "Empty annotations can just be removed.\r\n", "bodyText": "Empty annotations can just be removed.", "bodyHTML": "<p dir=\"auto\">Empty annotations can just be removed.</p>", "author": "t2gran", "createdAt": "2020-09-14T07:56:26Z", "path": "src/main/java/org/opentripplanner/routing/StopTimesHelper.java", "diffHunk": "@@ -34,6 +34,8 @@\n    * @param timeRange Searches forward for timeRange seconds from startTime\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n+   * @param includeCancelledTrips If true, cancelled trips will also be included in result\n+   * @return", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjYzNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972636", "bodyText": "I fixed this.", "author": "t2gran", "createdAt": "2020-09-14T14:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMDQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\nindex c9959ea66..3a22a74ba 100644\n--- a/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n+++ b/src/main/java/org/opentripplanner/routing/StopTimesHelper.java\n", "chunk": "@@ -35,7 +35,6 @@ public class StopTimesHelper {\n    * @param numberOfDepartures Number of departures to fetch per pattern\n    * @param omitNonPickups If true, do not include vehicles that will not pick up passengers.\n    * @param includeCancelledTrips If true, cancelled trips will also be included in result\n-   * @return\n    */\n   public static List<StopTimesInPattern> stopTimesForStop(\n       RoutingService routingService,\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMjY2Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487722666", "body": "Add as JavaDoc", "bodyText": "Add as JavaDoc", "bodyHTML": "<p dir=\"auto\">Add as JavaDoc</p>", "author": "t2gran", "createdAt": "2020-09-14T08:00:24Z", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk5MDQ4Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494990487", "bodyText": "Done", "author": "lassetyr", "createdAt": "2020-09-25T13:33:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMjY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "655f5c816d61de60833f95a73006669ca9963d4f", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbf..6f864480e 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -641,7 +641,9 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n \n-    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    /**\n+     * Need an equals() since trips in a pattern are no longer necessarily running on the same service ID.\n+     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) {\n", "next_change": {"commit": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 6f864480e..890dc1c7e 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -642,7 +642,28 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n     }\n \n     /**\n-     * Need an equals() since trips in a pattern are no longer necessarily running on the same service ID.\n+     * Need an equals() since trips in a pattern are no longer necessarily running on the same\n+     * service ID.\n+     * <p>\n+     * A TransitEntity SHOULD not implement hashCode/equals. We make an EXCEPTION to this for\n+     * TripPattern, because the alternative is worse. Since TripPatterns are cloned and changed by\n+     * realtime updates and exist in a \"global\" space in Sets/Maps, the equals and hash code\n+     * need to include all elements that can be changed. We could make a wrapper type and implement\n+     * hc/eq for that and use that in all Set/Maps, but that would also ve quite messy. The REAL\n+     * fix to this problem is to make TripPattern unique within the context it live. This is a\n+     * larger task and should be addressed when implementing the issue:\n+     * https://github.com/opentripplanner/OpenTripPlanner/issues/3030\n+     * <p>\n+     * The TripPattern is used as a <em>key</em> in a Set/Map in quite a few places. Use a reg-exp\n+     * search for \"(Map|Set)<TripPattern\") to find the places where it is used.\n+     * <p>\n+     * Note! Classes that have mutable fields that are part of eq/hc are vulnerable. If added to a\n+     * Set/Map the set/map MUST be re-indexed it the object is mutated. When mutating TripPattens\n+     * make sure the object is NOT part of an existing Set/Map.\n+     * <p>\n+     * {@code hopGeometries}  is NOT part of the equals/hashCode methods to avoid costly\n+     * computations. Hence; It is not allowed to ONLY change the hopGeometries, but at least one\n+     * other field must be changed.\n      */\n     @Override\n     public boolean equals(Object o) {\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc0NzYwMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487747601", "body": "Use the <project-root>/intellij-code-style.xml to format the code.", "bodyText": "Use the /intellij-code-style.xml to format the code.", "bodyHTML": "<p dir=\"auto\">Use the /intellij-code-style.xml to format the code.</p>", "author": "t2gran", "createdAt": "2020-09-14T08:43:10Z", "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac8..5816fe258 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -11,27 +11,7 @@ import org.opentripplanner.routing.alertpatch.TransitAlert;\n import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n import org.opentripplanner.updater.GraphUpdaterManager;\n import uk.org.ifopt.siri20.StopPlaceRef;\n-import uk.org.siri.siri20.AffectedLineStructure;\n-import uk.org.siri.siri20.AffectedRouteStructure;\n-import uk.org.siri.siri20.AffectedStopPlaceStructure;\n-import uk.org.siri.siri20.AffectedStopPointStructure;\n-import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n-import uk.org.siri.siri20.AffectsScopeStructure;\n-import uk.org.siri.siri20.DataFrameRefStructure;\n-import uk.org.siri.siri20.DefaultedTextStructure;\n-import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n-import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n-import uk.org.siri.siri20.InfoLinkStructure;\n-import uk.org.siri.siri20.LineRef;\n-import uk.org.siri.siri20.PtSituationElement;\n-import uk.org.siri.siri20.RoutePointTypeEnumeration;\n-import uk.org.siri.siri20.ServiceDelivery;\n-import uk.org.siri.siri20.SeverityEnumeration;\n-import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n-import uk.org.siri.siri20.SituationNumber;\n-import uk.org.siri.siri20.StopPointRef;\n-import uk.org.siri.siri20.VehicleJourneyRef;\n-import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+import uk.org.siri.siri20.*;\n \n import java.math.BigInteger;\n import java.time.ZonedDateTime;\n", "next_change": null}, {"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac8..5816fe258 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzc4NDA5Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487784097", "body": "**FYI**\r\n\r\nThese methods made me ask: Should these be pushed into the `TransitAlert` class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of `TransitAlert.entities` is always filtered down to a specific type - So maybe just keeping a set of `Selectors` for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?  \r\n\r\nI do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.", "bodyText": "FYI\nThese methods made me ask: Should these be pushed into the TransitAlert class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of TransitAlert.entities is always filtered down to a specific type - So maybe just keeping a set of Selectors for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?\nI do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.", "bodyHTML": "<p dir=\"auto\"><strong>FYI</strong></p>\n<p dir=\"auto\">These methods made me ask: Should these be pushed into the <code>TransitAlert</code> class? Is there other places in the code that perform the same logic? Then I investigated a little and it seems that this is over-engineered. The list of <code>TransitAlert.entities</code> is always filtered down to a specific type - So maybe just keeping a set of <code>Selectors</code> for each type is sufficient. The selectors do not select anything - they are just a placeholder witch reference a type(inderect) and one or two ids. It toke me a while before I got that. Or am I missing something?</p>\n<p dir=\"auto\">I do not expect this to be fixed as part of the PR, but I it would be good to clean it up at some point.</p>", "author": "t2gran", "createdAt": "2020-09-14T09:43:46Z", "path": "src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java", "diffHunk": "@@ -0,0 +1,933 @@\n+package org.opentripplanner.ext.siri;\n+\n+import org.junit.Test;\n+import org.opentripplanner.GtfsTest;\n+import org.opentripplanner.model.FeedScopedId;\n+import org.opentripplanner.routing.RoutingService;\n+import org.opentripplanner.routing.alertpatch.AlertUrl;\n+import org.opentripplanner.routing.alertpatch.EntitySelector;\n+import org.opentripplanner.routing.alertpatch.StopCondition;\n+import org.opentripplanner.routing.alertpatch.TransitAlert;\n+import org.opentripplanner.routing.impl.TransitAlertServiceImpl;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import uk.org.ifopt.siri20.StopPlaceRef;\n+import uk.org.siri.siri20.AffectedLineStructure;\n+import uk.org.siri.siri20.AffectedRouteStructure;\n+import uk.org.siri.siri20.AffectedStopPlaceStructure;\n+import uk.org.siri.siri20.AffectedStopPointStructure;\n+import uk.org.siri.siri20.AffectedVehicleJourneyStructure;\n+import uk.org.siri.siri20.AffectsScopeStructure;\n+import uk.org.siri.siri20.DataFrameRefStructure;\n+import uk.org.siri.siri20.DefaultedTextStructure;\n+import uk.org.siri.siri20.FramedVehicleJourneyRefStructure;\n+import uk.org.siri.siri20.HalfOpenTimestampOutputRangeStructure;\n+import uk.org.siri.siri20.InfoLinkStructure;\n+import uk.org.siri.siri20.LineRef;\n+import uk.org.siri.siri20.PtSituationElement;\n+import uk.org.siri.siri20.RoutePointTypeEnumeration;\n+import uk.org.siri.siri20.ServiceDelivery;\n+import uk.org.siri.siri20.SeverityEnumeration;\n+import uk.org.siri.siri20.SituationExchangeDeliveryStructure;\n+import uk.org.siri.siri20.SituationNumber;\n+import uk.org.siri.siri20.StopPointRef;\n+import uk.org.siri.siri20.VehicleJourneyRef;\n+import uk.org.siri.siri20.WorkflowStatusEnumeration;\n+\n+import java.math.BigInteger;\n+import java.time.ZonedDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+\n+    SiriAlertsUpdateHandler alertsUpdateHandler;\n+\n+    TransitAlertServiceImpl transitAlertService;\n+\n+    RoutingService routingService;\n+    private String feedId = \"FEED\";\n+\n+    public void init() {\n+            if (routingService == null) {\n+                routingService = new RoutingService(graph);\n+                graph.updaterManager = new GraphUpdaterManager(graph);\n+\n+            } else {\n+                transitAlertService.getAllAlerts().clear();\n+            }\n+            if (alertsUpdateHandler == null) {\n+                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+\n+                transitAlertService = new TransitAlertServiceImpl(graph);\n+                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+\n+                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+            }\n+        }\n+\n+        @Test\n+        public void testSiriSxUpdateForStop() {\n+            init();\n+            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final String situationNumber = \"TST:SituationNumber:1234\";\n+            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n+            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+\n+            PtSituationElement ptSituation = createPtSituationElement(\n+                    situationNumber,\n+                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+                    createAffectsStop(stopConditions, stopId.getId()));\n+\n+            long priorityValue = 3;\n+            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+\n+            InfoLinkStructure infoLink = new InfoLinkStructure();\n+            final String infoLinkUri = \"http://www.test.com\";\n+            final String infoLinkLabel = \"testlabel\";\n+\n+            infoLink.setUri(infoLinkUri);\n+            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+\n+            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+\n+            final String reportType = \"incident\";\n+            ptSituation.setReportType(reportType);\n+\n+            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+            alertsUpdateHandler.update(serviceDelivery);\n+\n+            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+            assertNotNull(stopPatches);\n+            assertEquals(1, stopPatches.size());\n+            final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+            assertFalse(containsTripEntity(transitAlert));\n+            assertEquals(situationNumber, transitAlert.getId());\n+            assertEquals(reportType, transitAlert.alertType);\n+            assertEquals(severity.value(), transitAlert.severity);\n+            assertEquals(priorityValue, transitAlert.priority);\n+\n+            assertTrue(matchesEntity(transitAlert, stopId));\n+\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+\n+            assertNotNull(transitAlert.getAlertUrlList());\n+            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+\n+            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+            AlertUrl alertUrl = alertUrlList.get(0);\n+            assertEquals(infoLinkUri, alertUrl.uri);\n+            assertEquals(infoLinkLabel, alertUrl.label);\n+\n+        }\n+\n+    private boolean containsStopEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Stop) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsTripEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Trip) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.Route) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+        for (EntitySelector entity : transitAlert.getEntities()) {\n+            if (entity instanceof EntitySelector.StopAndRoute) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }", "originalCommit": "1853a44ae4cac535aad915f92e24aff2912056b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "changed_code": [{"header": "diff --git a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\nindex 52c808ac8..5816fe258 100644\n--- a/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n+++ b/src/ext-test/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandlerTest.java\n", "chunk": "@@ -39,895 +19,1018 @@ import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n \n-public class SiriAlertsUpdateHandlerTest  extends GtfsTest {\n+public class SiriAlertsUpdateHandlerTest extends GtfsTest {\n+  private static final String FEED_ID = \"FEED\";\n \n-    SiriAlertsUpdateHandler alertsUpdateHandler;\n+  SiriAlertsUpdateHandler alertsUpdateHandler;\n \n-    TransitAlertServiceImpl transitAlertService;\n+  TransitAlertServiceImpl transitAlertService;\n \n-    RoutingService routingService;\n-    private String feedId = \"FEED\";\n+  RoutingService routingService;\n \n-    public void init() {\n-            if (routingService == null) {\n-                routingService = new RoutingService(graph);\n-                graph.updaterManager = new GraphUpdaterManager(graph);\n+  @Test\n+  public void testSiriSxUpdateForStop() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            } else {\n-                transitAlertService.getAllAlerts().clear();\n-            }\n-            if (alertsUpdateHandler == null) {\n-                alertsUpdateHandler = new SiriAlertsUpdateHandler(feedId);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP,\n+        RoutePointTypeEnumeration.EXCEPTIONAL_STOP,\n+        RoutePointTypeEnumeration.START_POINT\n+    );\n \n-                transitAlertService = new TransitAlertServiceImpl(graph);\n-                alertsUpdateHandler.setTransitAlertService(transitAlertService);\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n \n-                alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n-            }\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForStop() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP, RoutePointTypeEnumeration.EXCEPTIONAL_STOP, RoutePointTypeEnumeration.START_POINT);\n+    long priorityValue = 3;\n+    ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(stopConditions, stopId.getId()));\n+    InfoLinkStructure infoLink = new InfoLinkStructure();\n+    final String infoLinkUri = \"http://www.test.com\";\n+    final String infoLinkLabel = \"testlabel\";\n \n-            long priorityValue = 3;\n-            ptSituation.setPriority(BigInteger.valueOf(priorityValue));\n+    infoLink.setUri(infoLinkUri);\n+    infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n \n-            InfoLinkStructure infoLink = new InfoLinkStructure();\n-            final String infoLinkUri = \"http://www.test.com\";\n-            final String infoLinkLabel = \"testlabel\";\n+    ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n+    ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n \n-            infoLink.setUri(infoLinkUri);\n-            infoLink.getLabels().add(createDefaultedTextStructure(infoLinkLabel));\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n \n-            ptSituation.setInfoLinks(new PtSituationElement.InfoLinks());\n-            ptSituation.getInfoLinks().getInfoLinks().add(infoLink);\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertEquals(reportType, transitAlert.alertType);\n+    assertEquals(severity.value(), transitAlert.severity);\n+    assertEquals(priorityValue, transitAlert.priority);\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, stopId));\n \n-            assertFalse(containsTripEntity(transitAlert));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertEquals(reportType, transitAlert.alertType);\n-            assertEquals(severity.value(), transitAlert.severity);\n-            assertEquals(priorityValue, transitAlert.priority);\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n+    assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    assertNotNull(transitAlert.getAlertUrlList());\n+    assertFalse(transitAlert.getAlertUrlList().isEmpty());\n \n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.NOT_STOPPING));\n-            assertTrue(transitAlert.getStopConditions().contains(StopCondition.REQUEST_STOP));\n+    final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n+    AlertUrl alertUrl = alertUrlList.get(0);\n+    assertEquals(infoLinkUri, alertUrl.uri);\n+    assertEquals(infoLinkLabel, alertUrl.label);\n \n-            assertNotNull(transitAlert.getAlertUrlList());\n-            assertFalse(transitAlert.getAlertUrlList().isEmpty());\n+  }\n \n-            final List<AlertUrl> alertUrlList = transitAlert.getAlertUrlList();\n-            AlertUrl alertUrl = alertUrlList.get(0);\n-            assertEquals(infoLinkUri, alertUrl.uri);\n-            assertEquals(infoLinkLabel, alertUrl.label);\n-\n-        }\n+  public void init() {\n+    if (routingService == null) {\n+      routingService = new RoutingService(graph);\n+      graph.updaterManager = new GraphUpdaterManager(graph);\n \n-    private boolean containsStopEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Stop) {\n-                return true;\n-            }\n-        }\n-        return false;\n     }\n-\n-    private boolean containsTripEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Trip) {\n-                return true;\n-            }\n-        }\n-        return false;\n+    else {\n+      transitAlertService.getAllAlerts().clear();\n     }\n+    if (alertsUpdateHandler == null) {\n+      alertsUpdateHandler = new SiriAlertsUpdateHandler(FEED_ID);\n \n-    private boolean containsRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.Route) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n+      transitAlertService = new TransitAlertServiceImpl(graph);\n+      alertsUpdateHandler.setTransitAlertService(transitAlertService);\n \n-    private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (entity instanceof EntitySelector.StopAndRoute) {\n-                return true;\n-            }\n-        }\n-        return false;\n+      alertsUpdateHandler.setSiriFuzzyTripMatcher(new SiriFuzzyTripMatcher(routingService));\n+    }\n+  }\n+\n+  private PtSituationElement createPtSituationElement(\n+      String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime,\n+      AffectsScopeStructure affects\n+  ) {\n+    PtSituationElement element = new PtSituationElement();\n+    element.setCreationTime(ZonedDateTime.now());\n+    element.setProgress(WorkflowStatusEnumeration.OPEN);\n+    if (startTime != null | endTime != null) {\n+      HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n+\n+      if (startTime != null) {\n+        period.setStartTime(startTime);\n+      }\n+\n+      if (endTime != null) {\n+        period.setEndTime(endTime);\n+      }\n+      element.getValidityPeriods().add(period);\n     }\n \n-    @Test\n-        public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-\n-        final FeedScopedId stopId = new FeedScopedId(feedId, \"stop0\");\n-\n-            List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(RoutePointTypeEnumeration.DESTINATION, RoutePointTypeEnumeration.NOT_STOPPING, RoutePointTypeEnumeration.REQUEST_STOP);\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    null,\n-                    null,\n-                    createAffectsStop(stopConditions, stopId.getId()));\n-\n-            final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n-            final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n-            final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+    SituationNumber sn = new SituationNumber();\n+    sn.setValue(situationNumber);\n+    element.setSituationNumber(sn);\n \n-            HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n-            period_1.setStartTime(startTimePeriod_1);\n-            period_1.setEndTime(endTimePeriod_1);\n-            ptSituation.getValidityPeriods().add(period_1);\n+    element.setAffects(affects);\n \n-            HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n-            period_2.setStartTime(startTimePeriod_2);\n-            period_2.setEndTime(endTimePeriod_2);\n-            ptSituation.getValidityPeriods().add(period_2);\n+    element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n+    element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n \n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n+    return element;\n+  }\n \n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+  private AffectsScopeStructure createAffectsStop(\n+      List<RoutePointTypeEnumeration> stopConditions, String... stopIds\n+  ) {\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n \n-            final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+    for (String stopId : stopIds) {\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      if (stopConditions != null) {\n+        affectedStopPoint.getStopConditions().addAll(stopConditions);\n+      }\n+      stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+    }\n \n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            final TransitAlert transitAlert = stopPatches.iterator().next();\n+    affects.setStopPoints(stopPoints);\n \n-            assertTrue(matchesEntity(transitAlert, stopId));\n+    return affects;\n+  }\n \n-            assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+  private DefaultedTextStructure createDefaultedTextStructure(String value) {\n+    DefaultedTextStructure textStructure = new DefaultedTextStructure();\n+    textStructure.setValue(value);\n+    return textStructure;\n+  }\n \n-            assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+  private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n+    return createServiceDelivery(Arrays.asList(situationElement));\n+  }\n \n+  private boolean containsTripEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Trip) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.Stop) {\n+          foundMatch = ((EntitySelector.Stop) entity).stopId.equals(feedScopedEntityId);\n         }\n-\n-        private void assertValidity(String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1, ZonedDateTime endTimePeriod_1) {\n-            // TimePeriod ends BEFORE first validityPeriod starts\n-            assertFalse(\"TimePeriod ends BEFORE first validityPeriod starts: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-200, startTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()-1000, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()-100));\n-\n-            // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n-            assertTrue(\"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label, transitAlert.displayDuring(startTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+100));\n-\n-            // TimePeriod starts AFTER first validityPeriod ends\n-            assertFalse(\"TimePeriod starts AFTER first validityPeriod ends: \" + label, transitAlert.displayDuring(endTimePeriod_1.toEpochSecond()+100, endTimePeriod_1.toEpochSecond()+200));\n+        else if (entity instanceof EntitySelector.Trip) {\n+          foundMatch = ((EntitySelector.Trip) entity).tripId.equals(feedScopedEntityId);\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForMultipleStops() {\n-            init();\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsStop(null, stopId0.getId(), stopId1.getId()));\n-\n-            final String reportType = \"incident\";\n-            ptSituation.setReportType(reportType);\n-\n-            final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n-            ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            TransitAlert transitAlert = stopPatches.iterator().next();\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId0));\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n-\n-            stopPatches = transitAlertService.getStopAlerts(stopId1);\n-\n-            assertNotNull(stopPatches);\n-            assertEquals(1, stopPatches.size());\n-            transitAlert = stopPatches.iterator().next();\n-\n-            assertFalse(containsTripEntity(transitAlert));\n-            assertTrue(matchesEntity(transitAlert, stopId1));;\n-\n-            assertTrue(\"Alert does not contain default condition START_POINT\", transitAlert.getStopConditions().contains(StopCondition.START_POINT));\n-            assertTrue(\"Alert does not contain default condition DESTINATION\", transitAlert.getStopConditions().contains(StopCondition.DESTINATION));\n+        else if (entity instanceof EntitySelector.Route) {\n+          foundMatch = ((EntitySelector.Route) entity).routeId.equals(feedScopedEntityId);\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n+\n+  private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n+    ServiceDelivery delivery = new ServiceDelivery();\n+    SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n+    SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n+    situations.getPtSituationElements().addAll(situationElement);\n+    sxDeliveries.setSituations(situations);\n+    delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n+\n+    return delivery;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForStopMultipleValidityPeriods() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId = new FeedScopedId(FEED_ID, \"stop0\");\n+\n+    List<RoutePointTypeEnumeration> stopConditions = Arrays.asList(\n+        RoutePointTypeEnumeration.DESTINATION,\n+        RoutePointTypeEnumeration.NOT_STOPPING,\n+        RoutePointTypeEnumeration.REQUEST_STOP\n+    );\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        null,\n+        null,\n+        createAffectsStop(stopConditions, stopId.getId())\n+    );\n+\n+    final ZonedDateTime startTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_1 = ZonedDateTime.parse(\"2014-01-01T11:00:00+01:00\");\n+    final ZonedDateTime startTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T10:00:00+01:00\");\n+    final ZonedDateTime endTimePeriod_2 = ZonedDateTime.parse(\"2014-01-02T11:00:00+01:00\");\n+\n+    HalfOpenTimestampOutputRangeStructure period_1 = new HalfOpenTimestampOutputRangeStructure();\n+    period_1.setStartTime(startTimePeriod_1);\n+    period_1.setEndTime(endTimePeriod_1);\n+    ptSituation.getValidityPeriods().add(period_1);\n+\n+    HalfOpenTimestampOutputRangeStructure period_2 = new HalfOpenTimestampOutputRangeStructure();\n+    period_2.setStartTime(startTimePeriod_2);\n+    period_2.setEndTime(endTimePeriod_2);\n+    ptSituation.getValidityPeriods().add(period_2);\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    final TransitAlert transitAlert = stopPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, stopId));\n+\n+    assertValidity(\"period 1\", transitAlert, startTimePeriod_1, endTimePeriod_1);\n+\n+    assertValidity(\"period 2\", transitAlert, startTimePeriod_2, endTimePeriod_2);\n+\n+  }\n+\n+  private void assertValidity(\n+      String label, TransitAlert transitAlert, ZonedDateTime startTimePeriod_1,\n+      ZonedDateTime endTimePeriod_1\n+  ) {\n+    // TimePeriod ends BEFORE first validityPeriod starts\n+    assertFalse(\n+        \"TimePeriod ends BEFORE first validityPeriod starts: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 200,\n+            startTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod ends AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() - 1000,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, BEFORE it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() - 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends\n+    assertTrue(\n+        \"TimePeriod starts AFTER first validityPeriod starts, ends AFTER it ends: \" + label,\n+        transitAlert.displayDuring(\n+            startTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 100\n+        )\n+    );\n+\n+    // TimePeriod starts AFTER first validityPeriod ends\n+    assertFalse(\n+        \"TimePeriod starts AFTER first validityPeriod ends: \" + label,\n+        transitAlert.displayDuring(\n+            endTimePeriod_1.toEpochSecond() + 100,\n+            endTimePeriod_1.toEpochSecond() + 200\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForMultipleStops() {\n+    init();\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsStop(null, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    final String reportType = \"incident\";\n+    ptSituation.setReportType(reportType);\n+\n+    final SeverityEnumeration severity = SeverityEnumeration.SEVERE;\n+    ptSituation.setSeverity(SeverityEnumeration.SEVERE);\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> stopPatches = transitAlertService.getStopAlerts(stopId0);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    TransitAlert transitAlert = stopPatches.iterator().next();\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId0));\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+\n+    stopPatches = transitAlertService.getStopAlerts(stopId1);\n+\n+    assertNotNull(stopPatches);\n+    assertEquals(1, stopPatches.size());\n+    transitAlert = stopPatches.iterator().next();\n+\n+    assertFalse(containsTripEntity(transitAlert));\n+    assertTrue(matchesEntity(transitAlert, stopId1));\n+    ;\n+\n+    assertTrue(\n+        \"Alert does not contain default condition START_POINT\",\n+        transitAlert.getStopConditions().contains(StopCondition.START_POINT)\n+    );\n+    assertTrue(\n+        \"Alert does not contain default condition DESTINATION\",\n+        transitAlert.getStopConditions().contains(StopCondition.DESTINATION)\n+    );\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTrip() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null)\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertTrue(matchesEntity(transitAlert, tripId));\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n+\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n+\n+    assertTrue(effectiveStartDate.isAfter(startTime));\n+    assertTrue(effectiveEndDate.isBefore(endTime));\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsFramedVehicleJourney(\n+      String datedVehicleJourney, String dataFrameValue, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n+    FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n+    framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n+    DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n+    dataFrameRef.setValue(dataFrameValue);\n+    framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n+    affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n+\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n-        @Test\n-        public void testSiriSxUpdateForTrip() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", null));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    return affects;\n+  }\n \n-            assertTrue(matchesEntity(transitAlert, tripId));\n+  private boolean containsRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Route) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.Stop) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean containsStopAndRouteEntity(TransitAlert transitAlert) {\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (entity instanceof EntitySelector.StopAndRoute) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n+    AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n+    for (String stopId : stopIds) {\n+      AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+      StopPointRef stopPointRef = new StopPointRef();\n+      stopPointRef.setValue(stopId);\n+      affectedStopPoint.setStopPointRef(stopPointRef);\n+      stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    }\n+    return stopPoints;\n+  }\n \n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+  @Test\n+  public void testSiriSxUpdateForTripByVehicleJourney() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            assertTrue(effectiveStartDate.isAfter(startTime));\n-            assertTrue(effectiveEndDate.isBefore(endTime));\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, null)\n+    );\n \n-        }\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        @Test\n-        public void testSiriSxUpdateForTripByVehicleJourney() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, null));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, tripId));\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertFalse(containsRouteEntity(transitAlert));\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsStopAndRouteEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+  }\n \n-            final Collection<TransitAlert> tripPatches = transitAlertService.getTripAlerts(tripId);\n+  private AffectsScopeStructure createAffectsVehicleJourney(\n+      String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds\n+  ) {\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+    AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n+    AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n+    VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n+    vehicleJourney.setValue(vehicleJourneyRef);\n+    affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n+    affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, tripId));\n-\n-            assertFalse(containsRouteEntity(transitAlert));\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsStopAndRouteEntity(transitAlert));\n+    if (stopIds != null) {\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n+      affectedRoute.setStopPoints(stopPoints);\n+      affectedVehicleJourney.getRoutes().add(affectedRoute);\n+    }\n \n+    vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n+    affects.setVehicleJourneys(vehicleJourneys);\n+\n+    return affects;\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n+    init();\n+\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId())\n+    );\n+\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+\n+  }\n+\n+  private boolean matchesEntity(\n+      TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId\n+  ) {\n+    boolean foundMatch = false;\n+    for (EntitySelector entity : transitAlert.getEntities()) {\n+      if (!foundMatch) {\n+        if (entity instanceof EntitySelector.StopAndRoute) {\n+          foundMatch = ((EntitySelector.StopAndRoute) entity).stopAndRoute.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n-\n-\n-        @Test\n-        public void testSiriSxUpdateForTripAndStopByVehicleJourney() {\n-            init();\n-\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsVehicleJourney(tripId.getId(), startTime, stopId0.getId(), stopId1.getId()));\n-\n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n-\n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n-\n+        if (entity instanceof EntitySelector.StopAndTrip) {\n+          foundMatch = ((EntitySelector.StopAndTrip) entity).stopAndTrip.equals((\n+              new EntitySelector.StopAndRouteOrTripKey(\n+                  stopId,\n+                  routeOrTripId\n+              )\n+          ));\n         }\n+      }\n+    }\n+    return foundMatch;\n+  }\n \n-        @Test\n-        public void testSiriSxUpdateForLine() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n-\n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n-\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n-\n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n-\n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-\n-            final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n-\n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertFalse(containsStopEntity(transitAlert));\n-            assertFalse(containsTripEntity(transitAlert));\n-\n-\n-            // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n-            final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveStartDate().toInstant(), startTime.getZone());\n-            final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert.getEffectiveEndDate().toInstant(), endTime.getZone());\n-\n-            assertEquals(startTime, effectiveStartDate);\n-            assertEquals(endTime, effectiveEndDate);\n+  @Test\n+  public void testSiriSxUpdateForLine() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-        }\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-        @Test\n-        public void testSiriSxUpdateForLineThenExpiry() {\n-            init();\n-            final FeedScopedId lineRef = new FeedScopedId(feedId, \"route0\");\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n-            final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n+    final Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(containsStopEntity(transitAlert));\n+    assertFalse(containsTripEntity(transitAlert));\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    // Effective validity should be calculated based on the actual departures when Operating dat/service date is provided\n+    final ZonedDateTime effectiveStartDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveStartDate()\n+        .toInstant(), startTime.getZone());\n+    final ZonedDateTime effectiveEndDate = ZonedDateTime.ofInstant(transitAlert\n+        .getEffectiveEndDate()\n+        .toInstant(), endTime.getZone());\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    assertEquals(startTime, effectiveStartDate);\n+    assertEquals(endTime, effectiveEndDate);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            final TransitAlert transitAlert = tripPatches.iterator().next();\n-            assertTrue(matchesEntity(transitAlert, lineRef));\n-            assertEquals(situationNumber, transitAlert.getId());\n+  }\n \n-            ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    startTime,\n-                    endTime,\n-                    createAffectsLine(lineRef.getId(), null));\n+  private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n \n-            alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n \n-            tripPatches = transitAlertService.getRouteAlerts(lineRef);\n+    if (stopIds != null) {\n+      AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n+      AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n \n-            assertNotNull(tripPatches);\n-            assertTrue(tripPatches.isEmpty());\n-        }\n+      AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n \n-        @Test\n-        public void testSiriSxUpdateForTripAndStop() {\n-            init();\n-            final FeedScopedId tripId = new FeedScopedId(feedId, \"route0-trip1\");\n+      affectedRoute.setStopPoints(stopPoints);\n+      routes.getAffectedRoutes().add(affectedRoute);\n+      affectedLine.setRoutes(routes);\n+    }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final FeedScopedId stopId0 = new FeedScopedId(feedId, \"stop0\");\n-            final FeedScopedId stopId1 = new FeedScopedId(feedId, \"stop1\");\n+    return affects;\n+  }\n \n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsFramedVehicleJourney(tripId.getId(), \"2014-01-01\", stopId0.getId(), stopId1.getId()));\n+  @Test\n+  public void testSiriSxUpdateForLineThenExpiry() {\n+    init();\n+    final FeedScopedId lineRef = new FeedScopedId(FEED_ID, \"route0\");\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final ZonedDateTime startTime = ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\");\n+    final ZonedDateTime endTime = ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\");\n \n-            /*\n-             * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n-             */\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(stopId0, tripId);\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    final TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertTrue(matchesEntity(transitAlert, lineRef));\n+    assertEquals(situationNumber, transitAlert.getId());\n \n+    ptSituation = createPtSituationElement(situationNumber,\n+        startTime,\n+        endTime,\n+        createAffectsLine(lineRef.getId(), null)\n+    );\n \n-            tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n+    ptSituation.setProgress(WorkflowStatusEnumeration.CLOSED);\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n-            assertEquals(situationNumber, transitAlert.getId());\n-            assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n+    alertsUpdateHandler.update(createServiceDelivery(ptSituation));\n \n-        }\n+    tripPatches = transitAlertService.getRouteAlerts(lineRef);\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndStop() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertNotNull(tripPatches);\n+    assertTrue(tripPatches.isEmpty());\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForTripAndStop() {\n+    init();\n+    final FeedScopedId tripId = new FeedScopedId(FEED_ID, \"route0-trip1\");\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLine(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final FeedScopedId stopId0 = new FeedScopedId(FEED_ID, \"stop0\");\n+    final FeedScopedId stopId1 = new FeedScopedId(FEED_ID, \"stop1\");\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsFramedVehicleJourney(tripId.getId(),\n+            \"2014-01-01\",\n+            stopId0.getId(),\n+            stopId1.getId()\n+        )\n+    );\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n-\n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n-            init();\n-            final String routeId = \"route0\";\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+    /*\n+     * Trip and stop-alerts should result in several TransitAlertes. One for each tripId/stop combination\n+     */\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1));\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndTripAlerts(\n+        stopId0,\n+        tripId\n+    );\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId0, tripId));\n \n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    tripPatches = transitAlertService.getStopAndTripAlerts(stopId1, tripId);\n \n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n-        }\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, stopId1, tripId));\n \n-        @Test\n-        public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n-            init();\n-            final String routeId = \"route0\";\n+  }\n \n-            assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+  @Test\n+  public void testSiriSxUpdateForLineAndStop() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final String situationNumber = \"TST:SituationNumber:1234\";\n-            final String stopId0 = \"stop0\";\n-            final String stopId1 = \"stop1\";\n-            PtSituationElement ptSituation = createPtSituationElement(\n-                    situationNumber,\n-                    ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n-                    ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n-                    createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1));\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n-            alertsUpdateHandler.update(serviceDelivery);\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLine(routeId, stopId0, stopId1)\n+    );\n \n-            assertFalse(transitAlertService.getAllAlerts().isEmpty());\n-            assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-        }\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-        private void assertLineAndStopAlerts(String situationNumber, String routeId, String stopId0, String stopId1) {\n-            /*\n-             * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n-             */\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n-            final FeedScopedId feedRouteId = new FeedScopedId(feedId, routeId);\n-            final FeedScopedId feedStop_0_id = new FeedScopedId(feedId, stopId0);\n-            Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_0_id, feedRouteId);\n+    assertLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            TransitAlert transitAlert = tripPatches.iterator().next();\n+  private void assertLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and stop-alerts should result in several TransitAlertes. One for each routeId/stop combination\n+     */\n \n+    final FeedScopedId feedRouteId = new FeedScopedId(FEED_ID, routeId);\n+    final FeedScopedId feedStop_0_id = new FeedScopedId(FEED_ID, stopId0);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getStopAndRouteAlerts(\n+        feedStop_0_id,\n+        feedRouteId\n+    );\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+    assertTrue(matchesEntity(transitAlert, feedStop_0_id, feedRouteId));\n+\n+    final FeedScopedId feedStop_1_id = new FeedScopedId(FEED_ID, stopId1);\n+    tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n \n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+\n+    assertEquals(situationNumber, transitAlert.getId());\n+\n+    assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPoint() {\n+    init();\n+    final String routeId = \"route0\";\n \n-            final FeedScopedId feedStop_1_id = new FeedScopedId(feedId, stopId1);\n-            tripPatches = transitAlertService.getStopAndRouteAlerts(feedStop_1_id, feedRouteId);\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertNotNull(tripPatches);\n-            assertEquals(1, tripPatches.size());\n-            transitAlert = tripPatches.iterator().next();\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPoints(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n \n-            assertEquals(situationNumber, transitAlert.getId());\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n \n-            assertTrue(matchesEntity(transitAlert, feedStop_1_id, feedRouteId));\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+  }\n \n-        }\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n+      for (String stopId : stopIds) {\n+        AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n+        StopPointRef stopPointRef = new StopPointRef();\n+        stopPointRef.setValue(stopId);\n+        affectedStopPoint.setStopPointRef(stopPointRef);\n+        stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n+      }\n+      affects.setStopPoints(stopPoints);\n \n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId stopId, FeedScopedId routeOrTripId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.StopAndRoute){\n-                    foundMatch = ((EntitySelector.StopAndRoute)entity).stopAndRoute.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-                if (entity instanceof EntitySelector.StopAndTrip){\n-                    foundMatch = ((EntitySelector.StopAndTrip)entity).stopAndTrip.equals(\n-                        (new EntitySelector.StopAndRouteOrTripKey(stopId, routeOrTripId)));\n-                }\n-            }\n-        }\n-        return foundMatch;\n     }\n-    private boolean matchesEntity(TransitAlert transitAlert, FeedScopedId feedScopedEntityId) {\n-        boolean foundMatch = false;\n-        for (EntitySelector entity : transitAlert.getEntities()) {\n-            if (!foundMatch) {\n-                if (entity instanceof EntitySelector.Stop){\n-                    foundMatch = ((EntitySelector.Stop)entity).stopId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Trip){\n-                    foundMatch = ((EntitySelector.Trip)entity).tripId.equals(feedScopedEntityId);\n-                } else if (entity instanceof EntitySelector.Route){\n-                    foundMatch = ((EntitySelector.Route)entity).routeId.equals(feedScopedEntityId);\n-                }\n-            }\n-        }\n-        return foundMatch;\n-    }\n-\n-    private ServiceDelivery createServiceDelivery(PtSituationElement situationElement) {\n-            return createServiceDelivery(Arrays.asList(situationElement));\n-        }\n-\n-        private ServiceDelivery createServiceDelivery(List<PtSituationElement> situationElement) {\n-            ServiceDelivery delivery = new ServiceDelivery();\n-            SituationExchangeDeliveryStructure sxDeliveries = new SituationExchangeDeliveryStructure();\n-            SituationExchangeDeliveryStructure.Situations situations = new SituationExchangeDeliveryStructure.Situations();\n-            situations.getPtSituationElements().addAll(situationElement);\n-            sxDeliveries.setSituations(situations);\n-            delivery.getSituationExchangeDeliveries().add(sxDeliveries);\n-\n-            return delivery;\n-        }\n-\n-\n-\n-        private AffectsScopeStructure createAffectsVehicleJourney(String vehicleJourneyRef, ZonedDateTime originAimedDepartureTime, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-\n-            VehicleJourneyRef vehicleJourney = new VehicleJourneyRef();\n-            vehicleJourney.setValue(vehicleJourneyRef);\n-            affectedVehicleJourney.getVehicleJourneyReves().add(vehicleJourney);\n-            affectedVehicleJourney.setOriginAimedDepartureTime(originAimedDepartureTime);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsFramedVehicleJourney(String datedVehicleJourney, String dataFrameValue, String... stopIds) {\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-            AffectsScopeStructure.VehicleJourneys vehicleJourneys = new AffectsScopeStructure.VehicleJourneys();\n-            AffectedVehicleJourneyStructure affectedVehicleJourney = new AffectedVehicleJourneyStructure();\n-            FramedVehicleJourneyRefStructure framedVehicleJourneyRef = new FramedVehicleJourneyRefStructure();\n-            framedVehicleJourneyRef.setDatedVehicleJourneyRef(datedVehicleJourney);\n-            DataFrameRefStructure dataFrameRef = new DataFrameRefStructure();\n-            dataFrameRef.setValue(dataFrameValue);\n-            framedVehicleJourneyRef.setDataFrameRef(dataFrameRef);\n-            affectedVehicleJourney.setFramedVehicleJourneyRef(framedVehicleJourneyRef);\n-\n-            if (stopIds != null) {\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-                affectedRoute.setStopPoints(stopPoints);\n-                affectedVehicleJourney.getRoutes().add(affectedRoute);\n-            }\n-\n-            vehicleJourneys.getAffectedVehicleJourneies().add(affectedVehicleJourney);\n-            affects.setVehicleJourneys(vehicleJourneys);\n-\n-            return affects;\n-        }\n-        private AffectsScopeStructure createAffectsLine(String line, String... stopIds) {\n \n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n+    return affects;\n+  }\n+\n+  private void assertSeparateLineAndStopAlerts(\n+      String situationNumber, String routeId, String stopId0, String stopId1\n+  ) {\n+    /*\n+     * Line and external stop-alerts should result in several AlertPatches. One for each routeId AND for each stop\n+     */\n+\n+    final FeedScopedId feedRouteId = new FeedScopedId(\"FEED\", routeId);\n+    Collection<TransitAlert> tripPatches = transitAlertService.getRouteAlerts(feedRouteId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    TransitAlert transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedRouteId));\n+\n+    FeedScopedId feedStopId = new FeedScopedId(\"FEED\", stopId0);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+\n+    feedStopId = new FeedScopedId(\"FEED\", stopId1);\n+    tripPatches = transitAlertService.getStopAlerts(feedStopId);\n+\n+    assertNotNull(tripPatches);\n+    assertEquals(1, tripPatches.size());\n+    transitAlert = tripPatches.iterator().next();\n+    assertEquals(situationNumber, transitAlert.getId());\n+    assertTrue(matchesEntity(transitAlert, feedStopId));\n+  }\n+\n+  @Test\n+  public void testSiriSxUpdateForLineAndExternallyDefinedStopPlace() {\n+    init();\n+    final String routeId = \"route0\";\n+\n+    assertTrue(transitAlertService.getAllAlerts().isEmpty());\n+\n+    final String situationNumber = \"TST:SituationNumber:1234\";\n+    final String stopId0 = \"stop0\";\n+    final String stopId1 = \"stop1\";\n+    PtSituationElement ptSituation = createPtSituationElement(situationNumber,\n+        ZonedDateTime.parse(\"2014-01-01T00:00:00+01:00\"),\n+        ZonedDateTime.parse(\"2014-01-01T23:59:59+01:00\"),\n+        createAffectsLineWithExternallyDefinedStopPlaces(routeId, stopId0, stopId1)\n+    );\n+\n+    final ServiceDelivery serviceDelivery = createServiceDelivery(ptSituation);\n+    alertsUpdateHandler.update(serviceDelivery);\n+\n+    assertFalse(transitAlertService.getAllAlerts().isEmpty());\n+    assertSeparateLineAndStopAlerts(situationNumber, routeId, stopId0, stopId1);\n+\n+  }\n+\n+  private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(\n+      String line, String... stopIds\n+  ) {\n+\n+    AffectsScopeStructure affects = new AffectsScopeStructure();\n+\n+    AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n+    AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n+    AffectedLineStructure affectedLine = new AffectedLineStructure();\n+    LineRef lineRef = new LineRef();\n+    lineRef.setValue(line);\n+    affectedLine.setLineRef(lineRef);\n+    affectedNetwork.getAffectedLines().add(affectedLine);\n+\n+    networks.getAffectedNetworks().add(affectedNetwork);\n+    affects.setNetworks(networks);\n+    if (stopIds != null) {\n+      AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n+      for (String stopId : stopIds) {\n+        AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n+        StopPlaceRef stopPlaceRef = new StopPlaceRef();\n+        stopPlaceRef.setValue(stopId);\n+        affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n+        stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n+      }\n+      affects.setStopPlaces(stopPlaces);\n \n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            if (stopIds != null) {\n-                AffectedLineStructure.Routes routes = new AffectedLineStructure.Routes();\n-                AffectedRouteStructure affectedRoute = new AffectedRouteStructure();\n-\n-                AffectedRouteStructure.StopPoints stopPoints = createAffectedStopPoints(stopIds);\n-\n-                affectedRoute.setStopPoints(stopPoints);\n-                routes.getAffectedRoutes().add(affectedRoute);\n-                affectedLine.setRoutes(routes);\n-            }\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPoints(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                    StopPointRef stopPointRef = new StopPointRef();\n-                    stopPointRef.setValue(stopId);\n-                    affectedStopPoint.setStopPointRef(stopPointRef);\n-                    stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-                }\n-                affects.setStopPoints(stopPoints);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-        private AffectsScopeStructure createAffectsLineWithExternallyDefinedStopPlaces(String line, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.Networks networks = new AffectsScopeStructure.Networks();\n-            AffectsScopeStructure.Networks.AffectedNetwork affectedNetwork = new AffectsScopeStructure.Networks.AffectedNetwork();\n-            AffectedLineStructure affectedLine = new AffectedLineStructure();\n-            LineRef lineRef = new LineRef();\n-            lineRef.setValue(line);\n-            affectedLine.setLineRef(lineRef);\n-            affectedNetwork.getAffectedLines().add(affectedLine);\n-\n-            networks.getAffectedNetworks().add(affectedNetwork);\n-            affects.setNetworks(networks);\n-            if (stopIds != null) {\n-                AffectsScopeStructure.StopPlaces stopPlaces = new AffectsScopeStructure.StopPlaces();\n-                for (String stopId : stopIds) {\n-                    AffectedStopPlaceStructure affectedStopPlaceStructure = new AffectedStopPlaceStructure();\n-                    StopPlaceRef stopPlaceRef = new StopPlaceRef();\n-                    stopPlaceRef.setValue(stopId);\n-                    affectedStopPlaceStructure.setStopPlaceRef(stopPlaceRef);\n-                    stopPlaces.getAffectedStopPlaces().add(affectedStopPlaceStructure);\n-                }\n-                affects.setStopPlaces(stopPlaces);\n-\n-            }\n-\n-            return affects;\n-        }\n-\n-\n-        private AffectedRouteStructure.StopPoints createAffectedStopPoints(String... stopIds) {\n-            AffectedRouteStructure.StopPoints stopPoints = new AffectedRouteStructure.StopPoints();\n-            for (String stopId : stopIds) {\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                stopPoints.getAffectedStopPointsAndLinkProjectionToNextStopPoints().add(affectedStopPoint);\n-\n-            }\n-            return stopPoints;\n-        }\n-\n-        private AffectsScopeStructure createAffectsStop(List<RoutePointTypeEnumeration> stopConditions, String... stopIds) {\n-\n-            AffectsScopeStructure affects = new AffectsScopeStructure();\n-\n-            AffectsScopeStructure.StopPoints stopPoints = new AffectsScopeStructure.StopPoints();\n-\n-            for (String stopId : stopIds) {\n-                StopPointRef stopPointRef = new StopPointRef();\n-                stopPointRef.setValue(stopId);\n-                AffectedStopPointStructure affectedStopPoint = new AffectedStopPointStructure();\n-                affectedStopPoint.setStopPointRef(stopPointRef);\n-                if (stopConditions != null) {\n-                    affectedStopPoint.getStopConditions().addAll(stopConditions);\n-                }\n-                stopPoints.getAffectedStopPoints().add(affectedStopPoint);\n-            }\n-\n-            affects.setStopPoints(stopPoints);\n-\n-            return affects;\n-        }\n-\n-        private PtSituationElement createPtSituationElement(String situationNumber, ZonedDateTime startTime, ZonedDateTime endTime, AffectsScopeStructure affects) {\n-            PtSituationElement element = new PtSituationElement();\n-            element.setCreationTime(ZonedDateTime.now());\n-            element.setProgress(WorkflowStatusEnumeration.OPEN);\n-            if (startTime != null | endTime != null) {\n-                HalfOpenTimestampOutputRangeStructure period = new HalfOpenTimestampOutputRangeStructure();\n-\n-                if (startTime != null) {\n-                    period.setStartTime(startTime);\n-                }\n-\n-                if (endTime != null) {\n-                    period.setEndTime(endTime);\n-                }\n-                element.getValidityPeriods().add(period);\n-            }\n-\n-            SituationNumber sn = new SituationNumber();\n-            sn.setValue(situationNumber);\n-            element.setSituationNumber(sn);\n-\n-            element.setAffects(affects);\n-\n-            element.getDescriptions().add(createDefaultedTextStructure(\"description\"));\n-            element.getSummaries().add(createDefaultedTextStructure(\"summary\"));\n-\n-\n-            return element;\n-        }\n-\n-        private DefaultedTextStructure createDefaultedTextStructure(String value) {\n-            DefaultedTextStructure textStructure = new DefaultedTextStructure();\n-            textStructure.setValue(value);\n-            return textStructure;\n-        }\n+    }\n \n+    return affects;\n+  }\n \n-        @Override\n-        public String getFeedName() {\n-            return \"gtfs/interlining\";\n-        }\n-    }\n+  @Override\n+  public String getFeedName() {\n+    return \"gtfs/interlining\";\n+  }\n+}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzMDk4NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487830984", "body": "Below on line 364:\r\n```\r\n\r\nif (!effectiveValiditySetExplicitly) {\r\n```\r\nthe if is never entered. The only way the `effectiveValiditySetExplicitly` can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code. \r\n", "bodyText": "Below on line 364:\n\nif (!effectiveValiditySetExplicitly) {\n\nthe if is never entered. The only way the effectiveValiditySetExplicitly can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code.", "bodyHTML": "<p dir=\"auto\">Below on line 364:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\nif (!effectiveValiditySetExplicitly) {\"><pre><code>\nif (!effectiveValiditySetExplicitly) {\n</code></pre></div>\n<p dir=\"auto\">the if is never entered. The only way the <code>effectiveValiditySetExplicitly</code> can be true is that there is no tipIds added above. Clean up this - I am not sure if it is a mistake or just dead code.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:08:54Z", "path": "src/ext/java/org/opentripplanner/ext/siri/SiriAlertsUpdateHandler.java", "diffHunk": "@@ -335,13 +343,20 @@ private TransitAlert handleAlert(PtSituationElement situation) {\n                                 effectiveValiditySetExplicitly = true;\n \n                             } else {\n-                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n-                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n-                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n \n-                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n-                                effectiveStartDate = serviceDate.getAsDate();\n-                                effectiveEndDate = serviceDate.next().getAsDate();\n+//                                Commented out for now\n+//\n+//                                // TODO - SIRI: Support submode when fuzzy-searching for trips\n+//                                tripIds = siriFuzzyTripMatcher.getTripIdForTripShortNameServiceDateAndMode(vehicleJourneyRef.getValue(),\n+//                                        serviceDate, TraverseMode.RAIL/*, TransmodelTransportSubmode.RAIL_REPLACEMENT_BUS*/);\n+//\n+//                                // ServiceJourneyId does NOT match - calculate validity based on originAimedDepartureTime\n+//                                effectiveStartDate = serviceDate.getAsDate();\n+//                                effectiveEndDate = serviceDate.next().getAsDate();\n+\n+                                effectiveStartDate = null;\n+                                effectiveEndDate = null;\n+", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgzNTc0Nw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487835747", "body": "Below on line 227:\r\n```\r\nif (tripPattern != null &&\r\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\r\n```\r\nthe `tripPattern.getMode()` return type is `TransitMode`, not `TraverseMode` so the if branch is never entered.", "bodyText": "Below on line 227:\nif (tripPattern != null &&\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\n\nthe tripPattern.getMode() return type is TransitMode, not TraverseMode so the if branch is never entered.", "bodyHTML": "<p dir=\"auto\">Below on line 227:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (tripPattern != null &amp;&amp;\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\"><pre><code>if (tripPattern != null &amp;&amp;\n                        (tripPattern.getMode().equals(TraverseMode.RAIL) /*||\t                        (tripPattern.getMode().equals(TraverseMode.RAIL)\n</code></pre></div>\n<p dir=\"auto\">the <code>tripPattern.getMode()</code> return type is <code>TransitMode</code>, not <code>TraverseMode</code> so the if branch is never entered.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:18:30Z", "path": "src/ext/java/org/opentripplanner/ext/siri/SiriFuzzyTripMatcher.java", "diffHunk": "@@ -129,12 +131,27 @@ private String resolveDatedVehicleJourneyRef(EstimatedVehicleJourney journey) {\n             }\n         }\n         if (trips == null || trips.isEmpty()) {\n-            List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n-            EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n \n-            String lastStopPoint = lastStop.getStopPointRef().getValue();\n+            String lastStopPoint = null;\n+            ZonedDateTime arrivalTime = null;\n \n-            ZonedDateTime arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            if (journey.getEstimatedCalls() != null && journey.getEstimatedCalls().getEstimatedCalls() != null\n+                    && !journey.getEstimatedCalls().getEstimatedCalls().isEmpty()) { // Pick last stop from EstimatedCalls\n+                List<EstimatedCall> estimatedCalls = journey.getEstimatedCalls().getEstimatedCalls();\n+                EstimatedCall lastStop = estimatedCalls.get(estimatedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+\n+            } else if (journey.getRecordedCalls() != null && journey.getRecordedCalls().getRecordedCalls() != null\n+                    && !journey.getRecordedCalls().getRecordedCalls().isEmpty()) { // No EstimatedCalls exist - pick last RecordedCall\n+\n+                List<RecordedCall> recordedCalls = journey.getRecordedCalls().getRecordedCalls();\n+                final RecordedCall lastStop = recordedCalls.get(recordedCalls.size() - 1);\n+\n+                lastStopPoint = lastStop.getStopPointRef().getValue();\n+                arrivalTime = lastStop.getAimedArrivalTime() != null ? lastStop.getAimedArrivalTime() : lastStop.getAimedDepartureTime();\n+            }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NDk5MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487844990", "body": "Call to 'Thread.sleep()' in a loop, probably busy-waiting.", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting.", "bodyHTML": "<p dir=\"auto\">Call to 'Thread.sleep()' in a loop, probably busy-waiting.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:37:13Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);\n+                } catch (InterruptedException interruptedException) {\n+                    //Ignore\n+                }\n+            }\n+        }\n+\n+        Subscriber subscriber = null;\n+        while (true) {\n+            try {\n+                subscriber = Subscriber.newBuilder(subscription.getName(), receiver).build();\n+                subscriber.startAsync().awaitRunning();\n+\n+                subscriber.awaitTerminated();\n+            } catch (IllegalStateException e) {\n+\n+                if (subscriber != null) {\n+                    subscriber.stopAsync();\n+                }\n+            }\n+            try {\n+                Thread.sleep(reconnectPeriodSec * 1000);", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0NTE2NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487845164", "body": "Call to 'Thread.sleep()' in a loop, probably busy-waiting \r\n Inspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.", "bodyText": "Call to 'Thread.sleep()' in a loop, probably busy-waiting\nInspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.", "bodyHTML": "<p dir=\"auto\">Call to 'Thread.sleep()' in a loop, probably busy-waiting<br>\nInspection info: Reports calls to java.lang.Thread.sleep() that occur inside loops. Such calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks as busy-waiting threads do not release locked resources.</p>", "author": "t2gran", "createdAt": "2020-09-14T11:37:36Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriEstimatedTimetableGooglePubsubUpdater.java", "diffHunk": "@@ -0,0 +1,385 @@\n+/* This program is free software: you can redistribute it and/or\n+ modify it under the terms of the GNU Lesser General Public License\n+ as published by the Free Software Foundation, either version 3 of\n+ the License, or (at your option) any later version.\n+\n+ This program is distributed in the hope that it will be useful,\n+ but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License\n+ along with this program.  If not, see <http://www.gnu.org/licenses/>. */\n+\n+package org.opentripplanner.ext.siri.updater;\n+\n+import com.google.cloud.pubsub.v1.AckReplyConsumer;\n+import com.google.cloud.pubsub.v1.MessageReceiver;\n+import com.google.cloud.pubsub.v1.Subscriber;\n+import com.google.cloud.pubsub.v1.SubscriptionAdminClient;\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Duration;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import com.google.pubsub.v1.ExpirationPolicy;\n+import com.google.pubsub.v1.ProjectSubscriptionName;\n+import com.google.pubsub.v1.ProjectTopicName;\n+import com.google.pubsub.v1.PubsubMessage;\n+import com.google.pubsub.v1.PushConfig;\n+import com.google.pubsub.v1.Subscription;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.time.DurationFormatUtils;\n+import org.entur.protobuf.mapper.SiriMapper;\n+import org.opentripplanner.ext.siri.SiriTimetableSnapshotSource;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.updater.GraphUpdater;\n+import org.opentripplanner.updater.GraphUpdaterManager;\n+import org.opentripplanner.util.HttpUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import uk.org.siri.siri20.EstimatedTimetableDeliveryStructure;\n+import uk.org.siri.siri20.Siri;\n+import uk.org.siri.www.siri.SiriType;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.time.ZonedDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * This class starts a Google PubSub subscription\n+ *\n+ * NOTE:\n+ *   - Path to Google credentials (.json-file) MUST exist in environment-variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+ *     as described here: https://cloud.google.com/docs/authentication/getting-started\n+ *   - ServiceAccount need access to create subscription (\"editor\")\n+ *\n+ *\n+ *\n+ * Startup-flow:\n+ *   1. Create subscription to topic. Subscription will receive all updates after creation.\n+ *   2. Fetch current data to initialize state.\n+ *   3. Flag updater as initialized\n+ *   3. Start receiving updates from Pubsub-subscription\n+ *\n+ *\n+ * <pre>\n+ *   \"type\": \"google-pubsub-siri-et-updater\",\n+ *   \"projectName\":\"project-1234\",                                                      // Google Cloud project name\n+ *   \"topicName\": \"protobuf.estimated_timetables\",                                      // Google Cloud Pubsub topic\n+ *   \"dataInitializationUrl\": \"http://server/realtime/protobuf/et\"  // Optional URL used to initialize OTP with all existing data\n+ * </pre>\n+ *\n+ */\n+public class SiriEstimatedTimetableGooglePubsubUpdater implements GraphUpdater {\n+\n+    private static final int DEFAULT_RECONNECT_PERIOD_SEC = 5; // Five seconds\n+\n+    private static Logger LOG = LoggerFactory.getLogger(SiriEstimatedTimetableGooglePubsubUpdater.class);\n+\n+    /**\n+     * Parent update manager. Is used to execute graph writer runnables.\n+     */\n+    private GraphUpdaterManager updaterManager;\n+\n+    private SiriTimetableSnapshotSource snapshotSource;\n+\n+    /**\n+     * The URL used to fetch all initial updates\n+     */\n+    private URI dataInitializationUrl;\n+\n+    /**\n+     * The ID for the static feed to which these TripUpdates are applied\n+     */\n+    private String feedId;\n+\n+    /**\n+     * The number of seconds to wait before reconnecting after a failed connection.\n+     */\n+    private int reconnectPeriodSec;\n+\n+    private SubscriptionAdminClient subscriptionAdminClient;\n+    private ProjectSubscriptionName subscriptionName;\n+    private ProjectTopicName topic;\n+    private PushConfig pushConfig;\n+\n+    private static transient final AtomicLong messageCounter = new AtomicLong(0);\n+    private static transient final AtomicLong updateCounter = new AtomicLong(0);\n+    private static transient final AtomicLong sizeCounter = new AtomicLong(0);\n+    private transient long startTime;\n+    private boolean primed;\n+\n+\n+    public SiriEstimatedTimetableGooglePubsubUpdater(Parameters config) {\n+\n+        try {\n+            configure(config);\n+\n+            if (System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\") != null &&\n+                    !System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\").isEmpty()) {\n+\n+                /*\n+                  Google libraries expects path to credentials json-file is stored in environment variable \"GOOGLE_APPLICATION_CREDENTIALS\"\n+                  Ref.: https://cloud.google.com/docs/authentication/getting-started\n+                 */\n+\n+                subscriptionAdminClient = SubscriptionAdminClient.create();\n+\n+                addShutdownHook();\n+\n+            } else {\n+                throw new RuntimeException(\"Google Pubsub updater is configured, but environment variable 'GOOGLE_APPLICATION_CREDENTIALS' is not defined. \" +\n+                        \"See https://cloud.google.com/docs/authentication/getting-started\");\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    private void addShutdownHook() {\n+        // TODO: This should probably be on a higher level?\n+        try {\n+            Runtime.getRuntime().addShutdownHook(new Thread(this::teardown));\n+            LOG.info(\"Shutdown-hook to clean up Google Pubsub subscription has been added.\");\n+        } catch (IllegalStateException e) {\n+            // Handling cornercase when instance is being shut down before it has been initialized\n+            LOG.info(\"Instance is already shutting down - cleaning up immediately.\", e);\n+            teardown();\n+        }\n+    }\n+\n+    @Override\n+    public void setGraphUpdaterManager(GraphUpdaterManager updaterManager) {\n+        this.updaterManager = updaterManager;\n+    }\n+\n+    @Override\n+    public void setup(Graph graph) throws Exception {\n+        // TODO OTP2 - This is thread safe, but only because updater setup methods are called sequentially.\n+        //           - Ideally we should inject the snapshotSource on this class.\n+        snapshotSource = graph.getOrSetupTimetableSnapshotProvider(SiriTimetableSnapshotSource::new);\n+    }\n+\n+    private void configure(Parameters config) {\n+\n+        /*\n+           URL that responds to HTTP GET which returns all initial data in protobuf-format.\n+           Will be called once to initialize realtime-data. All updates will be received from Google Cloud Pubsub\n+          */\n+        dataInitializationUrl = URI.create(config.getDataInitializationUrl());\n+\n+        feedId = config.getFeedId();\n+        reconnectPeriodSec = config.getReconnectPeriodSec();\n+\n+        // set subscriber\n+        String subscriptionId = System.getenv(\"HOSTNAME\");\n+        if (subscriptionId == null || subscriptionId.isEmpty()) {\n+            subscriptionId = \"otp-\"+UUID.randomUUID().toString();\n+        }\n+\n+        String projectName = config.getProjectName();\n+\n+        String topicName = config.getTopicName();\n+\n+        subscriptionName = ProjectSubscriptionName.of(\n+                projectName, subscriptionId);\n+        topic = ProjectTopicName.of(projectName, topicName);\n+\n+        pushConfig = PushConfig.getDefaultInstance();\n+\n+    }\n+\n+    @Override\n+    public void run() throws IOException {\n+\n+        if (subscriptionAdminClient == null) {\n+            throw new RuntimeException(\"Unable to initialize Google Pubsub-updater: System.getenv('GOOGLE_APPLICATION_CREDENTIALS') = \" + System.getenv(\"GOOGLE_APPLICATION_CREDENTIALS\"));\n+        }\n+\n+        LOG.info(\"Creating subscription {}\", subscriptionName);\n+\n+        Subscription subscription = subscriptionAdminClient.createSubscription(Subscription.newBuilder()\n+                .setTopic(topic.toString())\n+                .setName(subscriptionName.toString())\n+                .setPushConfig(pushConfig)\n+                .setMessageRetentionDuration(\n+                        // How long will an unprocessed message be kept - minimum 10 minutes\n+                        Duration.newBuilder().setSeconds(600).build()\n+                )\n+                .setExpirationPolicy(ExpirationPolicy.newBuilder()\n+                        // How long will the subscription exist when no longer in use - minimum 1 day\n+                        .setTtl(Duration.newBuilder().setSeconds(86400).build()).build()\n+                )\n+                .build());\n+\n+        LOG.info(\"Created subscription {}\", subscriptionName);\n+\n+        startTime = now();\n+\n+        final EstimatedTimetableMessageReceiver receiver = new EstimatedTimetableMessageReceiver();\n+\n+        int sleepPeriod = 1000;\n+        int attemptCounter = 1;\n+        while (!isPrimed()) {  // Retrying until data is initialized successfully\n+            try {\n+                initializeData(dataInitializationUrl, receiver);\n+\n+            } catch (Exception e) {\n+\n+                sleepPeriod = sleepPeriod * 2;\n+\n+                LOG.warn(\"Caught Exception while initializing data, will retry after {} ms - attempt number {}. ({})\", sleepPeriod, attemptCounter++, e.toString());\n+\n+                try {\n+                    Thread.sleep(sleepPeriod);", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3MDk0MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487870941", "body": "You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat `InterruptedException` and as mention above the `Thread.sleep` blockes.", "bodyText": "You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat InterruptedException and as mention above the Thread.sleep blockes.", "bodyHTML": "<p dir=\"auto\">You may leave this as is, since it follows what seems to be the practice in OTP, but this is not the recomended way to treat <code>InterruptedException</code> and as mention above the <code>Thread.sleep</code> blockes.</p>", "author": "t2gran", "createdAt": "2020-09-14T12:26:11Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriSXUpdater.java", "diffHunk": "@@ -94,25 +103,44 @@ public void setup(Graph graph) {\n \n     @Override\n     protected void runPolling() {\n-        boolean moreData = false;\n-        do {\n-            Siri updates = getUpdates();\n-            if (updates != null) {\n-                ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n-                // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n-                moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n-                final boolean markPrimed = !moreData;\n-                if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n-                    updaterManager.execute(graph -> {\n-                        updateHandler.update(serviceDelivery);\n-                        if (markPrimed) primed = true;\n-                    });\n+        try {\n+            boolean moreData = false;\n+            do {\n+                Siri updates = getUpdates();\n+                if (updates != null) {\n+                    ServiceDelivery serviceDelivery = updates.getServiceDelivery();\n+                    // Use isTrue in case isMoreData returns null. Mark the updater as primed after last page of updates.\n+                    moreData = BooleanUtils.isTrue(serviceDelivery.isMoreData());\n+                    final boolean markPrimed = !moreData;\n+                    if (serviceDelivery.getSituationExchangeDeliveries() != null) {\n+                        updaterManager.execute(graph -> {\n+                            updateHandler.update(serviceDelivery);\n+                            if (markPrimed) primed = true;\n+                        });\n+                    }\n                 }\n+            } while (moreData);\n+        } catch (IOException e) {\n+\n+            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+\n+            retryCount++;\n+\n+            LOG.info(\"Caught timeout - retry no. {} after {} millis\", retryCount, sleepTime);\n+\n+            try {\n+                Thread.sleep(sleepTime);\n+            } catch (InterruptedException ex) {\n+                //Ignore\n             }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTYxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487875617", "body": "Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better. ", "bodyText": "Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better.", "bodyHTML": "<p dir=\"auto\">Any Exception (even a NPE) will cause this method to enter an infinite recursion - this is not pretty. Catching the typed exceptions like IOException ++ would be better.</p>", "author": "t2gran", "createdAt": "2020-09-14T12:33:47Z", "path": "src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java", "diffHunk": "@@ -90,6 +97,24 @@ public Siri getUpdates() {\n         } catch (Exception e) {", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjM1OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972358", "bodyText": "I fixed this.", "author": "t2gran", "createdAt": "2020-09-14T14:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NTYxNw=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\nindex 6e88313a6..ee003a07b 100644\n--- a/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n+++ b/src/ext/java/org/opentripplanner/ext/siri/updater/SiriVMHttpTripUpdateSource.java\n", "chunk": "@@ -94,11 +98,11 @@ public class SiriVMHttpTripUpdateSource implements VehicleMonitoringSource {\n                 return siri;\n \n             }\n-        } catch (Exception e) {\n+        } catch (IOException | JAXBException | XMLStreamException e) {\n             LOG.info(\"Failed after {} ms\", (System.currentTimeMillis()-t1));\n             LOG.warn(\"Failed to parse SIRI-VM feed from \" + url + \":\", e);\n \n-            final long sleepTime = retryIntervalMillis + retryIntervalMillis * retryCount;\n+            final long sleepTime = RETRY_INTERVAL_MILLIS + RETRY_INTERVAL_MILLIS * retryCount;\n \n             retryCount++;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MzQ1MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487893451", "body": "This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an `TransitEntity` or that the id is made uniq in all contexts it exist.\r\n\r\nIn OTP the `TransitEntity.equals` means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a `TripPattern`?", "bodyText": "This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an TransitEntity or that the id is made uniq in all contexts it exist.\nIn OTP the TransitEntity.equals means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a TripPattern?", "bodyHTML": "<p dir=\"auto\">This break the assumption that all entities can be identified by the id. The solution might be that a TripPattern should NOT be an <code>TransitEntity</code> or that the id is made uniq in all contexts it exist.</p>\n<p dir=\"auto\">In OTP the <code>TransitEntity.equals</code> means same identity, not same value. In the above method things like scheduledTimetable, hopGeometries and perStopFlags is part of the equals method. But is it really not allowed for these to change in the lifecycle of a <code>TripPattern</code>?</p>", "author": "t2gran", "createdAt": "2020-09-14T13:01:27Z", "path": "src/main/java/org/opentripplanner/model/TripPattern.java", "diffHunk": "@@ -639,4 +640,29 @@ public String getFeedId() {\n     private static Coordinate coordinate(Stop s) {\n         return new Coordinate(s.getLon(), s.getLat());\n     }\n+\n+    // Need an equals() since \"Trips in a pattern are no longer necessarily running on the same service ID.\"\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        if (!super.equals(o)) {\n+            return false;\n+        }\n+        TripPattern that = (TripPattern) o;\n+        return directionId == that.directionId &&\n+                Objects.equal(id, that.id) &&\n+                Objects.equal(name, that.name) &&\n+                Objects.equal(route, that.route) &&\n+                Objects.equal(stopPattern, that.stopPattern) &&\n+                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equal(trips, that.trips) &&\n+                Objects.equal(hopGeometries, that.hopGeometries) &&\n+                Objects.equal(perStopFlags, that.perStopFlags) &&\n+                Objects.equal(services, that.services);\n+    }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4OTQ4NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r494989484", "bodyText": "The TripPattern is used as a Key in a Set in quite a few places. RegExp Search for (Map|Set)<TripPattern.  This make it difficult to wrap it to \"extend\" the hashCode/equals method - so it might not be easy to remove the above method.\nWe should check witch fields we can remove from the equals method, at least the hopGeometries should be removed?\nIf we keep the equals method, then we need to add documentation why and add a hashCode. We will discuss this next Tuesday  in the OTP developer meeting.", "author": "t2gran", "createdAt": "2020-09-25T13:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MzQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/TripPattern.java b/src/main/java/org/opentripplanner/model/TripPattern.java\nindex 374e08cbf..890dc1c7e 100644\n--- a/src/main/java/org/opentripplanner/model/TripPattern.java\n+++ b/src/main/java/org/opentripplanner/model/TripPattern.java\n", "chunk": "@@ -655,14 +678,27 @@ public class TripPattern extends TransitEntity<FeedScopedId> implements Cloneabl\n         }\n         TripPattern that = (TripPattern) o;\n         return directionId == that.directionId &&\n-                Objects.equal(id, that.id) &&\n-                Objects.equal(name, that.name) &&\n-                Objects.equal(route, that.route) &&\n-                Objects.equal(stopPattern, that.stopPattern) &&\n-                Objects.equal(scheduledTimetable, that.scheduledTimetable) &&\n-                Objects.equal(trips, that.trips) &&\n-                Objects.equal(hopGeometries, that.hopGeometries) &&\n-                Objects.equal(perStopFlags, that.perStopFlags) &&\n-                Objects.equal(services, that.services);\n+                Objects.equals(id, that.id) &&\n+                Objects.equals(name, that.name) &&\n+                Objects.equals(route, that.route) &&\n+                Objects.equals(stopPattern, that.stopPattern) &&\n+                Objects.equals(scheduledTimetable, that.scheduledTimetable) &&\n+                Objects.equals(trips, that.trips) &&\n+                Objects.equals(services, that.services) &&\n+                Arrays.equals(perStopFlags, that.perStopFlags);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return 31 * Objects.hash(\n+            id,\n+            name,\n+            route,\n+            directionId,\n+            stopPattern,\n+            scheduledTimetable,\n+            trips,\n+            services\n+        ) + Arrays.hashCode(perStopFlags);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjkxMA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487906910", "body": "This should be documented or inlined, since the usage is limited inlineing is probably the best.", "bodyText": "This should be documented or inlined, since the usage is limited inlineing is probably the best.", "bodyHTML": "<p dir=\"auto\">This should be documented or inlined, since the usage is limited inlineing is probably the best.</p>", "author": "t2gran", "createdAt": "2020-09-14T13:21:36Z", "path": "src/main/java/org/opentripplanner/routing/RoutingService.java", "diffHunk": "@@ -79,9 +80,15 @@ public RoutingResponse route(RoutingRequest request, Router router) {\n                 startTime,\n                 timeRange,\n                 numberOfDepartures,\n-                omitNonPickups\n+                omitNonPickups,\n+                includeCancelledTrips\n         );\n     }\n+    public List<StopTimesInPattern> stopTimesForStop(\n+            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n+    ) {\n+        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n+    }", "originalCommit": "abe0d21c32aca02da5acae76ea4595cdfc3895ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MjE5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3166#discussion_r487972196", "bodyText": "I did inline this one.", "author": "t2gran", "createdAt": "2020-09-14T14:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjkxMA=="}], "type": "inlineReview", "revised_code": {"commit": "67617ca5b74d85bb0ec489e33dc704e1188e4d3a", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/RoutingService.java b/src/main/java/org/opentripplanner/routing/RoutingService.java\nindex a76a28847..c948d2042 100644\n--- a/src/main/java/org/opentripplanner/routing/RoutingService.java\n+++ b/src/main/java/org/opentripplanner/routing/RoutingService.java\n", "chunk": "@@ -84,11 +84,6 @@ public class RoutingService {\n                 includeCancelledTrips\n         );\n     }\n-    public List<StopTimesInPattern> stopTimesForStop(\n-            Stop stop, long startTime, int timeRange, int numberOfDepartures, boolean omitNonPickups\n-    ) {\n-        return stopTimesForStop(stop, startTime, timeRange, numberOfDepartures, omitNonPickups, false);\n-    }\n \n     /**\n      * Get a list of all trips that pass through a stop during a single ServiceDate. Useful when\n", "next_change": null}]}}, {"oid": "afa16eb606da23d6c30b6a7288e08d0e7a04b878", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/afa16eb606da23d6c30b6a7288e08d0e7a04b878", "message": "Removed custom alerts-handling where \"route OR stop\" was treated as \"route AND stop\"", "committedDate": "2020-09-18T14:11:44Z", "type": "commit"}, {"oid": "e76de7b7f1b8d041941b9ea357c50ce9671bf402", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e76de7b7f1b8d041941b9ea357c50ce9671bf402", "message": "Including open-ended alerts when calculating valid display-times", "committedDate": "2020-09-24T13:15:55Z", "type": "commit"}, {"oid": "27c2a63e660df962344672dd8a909c94f3618989", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/27c2a63e660df962344672dd8a909c94f3618989", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-25T08:21:09Z", "type": "commit"}, {"oid": "7fdbcea712bab20251082750842d0c5c7f0d4f49", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/7fdbcea712bab20251082750842d0c5c7f0d4f49", "message": "Removed license-information", "committedDate": "2020-09-25T11:48:55Z", "type": "commit"}, {"oid": "655f5c816d61de60833f95a73006669ca9963d4f", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/655f5c816d61de60833f95a73006669ca9963d4f", "message": "Added comment as javadoc", "committedDate": "2020-09-25T11:48:55Z", "type": "commit"}, {"oid": "f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/f28d16ce788e8ad69d18bdea8dc8104ef87c4353", "message": "clean code: Reformatted SiriAlertsUpdateHandlerTest.java", "committedDate": "2020-09-25T14:23:50Z", "type": "commit"}, {"oid": "30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/30a7c7ed9824ade9d66ec424deb1ccc6fceccc52", "message": "Merge branch 'dev-2.x' into siri-realtime", "committedDate": "2020-09-30T08:54:07Z", "type": "commit"}, {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "message": "Add HashCode to TripPattern and document the eq/hc hack.", "committedDate": "2020-09-30T09:33:13Z", "type": "commit"}, {"oid": "a9e439fa31f64a648812b7824aac2be8a3e8b42a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9e439fa31f64a648812b7824aac2be8a3e8b42a", "message": "Add HashCode to TripPattern and document the eq/hc hack.", "committedDate": "2020-09-30T09:33:13Z", "type": "forcePushed"}]}