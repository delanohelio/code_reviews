{"pr_number": 3187, "pr_title": "Add support for flexible transit routing", "pr_createdAt": "2020-09-18T08:57:29Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187", "merge_commit": "85cfdb1d37f233a7e5926b66ffa60549ab4907a7", "timeline": [{"oid": "b17ac1da6e5eb35553a53017e3f8c93d35acce01", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b17ac1da6e5eb35553a53017e3f8c93d35acce01", "message": "Add FLEXIBLE as transit mode", "committedDate": "2020-09-18T08:14:08Z", "type": "commit"}, {"oid": "0219bb8f2f795fc9f14b034210507e9722c58edd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0219bb8f2f795fc9f14b034210507e9722c58edd", "message": "Add DistanceCalculator", "committedDate": "2020-09-18T08:36:27Z", "type": "commit"}, {"oid": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "message": "Find flex locations when splitting streets for access/egress", "committedDate": "2020-09-18T08:37:52Z", "type": "commit"}, {"oid": "41d4f78595351387691e689a96c930c0940ce274", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/41d4f78595351387691e689a96c930c0940ce274", "message": "Add FlexRouter", "committedDate": "2020-09-18T08:46:51Z", "type": "commit"}, {"oid": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/29145c7230a80f0c21fc25d5b541d8ad000758b3", "message": "Make AccessEgressRouter return StopAtDistance", "committedDate": "2020-09-18T08:54:45Z", "type": "commit"}, {"oid": "2f40da1dc230a78dc355b6553cd62a759ce644e6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2f40da1dc230a78dc355b6553cd62a759ce644e6", "message": "Wire in FlexRouter", "committedDate": "2020-09-18T08:54:58Z", "type": "commit"}, {"oid": "0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/0909081a57da212d4c88038c9f0c5a9c3f3acbf9", "message": "Improve mapping of ScheduledDeviatedTrip", "committedDate": "2020-09-18T11:12:13Z", "type": "commit"}, {"oid": "539086c387320c547b2fc9803d63f8d4ab98943c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/539086c387320c547b2fc9803d63f8d4ab98943c", "message": "Add progress tracker", "committedDate": "2020-09-22T08:15:38Z", "type": "commit"}, {"oid": "bd7128519bfff9685d732094996e2eb0ce18008d", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/bd7128519bfff9685d732094996e2eb0ce18008d", "message": "Fix accesses within no through traffic area", "committedDate": "2020-09-22T08:15:48Z", "type": "commit"}, {"oid": "681acd20acf9c56073616856d09c49f43668be45", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/681acd20acf9c56073616856d09c49f43668be45", "message": "Improve flex mapping", "committedDate": "2020-09-22T08:15:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5MTM5MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492591391", "body": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like `NearByStop`.", "bodyText": "Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like NearByStop.", "bodyHTML": "<p dir=\"auto\">Move the mapping to a Mapper class under the RoutingWorker, and rename this class to something like <code>NearByStop</code>.</p>", "author": "t2gran", "createdAt": "2020-09-22T09:20:30Z", "path": "src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java", "diffHunk": "@@ -55,6 +57,15 @@ public int compareTo(StopAtDistance that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n+  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {", "originalCommit": "29145c7230a80f0c21fc25d5b541d8ad000758b3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java b/src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\nsimilarity index 81%\nrename from src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java\nrename to src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\nindex 40fc0ccff..5aba971ed 100644\n--- a/src/main/java/org/opentripplanner/routing/graphfinder/StopAtDistance.java\n+++ b/src/main/java/org/opentripplanner/routing/graphfinder/NearbyStop.java\n", "chunk": "@@ -53,19 +50,10 @@ public class StopAtDistance implements Comparable<StopAtDistance> {\n   }\n \n   @Override\n-  public int compareTo(StopAtDistance that) {\n+  public int compareTo(NearbyStop that) {\n     return (int) (this.distance) - (int) (that.distance);\n   }\n \n-  public AccessEgress toAccessEgress(StopIndexForRaptor stopIndex, boolean fromTarget) {\n-    if (!(stop instanceof Stop)) { return null; }\n-    return new AccessEgress(\n-        stopIndex.indexByStop.get(stop),\n-        (int) state.getElapsedTimeSeconds(),\n-        fromTarget ? state.reverse() : state\n-    );\n-  }\n-\n   public String toString() {\n     return String.format(\"stop %s at %.1f meters\", stop, distance);\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU5NDQzOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492594439", "body": "Rename parameters to fromStopIndex, toStopIndex", "bodyText": "Rename parameters to fromStopIndex, toStopIndex", "bodyHTML": "<p dir=\"auto\">Rename parameters to fromStopIndex, toStopIndex</p>", "author": "t2gran", "createdAt": "2020-09-22T09:25:17Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.routing.graph.Vertex;\n+\n+/**\n+ * DistanceCalculator is used to calculate the driving times and distances during flex routing\n+ */\n+public interface DistanceCalculator {\n+  DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex);", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java b/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java\ndeleted file mode 100644\nindex 12d860c26..000000000\n--- a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceCalculator.java\n+++ /dev/null\n", "chunk": "@@ -1,11 +0,0 @@\n-package org.opentripplanner.ext.flex.distancecalculator;\n-\n-import org.opentripplanner.routing.graph.Vertex;\n-\n-/**\n- * DistanceCalculator is used to calculate the driving times and distances during flex routing\n- */\n-public interface DistanceCalculator {\n-  DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex);\n-\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwMjMxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492602317", "body": "Add the geometry here? And then the class name become `FlexPath`?", "bodyText": "Add the geometry here? And then the class name become FlexPath?", "bodyHTML": "<p dir=\"auto\">Add the geometry here? And then the class name become <code>FlexPath</code>?</p>", "author": "t2gran", "createdAt": "2020-09-22T09:38:30Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+/**\n+ * This class contains the results from a DistanceCalculator.\n+ */\n+public class DistanceAndDuration {\n+\n+  public int distanceMeters;\n+  public int durationSeconds;", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java b/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java\ndeleted file mode 100644\nindex a3c873b80..000000000\n--- a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/DistanceAndDuration.java\n+++ /dev/null\n", "chunk": "@@ -1,15 +0,0 @@\n-package org.opentripplanner.ext.flex.distancecalculator;\n-\n-/**\n- * This class contains the results from a DistanceCalculator.\n- */\n-public class DistanceAndDuration {\n-\n-  public int distanceMeters;\n-  public int durationSeconds;\n-\n-  public DistanceAndDuration(int distanceMeters, int durationSeconds) {\n-    this.distanceMeters = distanceMeters;\n-    this.durationSeconds = durationSeconds;\n-  }\n-}\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDIxNw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604217", "body": "get more than duration, rename `calculaeFlexPath`", "bodyText": "get more than duration, rename calculaeFlexPath", "bodyHTML": "<p dir=\"auto\">get more than duration, rename <code>calculaeFlexPath</code></p>", "author": "t2gran", "createdAt": "2020-09-22T09:41:46Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java b/src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\nsimilarity index 74%\nrename from src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java\nrename to src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\nindex e657d2dee..c1d7342d4 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\n", "chunk": "@@ -15,25 +15,25 @@ import java.util.HashMap;\n import java.util.Map;\n \n /**\n- * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * StreetFlexPathCalculator calculates the driving times and distances based on the street network\n  * using the AStar algorithm.\n  *\n  * TODO: - Mast fast enough to be usable\n  *       - Use a one-to-many search\n  *       - Cache found times\n  */\n-public class StreetDistanceCalculator implements DistanceCalculator {\n+public class StreetFlexPathCalculator implements FlexPathCalculator {\n   private Graph graph;\n-  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+  private Map<T2<Vertex, Vertex>, FlexPath> cache = new HashMap<>();\n \n-  public StreetDistanceCalculator(Graph graph) {\n+  public StreetFlexPathCalculator(Graph graph) {\n     this.graph = graph;\n   }\n \n   @Override\n-  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {\n+  public FlexPath calculateFlexPath(Vertex fromv, Vertex tov, int fromStopIndex, int toStopIndex) {\n     T2<Vertex, Vertex> key = new T2<>(fromv, tov);\n-    DistanceAndDuration cacheValue = cache.get(key);\n+    FlexPath cacheValue = cache.get(key);\n     if (cacheValue != null) return cacheValue;\n \n     RoutingRequest routingRequest = new RoutingRequest(TraverseMode.CAR);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNDc3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492604773", "body": "What happes if we can not find a path?", "bodyText": "What happes if we can not find a path?", "bodyHTML": "<p dir=\"auto\">What happes if we can not find a path?</p>", "author": "t2gran", "createdAt": "2020-09-22T09:42:49Z", "path": "src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.opentripplanner.ext.flex.distancecalculator;\n+\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.routing.algorithm.astar.AStar;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.spt.DominanceFunction;\n+import org.opentripplanner.routing.spt.GraphPath;\n+import org.opentripplanner.routing.spt.ShortestPathTree;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * StreetDistanceCalculator calculates the driving times and distances based on the street network\n+ * using the AStar algorithm.\n+ *\n+ * TODO: - Mast fast enough to be usable\n+ *       - Use a one-to-many search\n+ *       - Cache found times\n+ */\n+public class StreetDistanceCalculator implements DistanceCalculator {\n+  private Graph graph;\n+  private Map<T2<Vertex, Vertex>, DistanceAndDuration> cache = new HashMap<>();\n+\n+  public StreetDistanceCalculator(Graph graph) {\n+    this.graph = graph;\n+  }\n+\n+  @Override\n+  public DistanceAndDuration getDuration(Vertex fromv, Vertex tov, int fromIndex, int toIndex) {\n+    T2<Vertex, Vertex> key = new T2<>(fromv, tov);\n+    DistanceAndDuration cacheValue = cache.get(key);\n+    if (cacheValue != null) return cacheValue;\n+\n+    RoutingRequest routingRequest = new RoutingRequest(TraverseMode.CAR);\n+    routingRequest.setNumItineraries(1);\n+\n+    routingRequest.setRoutingContext(graph, fromv, tov);\n+    routingRequest.dominanceFunction = new DominanceFunction.EarliestArrival();\n+    AStar search = new AStar();\n+    ShortestPathTree spt = search.getShortestPathTree(routingRequest);\n+\n+    GraphPath path = spt.getPaths().get(0);\n+\n+    int distance = (int) path.edges.stream().mapToDouble(Edge::getDistanceMeters).sum();\n+    int duration = path.getDuration();", "originalCommit": "0219bb8f2f795fc9f14b034210507e9722c58edd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java b/src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\nsimilarity index 74%\nrename from src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java\nrename to src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\nindex e657d2dee..c1d7342d4 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/distancecalculator/StreetDistanceCalculator.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/flexpathcalculator/StreetFlexPathCalculator.java\n", "chunk": "@@ -46,12 +46,14 @@ public class StreetDistanceCalculator implements DistanceCalculator {\n \n     GraphPath path = spt.getPaths().get(0);\n \n+    if (path == null) { return null; }\n+\n     int distance = (int) path.edges.stream().mapToDouble(Edge::getDistanceMeters).sum();\n     int duration = path.getDuration();\n \n     routingRequest.cleanup();\n \n-    DistanceAndDuration value = new DistanceAndDuration(distance, duration);\n+    FlexPath value = new FlexPath(distance, duration);\n     cache.put(key, value);\n     return value;\n   }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492607104", "body": "Use the `isEligibleForCarPickupDropOff()`  here instead.", "bodyText": "Use the isEligibleForCarPickupDropOff()  here instead.", "bodyHTML": "<p dir=\"auto\">Use the <code>isEligibleForCarPickupDropOff()</code>  here instead.</p>", "author": "t2gran", "createdAt": "2020-09-22T09:46:58Z", "path": "src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java", "diffHunk": "@@ -408,6 +412,22 @@ else if (ll.getSegmentIndex() == orig.getNumPoints() - 2 && ll.getSegmentFractio\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n+                Point p = GeometryUtils\n+                    .getGeometryFactory()\n+                    .createPoint(v0.getCoordinate());\n+                Envelope env = p.getEnvelopeInternal();\n+                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))", "originalCommit": "9f70dbc10f1e0f69f6e686b42085fc5eb8b1b837", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA4MzYwNA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494083604", "bodyText": "Using StreetTraversalPermission.PEDESTRIAN_AND_CAR, as isEligibleForCarPickupDropOff() operates on vertices", "author": "hannesj", "createdAt": "2020-09-24T07:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYwNzEwNA=="}], "type": "inlineReview", "revised_code": {"commit": "42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java b/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\nindex 426905d62..20e4a3904 100644\n--- a/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\n+++ b/src/main/java/org/opentripplanner/graph_builder/linking/SimpleStreetSplitter.java\n", "chunk": "@@ -412,18 +412,17 @@ public class SimpleStreetSplitter {\n             SplitterVertex v0 = split(edge, ll, temporaryVertex != null, endVertex);\n             makeLinkEdges(tstop, v0);\n \n-            if (OTPFeature.FlexRouting.isOn() && graph.index != null) {\n-                Point p = GeometryUtils\n-                    .getGeometryFactory()\n-                    .createPoint(v0.getCoordinate());\n+            if (OTPFeature.FlexRouting.isOn() && graph.index != null\n+                && edge.getPermission().allows(StreetTraversalPermission.PEDESTRIAN_AND_CAR)\n+            ) {\n+                Point p = GeometryUtils.getGeometryFactory().createPoint(v0.getCoordinate());\n                 Envelope env = p.getEnvelopeInternal();\n-                for (FlexStopLocation flexStopLocation : graph.index.getFlexIndex().locationIndex.query(env)) {\n-                    if (edge.canTraverse(new TraverseModeSet(TraverseMode.CAR))\n-                        && !flexStopLocation.getGeometry().disjoint(p)) {\n+                for (FlexStopLocation location : graph.index.getFlexIndex().locationIndex.query(env)) {\n+                    if (!location.getGeometry().disjoint(p)) {\n                         if (v0.flexStopLocations == null) {\n                             v0.flexStopLocations = new HashSet<>();\n                         }\n-                        v0.flexStopLocations.add(flexStopLocation);\n+                        v0.flexStopLocations.add(location);\n                     }\n                 }\n             }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxNzA4MA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492617080", "body": "Decuple the raptor API from Flex", "bodyText": "Decuple the raptor API from Flex", "bodyHTML": "<p dir=\"auto\">Decuple the raptor API from Flex</p>", "author": "t2gran", "createdAt": "2020-09-22T10:04:16Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.opentripplanner.ext.flex;\n+\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.core.State;\n+\n+public class FlexAccessEgress extends AccessEgress {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\nindex 882e845ee..4a966b76d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexAccessEgress.java\n", "chunk": "@@ -1,22 +1,23 @@\n package org.opentripplanner.ext.flex;\n \n import org.opentripplanner.ext.flex.trip.FlexTrip;\n-import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.model.Stop;\n import org.opentripplanner.routing.core.State;\n \n-public class FlexAccessEgress extends AccessEgress {\n-\n-  private final int preFlexTime;\n-  private final int flexTime;\n-  private final int postFlexTime;\n+public class FlexAccessEgress {\n+  public final Stop stop;\n+  public final int preFlexTime;\n+  public final int flexTime;\n+  public final int postFlexTime;\n   private final int fromStopIndex;\n   private final int toStopIndex;\n   private final int differenceFromStartOfTime;\n   private final FlexTrip trip;\n-  private final boolean directToStop;\n+  public final State lastState;\n+  public final boolean directToStop;\n \n   public FlexAccessEgress(\n-      int toFromStop,\n+      Stop stop,\n       int preFlexTime,\n       int flexTime,\n       int postFlexTime,\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyMDMwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492620305", "body": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "bodyText": "Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.", "bodyHTML": "<p dir=\"auto\">Remove this parameter, the stopIndex - it should not be necessary if the mapping to Raptor is moved out of flex.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:10:14Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..fab89e060 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -61,8 +60,8 @@ public class FlexRouter {\n       RoutingRequest request,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n-      Collection<StopAtDistance> streetAccesses,\n-      Collection<StopAtDistance> egressTransfers,\n+      Collection<NearbyStop> streetAccesses,\n+      Collection<NearbyStop> egressTransfers,\n       StopIndexForRaptor stopIndex\n   ) {\n     this.graph = request.rctx.graph;\n", "next_change": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e060..af11c11c3 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -70,7 +70,7 @@ public class FlexRouter {\n     this.stopIndex = stopIndex;\n     this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n-    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+    this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n     Instant searchInstant = request.getDateTime().toInstant();\n", "next_change": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex af11c11c3..32add6481 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -61,13 +59,11 @@ public class FlexRouter {\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n-      Collection<NearbyStop> egressTransfers,\n-      StopIndexForRaptor stopIndex\n+      Collection<NearbyStop> egressTransfers\n   ) {\n     this.graph = request.rctx.graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n-    this.stopIndex = stopIndex;\n     this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add6481..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -64,7 +60,6 @@ public class FlexRouter {\n     this.graph = request.rctx.graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n-    this.transitTransfers = graph.getTransferTable().getTransfers();\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9..0833d363c 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,74 +43,50 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.dates = new FlexServicesOnDate[totalDays];\n+    this.dates = new FlexServiceDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      dates[index] = new FlexServicesOnDate(\n-          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+      dates[index] = new FlexServiceDate(\n+          serviceDate,\n           DateMapper.secondsSinceStartOfTime(startOfTime, date),\n-          serviceDate\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate)\n       );\n     }\n   }\n \n-  private void calculateFlexAccessTemplates() {\n-    if (this.flexAccessTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n-\n-    this.flexAccessTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());\n-  }\n-\n-  private void calculateFlexEgressTemplates() {\n-    if (this.flexEgressTemplates != null) { return; }\n-\n-    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n-\n-    this.flexEgressTemplates = reachableFlexTrips\n-        .flatMap(t2 -> Arrays.stream(dates)\n-            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n-            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n-        .collect(Collectors.toList());;\n-  }\n-\n-\n-  public Collection<Itinerary> getFlexOnlyItineraries() {\n+  public Collection<Itinerary> createFlexOnlyItineraries() {\n     calculateFlexAccessTemplates();\n     calculateFlexEgressTemplates();\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYyNTQyNg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492625426", "body": "Maybe something like this:\r\n\r\n```\r\nclass FlexServicesOnDate {\r\n  private final TIntSet servicesRunning;\r\n  private final int secondsFromStartOfTime;\r\n  private final ServiceDate serviceDate;\r\n}\r\n```", "bodyText": "Maybe something like this:\nclass FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}", "bodyHTML": "<p dir=\"auto\">Maybe something like this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"class FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}\"><pre><code>class FlexServicesOnDate {\n  private final TIntSet servicesRunning;\n  private final int secondsFromStartOfTime;\n  private final ServiceDate serviceDate;\n}\n</code></pre></div>", "author": "t2gran", "createdAt": "2020-09-22T10:19:55Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -31,27 +28,23 @@ import java.util.Optional;\n import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n \n public class FlexRouter {\n \n   /* Transit data */\n   private final Graph graph;\n-  private final Collection<StopAtDistance> streetAccesses;\n-  private final Collection<StopAtDistance> streetEgresses;\n-  private final StopIndexForRaptor stopIndex;\n-  private final Collection<Transfer> transitTransfers;\n+  private final Collection<NearbyStop> streetAccesses;\n+  private final Collection<NearbyStop> streetEgresses;\n   private final FlexIndex flexIndex;\n-  private final DistanceCalculator distanceCalculator;\n+  private final FlexPathCalculator flexPathCalculator;\n \n   /* Request data */\n   private final ZonedDateTime startOfTime;\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final TIntSet[] servicesRunning;\n-  private final int[] differenceFromStartOfTime;\n-  private final ServiceDate[] serviceDates;\n+  private final FlexServicesOnDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n", "next_change": {"commit": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9..f59b84176 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -44,7 +44,7 @@ public class FlexRouter {\n   private final int departureTime;\n   private final boolean arriveBy;\n \n-  private final FlexServicesOnDate[] dates;\n+  private final FlexServiceDate[] dates;\n \n   /* State */\n   private List<FlexAccessTemplate> flexAccessTemplates = null;\n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex f59b84176..0833d363c 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -51,24 +50,25 @@ public class FlexRouter {\n   private List<FlexEgressTemplate> flexEgressTemplates = null;\n \n   public FlexRouter(\n-      RoutingRequest request,\n+      Graph graph,\n+      Instant searchInstant,\n+      boolean arriveBy,\n       int additionalPastSearchDays,\n       int additionalFutureSearchDays,\n       Collection<NearbyStop> streetAccesses,\n       Collection<NearbyStop> egressTransfers\n   ) {\n-    this.graph = request.rctx.graph;\n+    this.graph = graph;\n     this.streetAccesses = streetAccesses;\n     this.streetEgresses = egressTransfers;\n     this.flexIndex = graph.index.getFlexIndex();\n     this.flexPathCalculator = new DirectFlexPathCalculator(graph);\n \n     ZoneId tz = graph.getTimeZone().toZoneId();\n-    Instant searchInstant = request.getDateTime().toInstant();\n     LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n     this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n     this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n-    this.arriveBy = request.arriveBy;\n+    this.arriveBy = arriveBy;\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMDM4Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492630383", "body": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "bodyText": "Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.", "bodyHTML": "<p dir=\"auto\">Maybe add some JavaDoc on this method to explain the the intention of the method and any optimalizations.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:29:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -82,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzMTQ1NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492631454", "body": "Make this a local varable.", "bodyText": "Make this a local varable.", "bodyHTML": "<p dir=\"auto\">Make this a local varable.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:31:40Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -82,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjE3NA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636174", "body": "Add the call of these methods to the beginning of the method.", "bodyText": "Add the call of these methods to the beginning of the method.", "bodyHTML": "<p dir=\"auto\">Add the call of these methods to the beginning of the method.</p>", "author": "t2gran", "createdAt": "2020-09-22T10:40:58Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..fab89e060 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -150,9 +149,9 @@ public class FlexRouter {\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n     Set<StopLocation> egressStops = egressTransferByStop.keySet();\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e060..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNjUwNQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492636505", "body": "Maybe rename to `streetEgressByStop`", "bodyText": "Maybe rename to streetEgressByStop", "bodyHTML": "<p dir=\"auto\">Maybe rename to <code>streetEgressByStop</code></p>", "author": "t2gran", "createdAt": "2020-09-22T10:41:41Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..fab89e060 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -150,9 +149,9 @@ public class FlexRouter {\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n         .stream()\n-        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+        .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n     Set<StopLocation> egressStops = egressTransferByStop.keySet();\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e060..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzNzIxOA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492637218", "body": "Rename `getDirectItinerary` to `createDirectItinerary`", "bodyText": "Rename getDirectItinerary to createDirectItinerary", "bodyHTML": "<p dir=\"auto\">Rename <code>getDirectItinerary</code> to <code>createDirectItinerary</code></p>", "author": "t2gran", "createdAt": "2020-09-22T10:43:20Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1e268b26b76f66baf7347beed502c68a9353bb53", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..fab89e060 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -164,7 +163,7 @@ public class FlexRouter {\n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        NearbyStop egress = egressTransferByStop.get(transferStop);\n         Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex fab89e060..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -81,90 +72,63 @@ public class FlexRouter {\n \n     int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n \n-    this.differenceFromStartOfTime = new int[totalDays];\n-    this.servicesRunning = new TIntSet[totalDays];\n-    this.serviceDates = new ServiceDate[totalDays];\n+    this.dates = new FlexServicesOnDate[totalDays];\n \n     for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n       LocalDate date = searchDate.plusDays(d);\n       int index = d + additionalPastSearchDays;\n       ServiceDate serviceDate = new ServiceDate(date);\n-      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n-      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n-      serviceDates[index] = serviceDate;\n+      dates[index] = new FlexServicesOnDate(\n+          graph.index.getServiceCodesRunningForDate().get(serviceDate),\n+          DateMapper.secondsSinceStartOfTime(startOfTime, date),\n+          serviceDate\n+      );\n     }\n   }\n \n   private void calculateFlexAccessTemplates() {\n     if (this.flexAccessTemplates != null) { return; }\n \n-    this.flexAccessTemplates = streetAccesses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetAccesses);\n+\n+    this.flexAccessTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexAccessTemplates(t2.first, t2.second, this.flexPathCalculator)))\n         .collect(Collectors.toList());\n   }\n \n   private void calculateFlexEgressTemplates() {\n     if (this.flexEgressTemplates != null) { return; }\n \n-    this.flexEgressTemplates = streetEgresses\n-        .stream()\n-        .flatMap(accessEgress -> flexIndex\n-            .getFlexTripsByStop(accessEgress.stop)\n-            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n-        .collect(Collectors.groupingBy(t2 -> t2.second))\n-        .values()\n-        .stream()\n-        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n-        .flatMap(Optional::stream)\n-        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n-            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n-            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n-                t2.first,\n-                differenceFromStartOfTime[i],\n-                serviceDates[i],\n-                distanceCalculator\n-            ))\n-            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n-            .flatMap(Function.identity()))\n-        .collect(Collectors.toList());\n+    Stream<T2<NearbyStop, FlexTrip>> reachableFlexTrips = getReachableFlexTrips(streetEgresses);\n+\n+    this.flexEgressTemplates = reachableFlexTrips\n+        .flatMap(t2 -> Arrays.stream(dates)\n+            .filter(date -> date.isFlexTripRunning(t2.second, this.graph))\n+            .flatMap(date -> date.getFlexEgressTemplates(t2.first, t2.second, this.flexPathCalculator)))\n+        .collect(Collectors.toList());;\n   }\n \n \n   public Collection<Itinerary> getFlexOnlyItineraries() {\n-    Map<StopLocation, NearbyStop> egressTransferByStop = streetEgresses\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Map<StopLocation, NearbyStop> streetEgressByStop = streetEgresses\n         .stream()\n         .collect(Collectors.toMap(nearbyStop -> nearbyStop.stop, Function.identity()));\n \n-    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+    Set<StopLocation> egressStops = streetEgressByStop.keySet();\n \n-    calculateFlexAccessTemplates();\n-    calculateFlexEgressTemplates();\n \n     Collection<Itinerary> itineraries = new ArrayList<>();\n \n     for (FlexAccessTemplate template : this.flexAccessTemplates) {\n       StopLocation transferStop = template.getTransferStop();\n       if (egressStops.contains(transferStop)) {\n-        NearbyStop egress = egressTransferByStop.get(transferStop);\n-        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        NearbyStop egress = streetEgressByStop.get(transferStop);\n+        Itinerary itinerary = template.createDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n         if (itinerary != null) {\n           itineraries.add(itinerary);\n         }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzODE3Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492638173", "body": "Not Base use template", "bodyText": "Not Base use template", "bodyHTML": "<p dir=\"auto\">Not Base use template</p>", "author": "t2gran", "createdAt": "2020-09-22T10:45:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.common.model.T2;\n+import org.opentripplanner.ext.flex.distancecalculator.DirectDistanceCalculator;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessTemplate;\n+import org.opentripplanner.ext.flex.template.FlexEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Transfer;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.model.plan.Itinerary;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.algorithm.raptor.transit.mappers.DateMapper;\n+import org.opentripplanner.routing.api.request.RoutingRequest;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FlexRouter {\n+\n+  /* Transit data */\n+  private final Graph graph;\n+  private final Collection<StopAtDistance> streetAccesses;\n+  private final Collection<StopAtDistance> streetEgresses;\n+  private final StopIndexForRaptor stopIndex;\n+  private final Collection<Transfer> transitTransfers;\n+  private final FlexIndex flexIndex;\n+  private final DistanceCalculator distanceCalculator;\n+\n+  /* Request data */\n+  private final ZonedDateTime startOfTime;\n+  private final int departureTime;\n+  private final boolean arriveBy;\n+\n+  private final TIntSet[] servicesRunning;\n+  private final int[] differenceFromStartOfTime;\n+  private final ServiceDate[] serviceDates;\n+\n+  /* State */\n+  private List<FlexAccessTemplate> flexAccessTemplates = null;\n+  private List<FlexEgressTemplate> flexEgressTemplates = null;\n+\n+  public FlexRouter(\n+      RoutingRequest request,\n+      int additionalPastSearchDays,\n+      int additionalFutureSearchDays,\n+      Collection<StopAtDistance> streetAccesses,\n+      Collection<StopAtDistance> egressTransfers,\n+      StopIndexForRaptor stopIndex\n+  ) {\n+    this.graph = request.rctx.graph;\n+    this.streetAccesses = streetAccesses;\n+    this.streetEgresses = egressTransfers;\n+    this.stopIndex = stopIndex;\n+    this.transitTransfers = graph.getTransferTable().getTransfers();\n+    this.flexIndex = graph.index.getFlexIndex();\n+    this.distanceCalculator = new DirectDistanceCalculator(graph);\n+\n+    ZoneId tz = graph.getTimeZone().toZoneId();\n+    Instant searchInstant = request.getDateTime().toInstant();\n+    LocalDate searchDate = LocalDate.ofInstant(searchInstant, tz);\n+    this.startOfTime = DateMapper.asStartOfService(searchDate, tz);\n+    this.departureTime = DateMapper.secondsSinceStartOfTime(startOfTime, searchInstant);\n+    this.arriveBy = request.arriveBy;\n+\n+    int totalDays = additionalPastSearchDays + 1 + additionalFutureSearchDays;\n+\n+    this.differenceFromStartOfTime = new int[totalDays];\n+    this.servicesRunning = new TIntSet[totalDays];\n+    this.serviceDates = new ServiceDate[totalDays];\n+\n+    for (int d = -additionalPastSearchDays; d <= additionalFutureSearchDays; ++d) {\n+      LocalDate date = searchDate.plusDays(d);\n+      int index = d + additionalPastSearchDays;\n+      ServiceDate serviceDate = new ServiceDate(date);\n+      differenceFromStartOfTime[index] = DateMapper.secondsSinceStartOfTime(startOfTime, date);\n+      servicesRunning[index] = graph.index.getServiceCodesRunningForDate().get(serviceDate);\n+      serviceDates[index] = serviceDate;\n+    }\n+  }\n+\n+  private void calculateFlexAccessTemplates() {\n+    if (this.flexAccessTemplates != null) { return; }\n+\n+    this.flexAccessTemplates = streetAccesses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexAccessTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void calculateFlexEgressTemplates() {\n+    if (this.flexEgressTemplates != null) { return; }\n+\n+    this.flexEgressTemplates = streetEgresses\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)))\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values()\n+        .stream()\n+        .map(t2s -> t2s.stream().min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream)\n+        .flatMap(t2 -> IntStream.range(0, servicesRunning.length)\n+            .filter(i -> isFlexTripRunning(servicesRunning[i], t2.second))\n+            .mapToObj(i -> t2.second.getFlexEgressTemplates(\n+                t2.first,\n+                differenceFromStartOfTime[i],\n+                serviceDates[i],\n+                distanceCalculator\n+            ))\n+            // TODO: Optimization: Could we filter here if earliestDepartureTime or latestArrivalTime is -1\n+            .flatMap(Function.identity()))\n+        .collect(Collectors.toList());\n+  }\n+\n+\n+  public Collection<Itinerary> getFlexOnlyItineraries() {\n+    Map<StopLocation, StopAtDistance> egressTransferByStop = streetEgresses\n+        .stream()\n+        .collect(Collectors.toMap(stopAtDistance -> stopAtDistance.stop, Function.identity()));\n+\n+    Set<StopLocation> egressStops = egressTransferByStop.keySet();\n+\n+    calculateFlexAccessTemplates();\n+    calculateFlexEgressTemplates();\n+\n+    Collection<Itinerary> itineraries = new ArrayList<>();\n+\n+    for (FlexAccessTemplate template : this.flexAccessTemplates) {\n+      StopLocation transferStop = template.getTransferStop();\n+      if (egressStops.contains(transferStop)) {\n+        StopAtDistance egress = egressTransferByStop.get(transferStop);\n+        Itinerary itinerary = template.getDirectItinerary(egress, arriveBy, departureTime, startOfTime);\n+        if (itinerary != null) {\n+          itineraries.add(itinerary);\n+        }\n+      }\n+    }\n+\n+    return itineraries;\n+  }\n+\n+  public Collection<FlexAccessEgress> getFlexAccesses() {\n+    calculateFlexAccessTemplates();\n+\n+    return this.flexAccessTemplates\n+        .stream()\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex d866feaf3..32add6481 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -180,7 +173,7 @@ public class FlexRouter {\n \n     return this.flexAccessTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph, stopIndex.indexByStop))\n+        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n", "next_change": {"commit": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add6481..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -173,7 +143,7 @@ public class FlexRouter {\n \n     return this.flexAccessTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n+        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9..0833d363c 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -147,7 +121,7 @@ public class FlexRouter {\n         .collect(Collectors.toList());\n   }\n \n-  public Collection<FlexAccessEgress> getFlexEgresses() {\n+  public Collection<FlexAccessEgress> createFlexEgresses() {\n     calculateFlexEgressTemplates();\n \n     return this.flexEgressTemplates\n", "next_change": null}]}}, {"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex 32add6481..a599beff9 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -182,12 +152,32 @@ public class FlexRouter {\n \n     return this.flexEgressTemplates\n         .stream()\n-        .flatMap(flexAccessEgressBase -> flexAccessEgressBase.getFlexAccessEgressStream(graph))\n+        .flatMap(template -> template.createFlexAccessEgressStream(graph))\n         .collect(Collectors.toList());\n   }\n \n-  private boolean isFlexTripRunning(TIntSet services, FlexTrip flexTrip) {\n-    return services.contains(graph.getServiceCodes().get(flexTrip.getTrip().getServiceId()));\n+  private Stream<T2<NearbyStop, FlexTrip>> getReachableFlexTrips(Collection<NearbyStop> nearbyStops) {\n+    // Find all trips reachable from the nearbyStops\n+    Stream<T2<NearbyStop, FlexTrip>> flexTripsReachableFromNearbyStops = nearbyStops\n+        .stream()\n+        .flatMap(accessEgress -> flexIndex\n+            .getFlexTripsByStop(accessEgress.stop)\n+            .map(flexTrip -> new T2<>(accessEgress, flexTrip)));\n+\n+    // Group all (NearbyStop, FlexTrip) tuples by flexTrip\n+    Collection<List<T2<NearbyStop, FlexTrip>>> groupedReachableFlexTrips = flexTripsReachableFromNearbyStops\n+        .collect(Collectors.groupingBy(t2 -> t2.second))\n+        .values();\n+\n+    // Get the tuple with least walking time from each group\n+    Stream<T2<NearbyStop, FlexTrip>> nearestFlexibleTrips = groupedReachableFlexTrips\n+        .stream()\n+        .map(t2s -> t2s\n+            .stream()\n+            .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n+        .flatMap(Optional::stream);\n+\n+    return nearestFlexibleTrips;\n   }\n \n }\n", "next_change": {"commit": "a90d7ed6ba1607139510e269292605b9327acfd2", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\nindex a599beff9..0833d363c 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexRouter.java\n", "chunk": "@@ -170,14 +172,12 @@ public class FlexRouter {\n         .values();\n \n     // Get the tuple with least walking time from each group\n-    Stream<T2<NearbyStop, FlexTrip>> nearestFlexibleTrips = groupedReachableFlexTrips\n+    return groupedReachableFlexTrips\n         .stream()\n         .map(t2s -> t2s\n             .stream()\n             .min(Comparator.comparingLong(t2 -> t2.first.state.getElapsedTimeSeconds())))\n         .flatMap(Optional::stream);\n-\n-    return nearestFlexibleTrips;\n   }\n \n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYzOTc2MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492639761", "body": "create/generate not get, maybe?", "bodyText": "create/generate not get, maybe?", "bodyHTML": "<p dir=\"auto\">create/generate not get, maybe?</p>", "author": "t2gran", "createdAt": "2020-09-22T10:48:38Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9df667f4d..a66dadbca 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -73,33 +72,29 @@ public abstract class FlexAccessEgressTemplate {\n \n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n-      Graph graph, Map<Stop, Integer> indexByStop\n-  ) {\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n       if (isRouteable(flexVertex)) {\n-        return Stream.of(\n-            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n-        );\n+        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n       }\n       return Stream.empty();\n     } else {\n       return getTransfersFromTransferStop(graph)\n           .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) instanceof Stop)\n+          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n           .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n           .map(simpleTransfer -> {\n             List<Edge> edges = getTransferEdges(simpleTransfer);\n             return getFlexAccessEgress(edges,\n                 getFlexVertex(edges.get(0)),\n-                indexByStop.get(getFinalStop(simpleTransfer))\n+                getFinalStop(simpleTransfer)\n             );\n           });\n     }\n   }\n \n-  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, int stopIndex) {\n+  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n     State state = flexEdge.traverse(accessEgress.state);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "85cfdb1d37f233a7e5926b66ffa60549ab4907a7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9df667f4d9..61e295d41d 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -59,47 +58,68 @@ public abstract class FlexAccessEgressTemplate {\n     return trip;\n   }\n \n+  /**\n+   * Get a list of edges used for transferring to and from the scheduled transit network. The edges\n+   * should be in the order of traversal of the state in the NearbyStop\n+   * */\n   abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n \n-  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+  /**\n+   * Get the {@Link Stop} where the connection to the scheduled transit network is made.\n+   */\n+  abstract protected Stop getFinalStop(SimpleTransfer simpleTransfer);\n \n+  /**\n+   * Get the transfers to/from stops in the scheduled transit network from the beginning/end of the\n+   * flex ride for the access/egress.\n+   */\n   abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n \n+  /**\n+   * Get the {@Link Vertex} where the flex ride ends/begins for the access/egress.\n+   */\n   abstract protected Vertex getFlexVertex(Edge edge);\n \n+  /**\n+   * Get the times in seconds, before during and after the flex ride.\n+   */\n   abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n \n+  /**\n+   * Get the FlexTripEdge for the flex ride.\n+   */\n   abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n \n+  /**\n+   * Checks whether the routing is possible\n+   */\n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n-      Graph graph, Map<Stop, Integer> indexByStop\n-  ) {\n+  public Stream<FlexAccessEgress> createFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n       if (isRouteable(flexVertex)) {\n-        return Stream.of(\n-            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n-        );\n+        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n       }\n       return Stream.empty();\n-    } else {\n+    }\n+    // transferStop is Location Area/Line\n+    else {\n       return getTransfersFromTransferStop(graph)\n           .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) instanceof Stop)\n+          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n           .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n           .map(simpleTransfer -> {\n             List<Edge> edges = getTransferEdges(simpleTransfer);\n             return getFlexAccessEgress(edges,\n                 getFlexVertex(edges.get(0)),\n-                indexByStop.get(getFinalStop(simpleTransfer))\n+                getFinalStop(simpleTransfer)\n             );\n           });\n     }\n   }\n \n-  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, int stopIndex) {\n+  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n     State state = flexEdge.traverse(accessEgress.state);\n", "next_change": {"commit": "2f2fe4a58a545f70215f360ea8d9938cbd9136b9", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 61e295d41d..a4cf6ca411 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -91,40 +105,47 @@ public abstract class FlexAccessEgressTemplate {\n   abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n \n   /**\n-   * Checks whether the routing is possible\n+   * This method is very much the hot code path in the flex access/egress search so any optimization\n+   * here will lead to noticeable speedups.\n    */\n-  abstract protected boolean isRouteable(Vertex flexVertex);\n-\n   public Stream<FlexAccessEgress> createFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n-      if (isRouteable(flexVertex)) {\n-        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n-      }\n-      return Stream.empty();\n+      return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop))\n+              .filter(Objects::nonNull);\n     }\n     // transferStop is Location Area/Line\n     else {\n       return getTransfersFromTransferStop(graph)\n-          .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n-          .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n-          .map(simpleTransfer -> {\n-            List<Edge> edges = getTransferEdges(simpleTransfer);\n-            return getFlexAccessEgress(edges,\n-                getFlexVertex(edges.get(0)),\n-                getFinalStop(simpleTransfer)\n-            );\n-          });\n+              .stream()\n+              .filter(transfer -> getFinalStop(transfer) != null)\n+              .map(transfer -> {\n+                List<Edge> edges = getTransferEdges(transfer);\n+                return getFlexAccessEgress(\n+                        edges,\n+                        getFlexVertex(edges.get(0)),\n+                        getFinalStop(transfer)\n+                );\n+              })\n+              .filter(Objects::nonNull);\n     }\n   }\n \n   protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n+    // this code is a little repetitive but needed as a performance improvement. previously\n+    // the flex path was checked before this method was called. this meant that every path\n+    // was traversed twice leading to a noticeable slowdown.\n     State state = flexEdge.traverse(accessEgress.state);\n+    if (state == null) {\n+      return null;\n+    }\n     for (Edge e : transferEdges) {\n       state = e.traverse(state);\n+      if (state == null) {\n+        return null;\n+      }\n     }\n \n     int[] times = getFlexTimes(flexEdge, state);\n", "next_change": {"commit": "9c9dd613489a348d2381acdcbeab8f86589154d7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex a4cf6ca411..9880f9fdd3 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -151,16 +159,32 @@ public abstract class FlexAccessEgressTemplate {\n     int[] times = getFlexTimes(flexEdge, state);\n \n     return new FlexAccessEgress(\n-        stop,\n-        times[0],\n-        times[1],\n-        times[2],\n-        fromStopIndex,\n-        toStopIndex, secondsFromStartOfTime,\n-        trip,\n-        state,\n-        transferEdges.isEmpty()\n+      stop,\n+      times[0],\n+      times[1],\n+      times[2],\n+      fromStopIndex,\n+      toStopIndex,\n+      secondsFromStartOfTime,\n+      trip,\n+      state,\n+      transferEdges.isEmpty()\n     );\n   }\n \n+  @Override\n+  public String toString() {\n+    return MoreObjects\n+      .toStringHelper(this)\n+      .add(\"accessEgress\", accessEgress)\n+      .add(\"trip\", trip)\n+      .add(\"fromStopIndex\", fromStopIndex)\n+      .add(\"toStopIndex\", toStopIndex)\n+      .add(\"transferStop\", transferStop)\n+      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n+      .add(\"serviceDate\", serviceDate)\n+      .add(\"calculator\", calculator)\n+      .add(\"flexParams\", flexParams)\n+      .toString();\n+  }\n }\n", "next_change": {"commit": "6468e42f1e348eba2568f0abc0799965b68723b7", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9880f9fdd3..8c66b0e4ba 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -171,20 +186,4 @@ public abstract class FlexAccessEgressTemplate {\n       transferEdges.isEmpty()\n     );\n   }\n-\n-  @Override\n-  public String toString() {\n-    return MoreObjects\n-      .toStringHelper(this)\n-      .add(\"accessEgress\", accessEgress)\n-      .add(\"trip\", trip)\n-      .add(\"fromStopIndex\", fromStopIndex)\n-      .add(\"toStopIndex\", toStopIndex)\n-      .add(\"transferStop\", transferStop)\n-      .add(\"secondsFromStartOfTime\", secondsFromStartOfTime)\n-      .add(\"serviceDate\", serviceDate)\n-      .add(\"calculator\", calculator)\n-      .add(\"flexParams\", flexParams)\n-      .toString();\n-  }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "85cfdb1d37f233a7e5926b66ffa60549ab4907a7", "message": "Merge commit", "committedDate": null}, {"oid": "5498e06ef5b348232caa1500cbf2559f795306bd", "committedDate": "2021-03-24 13:49:00 +0100", "message": "Javadoc"}, {"oid": "3cb1df099879826f53000c2d86f6485ff0a08b3c", "committedDate": "2021-05-06 11:38:06 +0200", "message": "Apply the fix from #3439 to prevent duplicate direct flex itineraries"}, {"oid": "85df64b5384b94db86ab3d57c78715abecba0b9a", "committedDate": "2021-09-20 14:17:16 +0200", "message": "refactor: Rename SimpleTransfer to PathTransfer"}, {"oid": "2f2fe4a58a545f70215f360ea8d9938cbd9136b9", "committedDate": "2021-11-03 10:09:46 +0100", "message": "Improve performance of flex access/egress search by computing path only once"}, {"oid": "58cbb432a5cf7be976a046ecadcf07b39a0ad343", "committedDate": "2021-11-03 10:09:47 +0100", "message": "Make it possible to configure maximum length for a flex transfer"}, {"oid": "83a11bbd5fba92cbcdf337f1f4ac1618ceaa4de5", "committedDate": "2021-11-03 10:09:47 +0100", "message": "Move FlexConfig to sandbox location"}, {"oid": "606d32d4829990ad0f392370d8fb0e9e74301793", "committedDate": "2021-11-03 10:09:48 +0100", "message": "Address review feedback about configuration"}, {"oid": "3ab9c9377de8245fa45207ec36504ae1ba651efe", "committedDate": "2021-11-03 10:46:49 +0100", "message": "Rename config to params where appropriate"}, {"oid": "8298061e0a41e72d78b1f0f22b8a039251e7d8aa", "committedDate": "2021-11-05 11:45:12 +0100", "message": "Allow getting on and off at the same stop location for ScheduledDeviatedTrip"}, {"oid": "9c9dd613489a348d2381acdcbeab8f86589154d7", "committedDate": "2022-04-06 10:59:20 +0200", "message": "refactor: Format all code"}, {"oid": "6468e42f1e348eba2568f0abc0799965b68723b7", "committedDate": "2022-04-06 14:38:25 +0200", "message": "refactor: Reorder the content of all Java classes with IntelliJ"}, {"oid": "b0c367119fc2b637823337923b5504444eb45a52", "committedDate": "2022-06-13 17:38:22 +0200", "message": "refactor: Move Stop related classes into package site"}, {"oid": "49e5f98805c30177a666b405dc9c24907d103cf4", "committedDate": "2022-06-30 12:02:24 +0200", "message": "Introduce TransitModel and StopModel"}, {"oid": "a4ae7f4b50d0339e1bd881b5018fef438ac2da8b", "committedDate": "2022-07-06 15:08:16 +0300", "message": "Migrate FlexServiceDate to LocalDate"}, {"oid": "a9a481a11accd25c83e422497e3b507cf313b4e7", "committedDate": "2022-07-25 16:53:07 +0200", "message": "Encapsulate StopModelIndex"}, {"oid": "cc57d2d0a5597e481939d2f7446c9794fa73bf7a", "committedDate": "2022-07-26 18:38:37 +0200", "message": "Convert FlexRouter to use TransitService"}, {"oid": "fe94f9cacad69d80005b150cff15ea0b112b16f5", "committedDate": "2022-07-26 19:12:52 +0200", "message": "Merge branch 'otp2_merge_raptor_stop_index' into otp2_refactor_transitmodel"}, {"oid": "e98ac761f8b0a85c5c77a1634d3735f8b881dcf8", "committedDate": "2022-07-28 21:37:08 +0200", "message": "Remove usage of com.google.common.base.MoreObjects#toStringHelper"}, {"oid": "3f9e1f34ff870529f5fc616045769cedf29f8e95", "committedDate": "2022-08-16 22:36:56 +0200", "message": "refactor: Move transitStopVertices from StopModel to StreetVertexIndex."}, {"oid": "0a8954d22257597e5c90a4f558b319edc5650dbd", "committedDate": "2022-08-18 11:46:23 +0200", "message": "refactor: Rename Stop to RegularStop"}, {"oid": "759d43b71b8fc5a8ea51819bb6a211eff74bff0e", "committedDate": "2022-11-23 15:03:45 +0100", "message": "Move Edge and Vertex to AStar"}, {"oid": "dac80ffe201d18a644bd13c1d5fe896902261bd7", "committedDate": "2022-11-23 15:28:18 +0100", "message": "Move Vertices to street model"}, {"oid": "861eb367f31e9bb08d83aaba1a01123abb989506", "committedDate": "2022-11-23 16:04:55 +0100", "message": "refactor: Reformat code"}, {"oid": "b6f7bc0a2c89fed67bc23c274e8fbe4fd26d690d", "committedDate": "2022-11-23 16:52:13 +0100", "message": "refactor: Move o.o.util.lanf to o.o.framework.[lang"}, {"oid": "c0b3d0824f61aadb679eb991552910f59a833316", "committedDate": "2022-11-24 14:45:14 +0100", "message": "Move base Edge and Vertex to street model"}, {"oid": "bd3434f0fbd92aca1db79012b9d5d7e996aa8164", "committedDate": "2022-11-24 17:17:15 +0100", "message": "refactor: Turn DataImportIssueStore into a encapsulated module"}, {"oid": "3f83645e4b133679eec43cb91d96a2edd24b1b3c", "committedDate": "2022-11-25 10:10:04 +0200", "message": "Move code to street search"}, {"oid": "91d95559cd6a000a02b52a3aa6ed69be7d78ba56", "committedDate": "2022-11-29 14:35:32 +0200", "message": "Move form FlexParameters to using FlexConfig"}, {"oid": "3751a23163f161e6576620276ff14765a90cd120", "committedDate": "2022-11-29 14:38:24 +0200", "message": "Migrate maxTransferDuration to duration"}, {"oid": "0f784779a216cfc44ae8ab1a11d1936168e35c76", "committedDate": "2022-12-06 16:11:02 +0100", "message": "Allow configuration of flex walk access/egress duration"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0MDg4Mg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492640882", "body": "}\r\n// Location Area/Line\r\nelse {", "bodyText": "}\n// Location Area/Line\nelse {", "bodyHTML": "<p dir=\"auto\">}<br>\n// Location Area/Line<br>\nelse {</p>", "author": "t2gran", "createdAt": "2020-09-22T10:50:53Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexTripEdge;\n+import org.opentripplanner.ext.flex.distancecalculator.DistanceCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.StopAtDistance;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final StopAtDistance accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int differenceFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final DistanceCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      StopAtDistance accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      int differenceFromStartOfTime,\n+      ServiceDate serviceDate,\n+      DistanceCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.differenceFromStartOfTime = differenceFromStartOfTime;\n+    this.serviceDate = serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n+\n+  abstract protected StopLocation getFinalStop(SimpleTransfer simpleTransfer);\n+\n+  abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n+\n+  abstract protected Vertex getFlexVertex(Edge edge);\n+\n+  abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n+\n+  abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n+\n+  abstract protected boolean isRouteable(Vertex flexVertex);\n+\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n+      Graph graph, Map<Stop, Integer> indexByStop\n+  ) {\n+    if (transferStop instanceof Stop) {\n+      TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n+      if (isRouteable(flexVertex)) {\n+        return Stream.of(\n+            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n+        );\n+      }\n+      return Stream.empty();\n+    } else {", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71f72ce0442a141c189e89fb9a9f616584db566e", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 9df667f4d..a66dadbca 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -73,33 +72,29 @@ public abstract class FlexAccessEgressTemplate {\n \n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n-  public Stream<FlexAccessEgress> getFlexAccessEgressStream(\n-      Graph graph, Map<Stop, Integer> indexByStop\n-  ) {\n+  public Stream<FlexAccessEgress> getFlexAccessEgressStream(Graph graph) {\n     if (transferStop instanceof Stop) {\n       TransitStopVertex flexVertex = graph.index.getStopVertexForStop().get(transferStop);\n       if (isRouteable(flexVertex)) {\n-        return Stream.of(\n-            getFlexAccessEgress(new ArrayList<>(), flexVertex, indexByStop.get(transferStop))\n-        );\n+        return Stream.of(getFlexAccessEgress(new ArrayList<>(), flexVertex, (Stop) transferStop));\n       }\n       return Stream.empty();\n     } else {\n       return getTransfersFromTransferStop(graph)\n           .stream()\n-          .filter(simpleTransfer -> getFinalStop(simpleTransfer) instanceof Stop)\n+          .filter(simpleTransfer -> getFinalStop(simpleTransfer) != null)\n           .filter(simpleTransfer -> isRouteable(getFlexVertex(getTransferEdges(simpleTransfer).get(0))))\n           .map(simpleTransfer -> {\n             List<Edge> edges = getTransferEdges(simpleTransfer);\n             return getFlexAccessEgress(edges,\n                 getFlexVertex(edges.get(0)),\n-                indexByStop.get(getFinalStop(simpleTransfer))\n+                getFinalStop(simpleTransfer)\n             );\n           });\n     }\n   }\n \n-  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, int stopIndex) {\n+  protected FlexAccessEgress getFlexAccessEgress(List<Edge> transferEdges, Vertex flexVertex, Stop stop) {\n     FlexTripEdge flexEdge = getFlexEdge(flexVertex, transferStop);\n \n     State state = flexEdge.traverse(accessEgress.state);\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NzM3OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492647378", "body": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "bodyText": "Could you use the constant here. The ultimate goal would be to have enums in the internal model.", "bodyHTML": "<p dir=\"auto\">Could you use the constant here. The ultimate goal would be to have enums in the internal model.</p>", "author": "t2gran", "createdAt": "2020-09-22T11:02:21Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex b8d1abee3..a029a7c4e 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -70,7 +70,9 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n       if (stopTimes[toIndex].dropOffType == 1) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n-        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n+            scheduledFlexPathCalculator\n+        ));\n       }\n     }\n \n", "next_change": {"commit": "904839ba268e86576cc228199e187c632ea97b73", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex a029a7c4e..80dc93699 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -68,7 +69,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n \n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n-      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      if (stopTimes[toIndex].dropOffType == PICKDROP_NONE) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n         res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n             scheduledFlexPathCalculator\n", "next_change": {"commit": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\nindex 80dc93699..861b12de8 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java\n", "chunk": "@@ -71,9 +71,7 @@ public class ScheduledDeviatedTrip extends FlexTrip {\n     for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n       if (stopTimes[toIndex].dropOffType == PICKDROP_NONE) continue;\n       for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n-        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate,\n-            scheduledFlexPathCalculator\n-        ));\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, date, scheduledCalculator));\n       }\n     }\n \n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MDk2Mw==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492650963", "body": "These are good candidates for UnitTests", "bodyText": "These are good candidates for UnitTests", "bodyHTML": "<p dir=\"auto\">These are good candidates for UnitTests</p>", "author": "t2gran", "createdAt": "2020-09-22T11:09:37Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -43,6 +55,70 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n     }\n   }\n \n+  @Override\n+  public Stream<FlexAccessTemplate> getFlexAccessTemplates(\n+      StopAtDistance access, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int fromIndex = getFromIndex(access);\n+\n+    if (fromIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexAccessTemplate> res = new ArrayList<>();\n+\n+    for (int toIndex = fromIndex + 1; toIndex < stopTimes.length; toIndex++) {\n+      if (stopTimes[toIndex].dropOffType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[toIndex].stop)) {\n+        res.add(new FlexAccessTemplate(access, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public Stream<FlexEgressTemplate> getFlexEgressTemplates(\n+      StopAtDistance egress, int differenceFromStartOfTime, ServiceDate serviceDate, DistanceCalculator calculator\n+  ) {\n+    DistanceCalculator scheduledDistanceCalculator = new ScheduledDistanceCalculator(calculator, this);\n+\n+    int toIndex = getToIndex(egress);\n+\n+    if (toIndex == -1) return Stream.empty();\n+\n+    ArrayList<FlexEgressTemplate> res = new ArrayList<>();\n+\n+    for (int fromIndex = toIndex - 1; fromIndex >= 0; fromIndex--) {\n+      if (stopTimes[fromIndex].pickupType == 1) continue;\n+      for (StopLocation stop : expandStops(stopTimes[fromIndex].stop)) {\n+        res.add(new FlexEgressTemplate(egress, this, fromIndex, toIndex, stop, differenceFromStartOfTime, serviceDate, scheduledDistanceCalculator));\n+      }\n+    }\n+\n+    return res.stream();\n+  }\n+\n+  @Override\n+  public int earliestDepartureTime(\n+      int departureTime, int fromStopIndex, int toStopIndex, int flexTime\n+  ) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = fromStopIndex; stopTime == MISSING_VALUE && i >= 0; i--) {\n+      stopTime = stopTimes[i].departureTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime >= departureTime ? stopTime : -1;\n+  }\n+\n+  @Override\n+  public int latestArrivalTime(int arrivalTime, int fromStopIndex, int toStopIndex, int flexTime) {\n+    int stopTime = MISSING_VALUE;\n+    for (int i = toStopIndex; stopTime == MISSING_VALUE && i < stopTimes.length; i++) {\n+      stopTime = stopTimes[i].arrivalTime;\n+    }\n+    return stopTime != MISSING_VALUE && stopTime <= arrivalTime ? stopTime : -1;\n+  }\n+", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1MTM4OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492651389", "body": "UnitTests", "bodyText": "UnitTests", "bodyHTML": "<p dir=\"auto\">UnitTests</p>", "author": "t2gran", "createdAt": "2020-09-22T11:10:26Z", "path": "src/ext/java/org/opentripplanner/ext/flex/trip/ScheduledDeviatedTrip.java", "diffHunk": "@@ -51,7 +127,49 @@ public ScheduledDeviatedTrip(Trip trip, List<StopTime> stopTimes) {\n         .collect(Collectors.toSet());\n   }\n \n-  private static class ScheduledDeviatedStopTime {\n+  private Collection<StopLocation> expandStops(StopLocation stop) {\n+    return stop instanceof FlexLocationGroup\n+        ? ((FlexLocationGroup) stop).getLocations()\n+        : Collections.singleton(stop);\n+  }\n+\n+  private int getFromIndex(StopAtDistance accessEgress) {\n+    for (int i = 0; i < stopTimes.length; i++) {\n+      if (stopTimes[i].pickupType == 1) continue; // No pickup allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }\n+\n+  private int getToIndex(StopAtDistance accessEgress) {\n+    for (int i = stopTimes.length - 1; i >= 0; i--) {\n+      if (stopTimes[i].dropOffType == 1) continue; // No drop off allowed here\n+      StopLocation stop = stopTimes[i].stop;\n+      if (stop instanceof FlexLocationGroup) {\n+        if (((FlexLocationGroup) stop).getLocations().contains(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+      else {\n+        if (stop.equals(accessEgress.stop)) {\n+          return i;\n+        }\n+      }\n+    }\n+    return -1;\n+  }", "originalCommit": "41d4f78595351387691e689a96c930c0940ce274", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY1NDM2OA==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r492654368", "body": "Rename `flexContinuousPickup`", "bodyText": "Rename flexContinuousPickup", "bodyHTML": "<p dir=\"auto\">Rename <code>flexContinuousPickup</code></p>", "author": "t2gran", "createdAt": "2020-09-22T11:16:59Z", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;\n \n-    private int continuousPickup;\n+    // Disabled by default\n+    private int continuousPickup = MISSING_VALUE;\n \n-    private int continuousDropOff;\n+    // Disabled by default\n+    private int continuousDropOff = MISSING_VALUE;\n ", "originalCommit": "681acd20acf9c56073616856d09c49f43668be45", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199fa2e32cd31bcd0dbf540aed2bccde274dc913", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex 81cdacce2..dffa96622 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -47,10 +47,10 @@ public final class StopTime implements Comparable<StopTime> {\n     private int maxDepartureTime = MISSING_VALUE;\n \n     // Disabled by default\n-    private int continuousPickup = MISSING_VALUE;\n+    private int flexContinuousPickup = MISSING_VALUE;\n \n     // Disabled by default\n-    private int continuousDropOff = MISSING_VALUE;\n+    private int flexContinuousDropOff = MISSING_VALUE;\n \n     public StopTime() { }\n \n", "next_change": null}]}}, {"oid": "1e268b26b76f66baf7347beed502c68a9353bb53", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/1e268b26b76f66baf7347beed502c68a9353bb53", "message": "Rename StopAtDistance NearbyStop\n\nAlso move mapping code to AccessEgressMapper", "committedDate": "2020-09-24T06:53:15Z", "type": "commit"}, {"oid": "4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4d2fc82e2a9ec2362ae322303dc8431c7d8473dc", "message": "improve DistanceCalculator\n\n- rename from and to indext to stop index\n- rename DistanceAndDuration to FlexPath\n- rename getDuration to calculateFlexPath\n- rename DistanceCalculator FlexPathCalculator\n- fix potential NPE in StreetDistanceCalculator", "committedDate": "2020-09-24T07:00:22Z", "type": "commit"}, {"oid": "42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/42ddad1ba8d70825ee52f9cb7764ff1fc4fdcdb7", "message": "Fix comment in SimpleStreetSplitter", "committedDate": "2020-09-24T07:05:54Z", "type": "commit"}, {"oid": "71f72ce0442a141c189e89fb9a9f616584db566e", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/71f72ce0442a141c189e89fb9a9f616584db566e", "message": "Decouple FlexAccessEgress from Raptor", "committedDate": "2020-09-24T07:43:07Z", "type": "commit"}, {"oid": "b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/b4a5686ebf2b8a28e8f3309d7ba0934894da721c", "message": "Update FlexRouter based on comments", "committedDate": "2020-09-24T08:22:11Z", "type": "commit"}, {"oid": "904839ba268e86576cc228199e187c632ea97b73", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/904839ba268e86576cc228199e187c632ea97b73", "message": "Use constant for pickup/dropoff types", "committedDate": "2020-09-24T08:24:55Z", "type": "commit"}, {"oid": "199fa2e32cd31bcd0dbf540aed2bccde274dc913", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/199fa2e32cd31bcd0dbf540aed2bccde274dc913", "message": "Prefix continuous stop flags with flex", "committedDate": "2020-09-24T08:26:15Z", "type": "commit"}, {"oid": "3476ac74e362cab2b3048643555f0a50d70369ab", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/3476ac74e362cab2b3048643555f0a50d70369ab", "message": "Move FlexTripEdge to separate package", "committedDate": "2020-09-24T08:28:02Z", "type": "commit"}, {"oid": "a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a14e8d2c6d1576842a43d23a4dce3f1acb3163cd", "message": "Rename FlexServicesOnDate to FlexServiceDate and use it deeper", "committedDate": "2020-09-24T08:42:17Z", "type": "commit"}, {"oid": "dad87843e87453b99b29750c65a25b3a3f865d58", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/dad87843e87453b99b29750c65a25b3a3f865d58", "message": "Move private functions down", "committedDate": "2020-09-24T08:43:15Z", "type": "commit"}, {"oid": "a90d7ed6ba1607139510e269292605b9327acfd2", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a90d7ed6ba1607139510e269292605b9327acfd2", "message": "Do not pass in the whole request to FlexRouter", "committedDate": "2020-09-24T09:01:11Z", "type": "commit"}, {"oid": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/2d309285ec07c8e3cfde7affcfbd6470733458d6", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-24T09:02:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE3NjA5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494176096", "body": "Put this in `org.opentripplanner.routing.algorithm.raptor.transit`", "bodyText": "Put this in org.opentripplanner.routing.algorithm.raptor.transit", "bodyHTML": "<p dir=\"auto\">Put this in <code>org.opentripplanner.routing.algorithm.raptor.transit</code></p>", "author": "hannesj", "createdAt": "2020-09-24T09:36:44Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package org.opentripplanner.routing.algorithm.raptor.transit.mappers;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.routing.algorithm.raptor.transit.AccessEgress;\n+import org.opentripplanner.routing.algorithm.raptor.transit.StopIndexForRaptor;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class AccessEgressMapper {\n+\n+  private final StopIndexForRaptor stopIndex;\n+\n+  public AccessEgressMapper(StopIndexForRaptor stopIndex) {\n+    this.stopIndex = stopIndex;\n+  }\n+\n+  public AccessEgress mapNearbyStop(NearbyStop nearbyStop, boolean isEgress) {\n+    if (!(nearbyStop.stop instanceof Stop)) { return null; }\n+    return new AccessEgress(\n+        stopIndex.indexByStop.get(nearbyStop.stop),\n+        (int) nearbyStop.state.getElapsedTimeSeconds(),\n+        isEgress ? nearbyStop.state.reverse() : nearbyStop.state\n+    );\n+  }\n+\n+  public List<AccessEgress> mapNearbyStops(Collection<NearbyStop> accessStops, boolean isEgress) {\n+    return accessStops\n+        .stream()\n+        .map(stopAtDistance -> mapNearbyStop(stopAtDistance, isEgress))\n+        .filter(Objects::nonNull)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public Collection<AccessEgress> mapFlexAccessEgresses(\n+      Collection<FlexAccessEgress> flexAccessEgresses\n+  ) {\n+    return flexAccessEgresses.stream().map(FlexAccessEgressAdapter::new).collect(Collectors.toList());\n+  }\n+\n+  private class FlexAccessEgressAdapter extends AccessEgress {", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java\nindex 253c7a292..5e98aa8db 100644\n--- a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java\n+++ b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/AccessEgressMapper.java\n", "chunk": "@@ -39,40 +40,9 @@ public class AccessEgressMapper {\n   public Collection<AccessEgress> mapFlexAccessEgresses(\n       Collection<FlexAccessEgress> flexAccessEgresses\n   ) {\n-    return flexAccessEgresses.stream().map(FlexAccessEgressAdapter::new).collect(Collectors.toList());\n+    return flexAccessEgresses.stream()\n+        .map(flexAccessEgress -> new FlexAccessEgressAdapter(flexAccessEgress, stopIndex))\n+        .collect(Collectors.toList());\n   }\n \n-  private class FlexAccessEgressAdapter extends AccessEgress {\n-    private final FlexAccessEgress flexAccessEgress;\n-\n-    public FlexAccessEgressAdapter(FlexAccessEgress flexAccessEgress) {\n-      super(\n-          stopIndex.indexByStop.get(flexAccessEgress.stop),\n-          flexAccessEgress.preFlexTime + flexAccessEgress.flexTime + flexAccessEgress.postFlexTime,\n-          flexAccessEgress.lastState\n-      );\n-\n-      this.flexAccessEgress = flexAccessEgress;\n-    }\n-\n-    @Override\n-    public int earliestDepartureTime(int requestedDepartureTime) {\n-      return flexAccessEgress.earliestDepartureTime(requestedDepartureTime);\n-    }\n-\n-    @Override\n-    public int latestArrivalTime(int requestedArrivalTime) {\n-      return flexAccessEgress.latestArrivalTime(requestedArrivalTime);\n-    }\n-\n-    @Override\n-    public int numberOfLegs() {\n-      return flexAccessEgress.directToStop ? 2 : 3;\n-    }\n-\n-    @Override\n-    public boolean stopReachedOnBoard() {\n-      return flexAccessEgress.directToStop;\n-    }\n-  }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4MjU1MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494182551", "body": "Paralellize? Collect vertices and add afterwards", "bodyText": "Paralellize? Collect vertices and add afterwards", "bodyHTML": "<p dir=\"auto\">Paralellize? Collect vertices and add afterwards</p>", "author": "hannesj", "createdAt": "2020-09-24T09:47:08Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java", "diffHunk": "@@ -25,6 +30,9 @@ public void buildGraph(\n \n     StreetVertexIndex streetIndex = new StreetVertexIndex(graph);\n \n+    ProgressTracker progress = ProgressTracker.track(\"Add flex locations to street vertices\", 1, graph.locationsById.size());\n+\n+    LOG.info(progress.startMessage());", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java b/src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java\nindex c7528ca93..677d1c2bb 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexLocationsToStreetEdgesMapper.java\n", "chunk": "@@ -33,6 +33,7 @@ public class FlexLocationsToStreetEdgesMapper implements GraphBuilderModule {\n     ProgressTracker progress = ProgressTracker.track(\"Add flex locations to street vertices\", 1, graph.locationsById.size());\n \n     LOG.info(progress.startMessage());\n+    // TODO: Make this into a parallel stream, first calculate vertices per location and then add them.\n     for (FlexStopLocation flexStopLocation : graph.locationsById.values()) {\n       for (Vertex vertx : streetIndex.getVerticesForEnvelope(flexStopLocation\n           .getGeometry()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE4NzQzMg==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494187432", "body": "Move this up", "bodyText": "Move this up", "bodyHTML": "<p dir=\"auto\">Move this up</p>", "author": "hannesj", "createdAt": "2020-09-24T09:55:11Z", "path": "src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.opentripplanner.ext.flex.edgetype;\n+\n+import org.locationtech.jts.geom.Coordinate;\n+import org.locationtech.jts.geom.LineString;\n+import org.opentripplanner.common.geometry.GeometryUtils;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPath;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.template.FlexAccessEgressTemplate;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.Trip;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.core.StateEditor;\n+import org.opentripplanner.routing.core.TraverseMode;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Locale;\n+\n+public class FlexTripEdge extends Edge {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(FlexTripEdge.class);\n+\n+  private static final long serialVersionUID = 1L;\n+\n+  public StopLocation s1;\n+  public StopLocation s2;\n+  private FlexTrip trip;\n+  public FlexAccessEgressTemplate flexTemplate;\n+  public FlexPath flexPath;\n+\n+  public FlexTripEdge(\n+      Vertex v1, Vertex v2, StopLocation s1, StopLocation s2, FlexTrip trip,\n+      FlexAccessEgressTemplate flexTemplate, FlexPathCalculator calculator\n+  ) {\n+    super(new Vertex(null, null, 0.0, 0.0) {}, new Vertex(null, null, 0.0, 0.0) {});\n+    this.s1 = s1;\n+    this.s2 = s2;\n+    this.trip = trip;\n+    this.flexTemplate = flexTemplate;\n+    this.fromv = v1;\n+    this.tov = v2;\n+    // Why is this code so dirty? Because we don't want this edge to be added to the edge lists.", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java b/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\nindex 25051a224..c45e77f42 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\n", "chunk": "@@ -35,6 +35,8 @@ public class FlexTripEdge extends Edge {\n       Vertex v1, Vertex v2, StopLocation s1, StopLocation s2, FlexTrip trip,\n       FlexAccessEgressTemplate flexTemplate, FlexPathCalculator calculator\n   ) {\n+    // Why is this code so dirty? Because we don't want this edge to be added to the edge lists.\n+    // The first parameter in Vertex constructor is graph. If it is null, the vertex isn't added to it.\n     super(new Vertex(null, null, 0.0, 0.0) {}, new Vertex(null, null, 0.0, 0.0) {});\n     this.s1 = s1;\n     this.s2 = s2;\n", "next_change": null}, {"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java b/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\nindex 25051a224..c45e77f42 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/edgetype/FlexTripEdge.java\n", "chunk": "@@ -42,7 +44,6 @@ public class FlexTripEdge extends Edge {\n     this.flexTemplate = flexTemplate;\n     this.fromv = v1;\n     this.tov = v2;\n-    // Why is this code so dirty? Because we don't want this edge to be added to the edge lists.\n     this.flexPath = calculator.calculateFlexPath(fromv, tov, flexTemplate.fromStopIndex, flexTemplate.toStopIndex);\n   }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDE5ODAzOQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494198039", "body": "Add javadoc for the fields", "bodyText": "Add javadoc for the fields", "bodyHTML": "<p dir=\"auto\">Add javadoc for the fields</p>", "author": "hannesj", "createdAt": "2020-09-24T10:13:06Z", "path": "src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.opentripplanner.ext.flex;\n+\n+import gnu.trove.set.TIntSet;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.graph.Graph;\n+\n+public class FlexServiceDate {\n+  public final ServiceDate serviceDate;", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java b/src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java\nindex ee219207a..e8289c1fe 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/FlexServiceDate.java\n", "chunk": "@@ -5,9 +5,22 @@ import org.opentripplanner.ext.flex.trip.FlexTrip;\n import org.opentripplanner.model.calendar.ServiceDate;\n import org.opentripplanner.routing.graph.Graph;\n \n+/**\n+ * This class contains information used in a flex router, and depends on the date the search was\n+ * made on.\n+ */\n public class FlexServiceDate {\n+\n+  /** The local date */\n   public final ServiceDate serviceDate;\n+\n+  /**\n+   * How many seconds does this date's \"midnight\" (12 hours before noon) differ from the \"midnight\"\n+   * of the date for the search.\n+   * */\n   public final int secondsFromStartOfTime;\n+\n+  /** Which services are running on the date.*/\n   public final TIntSet servicesRunning;\n \n   FlexServiceDate(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIwNjk0MQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494206941", "body": "Add Javadoc to all these methods, why are they different in access/egress", "bodyText": "Add Javadoc to all these methods, why are they different in access/egress", "bodyHTML": "<p dir=\"auto\">Add Javadoc to all these methods, why are they different in access/egress</p>", "author": "hannesj", "createdAt": "2020-09-24T10:28:42Z", "path": "src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.opentripplanner.ext.flex.template;\n+\n+import org.opentripplanner.ext.flex.FlexAccessEgress;\n+import org.opentripplanner.ext.flex.FlexServiceDate;\n+import org.opentripplanner.ext.flex.edgetype.FlexTripEdge;\n+import org.opentripplanner.ext.flex.flexpathcalculator.FlexPathCalculator;\n+import org.opentripplanner.ext.flex.trip.FlexTrip;\n+import org.opentripplanner.model.SimpleTransfer;\n+import org.opentripplanner.model.Stop;\n+import org.opentripplanner.model.StopLocation;\n+import org.opentripplanner.model.calendar.ServiceDate;\n+import org.opentripplanner.routing.core.State;\n+import org.opentripplanner.routing.graph.Edge;\n+import org.opentripplanner.routing.graph.Graph;\n+import org.opentripplanner.routing.graph.Vertex;\n+import org.opentripplanner.routing.graphfinder.NearbyStop;\n+import org.opentripplanner.routing.vertextype.TransitStopVertex;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public abstract class FlexAccessEgressTemplate {\n+  protected final NearbyStop accessEgress;\n+  protected final FlexTrip trip;\n+  public final int fromStopIndex;\n+  public final int toStopIndex;\n+  protected final StopLocation transferStop;\n+  protected final int secondsFromStartOfTime;\n+  public final ServiceDate serviceDate;\n+  protected final FlexPathCalculator calculator;\n+\n+  FlexAccessEgressTemplate(\n+      NearbyStop accessEgress,\n+      FlexTrip trip,\n+      int fromStopIndex,\n+      int toStopIndex,\n+      StopLocation transferStop,\n+      FlexServiceDate date,\n+      FlexPathCalculator calculator\n+  ) {\n+    this.accessEgress = accessEgress;\n+    this.trip = trip;\n+    this.fromStopIndex = fromStopIndex;\n+    this.toStopIndex = toStopIndex;\n+    this.transferStop = transferStop;\n+    this.secondsFromStartOfTime = date.secondsFromStartOfTime;\n+    this.serviceDate = date.serviceDate;\n+    this.calculator = calculator;\n+  }\n+\n+  public StopLocation getTransferStop() {\n+    return transferStop;\n+  }\n+\n+  public FlexTrip getFlexTrip() {\n+    return trip;\n+  }\n+\n+  abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4fe831096cf1f973a18ef69ed88f442a893c74fc", "changed_code": [{"header": "diff --git a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\nindex 30b5e1e8a..61e295d41 100644\n--- a/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n+++ b/src/ext/java/org/opentripplanner/ext/flex/template/FlexAccessEgressTemplate.java\n", "chunk": "@@ -58,18 +58,41 @@ public abstract class FlexAccessEgressTemplate {\n     return trip;\n   }\n \n+  /**\n+   * Get a list of edges used for transferring to and from the scheduled transit network. The edges\n+   * should be in the order of traversal of the state in the NearbyStop\n+   * */\n   abstract protected List<Edge> getTransferEdges(SimpleTransfer simpleTransfer);\n \n+  /**\n+   * Get the {@Link Stop} where the connection to the scheduled transit network is made.\n+   */\n   abstract protected Stop getFinalStop(SimpleTransfer simpleTransfer);\n \n+  /**\n+   * Get the transfers to/from stops in the scheduled transit network from the beginning/end of the\n+   * flex ride for the access/egress.\n+   */\n   abstract protected Collection<SimpleTransfer> getTransfersFromTransferStop(Graph graph);\n \n+  /**\n+   * Get the {@Link Vertex} where the flex ride ends/begins for the access/egress.\n+   */\n   abstract protected Vertex getFlexVertex(Edge edge);\n \n+  /**\n+   * Get the times in seconds, before during and after the flex ride.\n+   */\n   abstract protected int[] getFlexTimes(FlexTripEdge flexEdge, State state);\n \n+  /**\n+   * Get the FlexTripEdge for the flex ride.\n+   */\n   abstract protected FlexTripEdge getFlexEdge(Vertex flexFromVertex, StopLocation transferStop);\n \n+  /**\n+   * Checks whether the routing is possible\n+   */\n   abstract protected boolean isRouteable(Vertex flexVertex);\n \n   public Stream<FlexAccessEgress> createFlexAccessEgressStream(Graph graph) {\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIxNTE2Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/3187#discussion_r494215166", "body": "Change these to flexWindowStart and flexWindowEnd\r\n\r\n", "bodyText": "Change these to flexWindowStart and flexWindowEnd", "bodyHTML": "<p dir=\"auto\">Change these to flexWindowStart and flexWindowEnd</p>", "author": "hannesj", "createdAt": "2020-09-24T10:44:22Z", "path": "src/main/java/org/opentripplanner/model/StopTime.java", "diffHunk": "@@ -46,9 +46,11 @@\n \n     private int maxDepartureTime = MISSING_VALUE;", "originalCommit": "2d309285ec07c8e3cfde7affcfbd6470733458d6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "changed_code": [{"header": "diff --git a/src/main/java/org/opentripplanner/model/StopTime.java b/src/main/java/org/opentripplanner/model/StopTime.java\nindex dffa96622..535267822 100644\n--- a/src/main/java/org/opentripplanner/model/StopTime.java\n+++ b/src/main/java/org/opentripplanner/model/StopTime.java\n", "chunk": "@@ -42,9 +42,9 @@ public final class StopTime implements Comparable<StopTime> {\n     /** This is a Conveyal extension to the GTFS spec to support Seattle on/off peak fares. */\n     private String farePeriodId;\n \n-    private int minArrivalTime = MISSING_VALUE;\n+    private int flexWindowStart = MISSING_VALUE;\n \n-    private int maxDepartureTime = MISSING_VALUE;\n+    private int flexWindowEnd = MISSING_VALUE;\n \n     // Disabled by default\n     private int flexContinuousPickup = MISSING_VALUE;\n", "next_change": null}]}}, {"oid": "69b08774efc0cdb575e7cc72163ef1a56fe00167", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/69b08774efc0cdb575e7cc72163ef1a56fe00167", "message": "Adapt changes from discussion", "committedDate": "2020-09-25T08:10:38Z", "type": "commit"}, {"oid": "558e06d0941eb87cc56301cd5b8bb093690638ae", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/558e06d0941eb87cc56301cd5b8bb093690638ae", "message": "Add initial docs", "committedDate": "2020-09-25T08:42:34Z", "type": "commit"}, {"oid": "4fe831096cf1f973a18ef69ed88f442a893c74fc", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/4fe831096cf1f973a18ef69ed88f442a893c74fc", "message": "Add javadoc", "committedDate": "2020-09-25T08:50:53Z", "type": "commit"}, {"oid": "76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/76163e1ed4c3ded3d32027798a8e7bdbd45d6b0a", "message": "Add Entur as additional contact", "committedDate": "2020-09-25T09:05:03Z", "type": "commit"}, {"oid": "aad1781643f2cec742877ae1f84f9852018680e7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/aad1781643f2cec742877ae1f84f9852018680e7", "message": "Fix legal name", "committedDate": "2020-09-25T09:12:36Z", "type": "commit"}, {"oid": "e9b59cc461641341397d35b60e4f061eb9382452", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e9b59cc461641341397d35b60e4f061eb9382452", "message": "Merge remote-tracking branch 'origin/dev-2.x' into flex-upstream-routing", "committedDate": "2020-09-25T09:12:52Z", "type": "commit"}]}