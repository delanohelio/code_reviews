{"pr_number": 346, "pr_title": "Config store IPC APIs - updates read, subscribe and adds write, validate", "pr_author": "shaguptashaikh", "pr_createdAt": "2020-08-03T07:18:24Z", "pr_url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346", "timeline": [{"oid": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "message": "Remove runtime config handling", "committedDate": "2020-08-04T23:10:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NzcwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465867704", "body": "update this comment, what is this a map of now?", "bodyText": "update this comment, what is this a map of now?", "bodyHTML": "<p dir=\"auto\">update this comment, what is this a map of now?</p>", "author": "MikeDombo", "createdAt": "2020-08-05T16:53:31Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -48,12 +53,19 @@ import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETE\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n+    // Map from component --> config update event subscribers\n     private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n             new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners = new ConcurrentHashMap<>();\n+    // Map from connection --> Function to call for triggering config change events\n+    private static final Map<ConnectionContext, BiConsumer<String, String>> configUpdateListeners =\n+            new ConcurrentHashMap<>();\n+    // Map from connection --> Function to call for triggering config validation events\n     private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReports =\n+            new ConcurrentHashMap<>();\n     private static final int TIMEOUT_SECONDS = 30;\n     private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n     private final ChildChanged onConfigChange = (whatHappened, node) -> {\n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -64,7 +64,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n             new ConcurrentHashMap<>();\n     // Map of component --> future to complete with validation status received from service in response to validate\n     // event\n-    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReports =\n+    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n     private static final int TIMEOUT_SECONDS = 30;\n     private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -52,62 +52,25 @@ import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETE\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from component --> config update event subscribers\n-    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n-            new ConcurrentHashMap<>();\n-    // Map from connection --> Function to call for triggering config change events\n-    private static final Map<ConnectionContext, BiConsumer<String, String>> configUpdateListeners =\n-            new ConcurrentHashMap<>();\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n     // Map from connection --> Function to call for triggering config validation events\n-    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n     // Map of component --> future to complete with validation status received from service in response to validate\n     // event\n-    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n-        if (nodePath.size() < 5) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration\n-        int configIndex = nodePath.size() - 4;\n-        if (!nodePath.get(configIndex).equals(PARAMETERS_CONFIG_KEY)) {\n-            return;\n-        }\n-        subscribers.stream().map(ctx -> configUpdateListeners.get(ctx))\n-                .forEach(c -> c.accept(serviceName, nodePath.get(configIndex - 1)));\n \n-    };\n     @Inject\n     private Kernel kernel;\n-    @Inject\n-    private ExecutorService executor;\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    @Inject\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -33,48 +27,86 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n-import lombok.AllArgsConstructor;\n-import lombok.Builder;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-\n-import java.util.Arrays;\n+\n+import java.io.IOException;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-@NoArgsConstructor\n-@AllArgsConstructor(access = AccessLevel.PACKAGE)\n-public class ConfigStoreIPCAgent {\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n-    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n-\n-    // Map from connection --> Function to call for triggering config validation events\n-    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n             new ConcurrentHashMap<>();\n-    // Map of component --> future to complete with validation status received from service in response to validate\n-    // event\n-    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ServiceEventHelper serviceEventHelper;\n+    private ExecutorService executor;\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        String[] nodePath = node.path();\n+        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n+        if (nodePath.length < 4) {\n+            return;\n+        }\n+\n+        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n+        // Do nothing if no one has subscribed\n+        if (subscribers == null || subscribers.isEmpty()) {\n+            return;\n+        }\n+\n+        // Ensure that the node which changed was part of component configuration/ runtime configuration\n+        int configIndex = 2;\n+        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n+            return;\n+        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n+            // Do not send update event for runtime config changes to the owner service\n+            // A service updates its own runtime config so it does not need to be updated for it\n+            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n+                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n+        } else {\n+            return;\n+        }\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n \n     /**\n-     * Handle the subscription request from the user.\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -27,83 +32,45 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-\n-import java.io.IOException;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.Arrays;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n-import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n-            new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n-\n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration/ runtime configuration\n-        int configIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n-            return;\n-        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n-            // Do not send update event for runtime config changes to the owner service\n-            // A service updates its own runtime config so it does not need to be updated for it\n-            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n-                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n-        } else {\n-            return;\n-        }\n-    };\n-\n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2OTY5NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465869695", "body": "I don't think you need the `contains` check, I'm pretty sure you can just do `remove`", "bodyText": "I don't think you need the contains check, I'm pretty sure you can just do remove", "bodyHTML": "<p dir=\"auto\">I don't think you need the <code>contains</code> check, I'm pretty sure you can just do <code>remove</code></p>", "author": "MikeDombo", "createdAt": "2020-08-05T16:56:40Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n         });\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -112,24 +124,19 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         configUpdateListeners.computeIfAbsent(context, (key) -> {\n             context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n+            return sendStoreUpdateToListener(context);\n         });\n \n         configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n         configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        context.onDisconnect(\n+                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n+    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n+        return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n", "next_change": {"commit": "dac25eeeea15629ed8f335290415076ea691bc22", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..dafa95dcbb 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -139,7 +139,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             try {\n                 ApplicationMessage applicationMessage =\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dafa95dcbb..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -122,52 +85,102 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        // Sends an event immediately after\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(\n-                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n-        return (componentName, changedKey) -> {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -180,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -84,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDk2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r465870967", "body": "[nit]\r\n\r\ncombine this string", "bodyText": "[nit]\ncombine this string", "bodyHTML": "<p dir=\"auto\">[nit]</p>\n<p dir=\"auto\">combine this string</p>", "author": "MikeDombo", "createdAt": "2020-08-05T16:58:37Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -219,7 +226,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         if (!context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -221,22 +244,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -262,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "647576c1f224d6603cec83e06225b81e8738162e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -224,66 +224,26 @@ public class ConfigStoreIPCAgent {\n     }\n \n     /**\n-     * Update specified key in the service's configuration.\n+     * Update specified key in the service's runtime config.\n      *\n      * @param request update config request\n      * @param context client context\n      * @return response data\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n-        log.atDebug().kv(CONTEXT_LOGGING_KEY, context).log(\"Config IPC config update request\");\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n-\n-        if (Utils.isEmpty(request.getKeyPath())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cross component updates are not allowed\").build();\n-        }\n-\n-        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n-                    .errorMessage(\"Service config not found\").build();\n-        }\n-        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = request.getKeyPath().toArray(new String[0]);\n-        Node node = configTopics.findNode(keyPath);\n-        if (node == null) {\n-            configTopics.lookup(keyPath).withValue(request.getNewValue());\n-            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n-        }\n-        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n-        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n-        //  nested config support at the component recipe and deployment level is hashed out.\n-        if (node instanceof Topics) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cannot update a \" + \"non-leaf config node\").build();\n-        }\n-        if (!(node instanceof Topic)) {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n-            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n-        }\n-        Topic topic = (Topic) node;\n-\n-        // Perform compare and swap if the customer has specified current value to compare\n-        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n-                    .build();\n-        }\n-\n-        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n-        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n-                .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n-        }\n+        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n         return response.build();\n     }\n \n", "next_change": {"commit": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..e1645a1057 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -232,14 +212,21 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n                 .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e1645a1057..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -227,7 +235,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         }\n \n         serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getValue());\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -220,22 +243,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -261,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "2fcea893248454e36733ab3403d7b3f9c9f63657", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2OTgxOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466769819", "body": "Are we not taking key (to subscribe to) as an input in the request as desribed in API design doc?", "bodyText": "Are we not taking key (to subscribe to) as an input in the request as desribed in API design doc?", "bodyHTML": "<p dir=\"auto\">Are we not taking key (to subscribe to) as an input in the request as desribed in API design doc?</p>", "author": "abanthiy", "createdAt": "2020-08-07T01:24:35Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwMzk1MA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466803950", "bodyText": "I'm waiting for Fahad to respond to a question about two conflicting suggestions in the doc https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design#GcZ9CAnF4nL If there is one subscription for all config then we do not need keyname, however I want to know his thought process", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc2OTgxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -112,24 +124,19 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         configUpdateListeners.computeIfAbsent(context, (key) -> {\n             context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n+            return sendStoreUpdateToListener(context);\n         });\n \n         configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n         configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        context.onDisconnect(\n+                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n+    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n+        return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n", "next_change": {"commit": "dac25eeeea15629ed8f335290415076ea691bc22", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..dafa95dcbb 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -139,7 +139,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             try {\n                 ApplicationMessage applicationMessage =\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dafa95dcbb..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -122,52 +85,102 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        // Sends an event immediately after\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(\n-                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n-        return (componentName, changedKey) -> {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -180,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -84,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3MTI5OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466771299", "body": "To me the name does not seem to fit. Don;t have great suggestions but maybe actionsByContext or methodToInvokeByContext", "bodyText": "To me the name does not seem to fit. Don;t have great suggestions but maybe actionsByContext or methodToInvokeByContext", "bodyHTML": "<p dir=\"auto\">To me the name does not seem to fit. Don;t have great suggestions but maybe actionsByContext or methodToInvokeByContext</p>", "author": "abanthiy", "createdAt": "2020-08-07T01:30:14Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -40,17 +49,13 @@\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n     // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners = new ConcurrentHashMap<>();", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -48,12 +53,19 @@ import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETE\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n+    // Map from component --> config update event subscribers\n     private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n             new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners = new ConcurrentHashMap<>();\n+    // Map from connection --> Function to call for triggering config change events\n+    private static final Map<ConnectionContext, BiConsumer<String, String>> configUpdateListeners =\n+            new ConcurrentHashMap<>();\n+    // Map from connection --> Function to call for triggering config validation events\n     private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReports =\n+            new ConcurrentHashMap<>();\n     private static final int TIMEOUT_SECONDS = 30;\n     private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n     private final ChildChanged onConfigChange = (whatHappened, node) -> {\n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -64,7 +64,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n             new ConcurrentHashMap<>();\n     // Map of component --> future to complete with validation status received from service in response to validate\n     // event\n-    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReports =\n+    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n     private static final int TIMEOUT_SECONDS = 30;\n     private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -52,62 +52,25 @@ import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETE\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from component --> config update event subscribers\n-    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n-            new ConcurrentHashMap<>();\n-    // Map from connection --> Function to call for triggering config change events\n-    private static final Map<ConnectionContext, BiConsumer<String, String>> configUpdateListeners =\n-            new ConcurrentHashMap<>();\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n     // Map from connection --> Function to call for triggering config validation events\n-    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n     // Map of component --> future to complete with validation status received from service in response to validate\n     // event\n-    private static final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n-        if (nodePath.size() < 5) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration\n-        int configIndex = nodePath.size() - 4;\n-        if (!nodePath.get(configIndex).equals(PARAMETERS_CONFIG_KEY)) {\n-            return;\n-        }\n-        subscribers.stream().map(ctx -> configUpdateListeners.get(ctx))\n-                .forEach(c -> c.accept(serviceName, nodePath.get(configIndex - 1)));\n \n-    };\n     @Inject\n     private Kernel kernel;\n-    @Inject\n-    private ExecutorService executor;\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    @Inject\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -33,48 +27,86 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n-import lombok.AllArgsConstructor;\n-import lombok.Builder;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-\n-import java.util.Arrays;\n+\n+import java.io.IOException;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-@NoArgsConstructor\n-@AllArgsConstructor(access = AccessLevel.PACKAGE)\n-public class ConfigStoreIPCAgent {\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n-    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n-\n-    // Map from connection --> Function to call for triggering config validation events\n-    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n             new ConcurrentHashMap<>();\n-    // Map of component --> future to complete with validation status received from service in response to validate\n-    // event\n-    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ServiceEventHelper serviceEventHelper;\n+    private ExecutorService executor;\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        String[] nodePath = node.path();\n+        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n+        if (nodePath.length < 4) {\n+            return;\n+        }\n+\n+        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n+        // Do nothing if no one has subscribed\n+        if (subscribers == null || subscribers.isEmpty()) {\n+            return;\n+        }\n+\n+        // Ensure that the node which changed was part of component configuration/ runtime configuration\n+        int configIndex = 2;\n+        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n+            return;\n+        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n+            // Do not send update event for runtime config changes to the owner service\n+            // A service updates its own runtime config so it does not need to be updated for it\n+            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n+                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n+        } else {\n+            return;\n+        }\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n \n     /**\n-     * Handle the subscription request from the user.\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -27,83 +32,45 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-\n-import java.io.IOException;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.Arrays;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n-import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n-            new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n-\n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration/ runtime configuration\n-        int configIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n-            return;\n-        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n-            // Do not send update event for runtime config changes to the owner service\n-            // A service updates its own runtime config so it does not need to be updated for it\n-            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n-                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n-        } else {\n-            return;\n-        }\n-    };\n-\n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466777204", "body": "Currently context represents one client and you can receive more than one subscriptions from one client. I think in that case this will not work. We probably need configUpdateListeners to be Map<Context, BiConsumer<String, String>>\r\nBiConsumer to consume keychanged and serviceName, and send that serviceName to the client. Let me know what you think.\r\n\r\nAlso, it is not implemented yet but I think the meaning of context will change when we use the new IPC, since that will have streamIds. A context object will represent a particular stream for a particular client. So when that happens this code will work. We can see if we can write something that works for both and we do not have to change much with new IPC.\r\n\r\n", "bodyText": "Currently context represents one client and you can receive more than one subscriptions from one client. I think in that case this will not work. We probably need configUpdateListeners to be Map<Context, BiConsumer<String, String>>\nBiConsumer to consume keychanged and serviceName, and send that serviceName to the client. Let me know what you think.\nAlso, it is not implemented yet but I think the meaning of context will change when we use the new IPC, since that will have streamIds. A context object will represent a particular stream for a particular client. So when that happens this code will work. We can see if we can write something that works for both and we do not have to change much with new IPC.", "bodyHTML": "<p dir=\"auto\">Currently context represents one client and you can receive more than one subscriptions from one client. I think in that case this will not work. We probably need configUpdateListeners to be Map&lt;Context, BiConsumer&lt;String, String&gt;&gt;<br>\nBiConsumer to consume keychanged and serviceName, and send that serviceName to the client. Let me know what you think.</p>\n<p dir=\"auto\">Also, it is not implemented yet but I think the meaning of context will change when we use the new IPC, since that will have streamIds. A context object will represent a particular stream for a particular client. So when that happens this code will work. We can see if we can write something that works for both and we do not have to change much with new IPC.</p>", "author": "abanthiy", "createdAt": "2020-08-07T01:53:25Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -84,22 +100,38 @@ public void postInject() {\n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n+     * @param request request for component update subscription\n      * @param context connection context\n      * @return response code Success if all went well\n      */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNDYxOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466804618", "bodyText": "This is based on the idea that there are no per key subscription one subscription for all config of a component, so component A can register 1 subscription for component B's config, one for component C's config etc, and this will work for that", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIxOTAyOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r468219028", "bodyText": "If I understand correctly - When componentA subscribes for componentB, the configUpdateListeners map will have entry for contextForComponentA with service name as componentB. When A subscribes for componentC, that time you won't update the entry in configUpdateListeners map and when you want to send the event to componentA corresponding to change in componentC's config, you would send the service name as componentB.", "author": "abanthiy", "createdAt": "2020-08-10T22:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3NzIwNA=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -112,24 +124,19 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         configUpdateListeners.computeIfAbsent(context, (key) -> {\n             context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n+            return sendStoreUpdateToListener(context);\n         });\n \n         configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n         configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        context.onDisconnect(\n+                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n+    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n+        return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n", "next_change": {"commit": "dac25eeeea15629ed8f335290415076ea691bc22", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..dafa95dcbb 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -139,7 +139,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         return (componentName, changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             try {\n                 ApplicationMessage applicationMessage =\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dafa95dcbb..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -122,52 +85,102 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        // Sends an event immediately after\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(\n-                () -> configUpdateSubscribersByService.entrySet().forEach(e -> e.getValue().remove(context)));\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private BiConsumer<String, String> sendStoreUpdateToListener(ConnectionContext context) {\n-        return (componentName, changedKey) -> {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -180,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -84,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Key not found\");\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3OTY2Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466779667", "body": "Is the key still called parameters? Or is it now called configuration?\r\nAlso, just making sure, event for the same service we allow only this part of config to be read?", "bodyText": "Is the key still called parameters? Or is it now called configuration?\nAlso, just making sure, event for the same service we allow only this part of config to be read?", "bodyHTML": "<p dir=\"auto\">Is the key still called parameters? Or is it now called configuration?<br>\nAlso, just making sure, event for the same service we allow only this part of config to be read?</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:03:04Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n-        if (configTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.NoDynamicConfig)\n-                    .errorMessage(\"Service has no dynamic config\").build();\n+        Topics componentConfigurationTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNDk3NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466804975", "bodyText": "It's still called parameters, we haven't done renaming of package->component or parameter->configuration terminology yet. Yes there is no need for a service to read any other config even if it's self", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc3OTY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -181,15 +188,15 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                     .build();\n         }\n \n-        Topics componentConfigurationTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n-        if (componentConfigurationTopics == null) {\n+        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+        if (configTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.NoConfig)\n-                    .errorMessage(\"Component has no dynamic configuration\").build();\n+                    .errorMessage(\"Service has no dynamic config\").build();\n         }\n \n-        Node node = componentConfigurationTopics.getChild(request.getKey());\n+        Node node = configTopics.getChild(request.getKey());\n         if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.NotFound).errorMessage(\"Key not found\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError).errorMessage(\"Key not found\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -196,7 +196,8 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         Node node = configTopics.getChild(request.getKey());\n         if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError).errorMessage(\"Key not found\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                    .errorMessage(\"Key not found\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -181,32 +194,41 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n     public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n         String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n-        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        Topics serviceTopics = kernel.findServiceTopic(serviceName);\n         GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+\n+        if (serviceTopics == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                    .errorMessage(\"Service not found\").build();\n         }\n \n-        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n         if (configTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.NoConfig)\n                     .errorMessage(\"Service has no dynamic config\").build();\n         }\n \n-        Node node = configTopics.getChild(request.getKey());\n-        if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n-                    .errorMessage(\"Key not found\").build();\n+        Node node;\n+        if (request.getKey() == null) {\n+            // Request is for reading all configuration\n+            node = configTopics;\n+        } else {\n+            String[] keyPath = parseKeyPath(request.getKey());\n+            node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                        .errorMessage(\"Key not found\").build();\n+            }\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n+        response.componentName(serviceName);\n         if (node instanceof Topic) {\n             response.value(((Topic) node).getOnce());\n         } else if (node instanceof Topics) {\n             response.value(((Topics) node).toPOJO());\n         } else {\n-            response.responseStatus(ConfigStoreResponseStatus.ServiceError).errorMessage(\"Node has an unknown type\");\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n             log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n         }\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -236,7 +224,7 @@ public class ConfigStoreIPCAgent {\n     }\n \n     /**\n-     * Update specified key in the service's configuration.\n+     * Update specified key in the service's runtime config.\n      *\n      * @param request update config request\n      * @param context client context\n", "next_change": {"commit": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..e1645a1057 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -232,14 +212,21 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n                 .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e1645a1057..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -227,7 +235,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         }\n \n         serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getValue());\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -220,22 +243,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -261,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "2fcea893248454e36733ab3403d7b3f9c9f63657", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780585", "body": "So when the device SDK team provides us the server code, I imagine we will get some POJOS for requests, responses and errors. Let see how we can reduce the changes we need to do when we want to move to using those POJOS. So putting all send error responses into a helper method would help. In that helper we can pass the error type and send the response accordingly and when we move to using SDK POJOS we just need to change that helper method. You can refer to ConfigStore APIs error messages at https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259", "bodyText": "So when the device SDK team provides us the server code, I imagine we will get some POJOS for requests, responses and errors. Let see how we can reduce the changes we need to do when we want to move to using those POJOS. So putting all send error responses into a helper method would help. In that helper we can pass the error type and send the response accordingly and when we move to using SDK POJOS we just need to change that helper method. You can refer to ConfigStore APIs error messages at https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259", "bodyHTML": "<p dir=\"auto\">So when the device SDK team provides us the server code, I imagine we will get some POJOS for requests, responses and errors. Let see how we can reduce the changes we need to do when we want to move to using those POJOS. So putting all send error responses into a helper method would help. In that helper we can pass the error type and send the response accordingly and when we move to using SDK POJOS we just need to change that helper method. You can refer to ConfigStore APIs error messages at <a href=\"https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259\" rel=\"nofollow\">https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L259</a></p>", "author": "abanthiy", "createdAt": "2020-08-07T02:06:44Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -134,27 +166,28 @@ public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n \n     /**\n      * Read specified key from the service's dynamic config.\n-     * @param readRequest read request\n+     *\n+     * @param request request\n      * @param context client context\n      * @return response data\n      */\n-    public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest, ConnectionContext context) {\n-        log.atDebug().kv(\"context\", context).log(\"Config IPC read request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ConfigStoreReadValueResponse.ConfigStoreReadValueResponseBuilder response =\n-                ConfigStoreReadValueResponse.builder();\n+    public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n+        String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n+        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDg1OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466780858", "bodyText": "Also, if we need other error messages then we can add to the Smithy model as well.", "author": "abanthiy", "createdAt": "2020-08-07T02:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNTU1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466805553", "bodyText": "I'm okay with making a refactor into the current IPC server side code to align with the smithy model but I will prefer to do that as part of a separate PR which will allow doing it for all existing IPC APIs i.e. lifecycle, pubsub and config store. I want to get this particular PR out sooner since stream manager folks are waiting for read write and subscribe APIs which was the original scope for this for last sprint", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MDU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -181,15 +188,15 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                     .build();\n         }\n \n-        Topics componentConfigurationTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n-        if (componentConfigurationTopics == null) {\n+        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+        if (configTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.NoConfig)\n-                    .errorMessage(\"Component has no dynamic configuration\").build();\n+                    .errorMessage(\"Service has no dynamic config\").build();\n         }\n \n-        Node node = componentConfigurationTopics.getChild(request.getKey());\n+        Node node = configTopics.getChild(request.getKey());\n         if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.NotFound).errorMessage(\"Key not found\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError).errorMessage(\"Key not found\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -196,7 +196,8 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         Node node = configTopics.getChild(request.getKey());\n         if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError).errorMessage(\"Key not found\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                    .errorMessage(\"Key not found\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -181,32 +194,41 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n     public GetConfigurationResponse getConfig(GetConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC get config request\");\n         String serviceName = request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n-        Topics serviceTopic = kernel.findServiceTopic(serviceName);\n+        Topics serviceTopics = kernel.findServiceTopic(serviceName);\n         GetConfigurationResponse.GetConfigurationResponseBuilder response = GetConfigurationResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+\n+        if (serviceTopics == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                    .errorMessage(\"Service not found\").build();\n         }\n \n-        Topics configTopics = serviceTopic.findInteriorChild(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.findInteriorChild(PARAMETERS_CONFIG_KEY);\n         if (configTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.NoConfig)\n                     .errorMessage(\"Service has no dynamic config\").build();\n         }\n \n-        Node node = configTopics.getChild(request.getKey());\n-        if (node == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n-                    .errorMessage(\"Key not found\").build();\n+        Node node;\n+        if (request.getKey() == null) {\n+            // Request is for reading all configuration\n+            node = configTopics;\n+        } else {\n+            String[] keyPath = parseKeyPath(request.getKey());\n+            node = configTopics.findNode(keyPath);\n+            if (node == null) {\n+                return response.responseStatus(ConfigStoreResponseStatus.ResourceNotFoundError)\n+                        .errorMessage(\"Key not found\").build();\n+            }\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n+        response.componentName(serviceName);\n         if (node instanceof Topic) {\n             response.value(((Topic) node).getOnce());\n         } else if (node instanceof Topics) {\n             response.value(((Topics) node).toPOJO());\n         } else {\n-            response.responseStatus(ConfigStoreResponseStatus.ServiceError).errorMessage(\"Node has an unknown type\");\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n             log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n         }\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -236,7 +224,7 @@ public class ConfigStoreIPCAgent {\n     }\n \n     /**\n-     * Update specified key in the service's configuration.\n+     * Update specified key in the service's runtime config.\n      *\n      * @param request update config request\n      * @param context client context\n", "next_change": {"commit": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..e1645a1057 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -232,14 +212,21 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n                 .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e1645a1057..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -227,7 +235,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         }\n \n         serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getValue());\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -220,22 +243,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -261,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "2fcea893248454e36733ab3403d7b3f9c9f63657", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MjcxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466782716", "body": "If we do not allow this then we should remove componentName from the request. We can add when we start supporting it. Let me know what is the decision, the API doc says we are. We need to update both Smithy model and doc to reflect the decision.", "bodyText": "If we do not allow this then we should remove componentName from the request. We can add when we start supporting it. Let me know what is the decision, the API doc says we are. We need to update both Smithy model and doc to reflect the decision.", "bodyHTML": "<p dir=\"auto\">If we do not allow this then we should remove componentName from the request. We can add when we start supporting it. Let me know what is the decision, the API doc says we are. We need to update both Smithy model and doc to reflect the decision.</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:14:44Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNTczNQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466805735", "bodyText": "Why is the smithy model different from the definitions in the API design doc?", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4MjcxNg=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -219,7 +226,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n \n         if (!context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -221,22 +244,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -262,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "647576c1f224d6603cec83e06225b81e8738162e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -224,66 +224,26 @@ public class ConfigStoreIPCAgent {\n     }\n \n     /**\n-     * Update specified key in the service's configuration.\n+     * Update specified key in the service's runtime config.\n      *\n      * @param request update config request\n      * @param context client context\n      * @return response data\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n-        log.atDebug().kv(CONTEXT_LOGGING_KEY, context).log(\"Config IPC config update request\");\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n-\n-        if (Utils.isEmpty(request.getKeyPath())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cross component updates are not allowed\").build();\n-        }\n-\n-        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n-                    .errorMessage(\"Service config not found\").build();\n-        }\n-        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = request.getKeyPath().toArray(new String[0]);\n-        Node node = configTopics.findNode(keyPath);\n-        if (node == null) {\n-            configTopics.lookup(keyPath).withValue(request.getNewValue());\n-            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n-        }\n-        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n-        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n-        //  nested config support at the component recipe and deployment level is hashed out.\n-        if (node instanceof Topics) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cannot update a \" + \"non-leaf config node\").build();\n-        }\n-        if (!(node instanceof Topic)) {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n-            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n-        }\n-        Topic topic = (Topic) node;\n-\n-        // Perform compare and swap if the customer has specified current value to compare\n-        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n-                    .build();\n-        }\n-\n-        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n-        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n-                .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n-        }\n+        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n         return response.build();\n     }\n \n", "next_change": {"commit": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..e1645a1057 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -232,14 +212,21 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n                 .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e1645a1057..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -227,7 +235,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         }\n \n         serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getValue());\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -220,22 +243,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -261,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "2fcea893248454e36733ab3403d7b3f9c9f63657", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4NzY5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466787698", "body": "I am thinking about how we can minimize the changes we need to do with new IPC. So putting this creation of application message and sending can be put in helper method (which takes the opcode and others as parameters). This helper can be used by the `sendStoreUpdateToListener` method as well.\r\nThis is just something I want to put out there so as you code you can keep it in mind and wherever possible we can attempt to do it.", "bodyText": "I am thinking about how we can minimize the changes we need to do with new IPC. So putting this creation of application message and sending can be put in helper method (which takes the opcode and others as parameters). This helper can be used by the sendStoreUpdateToListener method as well.\nThis is just something I want to put out there so as you code you can keep it in mind and wherever possible we can attempt to do it.", "bodyHTML": "<p dir=\"auto\">I am thinking about how we can minimize the changes we need to do with new IPC. So putting this creation of application message and sending can be put in helper method (which takes the opcode and others as parameters). This helper can be used by the <code>sendStoreUpdateToListener</code> method as well.<br>\nThis is just something I want to put out there so as you code you can keep it in mind and wherever possible we can attempt to do it.</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:34:43Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNjA0MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466806041", "bodyText": "I will try to see if I can refactor with minimal changes for this PR otherwise create a task to do initial refactoring for the long term IPC changes like I said in my other comment", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4NzY5OA=="}], "type": "inlineReview", "revised_code": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -260,33 +294,8 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                     ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n             log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n \n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n-                                .payload(IPCUtil.encode(validationEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n-                                .log(\"Error sending config validation event to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n-                        .log(\"Error sending config validation event to client\", e);\n-            }\n+            serviceEventHelper.sendServiceEvent(context, validationEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -295,7 +299,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n \n             serviceEventHelper.sendServiceEvent(context, validationEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal());\n+                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -298,8 +271,33 @@ public class ConfigStoreIPCAgent {\n                     ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n             log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n \n-            serviceEventHelper.sendServiceEvent(context, validationEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal(), ConfigStoreImpl.API_VERSION);\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -271,33 +293,8 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                     ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n             log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n \n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n-                                .payload(IPCUtil.encode(validationEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n-                                .log(\"Error sending config validation event to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n-                        .log(\"Error sending config validation event to client\", e);\n-            }\n+            serviceEventHelper.sendServiceEvent(context, validationEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -294,7 +299,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n \n             serviceEventHelper.sendServiceEvent(context, validationEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal());\n+                    ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc4OTYxNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466789616", "body": "Add handle in the method name?", "bodyText": "Add handle in the method name?", "bodyHTML": "<p dir=\"auto\">Add handle in the method name?</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:42:37Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -297,21 +304,27 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      * @param context client context\n      * @return response data\n      */\n-    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n-                                                                    ConnectionContext context) {\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n-                ReportConfigurationValidityResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReports.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n-        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n-        //  message\n+        CompletableFuture<ConfigurationValidityReport> report = configValidationReports.get(context.getServiceName());\n+        if (!report.isCancelled()) {\n+            report.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReports.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -313,18 +314,19 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n         //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n         //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n-        if (!configValidationReports.containsKey(context.getServiceName())) {\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        CompletableFuture<ConfigurationValidityReport> report = configValidationReports.get(context.getServiceName());\n-        if (!report.isCancelled()) {\n-            report.complete(\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n                     ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n                             .build());\n         }\n-        configValidationReports.remove(context.getServiceName());\n+        configValidationReportFutures.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -322,9 +309,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         CompletableFuture<ConfigurationValidityReport> reportFuture =\n                 configValidationReportFutures.get(context.getServiceName());\n         if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(\n-                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n-                            .build());\n+            reportFuture.complete(request.getConfigurationValidityReport());\n         }\n         configValidationReportFutures.remove(context.getServiceName());\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -291,27 +308,21 @@ public class ConfigStoreIPCAgent {\n      * @param context client context\n      * @return response data\n      */\n-    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n-            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n+                                                                    ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n-                SendConfigurationValidityReportResponse.builder();\n-\n-        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n-        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n-        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n-        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Validation request either timed out or was never made\").build();\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n+                ReportConfigurationValidityResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n         }\n \n-        CompletableFuture<ConfigurationValidityReport> reportFuture =\n-                configValidationReportFutures.get(context.getServiceName());\n-        if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(request.getConfigurationValidityReport());\n-        }\n-        configValidationReportFutures.remove(context.getServiceName());\n+        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n+        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n+        //  message\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -308,21 +303,28 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      * @param context client context\n      * @return response data\n      */\n-    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n-                                                                    ConnectionContext context) {\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n-                ReportConfigurationValidityResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n-        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n-        //  message\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReportFutures.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -320,9 +309,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         CompletableFuture<ConfigurationValidityReport> reportFuture =\n                 configValidationReportFutures.get(context.getServiceName());\n         if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(\n-                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n-                            .build());\n+            reportFuture.complete(request.getConfigurationValidityReport());\n         }\n         configValidationReportFutures.remove(context.getServiceName());\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790539", "body": "Most of the APIs for Config store does not send response. You can refer here : https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76\r\nEven the Subscribe APIs do not send any initial response. The acknowledgement of the message at protocol level should be taken care by new IPC. So for now you may want to add TODO to remove these sent responses when new IPC is used.", "bodyText": "Most of the APIs for Config store does not send response. You can refer here : https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76\nEven the Subscribe APIs do not send any initial response. The acknowledgement of the message at protocol level should be taken care by new IPC. So for now you may want to add TODO to remove these sent responses when new IPC is used.", "bodyHTML": "<p dir=\"auto\">Most of the APIs for Config store does not send response. You can refer here : <a href=\"https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76\" rel=\"nofollow\">https://code.amazon.com/packages/AwsIotGreengrassV2CoreIPCServiceModel/blobs/f851e39883445093f052e2739fed6c645aca6cb0/--/model/main.smithy#L76</a><br>\nEven the Subscribe APIs do not send any initial response. The acknowledgement of the message at protocol level should be taken care by new IPC. So for now you may want to add TODO to remove these sent responses when new IPC is used.</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:46:26Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java", "diffHunk": "@@ -70,13 +73,28 @@ public void postInject() {\n             ConfigStoreClientOpCodes opCode = ConfigStoreClientOpCodes.values()[applicationMessage.getOpCode()];\n             ConfigStoreGenericResponse configStoreGenericResponse = new ConfigStoreGenericResponse();\n             switch (opCode) {\n-                case SUBSCRIBE_ALL:\n-                    configStoreGenericResponse = agent.subscribe(context);\n+                case SUBSCRIBE_TO_ALL_CONFIG_UPDATES:\n+                    SubscribeToConfigurationUpdateRequest subscribeToConfigUpdateRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), SubscribeToConfigurationUpdateRequest.class);\n+                    configStoreGenericResponse = agent.subscribeToConfigUpdate(subscribeToConfigUpdateRequest, context);\n                     break;\n-                case READ_KEY:\n-                    ConfigStoreReadValueRequest readRequest =\n-                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), ConfigStoreReadValueRequest.class);\n-                    configStoreGenericResponse = agent.read(readRequest, context);\n+                case GET_CONFIG:\n+                    GetConfigurationRequest getConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), GetConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.getConfig(getConfigRequest, context);\n+                    break;\n+                case UPDATE_CONFIG:\n+                    UpdateConfigurationRequest updateConfigRequest =\n+                            CBOR_MAPPER.readValue(applicationMessage.getPayload(), UpdateConfigurationRequest.class);\n+                    configStoreGenericResponse = agent.updateConfig(updateConfigRequest, context);\n+                    break;\n+                case SUBSCRIBE_TO_CONFIG_VALIDATION:\n+                    configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n+                    break;\n+                case REPORT_CONFIG_VALIDITY:\n+                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n+                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNjc3Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466806777", "bodyText": "I see empty response object in the API design doc SubscribeToConfigurationUpdateResponse https://quip-amazon.com/mbN5ATEk6Db6/IPC-SDK-API-Design, again how is the doc and the model different?", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNzEzMg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466807132", "bodyText": "Current IPC implementation requires a response, so this is fine.", "author": "MikeDombo", "createdAt": "2020-08-07T03:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMDgzNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r468220836", "bodyText": "Doc an model are different because\n\nSome changes were made during model review as we learnt about Smithy and they are not reflected in the doc.\nSome decisions are taken after smithy model was written", "author": "abanthiy", "createdAt": "2020-08-10T22:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\nindex 3472ed1a82..2413381d54 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n", "chunk": "@@ -92,9 +92,9 @@ public class ConfigStoreIPCService extends EvergreenService {\n                     configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n                     break;\n                 case REPORT_CONFIG_VALIDITY:\n-                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n-                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n-                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n+                    SendConfigurationValidityReportRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), SendConfigurationValidityReportRequest.class);\n+                    configStoreGenericResponse = agent.handleConfigValidityReport(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);\n", "next_change": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\nindex 2413381d54..3ec074cb6c 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n", "chunk": "@@ -91,7 +108,7 @@ public class ConfigStoreIPCService extends EvergreenService {\n                 case SUBSCRIBE_TO_CONFIG_VALIDATION:\n                     configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n                     break;\n-                case REPORT_CONFIG_VALIDITY:\n+                case SEND_CONFIG_VALIDATION_REPORT:\n                     SendConfigurationValidityReportRequest reportConfigValidityRequest = CBOR_MAPPER\n                             .readValue(applicationMessage.getPayload(), SendConfigurationValidityReportRequest.class);\n                     configStoreGenericResponse = agent.handleConfigValidityReport(reportConfigValidityRequest, context);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\nindex 3ec074cb6c..3472ed1a82 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n", "chunk": "@@ -108,10 +91,10 @@ public class ConfigStoreIPCService extends EvergreenService {\n                 case SUBSCRIBE_TO_CONFIG_VALIDATION:\n                     configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n                     break;\n-                case SEND_CONFIG_VALIDATION_REPORT:\n-                    SendConfigurationValidityReportRequest reportConfigValidityRequest = CBOR_MAPPER\n-                            .readValue(applicationMessage.getPayload(), SendConfigurationValidityReportRequest.class);\n-                    configStoreGenericResponse = agent.handleConfigValidityReport(reportConfigValidityRequest, context);\n+                case REPORT_CONFIG_VALIDITY:\n+                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n+                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\nindex 3472ed1a82..2413381d54 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n", "chunk": "@@ -92,9 +92,9 @@ public class ConfigStoreIPCService extends EvergreenService {\n                     configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n                     break;\n                 case REPORT_CONFIG_VALIDITY:\n-                    ReportConfigurationValidityRequest reportConfigValidityRequest = CBOR_MAPPER\n-                            .readValue(applicationMessage.getPayload(), ReportConfigurationValidityRequest.class);\n-                    configStoreGenericResponse = agent.reportConfigValidity(reportConfigValidityRequest, context);\n+                    SendConfigurationValidityReportRequest reportConfigValidityRequest = CBOR_MAPPER\n+                            .readValue(applicationMessage.getPayload(), SendConfigurationValidityReportRequest.class);\n+                    configStoreGenericResponse = agent.handleConfigValidityReport(reportConfigValidityRequest, context);\n                     break;\n                 default:\n                     configStoreGenericResponse.setStatus(ConfigStoreResponseStatus.InvalidRequest);\n", "next_change": {"commit": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\nindex 2413381d54..02ae54f5c5 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/modules/ConfigStoreIPCService.java\n", "chunk": "@@ -91,7 +108,7 @@ public class ConfigStoreIPCService extends EvergreenService {\n                 case SUBSCRIBE_TO_CONFIG_VALIDATION:\n                     configStoreGenericResponse = agent.subscribeToConfigValidation(context);\n                     break;\n-                case REPORT_CONFIG_VALIDITY:\n+                case SEND_CONFIG_VALIDATION_REPORT:\n                     SendConfigurationValidityReportRequest reportConfigValidityRequest = CBOR_MAPPER\n                             .readValue(applicationMessage.getPayload(), SendConfigurationValidityReportRequest.class);\n                     configStoreGenericResponse = agent.handleConfigValidityReport(reportConfigValidityRequest, context);\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDY0Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466790646", "body": "Similar comment about helper for sending errors. This will be treated as ServiceError since this is not a clients mistake. ", "bodyText": "Similar comment about helper for sending errors. This will be treated as ServiceError since this is not a clients mistake.", "bodyHTML": "<p dir=\"auto\">Similar comment about helper for sending errors. This will be treated as ServiceError since this is not a clients mistake.</p>", "author": "abanthiy", "createdAt": "2020-08-07T02:46:52Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -171,4 +204,136 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's runtime config.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n+                                                                    ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n+                ReportConfigurationValidityResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }", "originalCommit": "1997dfc89b5162b6f18b3fde86ce3e1041baf0c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgwNzI5OA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r466807298", "bodyText": "I'll change message for this", "author": "shaguptashaikh", "createdAt": "2020-08-07T03:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc5MDY0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 96f7f2322f..fde8dfa08d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -297,21 +304,27 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      * @param context client context\n      * @return response data\n      */\n-    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n-                                                                    ConnectionContext context) {\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n-                ReportConfigurationValidityResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReports.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n-        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n-        //  message\n+        CompletableFuture<ConfigurationValidityReport> report = configValidationReports.get(context.getServiceName());\n+        if (!report.isCancelled()) {\n+            report.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReports.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex fde8dfa08d..aa00037c6e 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -313,18 +314,19 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n         //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n         //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n-        if (!configValidationReports.containsKey(context.getServiceName())) {\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        CompletableFuture<ConfigurationValidityReport> report = configValidationReports.get(context.getServiceName());\n-        if (!report.isCancelled()) {\n-            report.complete(\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n                     ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n                             .build());\n         }\n-        configValidationReports.remove(context.getServiceName());\n+        configValidationReportFutures.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex aa00037c6e..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -322,9 +309,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         CompletableFuture<ConfigurationValidityReport> reportFuture =\n                 configValidationReportFutures.get(context.getServiceName());\n         if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(\n-                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n-                            .build());\n+            reportFuture.complete(request.getConfigurationValidityReport());\n         }\n         configValidationReportFutures.remove(context.getServiceName());\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -291,27 +308,21 @@ public class ConfigStoreIPCAgent {\n      * @param context client context\n      * @return response data\n      */\n-    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n-            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n+    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n+                                                                    ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n-                SendConfigurationValidityReportResponse.builder();\n-\n-        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n-        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n-        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n-        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Validation request either timed out or was never made\").build();\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n+                ReportConfigurationValidityResponse.builder();\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n         }\n \n-        CompletableFuture<ConfigurationValidityReport> reportFuture =\n-                configValidationReportFutures.get(context.getServiceName());\n-        if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(request.getConfigurationValidityReport());\n-        }\n-        configValidationReportFutures.remove(context.getServiceName());\n+        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n+        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n+        //  message\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -308,21 +303,28 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      * @param context client context\n      * @return response data\n      */\n-    public ReportConfigurationValidityResponse reportConfigValidity(ReportConfigurationValidityRequest request,\n-                                                                    ConnectionContext context) {\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n         // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        ReportConfigurationValidityResponse.ReportConfigurationValidityResponseBuilder response =\n-                ReportConfigurationValidityResponse.builder();\n-        if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n         }\n \n-        log.atInfo().addKeyValue(\"status\", request.getStatus()).addKeyValue(\"message\", request.getMessage()).log();\n-        // TODO : Invoke caller's (Deployment service) handler to use the reported status and\n-        //  message\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReportFutures.remove(context.getServiceName());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -320,9 +309,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         CompletableFuture<ConfigurationValidityReport> reportFuture =\n                 configValidationReportFutures.get(context.getServiceName());\n         if (!reportFuture.isCancelled()) {\n-            reportFuture.complete(\n-                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n-                            .build());\n+            reportFuture.complete(request.getConfigurationValidityReport());\n         }\n         configValidationReportFutures.remove(context.getServiceName());\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "81ecc7100d8d18e21d85048a661cf47a0d12726e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/81ecc7100d8d18e21d85048a661cf47a0d12726e", "message": "Enhancements", "committedDate": "2020-08-07T04:31:29Z", "type": "forcePushed"}, {"oid": "dac25eeeea15629ed8f335290415076ea691bc22", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/dac25eeeea15629ed8f335290415076ea691bc22", "message": "Enhancements", "committedDate": "2020-08-07T04:34:31Z", "type": "forcePushed"}, {"oid": "85c8fa46d71692a43e5f4e3dfcf080bf38694230", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/85c8fa46d71692a43e5f4e3dfcf080bf38694230", "message": "Enhancements", "committedDate": "2020-08-07T04:42:58Z", "type": "forcePushed"}, {"oid": "35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/35798fd73576d2dcc4a06ba500c23f7aec2ecc18", "message": "Enhancements", "committedDate": "2020-08-07T04:52:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTU5MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331591", "body": "should this be in a `finally` so that it is always removed even if the test fails?", "bodyText": "should this be in a finally so that it is always removed even if the test fails?", "bodyHTML": "<p dir=\"auto\">should this be in a <code>finally</code> so that it is always removed even if the test fails?</p>", "author": "MikeDombo", "createdAt": "2020-08-07T23:55:15Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 751312fb13..0d674278b4 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -252,11 +255,13 @@ class IPCServicesTest {\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n                 new CompletableFuture<>();\n-        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n-                validateResultFuture);\n-        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n-\n-        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+        try {\n+            agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                    validateResultFuture);\n+            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        } finally {\n+            agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+        }\n     }\n \n     @Test\n", "next_change": {"commit": "647576c1f224d6603cec83e06225b81e8738162e", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 0d674278b4..e1787e7778 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -267,7 +235,7 @@ class IPCServicesTest {\n     @Test\n     void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n             throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n         client = new IPCClientImpl(config);\n         ConfigStore c = new ConfigStoreImpl(client);\n \n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex e1787e7778..5f3adbfa5e 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -208,70 +200,6 @@ class IPCServicesTest {\n         }\n     }\n \n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n-            throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n-        c.subscribeToValidateConfiguration((configMap) -> {\n-            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n-            eventReceivedByClient.countDown();\n-        });\n-\n-        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n-        CompletableFuture<ConfigurationValidityReport> validateResultFuture = new CompletableFuture<>();\n-        try {\n-            agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n-                    validateResultFuture);\n-            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n-        } finally {\n-            agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n-        }\n-    }\n-\n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n-            throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        Pair<CompletableFuture<Void>, Consumer<Map<String, Object>>> cb = asyncAssertOnConsumer((configMap) -> {\n-            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n-        });\n-        c.subscribeToValidateConfiguration(cb.getRight());\n-\n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n-        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n-        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n-        cb.getLeft().get(2, TimeUnit.SECONDS);\n-\n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n-    }\n-\n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        Topics configuration = kernel.findServiceTopic(\"ServiceName\").createInteriorChild(PARAMETERS_CONFIG_KEY);\n-        Topic configToUpdate = configuration.lookup(\"SomeKeyToUpdate\").withNewerValue(0, \"InitialValue\");\n-\n-        CountDownLatch configUpdated = new CountDownLatch(1);\n-        configToUpdate.subscribe((what, node) -> configUpdated.countDown());\n-\n-        c.updateConfiguration(\"ServiceName\", Collections.singletonList(\"SomeKeyToUpdate\"), \"SomeValueToUpdate\",\n-                System.currentTimeMillis(), null);\n-\n-        assertTrue(configUpdated.await(5, TimeUnit.SECONDS));\n-        assertEquals(\"SomeValueToUpdate\", configToUpdate.getOnce());\n-    }\n-\n     @Test\n     void GIVEN_ConfigStoreClient_WHEN_read_THEN_value_returned() throws Exception {\n         KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n", "next_change": {"commit": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 5f3adbfa5e..0c62be834b 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -200,6 +204,69 @@ class IPCServicesTest {\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        Topics configuration = kernel.findServiceTopic(\"ServiceName\").createInteriorChild(PARAMETERS_CONFIG_KEY);\n+        Topic configToUpdate = configuration.lookup(\"SomeKeyToUpdate\").withNewerValue(0, \"InitialValue\");\n+\n+        CountDownLatch configUpdated = new CountDownLatch(1);\n+        configToUpdate.subscribe((what, node) -> configUpdated.countDown());\n+\n+        c.updateConfiguration(\"ServiceName\", \"SomeKeyToUpdate\", \"SomeValueToUpdate\", System.currentTimeMillis());\n+\n+        assertTrue(configUpdated.await(5, TimeUnit.SECONDS));\n+        assertEquals(\"SomeValueToUpdate\", configToUpdate.getOnce());\n+    }\n+\n     @Test\n     void GIVEN_ConfigStoreClient_WHEN_read_THEN_value_returned() throws Exception {\n         KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTgwNg==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331806", "body": "this assertion won't do anything (except cause the CDL to not be counted down). I'd recommend using: https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60", "bodyText": "this assertion won't do anything (except cause the CDL to not be counted down). I'd recommend using: https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60", "bodyHTML": "<p dir=\"auto\">this assertion won't do anything (except cause the CDL to not be counted down). I'd recommend using: <a href=\"https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60\">https://github.com/aws/aws-greengrass-kernel/blob/708b5de9daf62f941429a6131523aaae3c448380/src/test/java/com/aws/iot/evergreen/testcommons/testutilities/TestUtils.java#L60</a></p>", "author": "MikeDombo", "createdAt": "2020-08-07T23:56:25Z", "path": "src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java", "diffHunk": "@@ -222,17 +225,80 @@ void GIVEN_ConfigStoreClient_WHEN_subscribe_THEN_key_sent_when_changed() throws\n             }\n         }, 2);\n \n-        c.subscribe(p.getRight());\n-        custom.createLeafChild(\"abc\").withValue(\"ABC\");\n-        custom.createLeafChild(\"DDF\").withValue(\"ddf\");\n+        c.subscribeToConfigurationUpdate(\"ServiceName\", p.getRight());\n+        configuration.createLeafChild(\"abc\").withValue(\"ABC\");\n+        configuration.createLeafChild(\"DDF\").withValue(\"ddf\");\n \n         try {\n-            p.getLeft().get(1, TimeUnit.SECONDS);\n+            p.getLeft().get(10, TimeUnit.SECONDS);\n         } finally {\n-            custom.remove();\n+            configuration.remove();\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 751312fb13..0d674278b4 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -266,16 +271,15 @@ class IPCServicesTest {\n         client = new IPCClientImpl(config);\n         ConfigStore c = new ConfigStoreImpl(client);\n \n-        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n-        c.subscribeToValidateConfiguration((configMap) -> {\n+        Pair<CompletableFuture<Void>, Consumer<Map<String, Object>>> cb = asyncAssertOnConsumer((configMap) -> {\n             assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n-            eventReceivedByClient.countDown();\n         });\n+        c.subscribeToValidateConfiguration(cb.getRight());\n \n         CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n-        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+        cb.getLeft().get(2, TimeUnit.SECONDS);\n \n         c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n         assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 0d674278b4..e24c2947ad 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -276,7 +243,7 @@ class IPCServicesTest {\n         });\n         c.subscribeToValidateConfiguration(cb.getRight());\n \n-        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n         ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n         agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n         cb.getLeft().get(2, TimeUnit.SECONDS);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex e24c2947ad..5f3adbfa5e 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -207,70 +200,6 @@ class IPCServicesTest {\n         }\n     }\n \n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n-            throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n-        c.subscribeToValidateConfiguration((configMap) -> {\n-            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n-            eventReceivedByClient.countDown();\n-        });\n-\n-        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n-        CompletableFuture<ConfigurationValidityReport> validateResultFuture = new CompletableFuture<>();\n-        try {\n-            agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n-                    validateResultFuture);\n-            assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n-        } finally {\n-            agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n-        }\n-    }\n-\n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n-            throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        Pair<CompletableFuture<Void>, Consumer<Map<String, Object>>> cb = asyncAssertOnConsumer((configMap) -> {\n-            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n-        });\n-        c.subscribeToValidateConfiguration(cb.getRight());\n-\n-        CompletableFuture<ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n-        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n-        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n-        cb.getLeft().get(2, TimeUnit.SECONDS);\n-\n-        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n-        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n-    }\n-\n-    @Test\n-    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n-        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n-        client = new IPCClientImpl(config);\n-        ConfigStore c = new ConfigStoreImpl(client);\n-\n-        Topics configuration = kernel.findServiceTopic(\"ServiceName\").createInteriorChild(PARAMETERS_CONFIG_KEY);\n-        Topic configToUpdate = configuration.lookup(\"SomeKeyToUpdate\").withNewerValue(0, \"InitialValue\");\n-\n-        CountDownLatch configUpdated = new CountDownLatch(1);\n-        configToUpdate.subscribe((what, node) -> configUpdated.countDown());\n-\n-        c.updateConfiguration(\"ServiceName\", Collections.singletonList(\"SomeKeyToUpdate\"), \"SomeValueToUpdate\",\n-                System.currentTimeMillis());\n-\n-        assertTrue(configUpdated.await(5, TimeUnit.SECONDS));\n-        assertEquals(\"SomeValueToUpdate\", configToUpdate.getOnce());\n-    }\n-\n     @Test\n     void GIVEN_ConfigStoreClient_WHEN_read_THEN_value_returned() throws Exception {\n         KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n", "next_change": {"commit": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "changed_code": [{"header": "diff --git a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\nindex 5f3adbfa5e..0c62be834b 100644\n--- a/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n+++ b/src/integrationtests/java/com/aws/iot/evergreen/integrationtests/ipc/IPCServicesTest.java\n", "chunk": "@@ -200,6 +204,69 @@ class IPCServicesTest {\n         }\n     }\n \n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_subscribe_to_validate_config_THEN_validate_event_can_be_sent_to_client()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validateResultFuture =\n+                new CompletableFuture<>();\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"),\n+                validateResultFuture);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        agent.discardValidationReportTracker(\"ServiceName\", validateResultFuture);\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_report_config_validation_status_THEN_inform_validation_requester()\n+            throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        CountDownLatch eventReceivedByClient = new CountDownLatch(1);\n+        c.subscribeToValidateConfiguration((configMap) -> {\n+            assertThat(configMap, IsMapContaining.hasEntry(\"keyToValidate\", \"valueToValidate\"));\n+            eventReceivedByClient.countDown();\n+        });\n+\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> responseTracker = new CompletableFuture<>();\n+        ConfigStoreIPCAgent agent = kernel.getContext().get(ConfigStoreIPCAgent.class);\n+        agent.validateConfiguration(\"ServiceName\", Collections.singletonMap(\"keyToValidate\", \"valueToValidate\"), responseTracker);\n+        assertTrue(eventReceivedByClient.await(500, TimeUnit.MILLISECONDS));\n+\n+        c.sendConfigurationValidityReport(ConfigurationValidityStatus.VALID, null);\n+        assertEquals(ConfigurationValidityStatus.VALID, responseTracker.get().getStatus());\n+    }\n+\n+    @Test\n+    void GIVEN_ConfigStoreClient_WHEN_update_config_request_THEN_config_is_updated() throws Exception {\n+        KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\");\n+        client = new IPCClientImpl(config);\n+        ConfigStore c = new ConfigStoreImpl(client);\n+\n+        Topics configuration = kernel.findServiceTopic(\"ServiceName\").createInteriorChild(PARAMETERS_CONFIG_KEY);\n+        Topic configToUpdate = configuration.lookup(\"SomeKeyToUpdate\").withNewerValue(0, \"InitialValue\");\n+\n+        CountDownLatch configUpdated = new CountDownLatch(1);\n+        configToUpdate.subscribe((what, node) -> configUpdated.countDown());\n+\n+        c.updateConfiguration(\"ServiceName\", \"SomeKeyToUpdate\", \"SomeValueToUpdate\", System.currentTimeMillis());\n+\n+        assertTrue(configUpdated.await(5, TimeUnit.SECONDS));\n+        assertEquals(\"SomeValueToUpdate\", configToUpdate.getOnce());\n+    }\n+\n     @Test\n     void GIVEN_ConfigStoreClient_WHEN_read_THEN_value_returned() throws Exception {\n         KernelIPCClientConfig config = getIPCConfigForService(\"ServiceName\", kernel);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMTk3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467331971", "body": "this is changed now due to my recent merge. You'll need to rebase.", "bodyText": "this is changed now due to my recent merge. You'll need to rebase.", "bodyHTML": "<p dir=\"auto\">this is changed now due to my recent merge. You'll need to rebase.</p>", "author": "MikeDombo", "createdAt": "2020-08-07T23:57:26Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -62,19 +91,30 @@\n         }\n \n         List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, custom, <someKey>\n+        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n         if (nodePath.size() < 5) {", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex a8f75bcb90..d4e0647f14 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -80,46 +66,11 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n     private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        List<String> nodePath = node.path();\n-        // The path should have at least 5 items: null (root), services, serviceName, parameters, <someKey>\n-        if (nodePath.size() < 5) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration\n-        int configIndex = nodePath.size() - 4;\n-        if (!nodePath.get(configIndex).equals(PARAMETERS_CONFIG_KEY)) {\n-            return;\n-        }\n-        subscribers.stream().map(ctx -> configUpdateListeners.get(ctx))\n-                .forEach(c -> c.accept(serviceName, nodePath.get(configIndex - 1)));\n-\n-    };\n     @Inject\n     private Kernel kernel;\n-    @Inject\n-    private ExecutorService executor;\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    @Inject\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -33,48 +27,86 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-import com.aws.iot.evergreen.util.Utils;\n-import lombok.AccessLevel;\n-import lombok.AllArgsConstructor;\n-import lombok.Builder;\n-import lombok.Getter;\n-import lombok.NoArgsConstructor;\n-\n-import java.util.Arrays;\n+\n+import java.io.IOException;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.CompletableFuture;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n+import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-@NoArgsConstructor\n-@AllArgsConstructor(access = AccessLevel.PACKAGE)\n-public class ConfigStoreIPCAgent {\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n-    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n-\n-    // Map from connection --> Function to call for triggering config validation events\n-    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+public class ConfigStoreIPCAgent implements InjectionActions {\n+    // Map from connection --> Function to call when service config changes\n+    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n+            new ConcurrentHashMap<>();\n+    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n             new ConcurrentHashMap<>();\n-    // Map of component --> future to complete with validation status received from service in response to validate\n-    // event\n-    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n+    private static final int TIMEOUT_SECONDS = 30;\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ServiceEventHelper serviceEventHelper;\n+    private ExecutorService executor;\n+\n+    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n+        if (node == null) {\n+            return;\n+        }\n+        String serviceName = Kernel.findServiceForNode(node);\n+        // Ensure a the node that changed belongs to a service\n+        if (serviceName == null) {\n+            return;\n+        }\n+\n+        String[] nodePath = node.path();\n+        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n+        if (nodePath.length < 4) {\n+            return;\n+        }\n+\n+        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n+        // Do nothing if no one has subscribed\n+        if (subscribers == null || subscribers.isEmpty()) {\n+            return;\n+        }\n+\n+        // Ensure that the node which changed was part of component configuration/ runtime configuration\n+        int configIndex = 2;\n+        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n+            return;\n+        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n+            // Do not send update event for runtime config changes to the owner service\n+            // A service updates its own runtime config so it does not need to be updated for it\n+            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n+                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n+        } else {\n+            return;\n+        }\n+    };\n+\n+    @Override\n+    public void postInject() {\n+        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+    }\n \n     /**\n-     * Handle the subscription request from the user.\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -27,83 +32,45 @@ import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdat\n import com.aws.iot.evergreen.kernel.Kernel;\n import com.aws.iot.evergreen.logging.api.Logger;\n import com.aws.iot.evergreen.logging.impl.LogManager;\n-\n-import java.io.IOException;\n+import com.aws.iot.evergreen.util.Utils;\n+import lombok.AccessLevel;\n+import lombok.AllArgsConstructor;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+\n+import java.util.Arrays;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n import java.util.function.Consumer;\n import javax.inject.Inject;\n \n-import static com.aws.iot.evergreen.kernel.EvergreenService.RUNTIME_STORE_NAMESPACE_TOPIC;\n import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n \n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<String, CopyOnWriteArraySet<ConnectionContext>> configUpdateSubscribersByService =\n-            new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<String>> configUpdateListeners =\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n             new ConcurrentHashMap<>();\n-    private static final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n             new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n-\n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n-        }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n-        }\n-\n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, parameters/runtime, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n-        }\n-\n-        Set<ConnectionContext> subscribers = configUpdateSubscribersByService.get(serviceName);\n-        // Do nothing if no one has subscribed\n-        if (subscribers == null || subscribers.isEmpty()) {\n-            return;\n-        }\n-\n-        // Ensure that the node which changed was part of component configuration/ runtime configuration\n-        int configIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[configIndex])) {\n-            return;\n-        } else if (nodePath[configIndex].equals(RUNTIME_STORE_NAMESPACE_TOPIC)) {\n-            // Do not send update event for runtime config changes to the owner service\n-            // A service updates its own runtime config so it does not need to be updated for it\n-            subscribers.stream().filter(ctx -> !ctx.getServiceName().equals(serviceName))\n-                    .map(ctx -> configUpdateListeners.get(ctx)).forEach(c -> c.accept(nodePath[configIndex + 1]));\n-        } else {\n-            return;\n-        }\n-    };\n-\n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n-    }\n+    private ServiceEventHelper serviceEventHelper;\n \n     /**\n      * Handle the subscription request from the user. Immediately sends the current state to the client.\n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -73,7 +74,7 @@ public class ConfigStoreIPCAgent {\n     private ServiceEventHelper serviceEventHelper;\n \n     /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     * Handle the subscription request from the user.\n      *\n      * @param request request for component update subscription\n      * @param context connection context\n", "next_change": null}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjM5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332396", "body": "should this be moved into our SDK package?", "bodyText": "should this be moved into our SDK package?", "bodyHTML": "<p dir=\"auto\">should this be moved into our SDK package?</p>", "author": "MikeDombo", "createdAt": "2020-08-07T23:59:57Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -165,10 +217,179 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n         } else if (node instanceof Topics) {\n             response.value(((Topics) node).toPOJO());\n         } else {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            response.responseStatus(ConfigStoreResponseStatus.ServiceError).errorMessage(\"Node has an unknown type\");\n             log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n         }\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n+                    .build();\n+        }\n+\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Handle subscription request from the user for validating config changes before deployments.\n+     *\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToValidateConfigurationResponse subscribeToConfigValidation(ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC subscribe to config validation request\");\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        configValidationListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configValidationListeners.remove(context));\n+            return sendConfigValidationEvent(context);\n+        });\n+\n+        return SubscribeToValidateConfigurationResponse.builder().responseStatus(ConfigStoreResponseStatus.Success)\n+                .build();\n+    }\n+\n+    private Consumer<Map<String, Object>> sendConfigValidationEvent(ConnectionContext context) {\n+        return (configuration) -> {\n+            ValidateConfigurationUpdateEvent validationEvent =\n+                    ValidateConfigurationUpdateEvent.builder().configuration(configuration).build();\n+            log.atDebug().log(\"Requesting validation for component config {}\", configuration, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal())\n+                                .payload(IPCUtil.encode(validationEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                                .log(\"Error sending config validation event to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-requesting-config-validation\").kv(\"context\", context)\n+                        .log(\"Error sending config validation event to client\", e);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Handle user service's response to config validation request.\n+     *\n+     * @param request request to report validation status for config\n+     * @param context client context\n+     * @return response data\n+     */\n+    public SendConfigurationValidityReportResponse handleConfigValidityReport(\n+            SendConfigurationValidityReportRequest request, ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC report config validation request\");\n+        SendConfigurationValidityReportResponse.SendConfigurationValidityReportResponseBuilder response =\n+                SendConfigurationValidityReportResponse.builder();\n+        // TODO : Edge case - With the current API model, there is no way to associate a validation report from client\n+        //  with the event sent from server, meaning if event 1 from server was abandoned due to timeout, then event\n+        //  2 was triggered, then report in response to event 1 arrives, server won't detect this.\n+        if (!configValidationReportFutures.containsKey(context.getServiceName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Validation request either timed out or was never made\").build();\n+        }\n+\n+        CompletableFuture<ConfigurationValidityReport> reportFuture =\n+                configValidationReportFutures.get(context.getServiceName());\n+        if (!reportFuture.isCancelled()) {\n+            reportFuture.complete(\n+                    ConfigurationValidityReport.builder().status(request.getStatus()).message(request.getMessage())\n+                            .build());\n+        }\n+        configValidationReportFutures.remove(context.getServiceName());\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n+        return response.build();\n+    }\n+\n+    /**\n+     * Trigger a validate event to service/component, typically used during deployments.\n+     *\n+     * @param componentName service/component to send validate event to\n+     * @param configuration new component configuration to validate\n+     * @param reportFuture  future to track validation report in response to the event\n+     * @return true if the service has registered a validator, false if not\n+     * @throws UnsupportedOperationException throws when triggering requested validation event is not allowed\n+     */\n+    public boolean validateConfiguration(String componentName, Map<String, Object> configuration,\n+                                         CompletableFuture<ConfigurationValidityReport> reportFuture)\n+            throws UnsupportedOperationException {\n+        // TODO : Consider handling a collection of components to abstract validation for the whole deployment\n+        if (configValidationReportFutures.containsKey(componentName)) {\n+            throw new UnsupportedOperationException(\n+                    \"A validation request to this component is already waiting for response\");\n+        }\n+\n+        for (Map.Entry<ConnectionContext, Consumer<Map<String, Object>>> e : configValidationListeners.entrySet()) {\n+            if (e.getKey().getServiceName().equals(componentName)) {\n+                configValidationReportFutures.put(componentName, reportFuture);\n+                e.getValue().accept(configuration);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Abandon tracking for report of configuration validation event. Can be used by the caller in the case of timeouts\n+     * or other errors.\n+     *\n+     * @param componentName component name to abandon validation for\n+     * @param reportFuture  tracking future for validation report to abandon\n+     * @return true if abandon request was successful\n+     */\n+    public boolean discardValidationReportTracker(String componentName,\n+                                                  CompletableFuture<ConfigurationValidityReport> reportFuture) {\n+        return configValidationReportFutures.remove(componentName, reportFuture);\n+    }\n+\n+    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n+    @Builder\n+    @Getter\n+    public static class ConfigurationValidityReport {", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzMjU3Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467632573", "bodyText": "will update smithy model with\n\nConfigurationValidityStatus status;\nString message;\nfor SendConfigurationValidityReportRequest", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex a8f75bcb90..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -384,12 +359,4 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                                                   CompletableFuture<ConfigurationValidityReport> reportFuture) {\n         return configValidationReportFutures.remove(componentName, reportFuture);\n     }\n-\n-    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n-    @Builder\n-    @Getter\n-    public static class ConfigurationValidityReport {\n-        private ConfigurationValidityStatus status;\n-        private String message;\n-    }\n }\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -323,40 +334,17 @@ public class ConfigStoreIPCAgent {\n      *\n      * @param componentName service/component to send validate event to\n      * @param configuration new component configuration to validate\n-     * @param reportFuture  future to track validation report in response to the event\n      * @return true if the service has registered a validator, false if not\n-     * @throws UnsupportedOperationException throws when triggering requested validation event is not allowed\n      */\n-    public boolean validateConfiguration(String componentName, Map<String, Object> configuration,\n-                                         CompletableFuture<ConfigurationValidityReport> reportFuture)\n-            throws UnsupportedOperationException {\n-        // TODO : Will handling a collection of components to abstract validation for the whole deployment\n-        //  be better?\n-        if (configValidationReportFutures.containsKey(componentName)) {\n-            throw new UnsupportedOperationException(\n-                    \"A validation request to this component is already waiting for response\");\n-        }\n-\n+    public boolean validateConfiguration(String componentName, Map<String, Object> configuration) {\n+        // TODO : Accept a handler from the requester and track it so that when the component\n+        //  reports the validation result, the handler can be invoked\n         for (Map.Entry<ConnectionContext, Consumer<Map<String, Object>>> e : configValidationListeners.entrySet()) {\n             if (e.getKey().getServiceName().equals(componentName)) {\n-                configValidationReportFutures.put(componentName, reportFuture);\n                 e.getValue().accept(configuration);\n                 return true;\n             }\n         }\n         return false;\n     }\n-\n-    /**\n-     * Abandon tracking for report of configuration validation event. Can be used by the caller in the case of timeouts\n-     * or other errors.\n-     *\n-     * @param componentName component name to abandon validation for\n-     * @param reportFuture  tracking future for validation report to abandon\n-     * @return true if abandon request was successful\n-     */\n-    public boolean discardValidationReportTracker(String componentName,\n-                                                  CompletableFuture<ConfigurationValidityReport> reportFuture) {\n-        return configValidationReportFutures.remove(componentName, reportFuture);\n-    }\n }\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -334,17 +336,47 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      *\n      * @param componentName service/component to send validate event to\n      * @param configuration new component configuration to validate\n+     * @param reportFuture  future to track validation report in response to the event\n      * @return true if the service has registered a validator, false if not\n+     * @throws UnsupportedOperationException throws when triggering requested validation event is not allowed\n      */\n-    public boolean validateConfiguration(String componentName, Map<String, Object> configuration) {\n-        // TODO : Accept a handler from the requester and track it so that when the component\n-        //  reports the validation result, the handler can be invoked\n+    public boolean validateConfiguration(String componentName, Map<String, Object> configuration,\n+                                         CompletableFuture<ConfigurationValidityReport> reportFuture)\n+            throws UnsupportedOperationException {\n+        // TODO : Consider handling a collection of components to abstract validation for the whole deployment\n+        if (configValidationReportFutures.containsKey(componentName)) {\n+            throw new UnsupportedOperationException(\n+                    \"A validation request to this component is already waiting for response\");\n+        }\n+\n         for (Map.Entry<ConnectionContext, Consumer<Map<String, Object>>> e : configValidationListeners.entrySet()) {\n             if (e.getKey().getServiceName().equals(componentName)) {\n+                configValidationReportFutures.put(componentName, reportFuture);\n                 e.getValue().accept(configuration);\n                 return true;\n             }\n         }\n         return false;\n     }\n+\n+    /**\n+     * Abandon tracking for report of configuration validation event. Can be used by the caller in the case of timeouts\n+     * or other errors.\n+     *\n+     * @param componentName component name to abandon validation for\n+     * @param reportFuture  tracking future for validation report to abandon\n+     * @return true if abandon request was successful\n+     */\n+    public boolean discardValidationReportTracker(String componentName,\n+                                                  CompletableFuture<ConfigurationValidityReport> reportFuture) {\n+        return configValidationReportFutures.remove(componentName, reportFuture);\n+    }\n+\n+    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n+    @Builder\n+    @Getter\n+    public static class ConfigurationValidityReport {\n+        private ConfigurationValidityStatus status;\n+        private String message;\n+    }\n }\n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -371,12 +359,4 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n                                                   CompletableFuture<ConfigurationValidityReport> reportFuture) {\n         return configValidationReportFutures.remove(componentName, reportFuture);\n     }\n-\n-    // TODO: If it adds value, add this to the SendConfigurationValidityReportRequest in smithy model\n-    @Builder\n-    @Getter\n-    public static class ConfigurationValidityReport {\n-        private ConfigurationValidityStatus status;\n-        private String message;\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzMjYwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467332608", "body": "close context in aftereach", "bodyText": "close context in aftereach", "bodyHTML": "<p dir=\"auto\">close context in aftereach</p>", "author": "MikeDombo", "createdAt": "2020-08-08T00:00:49Z", "path": "src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class ConfigStoreIPCAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private ExecutorService executor;\n+\n+    @Mock\n+    private ConnectionContext componentAContext;\n+\n+    @Mock\n+    private ConnectionContext componentBContext;\n+\n+    private ConfigStoreIPCAgent agent;\n+\n+    private Configuration configuration;\n+\n+    @BeforeEach\n+    void setup() {\n+        agent = new ConfigStoreIPCAgent(kernel, executor);\n+\n+        configuration = new Configuration(new Context());", "originalCommit": "a25849e13367a1d2345b91b308fe457fd4f6e220", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "changed_code": [{"header": "diff --git a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\nindex ddbebccc4b..8167a0b28c 100644\n--- a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n", "chunk": "@@ -85,19 +87,22 @@ public class ConfigStoreIPCAgentTest {\n \n     @BeforeEach\n     void setup() {\n-        agent = new ConfigStoreIPCAgent(kernel, executor);\n+        agent = new ConfigStoreIPCAgent(kernel, new ServiceEventHelper(executor));\n \n         configuration = new Configuration(new Context());\n         Topics root = configuration.getRoot();\n         root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_1).withValue(20);\n         root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_2).withValue(15);\n         root.lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_B);\n-        when(kernel.getConfig()).thenReturn(configuration);\n+        lenient().when(kernel.getConfig()).thenReturn(configuration);\n \n         lenient().when(componentAContext.getServiceName()).thenReturn(TEST_COMPONENT_A);\n         lenient().when(componentBContext.getServiceName()).thenReturn(TEST_COMPONENT_B);\n+    }\n \n-        agent.postInject();\n+    @AfterEach\n+    void cleanup() throws IOException {\n+        kernel.getConfig().context.close();\n     }\n \n     @Test\n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\nindex 8167a0b28c..0919de0ba4 100644\n--- a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n", "chunk": "@@ -109,8 +104,8 @@ public class ConfigStoreIPCAgentTest {\n     public void GIVEN_agent_running_WHEN_get_config_request_for_own_config_THEN_return_config_value() {\n         when(kernel.findServiceTopic(TEST_COMPONENT_A))\n                 .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        GetConfigurationRequest request =\n-                GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(TEST_CONFIG_KEY_1).build();\n+        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n+                .keyPath(Collections.singletonList(TEST_CONFIG_KEY_1)).build();\n         GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n         assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n         assertEquals(20, response.getValue());\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\ndeleted file mode 100644\nindex 0919de0ba4..0000000000\n--- a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n+++ /dev/null\n", "chunk": "@@ -1,288 +0,0 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-package com.aws.iot.evergreen.builtin.services.configstore;\n-\n-import com.aws.iot.evergreen.config.Configuration;\n-import com.aws.iot.evergreen.config.Topic;\n-import com.aws.iot.evergreen.config.Topics;\n-import com.aws.iot.evergreen.dependency.Context;\n-import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n-import com.aws.iot.evergreen.ipc.common.ServiceEventHelper;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationUpdateEvent;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityReport;\n-import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n-import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationRequest;\n-import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationResponse;\n-import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportRequest;\n-import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportResponse;\n-import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateRequest;\n-import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateResponse;\n-import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationRequest;\n-import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationResponse;\n-import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdateEvent;\n-import com.aws.iot.evergreen.kernel.Kernel;\n-import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.mockito.Mock;\n-import org.mockito.junit.jupiter.MockitoExtension;\n-\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-\n-import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n-import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n-import static org.mockito.Mockito.lenient;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-\n-@ExtendWith({MockitoExtension.class, EGExtension.class})\n-public class ConfigStoreIPCAgentTest {\n-    private static final String TEST_COMPONENT_A = \"Component_A\";\n-    private static final String TEST_COMPONENT_B = \"Component_B\";\n-    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n-    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n-\n-    @Mock\n-    private Kernel kernel;\n-\n-    @Mock\n-    private ServiceEventHelper serviceEventHelper;\n-\n-    @Mock\n-    private ConnectionContext componentAContext;\n-\n-    @Mock\n-    private ConnectionContext componentBContext;\n-\n-    private ConfigStoreIPCAgent agent;\n-\n-    private Configuration configuration;\n-\n-    @BeforeEach\n-    void setup() {\n-        agent = new ConfigStoreIPCAgent(kernel, serviceEventHelper);\n-\n-        configuration = new Configuration(new Context());\n-        Topics root = configuration.getRoot();\n-        root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_1).withValue(20);\n-        root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_2).withValue(15);\n-        root.lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_B);\n-        lenient().when(kernel.getConfig()).thenReturn(configuration);\n-\n-        lenient().when(componentAContext.getServiceName()).thenReturn(TEST_COMPONENT_A);\n-        lenient().when(componentBContext.getServiceName()).thenReturn(TEST_COMPONENT_B);\n-    }\n-\n-    @AfterEach\n-    void cleanup() throws IOException {\n-        kernel.getConfig().context.close();\n-    }\n-\n-    @Test\n-    public void GIVEN_agent_running_WHEN_get_config_request_for_own_config_THEN_return_config_value() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(TEST_CONFIG_KEY_1)).build();\n-        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n-        assertEquals(20, response.getValue());\n-    }\n-\n-    @Test\n-    public void GIVEN_agent_running_WHEN_get_config_request_for_cross_component_config_THEN_return_config_value() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(TEST_CONFIG_KEY_2)).build();\n-        GetConfigurationResponse response = agent.getConfig(request, componentBContext);\n-        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n-        assertEquals(15, response.getValue());\n-    }\n-\n-    @Test\n-    public void GIVEN_get_config_request_WHEN_key_does_not_exist_THEN_fail() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(\"WrongKey\")).build();\n-        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.ResourceNotFoundError, response.getStatus());\n-        assertEquals(\"Key not found\", response.getErrorMessage());\n-    }\n-\n-    @Test\n-    public void GIVEN_get_config_request_WHEN_component_requested_does_not_exist_THEN_fail() {\n-        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(\"WrongComponent\")\n-                .keyPath(Collections.singletonList(\"AnyKey\")).build();\n-        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.ResourceNotFoundError, response.getStatus());\n-        assertEquals(\"Key not found\", response.getErrorMessage());\n-    }\n-\n-    @Test\n-    public void GIVEN_get_config_request_WHEN_component_requested_does_not_have_configuration_THEN_fail() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_B))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_B));\n-        GetConfigurationRequest request = GetConfigurationRequest.builder().componentName(TEST_COMPONENT_B)\n-                .keyPath(Collections.singletonList(\"AnyKey\")).build();\n-        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.ResourceNotFoundError, response.getStatus());\n-        assertEquals(\"Key not found\", response.getErrorMessage());\n-    }\n-\n-    @Test\n-    public void GIVEN_agent_running_WHEN_update_config_request_THEN_update_config_value() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        UpdateConfigurationRequest request = UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(TEST_CONFIG_KEY_2)).newValue(30)\n-                .timestamp(System.currentTimeMillis()).build();\n-        UpdateConfigurationResponse response = agent.updateConfig(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n-        assertEquals(30,\n-                kernel.findServiceTopic(TEST_COMPONENT_A).find(PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_2).getOnce());\n-    }\n-\n-    @Test\n-    public void GIVEN_update_config_request_WHEN_update_key_does_not_exist_THEN_create_key() {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        UpdateConfigurationRequest request = UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(\"NewKey\")).newValue(\"SomeValue\")\n-                .timestamp(System.currentTimeMillis()).build();\n-        UpdateConfigurationResponse response = agent.updateConfig(request, componentAContext);\n-        Topic newConfigKeyTopic = kernel.findServiceTopic(TEST_COMPONENT_A).find(PARAMETERS_CONFIG_KEY, \"NewKey\");\n-        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n-        assertNotNull(newConfigKeyTopic);\n-        assertEquals(\"SomeValue\", newConfigKeyTopic.getOnce());\n-    }\n-\n-    @Test\n-    public void GIVEN_update_config_request_WHEN_requested_component_is_not_self_THEN_fail() {\n-        UpdateConfigurationRequest request = UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A)\n-                .keyPath(Collections.singletonList(TEST_CONFIG_KEY_1)).newValue(20)\n-                .timestamp(System.currentTimeMillis()).build();\n-        UpdateConfigurationResponse response = agent.updateConfig(request, componentBContext);\n-        assertEquals(ConfigStoreResponseStatus.InvalidRequest, response.getStatus());\n-        assertEquals(\"Cross component updates are not allowed\", response.getErrorMessage());\n-    }\n-\n-    @Test\n-    public void GIVEN_agent_running_WHEN_subscribe_to_config_update_request_THEN_next_config_update_triggers_event()\n-            throws InterruptedException {\n-        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n-                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n-        SubscribeToConfigurationUpdateRequest request =\n-                SubscribeToConfigurationUpdateRequest.builder().componentName(TEST_COMPONENT_A).build();\n-        SubscribeToConfigurationUpdateResponse response = agent.subscribeToConfigUpdate(request, componentBContext);\n-        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n-\n-        ConfigurationUpdateEvent updateEvent = ConfigurationUpdateEvent.builder().componentName(TEST_COMPONENT_A)\n-                .changedKeyPath(Collections.singletonList(TEST_CONFIG_KEY_1)).build();\n-        CountDownLatch eventSentToClient = new CountDownLatch(1);\n-        when(serviceEventHelper.sendServiceEvent(any(ConnectionContext.class), any(ConfigurationUpdateEvent.class),\n-                any(BuiltInServiceDestinationCode.class), anyInt(), anyInt())).thenAnswer(invocationOnMock -> {\n-            eventSentToClient.countDown();\n-            return null;\n-        });\n-\n-        configuration.getRoot()\n-                .lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_1)\n-                .withValue(25);\n-\n-        assertTrue(eventSentToClient.await(10, TimeUnit.SECONDS));\n-        verify(serviceEventHelper)\n-                .sendServiceEvent(componentBContext, updateEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                        ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n-    }\n-\n-    @Test\n-    public void GIVEN_agent_running_WHEN_subscribe_to_validate_config_request_THEN_validation_event_can_be_triggered() {\n-        assertEquals(ConfigStoreResponseStatus.Success,\n-                agent.subscribeToConfigValidation(componentAContext).getStatus());\n-\n-        Map<String, Object> configToValidate = new HashMap<>();\n-        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n-        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n-\n-        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, new CompletableFuture<>()));\n-        verify(serviceEventHelper).sendServiceEvent(componentAContext,\n-                ValidateConfigurationUpdateEvent.builder().configuration(configToValidate).build(),\n-                BuiltInServiceDestinationCode.CONFIG_STORE, ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal(),\n-                ConfigStoreImpl.API_VERSION);\n-\n-    }\n-\n-    @Test\n-    public void GIVEN_waiting_for_validation_response_WHEN_abandon_validation_event_THEN_succeed() throws IOException {\n-        assertEquals(ConfigStoreResponseStatus.Success,\n-                agent.subscribeToConfigValidation(componentAContext).getStatus());\n-\n-        Map<String, Object> configToValidate = new HashMap<>();\n-        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n-        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n-\n-        CompletableFuture validationTracker = new CompletableFuture<>();\n-        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, validationTracker));\n-\n-        assertTrue(agent.discardValidationReportTracker(TEST_COMPONENT_A, validationTracker));\n-    }\n-\n-    @Test\n-    public void GIVEN_validation_event_being_tracked_WHEN_send_config_validity_report_request_THEN_notify_validation_requester()\n-            throws ExecutionException, InterruptedException {\n-        assertEquals(ConfigStoreResponseStatus.Success,\n-                agent.subscribeToConfigValidation(componentAContext).getStatus());\n-\n-        Map<String, Object> configToValidate = new HashMap<>();\n-        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n-        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n-\n-        CompletableFuture<ConfigurationValidityReport> validationTracker = new CompletableFuture<>();\n-        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, validationTracker));\n-\n-        SendConfigurationValidityReportRequest reportRequest = SendConfigurationValidityReportRequest.builder()\n-                .configurationValidityReport(\n-                        ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build())\n-                .build();\n-        assertEquals(ConfigStoreResponseStatus.Success,\n-                agent.handleConfigValidityReport(reportRequest, componentAContext).getStatus());\n-\n-        assertTrue(validationTracker.isDone());\n-        assertEquals(ConfigurationValidityStatus.VALID, validationTracker.get().getStatus());\n-    }\n-\n-    @Test\n-    public void GIVEN_no_validation_event_is_tracked_WHEN_send_config_validity_report_request_THEN_fail() {\n-        SendConfigurationValidityReportRequest request = SendConfigurationValidityReportRequest.builder()\n-                .configurationValidityReport(\n-                        ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build())\n-                .build();\n-        SendConfigurationValidityReportResponse response = agent.handleConfigValidityReport(request, componentAContext);\n-        assertEquals(ConfigStoreResponseStatus.InvalidRequest, response.getStatus());\n-        assertEquals(\"Validation request either timed out or was never made\", response.getErrorMessage());\n-    }\n-}\n", "next_change": {"commit": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "changed_code": [{"header": "diff --git a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\nnew file mode 100644\nindex 0000000000..ddbebccc4b\n--- /dev/null\n+++ b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n", "chunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.aws.iot.evergreen.builtin.services.configstore;\n+\n+import com.aws.iot.evergreen.config.Configuration;\n+import com.aws.iot.evergreen.config.Topic;\n+import com.aws.iot.evergreen.config.Topics;\n+import com.aws.iot.evergreen.dependency.Context;\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.common.BuiltInServiceDestinationCode;\n+import com.aws.iot.evergreen.ipc.common.FrameReader;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreResponseStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreServiceOpCodes;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigurationValidityStatus;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.GetConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SendConfigurationValidityReportResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.SubscribeToConfigurationUpdateResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationRequest;\n+import com.aws.iot.evergreen.ipc.services.configstore.UpdateConfigurationResponse;\n+import com.aws.iot.evergreen.ipc.services.configstore.ValidateConfigurationUpdateEvent;\n+import com.aws.iot.evergreen.kernel.Kernel;\n+import com.aws.iot.evergreen.testcommons.testutilities.EGExtension;\n+import org.hamcrest.collection.IsMapContaining;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.aws.iot.evergreen.kernel.EvergreenService.SERVICES_NAMESPACE_TOPIC;\n+import static com.aws.iot.evergreen.packagemanager.KernelConfigResolver.PARAMETERS_CONFIG_KEY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+\n+@ExtendWith({MockitoExtension.class, EGExtension.class})\n+public class ConfigStoreIPCAgentTest {\n+    private static final String TEST_COMPONENT_A = \"Component_A\";\n+    private static final String TEST_COMPONENT_B = \"Component_B\";\n+    private static final String TEST_CONFIG_KEY_1 = \"temperature\";\n+    private static final String TEST_CONFIG_KEY_2 = \"humidity\";\n+\n+    @Mock\n+    private Kernel kernel;\n+\n+    @Mock\n+    private ExecutorService executor;\n+\n+    @Mock\n+    private ConnectionContext componentAContext;\n+\n+    @Mock\n+    private ConnectionContext componentBContext;\n+\n+    private ConfigStoreIPCAgent agent;\n+\n+    private Configuration configuration;\n+\n+    @BeforeEach\n+    void setup() {\n+        agent = new ConfigStoreIPCAgent(kernel, executor);\n+\n+        configuration = new Configuration(new Context());\n+        Topics root = configuration.getRoot();\n+        root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_1).withValue(20);\n+        root.lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_2).withValue(15);\n+        root.lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_B);\n+        when(kernel.getConfig()).thenReturn(configuration);\n+\n+        lenient().when(componentAContext.getServiceName()).thenReturn(TEST_COMPONENT_A);\n+        lenient().when(componentBContext.getServiceName()).thenReturn(TEST_COMPONENT_B);\n+\n+        agent.postInject();\n+    }\n+\n+    @Test\n+    public void GIVEN_agent_running_WHEN_get_config_request_for_own_config_THEN_return_config_value() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n+        GetConfigurationRequest request =\n+                GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(TEST_CONFIG_KEY_1).build();\n+        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n+        assertEquals(20, response.getValue());\n+    }\n+\n+    @Test\n+    public void GIVEN_agent_running_WHEN_get_config_request_for_cross_component_config_THEN_return_config_value() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n+        GetConfigurationRequest request =\n+                GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(TEST_CONFIG_KEY_2).build();\n+        GetConfigurationResponse response = agent.getConfig(request, componentBContext);\n+        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n+        assertEquals(15, response.getValue());\n+    }\n+\n+    @Test\n+    public void GIVEN_get_config_request_WHEN_key_does_not_exist_THEN_return_config_value() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n+        GetConfigurationRequest request =\n+                GetConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(\"WrongKey\").build();\n+        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.ResourceNotFoundError, response.getStatus());\n+        assertEquals(\"Key not found\", response.getErrorMessage());\n+    }\n+\n+    @Test\n+    public void GIVEN_get_config_request_WHEN_component_requested_does_not_exist_THEN_fail() {\n+        GetConfigurationRequest request =\n+                GetConfigurationRequest.builder().componentName(\"WrongComponent\").key(\"AnyKey\").build();\n+        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.ResourceNotFoundError, response.getStatus());\n+        assertEquals(\"Service not found\", response.getErrorMessage());\n+    }\n+\n+    @Test\n+    public void GIVEN_get_config_request_WHEN_component_requested_does_not_have_configuration_THEN_fail() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_B))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_B));\n+        GetConfigurationRequest request =\n+                GetConfigurationRequest.builder().componentName(TEST_COMPONENT_B).key(\"AnyKey\").build();\n+        GetConfigurationResponse response = agent.getConfig(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.NoConfig, response.getStatus());\n+        assertEquals(\"Service has no dynamic config\", response.getErrorMessage());\n+    }\n+\n+    @Test\n+    public void GIVEN_agent_running_WHEN_update_config_request_THEN_update_config_value() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n+        UpdateConfigurationRequest request =\n+                UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(TEST_CONFIG_KEY_2).newValue(30)\n+                        .timestamp(System.currentTimeMillis()).build();\n+        UpdateConfigurationResponse response = agent.updateConfig(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n+        assertEquals(30,\n+                kernel.findServiceTopic(TEST_COMPONENT_A).find(PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_2).getOnce());\n+    }\n+\n+    @Test\n+    public void GIVEN_update_config_request_WHEN_update_key_does_not_exist_THEN_create_key() {\n+        when(kernel.findServiceTopic(TEST_COMPONENT_A))\n+                .thenReturn(configuration.getRoot().lookupTopics(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A));\n+        UpdateConfigurationRequest request =\n+                UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(\"NewKey\").newValue(\"SomeValue\")\n+                        .timestamp(System.currentTimeMillis()).build();\n+        UpdateConfigurationResponse response = agent.updateConfig(request, componentAContext);\n+        Topic newConfigKeyTopic = kernel.findServiceTopic(TEST_COMPONENT_A).find(PARAMETERS_CONFIG_KEY, \"NewKey\");\n+        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n+        assertNotNull(newConfigKeyTopic);\n+        assertEquals(\"SomeValue\", newConfigKeyTopic.getOnce());\n+    }\n+\n+    @Test\n+    public void GIVEN_update_config_request_WHEN_requested_component_is_not_self_request_THEN_fail() {\n+        UpdateConfigurationRequest request =\n+                UpdateConfigurationRequest.builder().componentName(TEST_COMPONENT_A).key(TEST_CONFIG_KEY_1).newValue(20)\n+                        .timestamp(System.currentTimeMillis()).build();\n+        UpdateConfigurationResponse response = agent.updateConfig(request, componentBContext);\n+        assertEquals(ConfigStoreResponseStatus.InvalidRequest, response.getStatus());\n+        assertEquals(\"Cross component updates are not allowed\", response.getErrorMessage());\n+    }\n+\n+    @Test\n+    public void GIVEN_agent_running_WHEN_subscribe_to_config_update_request_THEN_next_config_update_triggers_event()\n+            throws InterruptedException, IOException {\n+        SubscribeToConfigurationUpdateRequest request =\n+                SubscribeToConfigurationUpdateRequest.builder().componentName(TEST_COMPONENT_A).build();\n+        SubscribeToConfigurationUpdateResponse response = agent.subscribeToConfigUpdate(request, componentBContext);\n+        assertEquals(ConfigStoreResponseStatus.Success, response.getStatus());\n+\n+        CountDownLatch messagePublishedToClient = new CountDownLatch(1);\n+        when(componentBContext.serverPush(anyInt(), any(FrameReader.Message.class))).thenAnswer(invocationOnMock -> {\n+            messagePublishedToClient.countDown();\n+            return new CompletableFuture<>();\n+        });\n+        configuration.getRoot()\n+                .lookup(SERVICES_NAMESPACE_TOPIC, TEST_COMPONENT_A, PARAMETERS_CONFIG_KEY, TEST_CONFIG_KEY_1)\n+                .withValue(25);\n+\n+        assertTrue(messagePublishedToClient.await(10, TimeUnit.SECONDS));\n+        ArgumentCaptor<FrameReader.Message> messageArgumentCaptor = ArgumentCaptor.forClass(FrameReader.Message.class);\n+        verify(componentBContext)\n+                .serverPush(eq(BuiltInServiceDestinationCode.CONFIG_STORE.getValue()), messageArgumentCaptor.capture());\n+        ApplicationMessage message = ApplicationMessage.fromBytes(messageArgumentCaptor.getValue().getPayload());\n+        assertEquals(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), message.getOpCode());\n+        ConfigurationUpdateEvent event = IPCUtil.decode(message.getPayload(), ConfigurationUpdateEvent.class);\n+        assertEquals(TEST_COMPONENT_A, event.getComponentName());\n+        assertEquals(TEST_CONFIG_KEY_1, event.getChangedKey());\n+    }\n+\n+    @Test\n+    public void GIVEN_agent_running_WHEN_subscribe_to_validate_config_request_THEN_validation_event_can_be_triggered()\n+            throws IOException {\n+        assertEquals(ConfigStoreResponseStatus.Success,\n+                agent.subscribeToConfigValidation(componentAContext).getStatus());\n+\n+        Map<String, Object> configToValidate = new HashMap<>();\n+        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n+        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n+\n+        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, new CompletableFuture<>()));\n+        ArgumentCaptor<FrameReader.Message> messageArgumentCaptor = ArgumentCaptor.forClass(FrameReader.Message.class);\n+        verify(componentAContext)\n+                .serverPush(eq(BuiltInServiceDestinationCode.CONFIG_STORE.getValue()), messageArgumentCaptor.capture());\n+        ApplicationMessage message = ApplicationMessage.fromBytes(messageArgumentCaptor.getValue().getPayload());\n+        assertEquals(ConfigStoreServiceOpCodes.VALIDATION_EVENT.ordinal(), message.getOpCode());\n+        ValidateConfigurationUpdateEvent event =\n+                IPCUtil.decode(message.getPayload(), ValidateConfigurationUpdateEvent.class);\n+        assertThat(event.getConfiguration(), IsMapContaining.hasEntry(TEST_CONFIG_KEY_1, 0));\n+        assertThat(event.getConfiguration(), IsMapContaining.hasEntry(TEST_CONFIG_KEY_2, 100));\n+\n+    }\n+\n+    @Test\n+    public void GIVEN_waiting_for_validation_response_WHEN_abandon_validation_event_THEN_succeed() throws IOException {\n+        assertEquals(ConfigStoreResponseStatus.Success,\n+                agent.subscribeToConfigValidation(componentAContext).getStatus());\n+\n+        Map<String, Object> configToValidate = new HashMap<>();\n+        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n+        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n+\n+        CompletableFuture validationTracker = new CompletableFuture<>();\n+        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, validationTracker));\n+\n+        assertTrue(agent.discardValidationReportTracker(TEST_COMPONENT_A, validationTracker));\n+    }\n+\n+    @Test\n+    public void GIVEN_validation_event_being_tracked_WHEN_send_config_validity_report_request_THEN_notify_validation_requester()\n+            throws ExecutionException, InterruptedException {\n+        assertEquals(ConfigStoreResponseStatus.Success,\n+                agent.subscribeToConfigValidation(componentAContext).getStatus());\n+\n+        Map<String, Object> configToValidate = new HashMap<>();\n+        configToValidate.put(TEST_CONFIG_KEY_1, 0);\n+        configToValidate.put(TEST_CONFIG_KEY_2, 100);\n+\n+        CompletableFuture<ConfigStoreIPCAgent.ConfigurationValidityReport> validationTracker =\n+                new CompletableFuture<>();\n+        assertTrue(agent.validateConfiguration(TEST_COMPONENT_A, configToValidate, validationTracker));\n+\n+        SendConfigurationValidityReportRequest reportRequest =\n+                SendConfigurationValidityReportRequest.builder().status(ConfigurationValidityStatus.VALID).build();\n+        assertEquals(ConfigStoreResponseStatus.Success,\n+                agent.handleConfigValidityReport(reportRequest, componentAContext).getStatus());\n+\n+        assertTrue(validationTracker.isDone());\n+        assertEquals(ConfigurationValidityStatus.VALID, validationTracker.get().getStatus());\n+    }\n+\n+    @Test\n+    public void GIVEN_no_validation_event_is_tracked_WHEN_send_config_validity_report_request_THEN_fail() {\n+        SendConfigurationValidityReportRequest request =\n+                SendConfigurationValidityReportRequest.builder().status(ConfigurationValidityStatus.VALID).build();\n+        SendConfigurationValidityReportResponse response = agent.handleConfigValidityReport(request, componentAContext);\n+        assertEquals(ConfigStoreResponseStatus.InvalidRequest, response.getStatus());\n+        assertEquals(\"Validation request either timed out or was never made\", response.getErrorMessage());\n+    }\n+}\n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\nindex ddbebccc4b..0919de0ba4 100644\n--- a/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n+++ b/src/test/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgentTest.java\n", "chunk": "@@ -281,8 +277,10 @@ public class ConfigStoreIPCAgentTest {\n \n     @Test\n     public void GIVEN_no_validation_event_is_tracked_WHEN_send_config_validity_report_request_THEN_fail() {\n-        SendConfigurationValidityReportRequest request =\n-                SendConfigurationValidityReportRequest.builder().status(ConfigurationValidityStatus.VALID).build();\n+        SendConfigurationValidityReportRequest request = SendConfigurationValidityReportRequest.builder()\n+                .configurationValidityReport(\n+                        ConfigurationValidityReport.builder().status(ConfigurationValidityStatus.VALID).build())\n+                .build();\n         SendConfigurationValidityReportResponse response = agent.handleConfigValidityReport(request, componentAContext);\n         assertEquals(ConfigStoreResponseStatus.InvalidRequest, response.getStatus());\n         assertEquals(\"Validation request either timed out or was never made\", response.getErrorMessage());\n", "next_change": null}]}}]}}]}}]}}]}}, {"oid": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/0eada4e4c5d2644f516058f34a4f43a9472fbc58", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-09T03:45:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjUyNw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532527", "body": "I changed this but forgot to remove this comment", "bodyText": "I changed this but forgot to remove this comment", "bodyHTML": "<p dir=\"auto\">I changed this but forgot to remove this comment</p>", "author": "shaguptashaikh", "createdAt": "2020-08-09T03:56:32Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,177 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        // Sends an event immediately after", "originalCommit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex d4e0647f14..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -103,7 +103,6 @@ public class ConfigStoreIPCAgent {\n                     \"Requested configuration key does not exist\");\n         }\n \n-        // Sends an event immediately after\n         Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n         if (!watcher.isPresent()) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n", "next_change": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -88,27 +89,31 @@ public class ConfigStoreIPCAgent {\n         Topics serviceTopics = kernel.findServiceTopic(componentName);\n         if (serviceTopics == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested component does not exist\");\n+                    \"Key not found\");\n         }\n \n         Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         if (configurationTopics == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested component does not have any configuration\");\n+                    \"Key not found\");\n         }\n \n         Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n         if (subscribeTo == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested configuration key does not exist\");\n+                    \"Key not found\");\n         }\n \n+        // TODO : Does not dedupe, need more details on the requirement\n         Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n         if (!watcher.isPresent()) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n                     \"Could not register update subscriber\");\n         }\n \n+        // TODO: How do users de-register? We need a signal for this on which we can clean up watchers\n+        //  from the config store. What will be the onDisconnect equivalent in the new protocol and\n+        //  are there any differences in how to handle it vs how it is today i.e. done like below\n         context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -98,47 +96,31 @@ public class ConfigStoreIPCAgent {\n                     \"Key not found\");\n         }\n \n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n         if (subscribeTo == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n                     \"Key not found\");\n         }\n \n-        // TODO : Does not dedupe, need more details on the requirement\n         Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n         if (!watcher.isPresent()) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n                     \"Could not register update subscriber\");\n         }\n \n-        // TODO: How do users de-register? We need a signal for this on which we can clean up watchers\n-        //  from the config store. What will be the onDisconnect equivalent in the new protocol and\n-        //  are there any differences in how to handle it vs how it is today i.e. done like below\n         context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (!Utils.isEmpty(keyName)) {\n-            String[] keyPath = parseKeyPath(keyName);\n-            subscribeTo = configurationTopics.findNode(keyPath);\n+        if (keyPath != null && keyPath.size() > 0) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n         }\n         return subscribeTo;\n     }\n \n-    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n-    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n-    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n-    //  keeping this as a TODO while the decision is made\n-    private String[] parseKeyPath(String key) {\n-        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n-            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n-        }\n-        return new String[] {key};\n-    }\n-\n     private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n         if (subscribeTo instanceof Topics) {\n             ChildChanged childChanged =\n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -115,8 +118,8 @@ public class ConfigStoreIPCAgent {\n \n     private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n+        if (keyPath != null && keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n         }\n         return subscribeTo;\n     }\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -87,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.isEmpty()) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjM1Nw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467532357", "body": "pass in the version too", "bodyText": "pass in the version too", "bodyHTML": "<p dir=\"auto\">pass in the version too</p>", "author": "MikeDombo", "createdAt": "2020-08-09T03:53:48Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)", "originalCommit": "0eada4e4c5d2644f516058f34a4f43a9472fbc58", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nindex d1c51b6a34..6aff78d043 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -27,24 +26,24 @@ public class ServiceEventHelper {\n     ExecutorService executor;\n \n     /**\n-     * Send requested event to requested IPC channel.\n+     * Asynchronously sends requested event to requested IPC channel.\n      *\n      * @param connectionContext client connection context\n-     * @param serviceEvent event data\n-     * @param destinationCode service destination code to denote the source of the event\n-     * @param opCode op code\n+     * @param serviceEvent      event data\n+     * @param destinationCode   service destination code to denote the source of the event\n+     * @param opCode            op code\n+     * @return Future for send event task\n      */\n-    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n-                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n-        try {\n-            ApplicationMessage applicationMessage =\n-                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n-                            .payload(IPCUtil.encode(serviceEvent)).build();\n-            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-            Future<FrameReader.Message> fut = connectionContext\n-                    .serverPush(destinationCode.getValue(), new FrameReader.Message(applicationMessage.toByteArray()));\n-            // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-            executor.execute(() -> {\n+    public Future<?> sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                      BuiltInServiceDestinationCode destinationCode, int opCode, int apiVersion) {\n+        return executor.submit(() -> {\n+            try {\n+                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(apiVersion).opCode(opCode)\n+                        .payload(IPCUtil.encode(serviceEvent)).build();\n+\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut = connectionContext.serverPush(destinationCode.getValue(),\n+                        new FrameReader.Message(applicationMessage.toByteArray()));\n                 try {\n                     fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n                     // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\ndeleted file mode 100644\nindex 6aff78d043..0000000000\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-package com.aws.iot.evergreen.ipc.common;\n-\n-import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.logging.api.Logger;\n-import com.aws.iot.evergreen.logging.impl.LogManager;\n-import lombok.AllArgsConstructor;\n-import lombok.NoArgsConstructor;\n-\n-import java.io.IOException;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import javax.inject.Inject;\n-\n-@NoArgsConstructor\n-@AllArgsConstructor\n-public class ServiceEventHelper {\n-    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n-    private static final int TIMEOUT_SECONDS = 30;\n-\n-    @Inject\n-    ExecutorService executor;\n-\n-    /**\n-     * Asynchronously sends requested event to requested IPC channel.\n-     *\n-     * @param connectionContext client connection context\n-     * @param serviceEvent      event data\n-     * @param destinationCode   service destination code to denote the source of the event\n-     * @param opCode            op code\n-     * @return Future for send event task\n-     */\n-    public Future<?> sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n-                                      BuiltInServiceDestinationCode destinationCode, int opCode, int apiVersion) {\n-        return executor.submit(() -> {\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(apiVersion).opCode(opCode)\n-                        .payload(IPCUtil.encode(serviceEvent)).build();\n-\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = connectionContext.serverPush(destinationCode.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-                try {\n-                    fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                    // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                    // Log\n-                    log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                            .log(\"Error sending config store update to client\", e);\n-                }\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nnew file mode 100644\nindex 0000000000..d1c51b6a34\n--- /dev/null\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n+                            .payload(IPCUtil.encode(serviceEvent)).build();\n+            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            Future<FrameReader.Message> fut = connectionContext\n+                    .serverPush(destinationCode.getValue(), new FrameReader.Message(applicationMessage.toByteArray()));\n+            // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+            executor.execute(() -> {\n+                try {\n+                    fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                    // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                    // Log\n+                    log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                            .log(\"Error sending config store update to client\", e);\n+                }\n+            });\n+\n+        } catch (IOException e) {\n+            // Log\n+            log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                    .log(\"Error sending config store update to client\", e);\n+        }\n+    }\n+}\n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nindex d1c51b6a34..6aff78d043 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -53,12 +52,11 @@ public class ServiceEventHelper {\n                     log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n                             .log(\"Error sending config store update to client\", e);\n                 }\n-            });\n-\n-        } catch (IOException e) {\n-            // Log\n-            log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                    .log(\"Error sending config store update to client\", e);\n-        }\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n+        });\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"oid": "21d36db9c58cff65320dc91184a2dab2b057cc32", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/21d36db9c58cff65320dc91184a2dab2b057cc32", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-09T04:04:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTUyOQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629529", "body": "Nice, this can be used by all ipc components\r\n\r\ndo the server push also with the executor thread? Since this will run by the publish thread, we should avoid doing IO. Also can we return the future so called can handle if the sendEvent failed. The caller might not use it always but is a nice to have", "bodyText": "Nice, this can be used by all ipc components\ndo the server push also with the executor thread? Since this will run by the publish thread, we should avoid doing IO. Also can we return the future so called can handle if the sendEvent failed. The caller might not use it always but is a nice to have", "bodyHTML": "<p dir=\"auto\">Nice, this can be used by all ipc components</p>\n<p dir=\"auto\">do the server push also with the executor thread? Since this will run by the publish thread, we should avoid doing IO. Also can we return the future so called can handle if the sendEvent failed. The caller might not use it always but is a nice to have</p>", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:14:28Z", "path": "src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n+                            .payload(IPCUtil.encode(serviceEvent)).build();\n+            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            Future<FrameReader.Message> fut = connectionContext", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nindex d1c51b6a34..6aff78d043 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -27,24 +26,24 @@ public class ServiceEventHelper {\n     ExecutorService executor;\n \n     /**\n-     * Send requested event to requested IPC channel.\n+     * Asynchronously sends requested event to requested IPC channel.\n      *\n      * @param connectionContext client connection context\n-     * @param serviceEvent event data\n-     * @param destinationCode service destination code to denote the source of the event\n-     * @param opCode op code\n+     * @param serviceEvent      event data\n+     * @param destinationCode   service destination code to denote the source of the event\n+     * @param opCode            op code\n+     * @return Future for send event task\n      */\n-    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n-                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n-        try {\n-            ApplicationMessage applicationMessage =\n-                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n-                            .payload(IPCUtil.encode(serviceEvent)).build();\n-            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-            Future<FrameReader.Message> fut = connectionContext\n-                    .serverPush(destinationCode.getValue(), new FrameReader.Message(applicationMessage.toByteArray()));\n-            // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-            executor.execute(() -> {\n+    public Future<?> sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                      BuiltInServiceDestinationCode destinationCode, int opCode, int apiVersion) {\n+        return executor.submit(() -> {\n+            try {\n+                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(apiVersion).opCode(opCode)\n+                        .payload(IPCUtil.encode(serviceEvent)).build();\n+\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut = connectionContext.serverPush(destinationCode.getValue(),\n+                        new FrameReader.Message(applicationMessage.toByteArray()));\n                 try {\n                     fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n                     // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\ndeleted file mode 100644\nindex 6aff78d043..0000000000\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ /dev/null\n", "chunk": "@@ -1,62 +0,0 @@\n-package com.aws.iot.evergreen.ipc.common;\n-\n-import com.aws.iot.evergreen.ipc.ConnectionContext;\n-import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n-import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n-import com.aws.iot.evergreen.logging.api.Logger;\n-import com.aws.iot.evergreen.logging.impl.LogManager;\n-import lombok.AllArgsConstructor;\n-import lombok.NoArgsConstructor;\n-\n-import java.io.IOException;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import javax.inject.Inject;\n-\n-@NoArgsConstructor\n-@AllArgsConstructor\n-public class ServiceEventHelper {\n-    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n-    private static final int TIMEOUT_SECONDS = 30;\n-\n-    @Inject\n-    ExecutorService executor;\n-\n-    /**\n-     * Asynchronously sends requested event to requested IPC channel.\n-     *\n-     * @param connectionContext client connection context\n-     * @param serviceEvent      event data\n-     * @param destinationCode   service destination code to denote the source of the event\n-     * @param opCode            op code\n-     * @return Future for send event task\n-     */\n-    public Future<?> sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n-                                      BuiltInServiceDestinationCode destinationCode, int opCode, int apiVersion) {\n-        return executor.submit(() -> {\n-            try {\n-                ApplicationMessage applicationMessage = ApplicationMessage.builder().version(apiVersion).opCode(opCode)\n-                        .payload(IPCUtil.encode(serviceEvent)).build();\n-\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut = connectionContext.serverPush(destinationCode.getValue(),\n-                        new FrameReader.Message(applicationMessage.toByteArray()));\n-                try {\n-                    fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                    // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                    // Log\n-                    log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                            .log(\"Error sending config store update to client\", e);\n-                }\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n-        });\n-    }\n-}\n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nnew file mode 100644\nindex 0000000000..d1c51b6a34\n--- /dev/null\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -0,0 +1,64 @@\n+package com.aws.iot.evergreen.ipc.common;\n+\n+import com.aws.iot.evergreen.ipc.ConnectionContext;\n+import com.aws.iot.evergreen.ipc.services.common.ApplicationMessage;\n+import com.aws.iot.evergreen.ipc.services.common.IPCUtil;\n+import com.aws.iot.evergreen.ipc.services.configstore.ConfigStoreImpl;\n+import com.aws.iot.evergreen.logging.api.Logger;\n+import com.aws.iot.evergreen.logging.impl.LogManager;\n+import lombok.AllArgsConstructor;\n+import lombok.NoArgsConstructor;\n+\n+import java.io.IOException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import javax.inject.Inject;\n+\n+@NoArgsConstructor\n+@AllArgsConstructor\n+public class ServiceEventHelper {\n+    private static final Logger log = LogManager.getLogger(ServiceEventHelper.class);\n+    private static final int TIMEOUT_SECONDS = 30;\n+\n+    @Inject\n+    ExecutorService executor;\n+\n+    /**\n+     * Send requested event to requested IPC channel.\n+     *\n+     * @param connectionContext client connection context\n+     * @param serviceEvent event data\n+     * @param destinationCode service destination code to denote the source of the event\n+     * @param opCode op code\n+     */\n+    public void sendServiceEvent(ConnectionContext connectionContext, ServiceEvent serviceEvent,\n+                                 BuiltInServiceDestinationCode destinationCode, int opCode) {\n+        try {\n+            ApplicationMessage applicationMessage =\n+                    ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION).opCode(opCode)\n+                            .payload(IPCUtil.encode(serviceEvent)).build();\n+            // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+            Future<FrameReader.Message> fut = connectionContext\n+                    .serverPush(destinationCode.getValue(), new FrameReader.Message(applicationMessage.toByteArray()));\n+            // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+            executor.execute(() -> {\n+                try {\n+                    fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                    // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                    // Log\n+                    log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                            .log(\"Error sending config store update to client\", e);\n+                }\n+            });\n+\n+        } catch (IOException e) {\n+            // Log\n+            log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                    .log(\"Error sending config store update to client\", e);\n+        }\n+    }\n+}\n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\nindex d1c51b6a34..6aff78d043 100644\n--- a/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n+++ b/src/main/java/com/aws/iot/evergreen/ipc/common/ServiceEventHelper.java\n", "chunk": "@@ -53,12 +52,11 @@ public class ServiceEventHelper {\n                     log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n                             .log(\"Error sending config store update to client\", e);\n                 }\n-            });\n-\n-        } catch (IOException e) {\n-            // Log\n-            log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n-                    .log(\"Error sending config store update to client\", e);\n-        }\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", connectionContext)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n+        });\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYyOTk5Ng==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467629996", "body": "This is leaking info about what components are present, from a security stand point we should always return key not found. Same goes for \"Requested component does not have any configuration\". Not sure how relevant this is right now, but changing it now might help in the future", "bodyText": "This is leaking info about what components are present, from a security stand point we should always return key not found. Same goes for \"Requested component does not have any configuration\". Not sure how relevant this is right now, but changing it now might help in the future", "bodyHTML": "<p dir=\"auto\">This is leaking info about what components are present, from a security stand point we should always return key not found. Same goes for \"Requested component does not have any configuration\". Not sure how relevant this is right now, but changing it now might help in the future</p>", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:19:33Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -88,27 +89,31 @@ public class ConfigStoreIPCAgent {\n         Topics serviceTopics = kernel.findServiceTopic(componentName);\n         if (serviceTopics == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested component does not exist\");\n+                    \"Key not found\");\n         }\n \n         Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         if (configurationTopics == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested component does not have any configuration\");\n+                    \"Key not found\");\n         }\n \n         Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n         if (subscribeTo == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    \"Requested configuration key does not exist\");\n+                    \"Key not found\");\n         }\n \n+        // TODO : Does not dedupe, need more details on the requirement\n         Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n         if (!watcher.isPresent()) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n                     \"Could not register update subscriber\");\n         }\n \n+        // TODO: How do users de-register? We need a signal for this on which we can clean up watchers\n+        //  from the config store. What will be the onDisconnect equivalent in the new protocol and\n+        //  are there any differences in how to handle it vs how it is today i.e. done like below\n         context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n", "next_change": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -98,47 +96,31 @@ public class ConfigStoreIPCAgent {\n                     \"Key not found\");\n         }\n \n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n         if (subscribeTo == null) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n                     \"Key not found\");\n         }\n \n-        // TODO : Does not dedupe, need more details on the requirement\n         Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n         if (!watcher.isPresent()) {\n             return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n                     \"Could not register update subscriber\");\n         }\n \n-        // TODO: How do users de-register? We need a signal for this on which we can clean up watchers\n-        //  from the config store. What will be the onDisconnect equivalent in the new protocol and\n-        //  are there any differences in how to handle it vs how it is today i.e. done like below\n         context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (!Utils.isEmpty(keyName)) {\n-            String[] keyPath = parseKeyPath(keyName);\n-            subscribeTo = configurationTopics.findNode(keyPath);\n+        if (keyPath != null && keyPath.size() > 0) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n         }\n         return subscribeTo;\n     }\n \n-    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n-    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n-    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n-    //  keeping this as a TODO while the decision is made\n-    private String[] parseKeyPath(String key) {\n-        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n-            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n-        }\n-        return new String[] {key};\n-    }\n-\n     private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n         if (subscribeTo instanceof Topics) {\n             ChildChanged childChanged =\n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -115,8 +118,8 @@ public class ConfigStoreIPCAgent {\n \n     private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n+        if (keyPath != null && keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n         }\n         return subscribeTo;\n     }\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -87,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.isEmpty()) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYzMTA3NA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r467631074", "body": "+1 for string arrays.", "bodyText": "+1 for string arrays.", "bodyHTML": "<p dir=\"auto\">+1 for string arrays.</p>", "author": "fahadmohammed01", "createdAt": "2020-08-09T21:31:32Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +52,176 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String CONFIGURATION_KEY_PATH_DELIMITER = \".\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user. Immediately sends the current state to the client.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {", "originalCommit": "21d36db9c58cff65320dc91184a2dab2b057cc32", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -114,26 +113,14 @@ public class ConfigStoreIPCAgent {\n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (!Utils.isEmpty(keyName)) {\n-            String[] keyPath = parseKeyPath(keyName);\n-            subscribeTo = configurationTopics.findNode(keyPath);\n+        if (keyPath != null && keyPath.size() > 0) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n         }\n         return subscribeTo;\n     }\n \n-    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n-    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n-    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n-    //  keeping this as a TODO while the decision is made\n-    private String[] parseKeyPath(String key) {\n-        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n-            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n-        }\n-        return new String[] {key};\n-    }\n-\n     private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n         if (subscribeTo instanceof Topics) {\n             ChildChanged childChanged =\n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -115,8 +118,8 @@ public class ConfigStoreIPCAgent {\n \n     private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n         Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.size() > 0) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[keyPath.size()]));\n+        if (keyPath != null && keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n         }\n         return subscribeTo;\n     }\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -87,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && keyPath.isEmpty()) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}]}}]}}, {"oid": "06ea9776f2584626db3feffbab6dbb09ff463b69", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/06ea9776f2584626db3feffbab6dbb09ff463b69", "message": "Address comments add more open questions as TODOs", "committedDate": "2020-08-10T16:42:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470166408", "body": "withNewerValue() will not change the value if the request timestamp is less than the topics last modified timestamp. We should return that information back to the callee rather than report success.", "bodyText": "withNewerValue() will not change the value if the request timestamp is less than the topics last modified timestamp. We should return that information back to the callee rather than report success.", "bodyHTML": "<p dir=\"auto\">withNewerValue() will not change the value if the request timestamp is less than the topics last modified timestamp. We should return that information back to the callee rather than report success.</p>", "author": "fahadmohammed01", "createdAt": "2020-08-13T18:38:16Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -170,4 +238,154 @@ public ConfigStoreReadValueResponse read(ConfigStoreReadValueRequest readRequest\n \n         return response.build();\n     }\n+\n+    /**\n+     * Update specified key in the service's configuration.\n+     *\n+     * @param request update config request\n+     * @param context client context\n+     * @return response data\n+     */\n+    public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n+        }\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());", "originalCommit": "06ea9776f2584626db3feffbab6dbb09ff463b69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI0NjIxMw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470246213", "bodyText": "It may or may not be needed. Basically withNewerValue() abstract the timestamp comparison and doesn't throw any exception if the update didn't take effect due to an older proposed timestamp. We can still explicitly compare if after the call the node has the proposed value and modtime, it can be done later if we think it is needed", "author": "shaguptashaikh", "createdAt": "2020-08-13T21:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3NTE1NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470375155", "bodyText": "Update - Incorporated this change while adding compare with swap update", "author": "shaguptashaikh", "createdAt": "2020-08-14T02:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NjQwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -266,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "647576c1f224d6603cec83e06225b81e8738162e", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "96005264f317b738b3a10e836112b85cc4ad0a6b", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2fecb78023..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -224,66 +224,26 @@ public class ConfigStoreIPCAgent {\n     }\n \n     /**\n-     * Update specified key in the service's configuration.\n+     * Update specified key in the service's runtime config.\n      *\n      * @param request update config request\n      * @param context client context\n      * @return response data\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n-        log.atDebug().kv(CONTEXT_LOGGING_KEY, context).log(\"Config IPC config update request\");\n+        log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n-\n-        if (Utils.isEmpty(request.getKeyPath())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+        if (serviceTopic == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cross component updates are not allowed\").build();\n-        }\n-\n-        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopics == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n-                    .errorMessage(\"Service config not found\").build();\n-        }\n-        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = request.getKeyPath().toArray(new String[0]);\n-        Node node = configTopics.findNode(keyPath);\n-        if (node == null) {\n-            configTopics.lookup(keyPath).withValue(request.getNewValue());\n-            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n-        }\n-        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n-        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n-        //  nested config support at the component recipe and deployment level is hashed out.\n-        if (node instanceof Topics) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n-                    .errorMessage(\"Cannot update a \" + \"non-leaf config node\").build();\n-        }\n-        if (!(node instanceof Topic)) {\n-            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n-            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n-        }\n-        Topic topic = (Topic) node;\n-\n-        // Perform compare and swap if the customer has specified current value to compare\n-        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n-                    .build();\n-        }\n-\n-        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n-        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n-                .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n-                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n-        }\n+        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+                .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n+\n         return response.build();\n     }\n \n", "next_change": {"commit": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..e1645a1057 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -232,14 +212,21 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n+\n+        if (!context.getServiceName().equals(request.getComponentName())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n+                    .errorMessage(\"Cross component \" + \"updates are not allowed\").build();\n+        }\n+\n+        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n                     .build();\n         }\n \n-        serviceTopic.lookup(RUNTIME_STORE_NAMESPACE_TOPIC, request.getKey())\n+        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n                 .withNewerValue(request.getTimestamp(), request.getValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e1645a1057..755e9b3038 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -227,7 +235,7 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         }\n \n         serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getValue());\n+                .withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 755e9b3038..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -220,22 +243,26 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n      */\n     public UpdateConfigurationResponse updateConfig(UpdateConfigurationRequest request, ConnectionContext context) {\n         log.atDebug().kv(\"context\", context).log(\"Config IPC config update request\");\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n         UpdateConfigurationResponse.UpdateConfigurationResponseBuilder response = UpdateConfigurationResponse.builder();\n \n-        if (!context.getServiceName().equals(request.getComponentName())) {\n+        if (request.getKey() == null) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Key is required\")\n+                    .build();\n+        }\n+\n+        if (request.getComponentName() != null && !context.getServiceName().equals(request.getComponentName())) {\n             return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest)\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n         Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n         if (serviceTopic == null) {\n-            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Service not found\")\n-                    .build();\n+            return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n+                    .errorMessage(\"Service config not found\").build();\n         }\n-\n-        serviceTopic.lookup(PARAMETERS_CONFIG_KEY, request.getKey())\n-                .withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        String[] keyPath = parseKeyPath(request.getKey());\n+        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -261,7 +247,7 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Service config not found\").build();\n         }\n         Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        String[] keyPath = parseKeyPath(request.getKey());\n+        String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n         configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": {"commit": "2fcea893248454e36733ab3403d7b3f9c9f63657", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex ae4e2d44fa..01c80eba6d 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -241,17 +241,46 @@ public class ConfigStoreIPCAgent {\n                     .errorMessage(\"Cross component updates are not allowed\").build();\n         }\n \n-        Topics serviceTopic = kernel.findServiceTopic(context.getServiceName());\n-        if (serviceTopic == null) {\n+        Topics serviceTopics = kernel.findServiceTopic(context.getServiceName());\n+        if (serviceTopics == null) {\n             return response.responseStatus(ConfigStoreResponseStatus.InternalError)\n                     .errorMessage(\"Service config not found\").build();\n         }\n-        Topics configTopic = serviceTopic.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        Topics configTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n         String[] keyPath = request.getKeyPath().toArray(new String[request.getKeyPath().size()]);\n-        configTopic.lookup(keyPath).withNewerValue(request.getTimestamp(), request.getNewValue());\n+        Node node = configTopics.findNode(keyPath);\n+        if (node == null) {\n+            configTopics.lookup(keyPath).withValue(request.getNewValue());\n+            return response.responseStatus(ConfigStoreResponseStatus.Success).build();\n+        }\n+        // TODO : Does not support updating internal nodes, at least yet, will need to decide if that\n+        //  should be a merge/replace or a choice for customers to make. We'll gain clarity once\n+        //  nested config support at the component recipe and deployment level is hashed out.\n+        if (node instanceof Topics) {\n+            return response.responseStatus(ConfigStoreResponseStatus.InvalidRequest).errorMessage(\"Cannot update a \"\n+                    + \"non-leaf config node\").build();\n+        }\n+        if (!(node instanceof Topic)) {\n+            response.responseStatus(ConfigStoreResponseStatus.InternalError).errorMessage(\"Node has an unknown type\");\n+            log.atError().log(\"Somehow Node has an unknown type {}\", node.getClass());\n+        }\n+        Topic topic = (Topic) node;\n \n-        response.responseStatus(ConfigStoreResponseStatus.Success);\n+        // Perform compare and swap if the customer has specified current value to compare\n+        if (request.getCurrentValue() != null && !request.getCurrentValue().equals(topic.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Current value for config is different from the current value needed for the update\")\n+                    .build();\n+        }\n \n+        Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n+        if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n+                .equals(updatedNode.getOnce())) {\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n+                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+        }\n+\n+        response.responseStatus(ConfigStoreResponseStatus.Success);\n         return response.build();\n     }\n \n", "next_change": {"commit": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 01c80eba6d..2fecb78023 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -276,8 +279,8 @@ public class ConfigStoreIPCAgent {\n         Topic updatedNode = topic.withNewerValue(request.getTimestamp(), request.getNewValue());\n         if (request.getTimestamp() != updatedNode.getModtime() && !request.getNewValue()\n                 .equals(updatedNode.getOnce())) {\n-            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck).errorMessage(\n-                    \"Proposed timestamp is older than the config's latest modified timestamp\").build();\n+            return response.responseStatus(ConfigStoreResponseStatus.FailedUpdateConditionCheck)\n+                    .errorMessage(\"Proposed timestamp is older than the config's latest modified timestamp\").build();\n         }\n \n         response.responseStatus(ConfigStoreResponseStatus.Success);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}, {"oid": "ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/ab0e0ccc2ebb33bb738c2bdb117beb9704e7a44a", "message": "Implemented TODOs for previously open/now resolved questions", "committedDate": "2020-08-13T20:46:32Z", "type": "forcePushed"}, {"oid": "647576c1f224d6603cec83e06225b81e8738162e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/647576c1f224d6603cec83e06225b81e8738162e", "message": "Support compare and swap update", "committedDate": "2020-08-14T02:23:16Z", "type": "forcePushed"}, {"oid": "96005264f317b738b3a10e836112b85cc4ad0a6b", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/96005264f317b738b3a10e836112b85cc4ad0a6b", "message": "Make checkstyle and pmd happy", "committedDate": "2020-08-14T05:41:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470836865", "body": "Initialize to null? as you are doing a null check where it is being called.", "bodyText": "Initialize to null? as you are doing a null check where it is being called.", "bodyHTML": "<p dir=\"auto\">Initialize to null? as you are doing a null check where it is being called.</p>", "author": "abanthiy", "createdAt": "2020-08-14T19:53:58Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;", "originalCommit": "4053d8d291511f5087460f3ea17fd05dd88045f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MTU2OQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470881569", "bodyText": "This call configurationTopics.findNode(keyPath.toArray(new String[0])); on line 122 below can return null and change a non null value to null which is why I did it this way", "author": "shaguptashaikh", "createdAt": "2020-08-14T21:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MzQ1Mw==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470883453", "bodyText": "oh right and you want to setup the subscription for the whole config if key path is not specified. Looks good then", "author": "abanthiy", "createdAt": "2020-08-14T22:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzNjg2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2f64c16a4b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -87,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && !keyPath.isEmpty()) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzODgyMA==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470838820", "body": "Dead code? If not needed, may remove the check watcher.isPresent() in the calling method.", "bodyText": "Dead code? If not needed, may remove the check watcher.isPresent() in the calling method.", "bodyHTML": "<p dir=\"auto\">Dead code? If not needed, may remove the check watcher.isPresent() in the calling method.</p>", "author": "abanthiy", "createdAt": "2020-08-14T19:58:36Z", "path": "src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java", "diffHunk": "@@ -37,128 +53,164 @@\n /**\n  * Class to handle business logic for all ConfigStore requests over IPC.\n  */\n-public class ConfigStoreIPCAgent implements InjectionActions {\n-    // Map from connection --> Function to call when service config changes\n-    private static final Map<ConnectionContext, Consumer<String>> listeners = new ConcurrentHashMap<>();\n-    private static final int TIMEOUT_SECONDS = 30;\n+@NoArgsConstructor\n+@AllArgsConstructor(access = AccessLevel.PACKAGE)\n+public class ConfigStoreIPCAgent {\n+    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    private static final String KEY_NOT_FOUND_ERROR_MESSAGE = \"Key not found\";\n+    private static final String CONTEXT_LOGGING_KEY = \"context\";\n+\n+    // Map from connection --> Function to call for triggering config validation events\n+    private final Map<ConnectionContext, Consumer<Map<String, Object>>> configValidationListeners =\n+            new ConcurrentHashMap<>();\n+    // Map of component --> future to complete with validation status received from service in response to validate\n+    // event\n+    private final Map<String, CompletableFuture<ConfigurationValidityReport>> configValidationReportFutures =\n+            new ConcurrentHashMap<>();\n \n     @Inject\n     private Kernel kernel;\n \n     @Inject\n-    private ExecutorService executor;\n+    private ServiceEventHelper serviceEventHelper;\n \n-    private static final Logger log = LogManager.getLogger(ConfigStoreIPCAgent.class);\n+    /**\n+     * Handle the subscription request from the user.\n+     *\n+     * @param request request for component update subscription\n+     * @param context connection context\n+     * @return response code Success if all went well\n+     */\n+    public SubscribeToConfigurationUpdateResponse subscribeToConfigUpdate(SubscribeToConfigurationUpdateRequest request,\n+                                                                          ConnectionContext context) {\n+        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n+        String componentName =\n+                request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-    private final ChildChanged onConfigChange = (whatHappened, node) -> {\n-        if (node == null) {\n-            return;\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        String serviceName = Kernel.findServiceForNode(node);\n-        // Ensure a the node that changed belongs to a service\n-        if (serviceName == null) {\n-            return;\n+\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n \n-        String[] nodePath = node.path();\n-        // The path should have at least 4 items: services, serviceName, custom, <someKey>\n-        if (nodePath.length < 4) {\n-            return;\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    KEY_NOT_FOUND_ERROR_MESSAGE);\n         }\n-        // Ensure that the node which changed was part of the custom config\n-        int customConfigIndex = 2;\n-        if (!PARAMETERS_CONFIG_KEY.equals(nodePath[customConfigIndex])) {\n-            return;\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n         }\n \n-        listeners.entrySet().stream().filter(e -> e.getKey().getServiceName().equals(serviceName))\n-                .map(Map.Entry::getValue).forEach(c -> c.accept(nodePath[customConfigIndex + 1]));\n-    };\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n-    @Override\n-    public void postInject() {\n-        kernel.getConfig().getRoot().subscribe(onConfigChange);\n+        return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    /**\n-     * Handle the subscription request from the user. Immediately sends the current state to the client.\n-     *\n-     * @param context connection context\n-     * @return response code Success if all went well\n-     */\n-    public ConfigStoreGenericResponse subscribe(ConnectionContext context) {\n-        // TODO: Input validation. https://sim.amazon.com/issues/P32540011\n-        listeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> listeners.remove(context));\n-            return sendStoreUpdateToListener(context);\n-        });\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n+        Node subscribeTo = configurationTopics;\n+        if (keyPath != null && !keyPath.isEmpty()) {\n+            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n+        }\n+        return subscribeTo;\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n \n-        return new ConfigStoreGenericResponse(ConfigStoreResponseStatus.Success, null);\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();", "originalCommit": "4053d8d291511f5087460f3ea17fd05dd88045f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg4MDg3MQ==", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/pull/346#discussion_r470880871", "bodyText": "It's logically dead code because we will never have a situation where a node is neither a Topic instance nor a Topics instance, but theoretically it's possible for this piece of code because of which the compiler complains if I remove this return statement", "author": "shaguptashaikh", "createdAt": "2020-08-14T21:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDgzODgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "a197e2f42f728d7d18772483a5b9069198b6c816", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 2f64c16a4b..e674ca4227 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -87,88 +118,57 @@ public class ConfigStoreIPCAgent {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        Topics serviceTopics = kernel.findServiceTopic(componentName);\n-        if (serviceTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n-        if (configurationTopics == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyPath());\n-        if (subscribeTo == null) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n-                    KEY_NOT_FOUND_ERROR_MESSAGE);\n-        }\n-\n-        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n-        if (!watcher.isPresent()) {\n-            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n-                    \"Could not register update subscriber\");\n-        }\n+        configUpdateListeners.computeIfAbsent(context, (key) -> {\n+            context.onDisconnect(() -> configUpdateListeners.remove(context));\n+            return sendStoreUpdateToListener(context, componentName);\n+        });\n \n-        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n+        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n+        configUpdateSubscribersByService.get(componentName).add(context);\n+        context.onDisconnect(() -> {\n+            configUpdateSubscribersByService.entrySet().forEach(e -> {\n+                if (e.getValue().contains(context)) {\n+                    e.getValue().remove(context);\n+                }\n+            });\n+        });\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Node getNodeToSubscribeTo(Topics configurationTopics, List<String> keyPath) {\n-        Node subscribeTo = configurationTopics;\n-        if (keyPath != null && !keyPath.isEmpty()) {\n-            subscribeTo = configurationTopics.findNode(keyPath.toArray(new String[0]));\n-        }\n-        return subscribeTo;\n-    }\n-\n-    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n-        if (subscribeTo instanceof Topics) {\n-            ChildChanged childChanged =\n-                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n-\n-            ((Topics) subscribeTo).subscribe(childChanged);\n-            return Optional.of(childChanged);\n-\n-        } else if (subscribeTo instanceof Topic) {\n-            Subscriber subscriber =\n-                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n-\n-            ((Topic) subscribeTo).subscribe(subscriber);\n-            return Optional.of(subscriber);\n-        }\n-        return Optional.empty();\n-    }\n-\n-    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n-                                        String componentName) {\n-        // Blocks from sending an event on subscription\n-        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n-            return;\n-        }\n-        // The path sent in config update event should be the path for the changed node within the component\n-        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n-        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n-        // then the path in update event should be key_1.nested_key_1\n-        int configurationTopicsIndex =\n-                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n-        String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n-\n-        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n-    }\n-\n-    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKeyPath) -> {\n-            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n-                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n-            log.atDebug()\n-                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n-\n-            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n+    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKey) -> {\n+            ConfigurationUpdateEvent valueChangedEvent =\n+                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n+            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n+\n+            try {\n+                ApplicationMessage applicationMessage =\n+                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n+                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n+                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n+                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n+                Future<FrameReader.Message> fut =\n+                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n+                                new FrameReader.Message(applicationMessage.toByteArray()));\n+\n+                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n+                executor.execute(() -> {\n+                    try {\n+                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n+                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n+                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+                        // Log\n+                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                                .log(\"Error sending config store update to client\", e);\n+                    }\n+                });\n+\n+            } catch (IOException e) {\n+                // Log\n+                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n+                        .log(\"Error sending config store update to client\", e);\n+            }\n         };\n     }\n \n", "next_change": {"commit": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex e674ca4227..dc44366963 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -118,57 +85,101 @@ public class ConfigStoreIPCAgent implements InjectionActions {\n         String componentName =\n                 request.getComponentName() == null ? context.getServiceName() : request.getComponentName();\n \n-        configUpdateListeners.computeIfAbsent(context, (key) -> {\n-            context.onDisconnect(() -> configUpdateListeners.remove(context));\n-            return sendStoreUpdateToListener(context, componentName);\n-        });\n+        Topics serviceTopics = kernel.findServiceTopic(componentName);\n+        if (serviceTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not exist\");\n+        }\n \n-        configUpdateSubscribersByService.putIfAbsent(componentName, new CopyOnWriteArraySet<>());\n-        configUpdateSubscribersByService.get(componentName).add(context);\n-        context.onDisconnect(() -> {\n-            configUpdateSubscribersByService.entrySet().forEach(e -> {\n-                if (e.getValue().contains(context)) {\n-                    e.getValue().remove(context);\n-                }\n-            });\n-        });\n+        Topics configurationTopics = serviceTopics.lookupTopics(PARAMETERS_CONFIG_KEY);\n+        if (configurationTopics == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested component does not have any configuration\");\n+        }\n+\n+        Node subscribeTo = getNodeToSubscribeTo(configurationTopics, request.getKeyName());\n+        if (subscribeTo == null) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.ResourceNotFoundError,\n+                    \"Requested configuration key does not exist\");\n+        }\n+\n+        Optional<Watcher> watcher = registerWatcher(subscribeTo, context, componentName);\n+        if (!watcher.isPresent()) {\n+            return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.InternalError,\n+                    \"Could not register update subscriber\");\n+        }\n+\n+        context.onDisconnect(() -> subscribeTo.remove(watcher.get()));\n \n         return new SubscribeToConfigurationUpdateResponse(ConfigStoreResponseStatus.Success, null);\n     }\n \n-    private Consumer<String> sendStoreUpdateToListener(ConnectionContext context, String componentName) {\n+    private Node getNodeToSubscribeTo(Topics configurationTopics, String keyName) {\n+        Node subscribeTo = configurationTopics;\n+        if (!Utils.isEmpty(keyName)) {\n+            String[] keyPath = parseKeyPath(keyName);\n+            subscribeTo = configurationTopics.findNode(keyPath);\n+        }\n+        return subscribeTo;\n+    }\n+\n+    // TODO : We shouldn't be splitting or joining paths based on the '.' delimiter(or any char as delimiter)\n+    //  since it will not work when keys have names with '.' in them, instead, we should explore if we can\n+    //  use string arrays for explicitly denoting key paths in Get/Update/Subscribe API models\n+    //  keeping this as a TODO while the decision is made\n+    private String[] parseKeyPath(String key) {\n+        if (key.contains(CONFIGURATION_KEY_PATH_DELIMITER)) {\n+            return key.split(CONFIGURATION_KEY_PATH_DELIMITER);\n+        }\n+        return new String[] {key};\n+    }\n+\n+    private Optional<Watcher> registerWatcher(Node subscribeTo, ConnectionContext context, String componentName) {\n+        if (subscribeTo instanceof Topics) {\n+            ChildChanged childChanged =\n+                    (whatHappened, node) -> handleConfigNodeUpdate(whatHappened, node, context, componentName);\n+\n+            ((Topics) subscribeTo).subscribe(childChanged);\n+            return Optional.of(childChanged);\n+\n+        } else if (subscribeTo instanceof Topic) {\n+            Subscriber subscriber =\n+                    (whatHappened, topic) -> handleConfigNodeUpdate(whatHappened, topic, context, componentName);\n+\n+            ((Topic) subscribeTo).subscribe(subscriber);\n+            return Optional.of(subscriber);\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private void handleConfigNodeUpdate(WhatHappened whatHappened, Node changedNode, ConnectionContext context,\n+                                        String componentName) {\n+        // Blocks from sending an event on subscription\n+        if (changedNode == null || WhatHappened.initialized.equals(whatHappened)) {\n+            return;\n+        }\n+        // The path sent in config update event should be the path for the changed node within the component\n+        // 'configuration' namespace such that it can be used as it is to make a subsequent get call by the client.\n+        // e.g. if the path for changed node is services.<service_name>.configuration.key_1.nested_key_1\n+        // then the path in update event should be key_1.nested_key_1\n+        int configurationTopicsIndex =\n+                kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n+        String[] keyPath =\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n+                        changedNode.path().length);\n+\n+        sendConfigUpdateToListener(context, componentName)\n+                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+    }\n+\n+    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n         return (changedKey) -> {\n             ConfigurationUpdateEvent valueChangedEvent =\n                     ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending updated config key {} to {}\", changedKey, context);\n-\n-            try {\n-                ApplicationMessage applicationMessage =\n-                        ApplicationMessage.builder().version(ConfigStoreImpl.API_VERSION)\n-                                .opCode(ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal())\n-                                .payload(IPCUtil.encode(valueChangedEvent)).build();\n-                // TODO: Add timeout and retry to make sure the client got the request. https://sim.amazon.com/issues/P32541289\n-                Future<FrameReader.Message> fut =\n-                        context.serverPush(BuiltInServiceDestinationCode.CONFIG_STORE.getValue(),\n-                                new FrameReader.Message(applicationMessage.toByteArray()));\n-\n-                // call the blocking \"get\" in a separate thread so we don't block the publish queue\n-                executor.execute(() -> {\n-                    try {\n-                        fut.get(TIMEOUT_SECONDS, TimeUnit.SECONDS);\n-                        // TODO: Check the response message and make sure it was successful. https://sim.amazon.com/issues/P32541289\n-                    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n-                        // Log\n-                        log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                                .log(\"Error sending config store update to client\", e);\n-                    }\n-                });\n-\n-            } catch (IOException e) {\n-                // Log\n-                log.atError(\"error-sending-configstore-update\").kv(\"context\", context)\n-                        .log(\"Error sending config store update to client\", e);\n-            }\n+            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+\n+            serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n         };\n     }\n \n", "next_change": {"commit": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex dc44366963..6a10bd513b 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -179,7 +184,7 @@ public class ConfigStoreIPCAgent {\n             log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n-                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal());\n+                    ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n         };\n     }\n \n", "next_change": {"commit": "a80552617929885383367fa73312d0463252df98", "changed_code": [{"header": "diff --git a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\nindex 6a10bd513b..ae4e2d44fa 100644\n--- a/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n+++ b/src/main/java/com/aws/iot/evergreen/builtin/services/configstore/ConfigStoreIPCAgent.java\n", "chunk": "@@ -170,18 +152,17 @@ public class ConfigStoreIPCAgent {\n         int configurationTopicsIndex =\n                 kernel.findServiceTopic(componentName).lookupTopics(PARAMETERS_CONFIG_KEY).path().length - 1;\n         String[] keyPath =\n-                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1,\n-                        changedNode.path().length);\n+                Arrays.copyOfRange(changedNode.path(), configurationTopicsIndex + 1, changedNode.path().length);\n \n-        sendConfigUpdateToListener(context, componentName)\n-                .accept(String.join(CONFIGURATION_KEY_PATH_DELIMITER, keyPath));\n+        sendConfigUpdateToListener(context, componentName).accept(keyPath);\n     }\n \n-    private Consumer<String> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n-        return (changedKey) -> {\n-            ConfigurationUpdateEvent valueChangedEvent =\n-                    ConfigurationUpdateEvent.builder().componentName(componentName).changedKey(changedKey).build();\n-            log.atDebug().log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKey, context);\n+    private Consumer<String[]> sendConfigUpdateToListener(ConnectionContext context, String componentName) {\n+        return (changedKeyPath) -> {\n+            ConfigurationUpdateEvent valueChangedEvent = ConfigurationUpdateEvent.builder().componentName(componentName)\n+                    .changedKeyPath(Arrays.asList(changedKeyPath)).build();\n+            log.atDebug()\n+                    .log(\"Sending component {}'s updated config key {} to {}\", componentName, changedKeyPath, context);\n \n             serviceEventHelper.sendServiceEvent(context, valueChangedEvent, BuiltInServiceDestinationCode.CONFIG_STORE,\n                     ConfigStoreServiceOpCodes.KEY_CHANGED.ordinal(), ConfigStoreImpl.API_VERSION);\n", "next_change": null}]}}]}}]}}]}}, {"oid": "a197e2f42f728d7d18772483a5b9069198b6c816", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a197e2f42f728d7d18772483a5b9069198b6c816", "message": "Config store APIs - updates read, subscribe for supporting shared config, adds write and validate", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "8bf751c899bf489deab8fae35f87a339e2d4ca18", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8bf751c899bf489deab8fae35f87a339e2d4ca18", "message": "Remove runtime config handling", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/856a0cf8bdf58d81cbf46c3f29fd4332586fb2cf", "message": "Enhancements", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/8b7c7bceafd0c2cbd28e7d85573f021d48aefda8", "message": "Unit and integ tests", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "a9ade7d386a806aa6a0b7287151d4c385ab552ab", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a9ade7d386a806aa6a0b7287151d4c385ab552ab", "message": "Simplified version with per key and nested key subscriptions", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/08acaf83efe465aa1aac8cd1ea641fb8dd430acc", "message": "Address comments add more open questions as TODOs", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "a80552617929885383367fa73312d0463252df98", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/a80552617929885383367fa73312d0463252df98", "message": "Implemented TODOs for previously open/now resolved questions", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "2fcea893248454e36733ab3403d7b3f9c9f63657", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/2fcea893248454e36733ab3403d7b3f9c9f63657", "message": "Support compare and swap update", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/b0b3aa321fd18b8498fbbcf82a1becd5e8593542", "message": "Make checkstyle and pmd happy", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "af1db22427c77a4b6d617ebd503c6eb878b08f21", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/af1db22427c77a4b6d617ebd503c6eb878b08f21", "message": "Fix integ test", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "151638416620da7204def0d2fc975075be6363d7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "message": "Fix flakiness in subscribe to config update tests", "committedDate": "2020-08-14T23:36:42Z", "type": "commit"}, {"oid": "151638416620da7204def0d2fc975075be6363d7", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/151638416620da7204def0d2fc975075be6363d7", "message": "Fix flakiness in subscribe to config update tests", "committedDate": "2020-08-14T23:36:42Z", "type": "forcePushed"}, {"oid": "9cc694b3d02b1f6abc2bae044415818f638cc1c6", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/9cc694b3d02b1f6abc2bae044415818f638cc1c6", "message": "Fix another flake in integ test", "committedDate": "2020-08-15T00:57:45Z", "type": "commit"}, {"oid": "02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/02bedd38a3acab477dda371b3d7eb2ae50c68f2e", "message": "Merge branch 'master' into shared-config", "committedDate": "2020-08-18T15:59:00Z", "type": "commit"}, {"oid": "3cf93b4af6ecaf3649e133e46de6918204f297c2", "url": "https://github.com/aws-greengrass/aws-greengrass-nucleus/commit/3cf93b4af6ecaf3649e133e46de6918204f297c2", "message": "Merge branch 'master' into shared-config", "committedDate": "2020-08-18T17:28:55Z", "type": "commit"}]}