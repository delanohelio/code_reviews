{"pr_number": 2372, "pr_title": "Streamline HTTP header/trailer validation and conversion", "pr_author": "jyblue", "pr_createdAt": "2020-01-04T16:53:39Z", "pr_url": "https://github.com/line/armeria/pull/2372", "merge_commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3NjM3MQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r363176371", "body": "These methods can be `static`?", "bodyText": "These methods can be static?", "bodyHTML": "<p dir=\"auto\">These methods can be <code>static</code>?</p>", "author": "trustin", "createdAt": "2020-01-06T06:51:46Z", "path": "benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2019 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+import com.linecorp.armeria.client.ClientRequestContext;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.server.Server;\n+\n+@State(Scope.Benchmark)\n+public class HttpRequestHeaderConversionBenchmark {\n+\n+    private Server serverWithoutAdditionalHeaders;\n+\n+    private WebClient clientWithAdditionalHeadersHttp1;\n+    private WebClient clientWithAdditionalHeadersHttp2;\n+\n+    @Setup\n+    public void startServer() {\n+        final int port = 8080;\n+\n+        serverWithoutAdditionalHeaders = Server.builder()\n+                                               .http(port)\n+                                               .service(\"/header_conversion\", (ctx, req) -> {\n+                                                   return HttpResponse.of(HttpStatus.OK);\n+                                               })\n+                                               .build();\n+        serverWithoutAdditionalHeaders.start().join();\n+\n+        clientWithAdditionalHeadersHttp1 = WebClient.builder(\"h1c://127.0.0.1:\" + port)\n+                                                    .decorator(((delegate, ctx, req) -> {\n+                                                        addAdditionalHeaders(ctx);\n+                                                        addProhibitedHeaders(ctx);\n+                                                        addCookies(ctx);\n+                                                        return delegate.execute(ctx, req);\n+                                                    })).build();\n+\n+        clientWithAdditionalHeadersHttp2 = WebClient.builder(\"h2c://127.0.0.1:\" + port)\n+                                                    .decorator(((delegate, ctx, req) -> {\n+                                                        addAdditionalHeaders(ctx);\n+                                                        addProhibitedHeaders(ctx);\n+                                                        addCookies(ctx);\n+                                                        return delegate.execute(ctx, req);\n+                                                    })).build();\n+    }\n+\n+    private void addAdditionalHeaders(ClientRequestContext ctx) {\n+        ctx.addAdditionalRequestHeader(\"custom-header-1\", \"my-header-1\");\n+        ctx.addAdditionalRequestHeader(\"custom-header-2\", \"my-header-2\");\n+        ctx.addAdditionalRequestHeader(\"custom-header-3\", \"my-header-3\");\n+        ctx.addAdditionalRequestHeader(\"custom-header-4\", \"my-header-4\");\n+    }\n+\n+    private void addProhibitedHeaders(ClientRequestContext ctx) {\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.SCHEME, \"https\");\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.STATUS, \"503\");\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.METHOD, \"CONNECT\");\n+    }\n+\n+    private void addCookies(ClientRequestContext ctx) {\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"e=f; g=h\");\n+        ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"i=j; k=l\");\n+    }", "originalCommit": "c70af23b0433e88930a8360a73f94d646af59309", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "changed_code": [{"header": "diff --git a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\nindex eab2f3ae6..b66416874 100644\n--- a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n+++ b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n", "chunk": "@@ -63,20 +63,20 @@ public class HttpRequestHeaderConversionBenchmark {\n                                                     })).build();\n     }\n \n-    private void addAdditionalHeaders(ClientRequestContext ctx) {\n+    private static void addAdditionalHeaders(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(\"custom-header-1\", \"my-header-1\");\n         ctx.addAdditionalRequestHeader(\"custom-header-2\", \"my-header-2\");\n         ctx.addAdditionalRequestHeader(\"custom-header-3\", \"my-header-3\");\n         ctx.addAdditionalRequestHeader(\"custom-header-4\", \"my-header-4\");\n     }\n \n-    private void addProhibitedHeaders(ClientRequestContext ctx) {\n+    private static void addProhibitedHeaders(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.SCHEME, \"https\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.STATUS, \"503\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.METHOD, \"CONNECT\");\n     }\n \n-    private void addCookies(ClientRequestContext ctx) {\n+    private static void addCookies(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"e=f; g=h\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"i=j; k=l\");\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\nindex eab2f3ae6..9a893c3a5 100644\n--- a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n+++ b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n", "chunk": "@@ -63,20 +63,20 @@ public class HttpRequestHeaderConversionBenchmark {\n                                                     })).build();\n     }\n \n-    private void addAdditionalHeaders(ClientRequestContext ctx) {\n+    private static void addAdditionalHeaders(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(\"custom-header-1\", \"my-header-1\");\n         ctx.addAdditionalRequestHeader(\"custom-header-2\", \"my-header-2\");\n         ctx.addAdditionalRequestHeader(\"custom-header-3\", \"my-header-3\");\n         ctx.addAdditionalRequestHeader(\"custom-header-4\", \"my-header-4\");\n     }\n \n-    private void addProhibitedHeaders(ClientRequestContext ctx) {\n+    private static void addProhibitedHeaders(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.SCHEME, \"https\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.STATUS, \"503\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.METHOD, \"CONNECT\");\n     }\n \n-    private void addCookies(ClientRequestContext ctx) {\n+    private static void addCookies(ClientRequestContext ctx) {\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"a=b; c=d\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"e=f; g=h\");\n         ctx.addAdditionalRequestHeader(HttpHeaderNames.COOKIE, \"i=j; k=l\");\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "2caa0f8812e7435b7141136da95b5fd1f3efa2be", "committedDate": "2021-09-28 19:45:27 +0900", "message": "Add a benchmark that measures gRPC server performance with `ghz` (#3814)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3NjQ5NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r363176495", "body": "These methods could be `static`.", "bodyText": "These methods could be static.", "bodyHTML": "<p dir=\"auto\">These methods could be <code>static</code>.</p>", "author": "trustin", "createdAt": "2020-01-06T06:52:26Z", "path": "benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpResponseHeaderConversionBenchmark.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2019 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.server.Server;\n+import com.linecorp.armeria.server.ServiceRequestContext;\n+\n+@State(Scope.Benchmark)\n+public class HttpResponseHeaderConversionBenchmark {\n+\n+    private Server serverWithAdditionalHeaders;\n+\n+    private WebClient clientWithoutAdditionalHeadersHttp1;\n+    private WebClient clientWithoutAdditionalHeadersHttp2;\n+\n+    @Setup\n+    public void startServer() {\n+        final int port = 8080;\n+\n+        serverWithAdditionalHeaders = Server.builder()\n+                                            .http(port)\n+                                            .service(\"/header_conversion\", (ctx, req) -> {\n+                           addAdditionalHeaders(ctx);\n+                           addProhibitedHeaders(ctx);\n+                           return HttpResponse.of(HttpStatus.OK);\n+                       })\n+                                            .build();\n+        serverWithAdditionalHeaders.start().join();\n+\n+        clientWithoutAdditionalHeadersHttp1 = WebClient.of(\"h1c://127.0.0.1:\" + port);\n+        clientWithoutAdditionalHeadersHttp2 = WebClient.of(\"h2c://127.0.0.1:\" + port);\n+    }\n+\n+    private void addAdditionalHeaders(ServiceRequestContext ctx) {\n+        ctx.addAdditionalResponseHeader(\"custom-header-1\", \"my-header-1\");\n+        ctx.addAdditionalResponseHeader(\"custom-header-2\", \"my-header-2\");\n+        ctx.addAdditionalResponseHeader(\"custom-header-3\", \"my-header-3\");\n+        ctx.addAdditionalResponseHeader(\"custom-header-4\", \"my-header-4\");\n+\n+        ctx.addAdditionalResponseTrailer(\"custom-trailer-1\", \"my-trailer-1\");\n+        ctx.addAdditionalResponseTrailer(\"custom-trailer-2\", \"my-trailer-2\");\n+        ctx.addAdditionalResponseTrailer(\"custom-trailer-3\", \"my-trailer-3\");\n+        ctx.addAdditionalResponseTrailer(\"custom-trailer-4\", \"my-trailer-4\");\n+    }\n+\n+    private void addProhibitedHeaders(ServiceRequestContext ctx) {\n+        ctx.addAdditionalResponseHeader(HttpHeaderNames.SCHEME, \"https\");\n+        ctx.addAdditionalResponseHeader(HttpHeaderNames.STATUS, \"100\");\n+        ctx.addAdditionalResponseHeader(HttpHeaderNames.METHOD, \"CONNECT\");\n+        ctx.addAdditionalResponseHeader(HttpHeaderNames.PATH, \"/foo\");\n+\n+        ctx.addAdditionalResponseTrailer(HttpHeaderNames.SCHEME, \"https\");\n+        ctx.addAdditionalResponseTrailer(HttpHeaderNames.STATUS, \"100\");\n+        ctx.addAdditionalResponseTrailer(HttpHeaderNames.METHOD, \"CONNECT\");\n+        ctx.addAdditionalResponseTrailer(HttpHeaderNames.PATH, \"/foo\");\n+        ctx.addAdditionalResponseTrailer(HttpHeaderNames.TRANSFER_ENCODING, \"magic\");\n+    }", "originalCommit": "c70af23b0433e88930a8360a73f94d646af59309", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "2caa0f8812e7435b7141136da95b5fd1f3efa2be", "committedDate": "2021-09-28 19:45:27 +0900", "message": "Add a benchmark that measures gRPC server performance with `ghz` (#3814)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3ODA3Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r363178076", "body": "Could we calculate `userAgentHeader` and `authorityHeader` until here (or `Http2ObjectEncoder`)? By doing so, we could remove `userAgentHeader` and `authorityHeader` parameter for many methods.", "bodyText": "Could we calculate userAgentHeader and authorityHeader until here (or Http2ObjectEncoder)? By doing so, we could remove userAgentHeader and authorityHeader parameter for many methods.", "bodyHTML": "<p dir=\"auto\">Could we calculate <code>userAgentHeader</code> and <code>authorityHeader</code> until here (or <code>Http2ObjectEncoder</code>)? By doing so, we could remove <code>userAgentHeader</code> and <code>authorityHeader</code> parameter for many methods.</p>", "author": "trustin", "createdAt": "2020-01-06T07:00:44Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -277,26 +309,67 @@ private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boole\n \n     private void convert(int streamId, HttpHeaders inHeaders,\n                          io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest) throws Http2Exception {\n+                         boolean isRequest, boolean endStream,\n+                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                         boolean enableServerHeader, boolean enableDateHeader,\n+                         @Nullable String authorityHeader, @Nullable String userAgentHeader)\n+            throws Http2Exception {\n \n         ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, outHeaders, HttpVersion.HTTP_1_1, trailer, isRequest);\n+                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n+                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n \n         outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n+\n         if (server) {\n             outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n+\n+            if (!trailer) {\n+                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+                    !additionalTrailers.isEmpty()) {\n+                    // We don't apply chunked encoding when the content-length header is set, which would\n+                    // prevent the trailers from being sent so we go ahead and remove content-length to\n+                    // force chunked encoding.\n+                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+                }\n+\n+                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n+                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+                }\n+\n+                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n+                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+                }\n+            }\n         } else {\n             outHeaders.remove(ExtensionHeaderNames.PATH.text());\n+\n+            if (!trailer) {\n+                if (userAgentHeader != null && !outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+                    outHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n+                }\n+\n+                if (authorityHeader != null && !outHeaders.contains(HttpHeaderNames.HOST)) {\n+                    outHeaders.add(HttpHeaderNames.HOST, authorityHeader);\n+                }", "originalCommit": "c70af23b0433e88930a8360a73f94d646af59309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxNTk4NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r371015985", "bodyText": "Removed userAgentHeader and authorityHeader", "author": "jyblue", "createdAt": "2020-01-26T17:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3ODA3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 7b2ebc379..66dd71a43 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -345,12 +341,16 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n             outHeaders.remove(ExtensionHeaderNames.PATH.text());\n \n             if (!trailer) {\n-                if (userAgentHeader != null && !outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n+                if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+                    outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n                 }\n \n-                if (authorityHeader != null && !outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST, authorityHeader);\n+                if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n+                    outHeaders.add(HttpHeaderNames.HOST,\n+                                   ArmeriaHttpUtil.authorityHeader(\n+                                           ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n+                                           ((InetSocketAddress) channel().remoteAddress()).getPort(),\n+                                           sessionProtocol.defaultPort()));\n                 }\n             }\n         }\n", "next_change": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 66dd71a43..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -303,74 +360,27 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n         return req;\n     }\n \n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest, boolean endStream,\n-                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                         boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n-\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n+    private LastHttpContent convertClientTrailers(\n+            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n \n-            if (!trailer) {\n-                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to\n-                    // force chunked encoding.\n-                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n+        if (inHeaders.isEmpty()) {\n+            return LastHttpContent.EMPTY_LAST_CONTENT;\n+        }\n \n-                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n+        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n \n-                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            }\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n+                HttpVersion.HTTP_1_1, true, true, endStream);\n \n-            if (!trailer) {\n-                if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n+        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n \n-                if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST,\n-                                   ArmeriaHttpUtil.authorityHeader(\n-                                           ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                           ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                           sessionProtocol.defaultPort()));\n-                }\n-            }\n-        }\n+        return  lastContent;\n     }\n \n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers,\n-                                                   boolean endStream, HttpHeaders additionalHeaders,\n-                                                   HttpHeaders additionalTrailers,\n-                                                   @Nullable SessionProtocol sessionProtocol,\n-                                                   boolean isRequest) throws Http2Exception {\n-        final LastHttpContent lastContent;\n-        if (headers.isEmpty()) {\n-            lastContent = LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-            convert(streamId, headers, lastContent.trailingHeaders(), true, isRequest,\n-                    endStream, additionalHeaders, additionalTrailers,\n-                    false, false, sessionProtocol);\n-        }\n-        return lastContent;\n+    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n+        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n+        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n     }\n \n     private static void setTransferEncoding(HttpMessage out) {\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 6f9bf297c..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private static HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private static void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(req.headers());\n-\n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 7b2ebc379..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,613 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol,\n-                                           @Nullable String authorityHeader,\n-                                           @Nullable String userAgentHeader) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               authorityHeader, userAgentHeader);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted = convertServerHeaders(streamId, headers, endStream,\n-                                                          additionalHeaders, additionalTrailers,\n-                                                          enableServerHeader, enableDateHeader);\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable String authorityHeader, @Nullable String userAgentHeader) throws Http2Exception {\n-\n-        return writeNonInformationalHeaders(id,\n-                                            convertClientHeaders(streamId, headers, endStream,\n-                                                                 additionalHeaders,\n-                                                                 authorityHeader, userAgentHeader),\n-                                            endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        // Leading headers will always have :status, trailers will never have it.\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                          null, null, false);\n-        }\n-\n-        // Convert leading headers.\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convert(streamId, headers, outHeaders, false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader,\n-                    null, null);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convert(streamId, headers, res.headers(), false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader,\n-                    null, null);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            @Nullable String authorityHeader, @Nullable String userAgentHeader)\n-            throws Http2Exception {\n-\n-        // Leading headers will always have :method, trailers will never have it.\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, HttpHeaders.of(),\n-                                          authorityHeader, userAgentHeader, true);\n-        }\n-\n-        // Convert leading headers.\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convert(streamId, headers, req.headers(), false, true, endStream,\n-                additionalHeaders, HttpHeaders.of(), false, false,\n-                authorityHeader, userAgentHeader);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest, boolean endStream,\n-                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                         boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable String authorityHeader, @Nullable String userAgentHeader)\n-            throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n-\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n-\n-            if (!trailer) {\n-                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to\n-                    // force chunked encoding.\n-                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            }\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-\n-            if (!trailer) {\n-                if (userAgentHeader != null && !outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n-                }\n-\n-                if (authorityHeader != null && !outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST, authorityHeader);\n-                }\n-            }\n-        }\n-    }\n-\n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers,\n-                                                   boolean endStream, HttpHeaders additionalHeaders,\n-                                                   HttpHeaders additionalTrailers,\n-                                                   @Nullable String authorityHeader,\n-                                                   @Nullable String userAgentHeader,\n-                                                   boolean isRequest) throws Http2Exception {\n-        final LastHttpContent lastContent;\n-        if (headers.isEmpty()) {\n-            lastContent = LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-            convert(streamId, headers, lastContent.trailingHeaders(), true, isRequest,\n-                    endStream, additionalHeaders, additionalTrailers, false, false,\n-                    authorityHeader, userAgentHeader);\n-        }\n-        return lastContent;\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3ODM1NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r363178355", "body": "This is not correct. It must be either `https` or `http` (not `h1c`, ..)", "bodyText": "This is not correct. It must be either https or http (not h1c, ..)", "bodyHTML": "<p dir=\"auto\">This is not correct. It must be either <code>https</code> or <code>http</code> (not <code>h1c</code>, ..)</p>", "author": "trustin", "createdAt": "2020-01-06T07:02:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -70,8 +88,58 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n         }\n \n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId,\n+                                    convert(headers, additionalHeaders, additionalTrailers,\n+                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n+                                            sessionProtocol, authorityHeader, userAgentHeader),\n+                                    0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convert(HttpHeaders inputHeaders,\n+                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                 boolean server, boolean endStream, boolean isTrailer,\n+                                 boolean enableServerHeader, boolean enableDateHeader,\n+                                 @Nullable SessionProtocol sessionProtocol,\n+                                 @Nullable String authorityHeader,\n+                                 @Nullable String userAgentHeader) {\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        server, endStream, isTrailer);\n+\n+        if (!isTrailer) {\n+            if (server) {\n+                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+                    !additionalTrailers.isEmpty()) {\n+                    // We don't apply chunked encoding when the content-length header is set, which would\n+                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n+                    // chunked encoding.\n+                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+                }\n+\n+                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+                }\n+\n+                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+                }\n+            } else {\n+                if (userAgentHeader != null && !outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+                    outputHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n+                }\n+\n+                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+                    outputHeaders.scheme(sessionProtocol.toString());", "originalCommit": "c70af23b0433e88930a8360a73f94d646af59309", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex e291e3f11..4e89a61e8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -125,16 +123,20 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n                     outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n                 }\n             } else {\n-                if (userAgentHeader != null && !outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n+                if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+                    outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n                 }\n \n                 if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.toString());\n+                    outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n                 }\n \n-                if (authorityHeader != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY, authorityHeader);\n+                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+                    outputHeaders.add(HttpHeaderNames.AUTHORITY,\n+                                      ArmeriaHttpUtil.authorityHeader(\n+                                              ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n+                                              ((InetSocketAddress) channel().remoteAddress()).getPort(),\n+                                              sessionProtocol.defaultPort()));\n                 }\n             }\n         }\n", "next_change": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 4e89a61e8..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -87,63 +101,86 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol),\n-                                    0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n     }\n \n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol) {\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n \n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n+                                                                        true, endStream, false);\n+\n+        if (!additionalTrailers.isEmpty() &&\n+            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n \n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n \n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n \n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n+        return outputHeaders;\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-                }\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                                      ArmeriaHttpUtil.authorityHeader(\n-                                              ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                              ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                              sessionProtocol.defaultPort()));\n-                }\n-            }\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        false, endStream, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                         : SessionProtocol.HTTP.uriText());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n+            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n+                              ArmeriaHttpUtil.authorityHeader(\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n+                                      sessionProtocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n+    private Http2Headers convertClientTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            false, endStream, true);\n+    }\n+\n     @Override\n     protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (isStreamPresentAndWritable(streamId)) {\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 0e35d95d8..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,238 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex e291e3f11..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,199 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol,\n-                                           @Nullable String authorityHeader,\n-                                           @Nullable String userAgentHeader) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId,\n-                                        convert(headers, additionalHeaders, additionalTrailers,\n-                                                server, endStream, isTrailer,\n-                                                enableServerHeader, enableDateHeader,\n-                                                sessionProtocol, authorityHeader, userAgentHeader),\n-                                        0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol, authorityHeader, userAgentHeader),\n-                                    0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol,\n-                                 @Nullable String authorityHeader,\n-                                 @Nullable String userAgentHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n-\n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (userAgentHeader != null && !outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n-                }\n-\n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.toString());\n-                }\n-\n-                if (authorityHeader != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY, authorityHeader);\n-                }\n-            }\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3ODM5Mg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r363178392", "body": "Ditto for `userAgentHeader` and `authorityHeader`", "bodyText": "Ditto for userAgentHeader and authorityHeader", "bodyHTML": "<p dir=\"auto\">Ditto for <code>userAgentHeader</code> and <code>authorityHeader</code></p>", "author": "trustin", "createdAt": "2020-01-06T07:02:29Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -70,8 +88,58 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n         }\n \n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId,\n+                                    convert(headers, additionalHeaders, additionalTrailers,\n+                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n+                                            sessionProtocol, authorityHeader, userAgentHeader),\n+                                    0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convert(HttpHeaders inputHeaders,\n+                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                 boolean server, boolean endStream, boolean isTrailer,\n+                                 boolean enableServerHeader, boolean enableDateHeader,\n+                                 @Nullable SessionProtocol sessionProtocol,\n+                                 @Nullable String authorityHeader,\n+                                 @Nullable String userAgentHeader) {", "originalCommit": "c70af23b0433e88930a8360a73f94d646af59309", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxNTk4Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r371015987", "bodyText": "Removed userAgentHeader and authorityHeader", "author": "jyblue", "createdAt": "2020-01-26T17:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzE3ODM5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex e291e3f11..4e89a61e8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -99,9 +99,7 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n                                  HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n                                  boolean server, boolean endStream, boolean isTrailer,\n                                  boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol,\n-                                 @Nullable String authorityHeader,\n-                                 @Nullable String userAgentHeader) {\n+                                 @Nullable SessionProtocol sessionProtocol) {\n \n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n", "next_change": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 4e89a61e8..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -87,63 +101,86 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol),\n-                                    0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n     }\n \n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol) {\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n \n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n+                                                                        true, endStream, false);\n+\n+        if (!additionalTrailers.isEmpty() &&\n+            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n \n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n \n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n \n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n+        return outputHeaders;\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-                }\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                                      ArmeriaHttpUtil.authorityHeader(\n-                                              ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                              ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                              sessionProtocol.defaultPort()));\n-                }\n-            }\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        false, endStream, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                         : SessionProtocol.HTTP.uriText());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n+            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n+                              ArmeriaHttpUtil.authorityHeader(\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n+                                      sessionProtocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n+    private Http2Headers convertClientTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            false, endStream, true);\n+    }\n+\n     @Override\n     protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (isStreamPresentAndWritable(streamId)) {\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 0e35d95d8..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,238 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex e291e3f11..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,199 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol,\n-                                           @Nullable String authorityHeader,\n-                                           @Nullable String userAgentHeader) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId,\n-                                        convert(headers, additionalHeaders, additionalTrailers,\n-                                                server, endStream, isTrailer,\n-                                                enableServerHeader, enableDateHeader,\n-                                                sessionProtocol, authorityHeader, userAgentHeader),\n-                                        0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol, authorityHeader, userAgentHeader),\n-                                    0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol,\n-                                 @Nullable String authorityHeader,\n-                                 @Nullable String userAgentHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n-\n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (userAgentHeader != null && !outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, userAgentHeader);\n-                }\n-\n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.toString());\n-                }\n-\n-                if (authorityHeader != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY, authorityHeader);\n-                }\n-            }\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4OTYwNg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r368389606", "body": "If made public, should move to the `internal` package.", "bodyText": "If made public, should move to the internal package.", "bodyHTML": "<p dir=\"auto\">If made public, should move to the <code>internal</code> package.</p>", "author": "trustin", "createdAt": "2020-01-20T06:47:21Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpHeaderUtil.java", "diffHunk": "@@ -20,11 +20,14 @@\n \n import io.netty.util.AsciiString;\n \n-final class HttpHeaderUtil {\n+/**\n+ * Provides utility functions for internal use related with HTTP headers.\n+ */\n+public final class HttpHeaderUtil {", "originalCommit": "96e977b73dcb893b93ce885d83d766551dbe5be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxNTk5Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r371015997", "bodyText": "Moved to internal package.", "author": "jyblue", "createdAt": "2020-01-26T17:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4OTYwNg=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": null, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MDY5Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r368390693", "body": "You can also remove the `authorityHeader`, because it can be derived from `firstHeaders`, `reqCtx.additionalRequestHeaders()` and `channel.remoteAddress()`. Note that `HttpObjectEncoder` and its subtypes always have a reference to the current `channel`.", "bodyText": "You can also remove the authorityHeader, because it can be derived from firstHeaders, reqCtx.additionalRequestHeaders() and channel.remoteAddress(). Note that HttpObjectEncoder and its subtypes always have a reference to the current channel.", "bodyHTML": "<p dir=\"auto\">You can also remove the <code>authorityHeader</code>, because it can be derived from <code>firstHeaders</code>, <code>reqCtx.additionalRequestHeaders()</code> and <code>channel.remoteAddress()</code>. Note that <code>HttpObjectEncoder</code> and its subtypes always have a reference to the current <code>channel</code>.</p>", "author": "trustin", "createdAt": "2020-01-20T06:52:19Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java", "diffHunk": "@@ -192,11 +191,11 @@ private void writeFirstHeader() {\n         if (request.isEmpty()) {\n             state = State.DONE;\n             write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader, userAgentHeader);\n+                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader);", "originalCommit": "96e977b73dcb893b93ce885d83d766551dbe5be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxNjAyOQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r371016029", "bodyText": "Thanks for education \ud83d\ude00", "author": "jyblue", "createdAt": "2020-01-26T17:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM5MDY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex da923dcf9..b021b176d 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -191,11 +171,11 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         if (request.isEmpty()) {\n             state = State.DONE;\n             write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader);\n+                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n             write0(firstHeaders, false, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader);\n+                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n         }\n     }\n \n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex b021b176d..78294af91 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -161,21 +164,17 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         }\n \n         final RequestHeaders firstHeaders = request.headers();\n-        final SessionProtocol requestSessionProtocol = reqCtx.sessionProtocol();\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n-        logBuilder.startRequest(ch, protocol);\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n+            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n+            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n     }\n \n", "next_change": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,11 +167,18 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n", "next_change": {"commit": "d13565c88bd382876ad62fb24d1fada977338188", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 684f01987..59c9fa016 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,8 +184,9 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex da923dcf9..19b094480 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -160,50 +160,33 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         }\n \n         final RequestHeaders firstHeaders = request.headers();\n-        final SessionProtocol requestSessionProtocol = reqCtx.sessionProtocol();\n-        String authorityHeader = null;\n-\n-        if (!firstHeaders.contains(HttpHeaderNames.AUTHORITY) &&\n-            !reqCtx.additionalRequestHeaders().contains(HttpHeaderNames.AUTHORITY)) {\n-\n-            final String hostname = remoteAddress.getHostName();\n-            final int port = remoteAddress.getPort();\n-\n-            final String authority;\n-            if (port == requestSessionProtocol.defaultPort()) {\n-                authority = hostname;\n-            } else {\n-                final StringBuilder buf = new StringBuilder(hostname.length() + 6);\n-                buf.append(hostname);\n-                buf.append(':');\n-                buf.append(port);\n-                authority = buf.toString();\n-            }\n-\n-            authorityHeader = authority;\n-        }\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n-        logBuilder.startRequest(ch, protocol);\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader);\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol, authorityHeader);\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": {"commit": "711cea08b59286f5f847e5c4f17aedec5ada97de", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,7 +207,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            fail(new IllegalArgumentException(\n+            failAndReset(new IllegalArgumentException(\n                     \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n             return;\n         }\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -212,29 +76,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             return;\n         }\n \n-        boolean endOfStream = o.isEndOfStream();\n-        switch (state) {\n+        switch (state()) {\n             case NEEDS_DATA_OR_TRAILERS: {\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -195,7 +218,8 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        fail(new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(\n+                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "ec336fa661ddc4308e8a831b99c959f939533f99", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..365f7dd67 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -218,8 +228,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 365f7dd67..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,18 +85,17 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "711cea08b59286f5f847e5c4f17aedec5ada97de", "committedDate": "2020-03-19 13:54:44 +0900", "message": "Assign stream ID right before writing RequestHeaders (#2597)"}, {"oid": "6d21bfd5d5ac863d7d68420873190b4dc5f8f018", "committedDate": "2020-03-23 11:00:30 +0900", "message": "Wrap ProxyConnectException with UnprocessedRequestException (#2609)"}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ac3440be28a34d436e4382257d46bbf2cbdbca8a", "committedDate": "2020-05-14 15:15:17 +0900", "message": "Fix a bug where a response cause is not propagated when retrying a fa\u2026 (#2709)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "e5cea5e9ba7afc6a3b2c38d0663b8b1e3334ad37", "committedDate": "2020-06-26 19:10:34 +0900", "message": "Wrap `DnsTimeoutException` with `UnprocessedRequestException` (#2836)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "223c7c1cc4f98f1e56f1a95351f99155f7c365da", "committedDate": "2021-05-27 16:37:18 +0900", "message": "HttpRequestSubscriber should update RequestLogBuilder with all sent request headers (#3581)"}, {"oid": "6449551d515e2a612b0291f9b72c1c0d368364f2", "committedDate": "2021-07-28 16:43:35 +0900", "message": "Make `GrpcStatusFunction` access `RequestContext` (#3693)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "f777f14714f363656b1c12d1601dce12173394e9", "committedDate": "2022-06-01 16:24:20 +0900", "message": "Correctly throw `WriteTimeoutException` for requests without content (#4259)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "5382f15db770d545434cabb41cf8f9f4e5315e62", "committedDate": "2023-03-23 11:31:17 +0900", "message": "Provide a way to disconnect gracefully connection using `RequestContext` (#4708)"}]}, {"oid": "5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "url": "https://github.com/line/armeria/commit/5dc7e0ace79fd4942c7ce47ade3cbfccc9e8e919", "message": "Fix `SCHEME` header", "committedDate": "2020-01-22T16:51:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkwNjgxNA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r369906814", "body": "`, \"sessionProtocol\"` ?", "bodyText": ", \"sessionProtocol\" ?", "bodyHTML": "<p dir=\"auto\"><code>, \"sessionProtocol\"</code> ?</p>", "author": "trustin", "createdAt": "2020-01-23T02:28:01Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -133,7 +133,7 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n                                                additionalHeaders, additionalTrailers,\n                                                enableServerHeader, enableDateHeader)\n                           : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               authorityHeader);\n+                                               requireNonNull(sessionProtocol));", "originalCommit": "4f09cb1b4b6d393fd3499241da0da0b2f8cc27cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTAxNjA0Mg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r371016042", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-01-26T17:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkwNjgxNA=="}], "type": "inlineReview", "revised_code": {"commit": "f834bbb05d6381b1dbd94f1a2262a1ab441fb0be", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 66dd71a43..d88f12807 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -133,7 +133,7 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n                                                additionalHeaders, additionalTrailers,\n                                                enableServerHeader, enableDateHeader)\n                           : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               requireNonNull(sessionProtocol));\n+                                               sessionProtocol);\n         } catch (Throwable t) {\n             return newFailedFuture(t);\n         }\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nsimilarity index 74%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex d88f12807..5c5388091 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -121,19 +126,15 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n \n     @Override\n     protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n+                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+        if (!isWritable(id)) {\n             return newClosedSessionFuture();\n         }\n \n         try {\n             return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n+                                               additionalHeaders, additionalTrailers)\n+                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders);\n         } catch (Throwable t) {\n             return newFailedFuture(t);\n         }\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nsimilarity index 74%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex d88f12807..5c5388091 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -141,20 +142,20 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n \n     private ChannelFuture writeServerHeaders(\n             int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n+            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) throws Http2Exception {\n \n-        final HttpObject converted = convertServerHeaders(streamId, headers, endStream,\n-                                                          additionalHeaders, additionalTrailers,\n-                                                          enableServerHeader, enableDateHeader);\n+        final HttpObject converted;\n         final String status = headers.get(HttpHeaderNames.STATUS);\n         if (status == null) {\n             // Trailers\n+            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n             final ChannelFuture f = write(id, converted, endStream);\n             ch.flush();\n             return f;\n         }\n \n+        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers);\n+\n         if (!status.isEmpty() && status.charAt(0) == '1') {\n             // Informational status headers.\n             final ChannelFuture f = write(id, converted, false);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 66dd71a43..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,612 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               requireNonNull(sessionProtocol));\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted = convertServerHeaders(streamId, headers, endStream,\n-                                                          additionalHeaders, additionalTrailers,\n-                                                          enableServerHeader, enableDateHeader);\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        return writeNonInformationalHeaders(id,\n-                                            convertClientHeaders(streamId, headers, endStream,\n-                                                                 additionalHeaders, sessionProtocol),\n-                                            endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        // Leading headers will always have :status, trailers will never have it.\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                          null, false);\n-        }\n-\n-        // Convert leading headers.\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convert(streamId, headers, outHeaders, false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader, null);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convert(streamId, headers, res.headers(), false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader, null);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        // Leading headers will always have :method, trailers will never have it.\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, HttpHeaders.of(),\n-                                          sessionProtocol, true);\n-        }\n-\n-        // Convert leading headers.\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convert(streamId, headers, req.headers(), false, true, endStream,\n-                additionalHeaders, HttpHeaders.of(), false, false,\n-                sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest, boolean endStream,\n-                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                         boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n-\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n-\n-            if (!trailer) {\n-                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to\n-                    // force chunked encoding.\n-                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            }\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-\n-            if (!trailer) {\n-                if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n-\n-                if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST,\n-                                   ArmeriaHttpUtil.authorityHeader(\n-                                           ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                           ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                           sessionProtocol.defaultPort()));\n-                }\n-            }\n-        }\n-    }\n-\n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers,\n-                                                   boolean endStream, HttpHeaders additionalHeaders,\n-                                                   HttpHeaders additionalTrailers,\n-                                                   @Nullable SessionProtocol sessionProtocol,\n-                                                   boolean isRequest) throws Http2Exception {\n-        final LastHttpContent lastContent;\n-        if (headers.isEmpty()) {\n-            lastContent = LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-            convert(streamId, headers, lastContent.trailingHeaders(), true, isRequest,\n-                    endStream, additionalHeaders, additionalTrailers,\n-                    false, false, sessionProtocol);\n-        }\n-        return lastContent;\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkwNzE2MQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r369907161", "body": "How about splitting this method into four:\r\n\r\n- `convertClientHeaders()` and `convertClientTrailers()`, which don't require `SessionProtocol`\r\n- `convertServerHeaders()` and `convertServerTrailers()`, which require non-null `SessionProtocol`\r\n\r\n.. and remove all the `if`s?", "bodyText": "How about splitting this method into four:\n\nconvertClientHeaders() and convertClientTrailers(), which don't require SessionProtocol\nconvertServerHeaders() and convertServerTrailers(), which require non-null SessionProtocol\n\n.. and remove all the ifs?", "bodyHTML": "<p dir=\"auto\">How about splitting this method into four:</p>\n<ul dir=\"auto\">\n<li><code>convertClientHeaders()</code> and <code>convertClientTrailers()</code>, which don't require <code>SessionProtocol</code></li>\n<li><code>convertServerHeaders()</code> and <code>convertServerTrailers()</code>, which require non-null <code>SessionProtocol</code></li>\n</ul>\n<p dir=\"auto\">.. and remove all the <code>if</code>s?</p>", "author": "trustin", "createdAt": "2020-01-23T02:30:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -311,7 +308,7 @@ private void convert(int streamId, HttpHeaders inHeaders,\n                          boolean isRequest, boolean endStream,\n                          HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n                          boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable String authorityHeader)\n+                         @Nullable SessionProtocol sessionProtocol)", "originalCommit": "4f09cb1b4b6d393fd3499241da0da0b2f8cc27cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 66dd71a43..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -303,74 +360,27 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n         return req;\n     }\n \n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest, boolean endStream,\n-                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                         boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n-\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n+    private LastHttpContent convertClientTrailers(\n+            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n \n-            if (!trailer) {\n-                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to\n-                    // force chunked encoding.\n-                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n+        if (inHeaders.isEmpty()) {\n+            return LastHttpContent.EMPTY_LAST_CONTENT;\n+        }\n \n-                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n+        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n \n-                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            }\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n+                HttpVersion.HTTP_1_1, true, true, endStream);\n \n-            if (!trailer) {\n-                if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n+        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n \n-                if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST,\n-                                   ArmeriaHttpUtil.authorityHeader(\n-                                           ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                           ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                           sessionProtocol.defaultPort()));\n-                }\n-            }\n-        }\n+        return  lastContent;\n     }\n \n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers,\n-                                                   boolean endStream, HttpHeaders additionalHeaders,\n-                                                   HttpHeaders additionalTrailers,\n-                                                   @Nullable SessionProtocol sessionProtocol,\n-                                                   boolean isRequest) throws Http2Exception {\n-        final LastHttpContent lastContent;\n-        if (headers.isEmpty()) {\n-            lastContent = LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-            convert(streamId, headers, lastContent.trailingHeaders(), true, isRequest,\n-                    endStream, additionalHeaders, additionalTrailers,\n-                    false, false, sessionProtocol);\n-        }\n-        return lastContent;\n+    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n+        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n+        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n     }\n \n     private static void setTransferEncoding(HttpMessage out) {\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 6f9bf297c..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private static HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private static void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(req.headers());\n-\n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 66dd71a43..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,612 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               requireNonNull(sessionProtocol));\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted = convertServerHeaders(streamId, headers, endStream,\n-                                                          additionalHeaders, additionalTrailers,\n-                                                          enableServerHeader, enableDateHeader);\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        return writeNonInformationalHeaders(id,\n-                                            convertClientHeaders(streamId, headers, endStream,\n-                                                                 additionalHeaders, sessionProtocol),\n-                                            endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        // Leading headers will always have :status, trailers will never have it.\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                          null, false);\n-        }\n-\n-        // Convert leading headers.\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convert(streamId, headers, outHeaders, false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader, null);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convert(streamId, headers, res.headers(), false, false, endStream,\n-                    additionalHeaders, additionalTrailers, enableServerHeader, enableDateHeader, null);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        // Leading headers will always have :method, trailers will never have it.\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            return convertTrailingHeaders(streamId, headers, endStream, additionalHeaders, HttpHeaders.of(),\n-                                          sessionProtocol, true);\n-        }\n-\n-        // Convert leading headers.\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convert(streamId, headers, req.headers(), false, true, endStream,\n-                additionalHeaders, HttpHeaders.of(), false, false,\n-                sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest, boolean endStream,\n-                         HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                         boolean enableServerHeader, boolean enableDateHeader,\n-                         @Nullable SessionProtocol sessionProtocol)\n-            throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, trailer, isRequest, endStream);\n-\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n-\n-            if (!trailer) {\n-                if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to\n-                    // force chunked encoding.\n-                    outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            }\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-\n-            if (!trailer) {\n-                if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n-\n-                if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-                    outHeaders.add(HttpHeaderNames.HOST,\n-                                   ArmeriaHttpUtil.authorityHeader(\n-                                           ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                           ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                           sessionProtocol.defaultPort()));\n-                }\n-            }\n-        }\n-    }\n-\n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers,\n-                                                   boolean endStream, HttpHeaders additionalHeaders,\n-                                                   HttpHeaders additionalTrailers,\n-                                                   @Nullable SessionProtocol sessionProtocol,\n-                                                   boolean isRequest) throws Http2Exception {\n-        final LastHttpContent lastContent;\n-        if (headers.isEmpty()) {\n-            lastContent = LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-            convert(streamId, headers, lastContent.trailingHeaders(), true, isRequest,\n-                    endStream, additionalHeaders, additionalTrailers,\n-                    false, false, sessionProtocol);\n-        }\n-        return lastContent;\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTkwODYwOA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r369908608", "body": "Ditto - could be split into 4 methods with clear roles.", "bodyText": "Ditto - could be split into 4 methods with clear roles.", "bodyHTML": "<p dir=\"auto\">Ditto - could be split into 4 methods with clear roles.</p>", "author": "trustin", "createdAt": "2020-01-23T02:37:55Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -90,16 +91,15 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n         return encoder.writeHeaders(ctx, streamId,\n                                     convert(headers, additionalHeaders, additionalTrailers,\n                                             false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol, authorityHeader),\n+                                            sessionProtocol),\n                                     0, endStream, ctx.newPromise());\n     }\n \n     private Http2Headers convert(HttpHeaders inputHeaders,\n                                  HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n                                  boolean server, boolean endStream, boolean isTrailer,\n                                  boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol,\n-                                 @Nullable String authorityHeader) {\n+                                 @Nullable SessionProtocol sessionProtocol) {", "originalCommit": "4f09cb1b4b6d393fd3499241da0da0b2f8cc27cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex b877db789..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -87,63 +101,86 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol),\n-                                    0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n     }\n \n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol) {\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n \n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n+                                                                        true, endStream, false);\n+\n+        if (!additionalTrailers.isEmpty() &&\n+            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n \n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n \n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n \n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n+        return outputHeaders;\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.toString());\n-                }\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n \n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                                      ArmeriaHttpUtil.authorityHeader(\n-                                              ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                              ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                              sessionProtocol.defaultPort()));\n-                }\n-            }\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        false, endStream, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                         : SessionProtocol.HTTP.uriText());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n+            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n+                              ArmeriaHttpUtil.authorityHeader(\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n+                                      sessionProtocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n+    private Http2Headers convertClientTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            false, endStream, true);\n+    }\n+\n     @Override\n     protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (isStreamPresentAndWritable(streamId)) {\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 0e35d95d8..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,238 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex b877db789..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId,\n-                                        convert(headers, additionalHeaders, additionalTrailers,\n-                                                server, endStream, isTrailer,\n-                                                enableServerHeader, enableDateHeader,\n-                                                sessionProtocol),\n-                                        0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId,\n-                                    convert(headers, additionalHeaders, additionalTrailers,\n-                                            false, endStream, isTrailer, enableServerHeader, enableDateHeader,\n-                                            sessionProtocol),\n-                                    0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convert(HttpHeaders inputHeaders,\n-                                 HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                 boolean server, boolean endStream, boolean isTrailer,\n-                                 boolean enableServerHeader, boolean enableDateHeader,\n-                                 @Nullable SessionProtocol sessionProtocol) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        server, endStream, isTrailer);\n-\n-        if (!isTrailer) {\n-            if (server) {\n-                if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-                    !additionalTrailers.isEmpty()) {\n-                    // We don't apply chunked encoding when the content-length header is set, which would\n-                    // prevent the trailers from being sent so we go ahead and remove content-length to force\n-                    // chunked encoding.\n-                    outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-                }\n-\n-                if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-                    outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-                }\n-\n-                if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-                    outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-                }\n-            } else {\n-                if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-                    outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-                }\n-\n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-                    outputHeaders.scheme(sessionProtocol.toString());\n-                }\n-\n-                if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-                    outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                                      ArmeriaHttpUtil.authorityHeader(\n-                                              ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                              ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                              sessionProtocol.defaultPort()));\n-                }\n-            }\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"oid": "f834bbb05d6381b1dbd94f1a2262a1ab441fb0be", "url": "https://github.com/line/armeria/commit/f834bbb05d6381b1dbd94f1a2262a1ab441fb0be", "message": "Remove requireNonNull for `sessionProtocol` parameter", "committedDate": "2020-01-26T10:11:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5ODc4Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372198783", "body": "`convertClientHeaders0()` could be inlined here because it's used only once.", "bodyText": "convertClientHeaders0() could be inlined here because it's used only once.", "bodyHTML": "<p dir=\"auto\"><code>convertClientHeaders0()</code> could be inlined here because it's used only once.</p>", "author": "trustin", "createdAt": "2020-01-29T05:44:38Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -216,31 +239,78 @@ private HttpObject convertServerHeaders(\n         } else {\n             res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n             // Perform conversion.\n-            convert(streamId, headers, res.headers(), false, false);\n+            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n+                                  additionalHeaders, additionalTrailers,\n+                                  enableServerHeader, enableDateHeader);\n             setTransferEncoding(res);\n         }\n \n         return res;\n     }\n \n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream)\n-            throws Http2Exception {\n+    private void convertServerHeaders0(\n+            int streamId, HttpHeaders inHeaders,\n+            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n+            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n \n-        // Leading headers will always have :method, trailers will never have it.\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            return convertTrailingHeaders(streamId, headers);\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n+                HttpVersion.HTTP_1_1, false, false, endStream);\n+\n+        removeHttpExtensionHeaders(outHeaders);\n+\n+        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to\n+            // force chunked encoding.\n+            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n+\n+        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n+\n+        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n+            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n+    }\n+\n+    private LastHttpContent convertServerTrailers(\n+            int streamId, HttpHeaders inHeaders, boolean endStream,\n+            HttpHeaders additionalTrailers) throws Http2Exception {\n+\n+        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n+\n+        if (inHeaders.isEmpty()) {\n+            return lastContent;\n         }\n \n-        // Convert leading headers.\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n+                HttpVersion.HTTP_1_1, true, false, endStream);\n+\n+        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n+\n+        return lastContent;\n+    }\n+\n+    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n+                                            HttpHeaders additionalHeaders,\n+                                            SessionProtocol sessionProtocol) throws Http2Exception {\n+        requireNonNull(sessionProtocol);\n+\n+        final String method = headers.get(HttpHeaderNames.METHOD);\n         final String path = headers.get(HttpHeaderNames.PATH);\n         assert path != null;\n         final HttpRequest req = new DefaultHttpRequest(\n                 HttpVersion.HTTP_1_1,\n                 HttpMethod.valueOf(method),\n                 path, false);\n \n-        convert(streamId, headers, req.headers(), false, true);\n+        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n+                              sessionProtocol);", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1MDI1OQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372650259", "bodyText": "Inlined convertClientHeaders0().", "author": "jyblue", "createdAt": "2020-01-29T21:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5ODc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 2ee986fb5..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -309,8 +309,23 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n                 HttpMethod.valueOf(method),\n                 path, false);\n \n-        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n-                              sessionProtocol);\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n+                HttpVersion.HTTP_1_1, false, true, endStream);\n+\n+        removeHttpExtensionHeaders(req.headers());\n+\n+        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n+            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n+            req.headers().add(HttpHeaderNames.HOST,\n+                              ArmeriaHttpUtil.authorityHeader(\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n+                                      sessionProtocol.defaultPort()));\n+        }\n \n         if (endStream) {\n             req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nsimilarity index 91%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 6f9bf297c..5c5388091 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -324,7 +317,7 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n             req.headers().add(HttpHeaderNames.HOST,\n                               ArmeriaHttpUtil.authorityHeader(\n                                       remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n+                                      protocol.defaultPort()));\n         }\n \n         if (endStream) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 2ee986fb5..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,639 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n-                              sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convertClientHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, HttpHeaders.of(), outHeaders,\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-            outHeaders.add(HttpHeaderNames.HOST,\n-                           ArmeriaHttpUtil.authorityHeader(\n-                                   ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                   ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                   sessionProtocol.defaultPort()));\n-        }\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private LastHttpContent getLastHttpContent(HttpHeaders headers) {\n-        if (headers.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-        }\n-    }\n-\n-    private void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTc1Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372199753", "body": "What do you think about inlining this method? i.e.\r\n\r\n```java\r\nif (inHeaders.inEmpty()) {\r\n    return LastHttpContent.EMPTY_LAST_CONTENT;\r\n}\r\n\r\nfinal LastHttpContent lastContent = new DefaultLastHttpContent(...);\r\n```\r\n\r\n.. which is more readable in my opinion.", "bodyText": "What do you think about inlining this method? i.e.\nif (inHeaders.inEmpty()) {\n    return LastHttpContent.EMPTY_LAST_CONTENT;\n}\n\nfinal LastHttpContent lastContent = new DefaultLastHttpContent(...);\n.. which is more readable in my opinion.", "bodyHTML": "<p dir=\"auto\">What do you think about inlining this method? i.e.</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (inHeaders.inEmpty()) {\n    return LastHttpContent.EMPTY_LAST_CONTENT;\n}\n\nfinal LastHttpContent lastContent = new DefaultLastHttpContent(...);\n\"><pre><span class=\"pl-k\">if</span> (inHeaders<span class=\"pl-k\">.</span>inEmpty()) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">LastHttpContent</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>EMPTY_LAST_CONTENT</span>;\n}\n\n<span class=\"pl-k\">final</span> <span class=\"pl-smi\">LastHttpContent</span> lastContent <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">DefaultLastHttpContent</span>(<span class=\"pl-c1\">...</span>);</pre></div>\n<p dir=\"auto\">.. which is more readable in my opinion.</p>", "author": "trustin", "createdAt": "2020-01-29T05:49:12Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -275,30 +345,59 @@ private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boole\n         return req;\n     }\n \n-    private void convert(int streamId, HttpHeaders inHeaders,\n-                         io.netty.handler.codec.http.HttpHeaders outHeaders, boolean trailer,\n-                         boolean isRequest) throws Http2Exception {\n+    private void convertClientHeaders0(\n+            int streamId, HttpHeaders inHeaders,\n+            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n+            HttpHeaders additionalHeaders, SessionProtocol sessionProtocol) throws Http2Exception {\n \n         ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, outHeaders, HttpVersion.HTTP_1_1, trailer, isRequest);\n+                streamId, inHeaders, additionalHeaders, HttpHeaders.of(), outHeaders,\n+                HttpVersion.HTTP_1_1, false, true, endStream);\n \n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        if (server) {\n-            outHeaders.remove(ExtensionHeaderNames.SCHEME.text());\n-        } else {\n-            outHeaders.remove(ExtensionHeaderNames.PATH.text());\n+        removeHttpExtensionHeaders(outHeaders);\n+\n+        if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n+            outHeaders.add(HttpHeaderNames.HOST,\n+                           ArmeriaHttpUtil.authorityHeader(\n+                                   ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n+                                   ((InetSocketAddress) channel().remoteAddress()).getPort(),\n+                                   sessionProtocol.defaultPort()));\n         }\n     }\n \n-    private LastHttpContent convertTrailingHeaders(int streamId, HttpHeaders headers) throws Http2Exception {\n-        final LastHttpContent lastContent;\n+    private LastHttpContent convertClientTrailers(\n+            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n+\n+        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n+\n+        if (inHeaders.isEmpty()) {\n+            return lastContent;\n+        }\n+\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n+                HttpVersion.HTTP_1_1, true, true, endStream);\n+\n+        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n+\n+        return  lastContent;\n+    }\n+\n+    private LastHttpContent getLastHttpContent(HttpHeaders headers) {", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDQ4OA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373210488", "bodyText": "Inlined method.\nI was thinking, removing code duplication by this method made poor readability and added more unnecessary codes. But I was not sure. Thanks for education.", "author": "jyblue", "createdAt": "2020-01-30T21:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE5OTc1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 2ee986fb5..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -387,15 +378,7 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n         return  lastContent;\n     }\n \n-    private LastHttpContent getLastHttpContent(HttpHeaders headers) {\n-        if (headers.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-        }\n-    }\n-\n-    private void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n+    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n         outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n         outHeaders.remove(ExtensionHeaderNames.PATH.text());\n     }\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 6f9bf297c..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private static HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private static void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(req.headers());\n-\n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 2ee986fb5..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,639 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n-                              sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convertClientHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, HttpHeaders.of(), outHeaders,\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-            outHeaders.add(HttpHeaderNames.HOST,\n-                           ArmeriaHttpUtil.authorityHeader(\n-                                   ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                   ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                   sessionProtocol.defaultPort()));\n-        }\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private LastHttpContent getLastHttpContent(HttpHeaders headers) {\n-        if (headers.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-        }\n-    }\n-\n-    private void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwMjI1NA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372202254", "body": "This method could be replaced with `ArmeriaHttpUtil.authorityHeader()`?", "bodyText": "This method could be replaced with ArmeriaHttpUtil.authorityHeader()?", "bodyHTML": "<p dir=\"auto\">This method could be replaced with <code>ArmeriaHttpUtil.authorityHeader()</code>?</p>", "author": "trustin", "createdAt": "2020-01-29T06:01:36Z", "path": "core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java", "diffHunk": "@@ -14,19 +14,22 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.client;\n+package com.linecorp.armeria.internal;\n \n import com.linecorp.armeria.common.util.Version;\n \n import io.netty.util.AsciiString;\n \n-final class HttpHeaderUtil {\n+/**\n+ * Provides utility functions for internal use related with HTTP headers.\n+ */\n+public final class HttpHeaderUtil {\n \n     private static final String CLIENT_ARTIFACT_ID = \"armeria\";\n \n-    static final AsciiString USER_AGENT = AsciiString.cached(createUserAgentName());\n+    public static final AsciiString USER_AGENT = AsciiString.cached(createUserAgentName());\n \n-    static String hostHeader(String host, int port, int defaultPort) {\n+    public static String hostHeader(String host, int port, int defaultPort) {\n         if (port == defaultPort) {\n             return host;\n         }", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1MTIzNw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372651237", "bodyText": "Replaced with ArmeriaHttpUtil.authorityHeader().", "author": "jyblue", "createdAt": "2020-01-29T21:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIwMjI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java b/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\nindex b231e1af5..2671e0ff3 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\n", "chunk": "@@ -29,14 +29,6 @@ public final class HttpHeaderUtil {\n \n     public static final AsciiString USER_AGENT = AsciiString.cached(createUserAgentName());\n \n-    public static String hostHeader(String host, int port, int defaultPort) {\n-        if (port == defaultPort) {\n-            return host;\n-        }\n-\n-        return host + ':' + port;\n-    }\n-\n     private static String createUserAgentName() {\n         final Version version = Version.get(CLIENT_ARTIFACT_ID, HttpHeaderUtil.class.getClassLoader());\n         return CLIENT_ARTIFACT_ID + '/' + version.artifactVersion();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nsimilarity index 84%\nrename from core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nindex b231e1af5..8927fac0d 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\n", "chunk": "@@ -29,14 +29,6 @@ public final class HttpHeaderUtil {\n \n     public static final AsciiString USER_AGENT = AsciiString.cached(createUserAgentName());\n \n-    public static String hostHeader(String host, int port, int defaultPort) {\n-        if (port == defaultPort) {\n-            return host;\n-        }\n-\n-        return host + ':' + port;\n-    }\n-\n     private static String createUserAgentName() {\n         final Version version = Version.get(CLIENT_ARTIFACT_ID, HttpHeaderUtil.class.getClassLoader());\n         return CLIENT_ARTIFACT_ID + '/' + version.artifactVersion();\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMTg4Mg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372211882", "body": "`inputHeaders.iterator()` can return multiple entries with same name, so `outputHeaders.remove(name);` and `inputHeaders.forEachValue()` are highly inefficient. How about this:\r\n\r\n```java\r\nSet<AsciiString> removed = ...;\r\nfor (Entry<AsciiString, String> entry : inputHeaders) {\r\n    ... continue ...\r\n\r\n    if (removed.add(name)) {\r\n        outputHeaders.remove(name);\r\n    }\r\n    outputHeaders.add(name, value);\r\n}\r\n```\r\n\r\nI have some more ideas for improving this, but I think it's not part of this PR.", "bodyText": "inputHeaders.iterator() can return multiple entries with same name, so outputHeaders.remove(name); and inputHeaders.forEachValue() are highly inefficient. How about this:\nSet<AsciiString> removed = ...;\nfor (Entry<AsciiString, String> entry : inputHeaders) {\n    ... continue ...\n\n    if (removed.add(name)) {\n        outputHeaders.remove(name);\n    }\n    outputHeaders.add(name, value);\n}\nI have some more ideas for improving this, but I think it's not part of this PR.", "bodyHTML": "<p dir=\"auto\"><code>inputHeaders.iterator()</code> can return multiple entries with same name, so <code>outputHeaders.remove(name);</code> and <code>inputHeaders.forEachValue()</code> are highly inefficient. How about this:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Set&lt;AsciiString&gt; removed = ...;\nfor (Entry&lt;AsciiString, String&gt; entry : inputHeaders) {\n    ... continue ...\n\n    if (removed.add(name)) {\n        outputHeaders.remove(name);\n    }\n    outputHeaders.add(name, value);\n}\"><pre><span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">AsciiString</span>&gt;</span> removed <span class=\"pl-k\">=</span> <span class=\"pl-c1\">...</span>;\n<span class=\"pl-k\">for</span> (<span class=\"pl-k\">Entry&lt;<span class=\"pl-smi\">AsciiString</span>, <span class=\"pl-smi\">String</span>&gt;</span> entry <span class=\"pl-k\">:</span> inputHeaders) {\n    <span class=\"pl-c1\">...</span> <span class=\"pl-k\">continue</span> <span class=\"pl-c1\">...</span>\n\n    <span class=\"pl-k\">if</span> (removed<span class=\"pl-k\">.</span>add(name)) {\n        outputHeaders<span class=\"pl-k\">.</span>remove(name);\n    }\n    outputHeaders<span class=\"pl-k\">.</span>add(name, value);\n}</pre></div>\n<p dir=\"auto\">I have some more ideas for improving this, but I think it's not part of this PR.</p>", "author": "trustin", "createdAt": "2020-01-29T06:44:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -801,62 +813,127 @@ private static void addHttp2Scheme(io.netty.handler.codec.http.HttpHeaders in, U\n \n     /**\n      * Converts the specified Armeria HTTP/2 headers into Netty HTTP/2 headers.\n+     *\n+     * @param inputHeaders The HTTP/2 headers to convert.\n+     * @param additionalHeaders The additional headers which will be merged.\n+     * @param additionalTrailers The additional trailers which will be merged.\n+     * @param server    {@code true} if the returned headers will be used in a response message.\n+     *                  {@code false} for request message.\n+     * @param endStream {@code true} if returned headers will end streams.\n+     *                  {@code false} otherwise.\n+     * @param isTrailer {@code true} if returned headers should be treated as trailers.\n+     *                  {@code false} otherwise.\n      */\n-    public static Http2Headers toNettyHttp2(HttpHeaders in, boolean server) {\n-        final Http2Headers out = new DefaultHttp2Headers(false, in.size());\n+    public static Http2Headers toNettyHttp2(HttpHeaders inputHeaders,\n+                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                            boolean server, boolean endStream, boolean isTrailer) {\n+        final int headerSizeHint = inputHeaders.size() + additionalHeaders.size() + additionalTrailers.size();\n+        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n \n-        // Trailers if it does not have :status.\n-        if (server && !in.contains(HttpHeaderNames.STATUS)) {\n-            for (Entry<AsciiString, String> entry : in) {\n-                final AsciiString name = entry.getKey();\n-                final String value = entry.getValue();\n-                if (name.isEmpty() || isTrailerBlacklisted(name)) {\n-                    continue;\n-                }\n-                out.add(name, value);\n-            }\n-        } else {\n-            in.forEach((BiConsumer<AsciiString, String>) out::add);\n-            out.remove(HttpHeaderNames.CONNECTION);\n-            out.remove(HttpHeaderNames.TRANSFER_ENCODING);\n+        mergeHeadersHttp2(inputHeaders, outputHeaders, !server, isTrailer, false);\n+\n+        if (!isTrailer) {\n+            mergeHeadersHttp2(additionalHeaders, outputHeaders, !server, false, true);\n         }\n \n-        if (!out.contains(HttpHeaderNames.COOKIE)) {\n-            return out;\n+        if (server && endStream) {\n+            mergeHeadersHttp2(additionalTrailers, outputHeaders, false, isTrailer, true);\n+        }\n+\n+        outputHeaders.remove(HttpHeaderNames.CONNECTION);\n+        outputHeaders.remove(HttpHeaderNames.TRANSFER_ENCODING);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.COOKIE)) {\n+            return outputHeaders;\n         }\n \n         // Split up cookies to allow for better compression.\n         // https://tools.ietf.org/html/rfc7540#section-8.1.2.5\n-        final List<CharSequence> cookies = out.getAllAndRemove(HttpHeaderNames.COOKIE);\n+        final List<CharSequence> cookies = outputHeaders.getAllAndRemove(HttpHeaderNames.COOKIE);\n         for (CharSequence c : cookies) {\n-            out.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n+            outputHeaders.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n         }\n \n-        return out;\n+        return outputHeaders;\n+    }\n+\n+    private static void mergeHeadersHttp2(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n+                                          boolean isRequest, boolean isTrailer, boolean isAdditionalHeaders) {\n+        final Set<AsciiString> additionalHeaderBlackList = isRequest ? ADDITIONAL_REQUEST_HEADER_BLACKLIST\n+                                                                     : ADDITIONAL_RESPONSE_HEADER_BLACKLIST;\n+\n+        for (Entry<AsciiString, String> entry : inputHeaders) {\n+            final AsciiString name = entry.getKey();\n+\n+            if (name.isEmpty()) {\n+                continue;\n+            }\n+\n+            if (isAdditionalHeaders && additionalHeaderBlackList.contains(name)) {\n+                continue;\n+            }\n+\n+            if (isTrailer && isTrailerBlacklisted(name)) {\n+                continue;\n+            }\n+\n+            outputHeaders.remove(name);\n+            inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));\n+        }", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDkyOA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373210928", "bodyText": "Thanks, I fixed it.", "author": "jyblue", "createdAt": "2020-01-30T21:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMTg4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nindex 9ed11e22b..e5f212d41 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n", "chunk": "@@ -877,8 +874,10 @@ public final class ArmeriaHttpUtil {\n                 continue;\n             }\n \n-            outputHeaders.remove(name);\n-            inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));\n+            if (removed.add(name)) {\n+                outputHeaders.remove(name);\n+            }\n+            outputHeaders.add(name, value);\n         }\n     }\n \n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 86%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex e5f212d41..6da3f0b9f 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -882,10 +930,10 @@ public final class ArmeriaHttpUtil {\n     }\n \n     /**\n-     * Translate and add HTTP/2 headers to HTTP/1.x headers.\n+     * Translate and add HTTP/2 response headers to HTTP/1.x headers.\n      *\n      * @param streamId The stream associated with {@code sourceHeaders}.\n-     * @param inputHeaders The HTTP/2 headers to convert.\n+     * @param inputHeaders The HTTP/2 response headers to convert.\n      * @param additionalHeaders The additional headers which will be merged.\n      * @param additionalTrailers The additional trailers which will be merged.\n      * @param outputHeaders The object which will contain the resulting HTTP/1.x headers..\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex 9ed11e22b..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -877,78 +939,159 @@ public final class ArmeriaHttpUtil {\n                 continue;\n             }\n \n-            outputHeaders.remove(name);\n-            inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));\n+            if (removed.add(name)) {\n+                outputHeaders.remove(name);\n+            }\n+            outputHeaders.add(name, value);\n         }\n     }\n \n     /**\n-     * Translate and add HTTP/2 headers to HTTP/1.x headers.\n+     * Translate and add HTTP/2 response headers to HTTP/1.x headers.\n      *\n      * @param streamId The stream associated with {@code sourceHeaders}.\n-     * @param inputHeaders The HTTP/2 headers to convert.\n+     * @param inputHeaders The HTTP/2 response headers to convert.\n      * @param additionalHeaders The additional headers which will be merged.\n      * @param additionalTrailers The additional trailers which will be merged.\n      * @param outputHeaders The object which will contain the resulting HTTP/1.x headers..\n      * @param httpVersion What HTTP/1.x version {@code outputHeaders} should be treated as\n      *                    when doing the conversion.\n-     * @param isTrailer {@code true} if {@code outputHeaders} should be treated as trailers.\n-     *                  {@code false} otherwise.\n-     * @param isRequest {@code true} if the {@code outputHeaders} will be used in a request message.\n-     *                  {@code false} for response message.\n      * @param endStream {@code true} if {@code outputHeaders} will end streams.\n      *                  {@code false} otherwise.\n      *\n      * @throws Http2Exception If not all HTTP/2 headers can be translated to HTTP/1.x.\n      */\n-    public static void toNettyHttp1(\n+    public static void toNettyHttp1ServerHeader(\n             int streamId, HttpHeaders inputHeaders,\n             HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            io.netty.handler.codec.http.HttpHeaders outputHeaders,\n-            HttpVersion httpVersion, boolean isTrailer, boolean isRequest, boolean endStream)\n+            io.netty.handler.codec.http.HttpHeaders outputHeaders, HttpVersion httpVersion, boolean endStream)\n             throws Http2Exception {\n+        mergeHeadersHttp1Server(streamId, inputHeaders, outputHeaders, false, false);\n+        mergeHeadersHttp1Server(streamId, additionalHeaders, outputHeaders, false, true);\n \n-        mergeHeadersHttp1(streamId, inputHeaders, outputHeaders, isRequest, isTrailer, false);\n-\n-        if (!isTrailer) {\n-            mergeHeadersHttp1(streamId, additionalHeaders, outputHeaders, isRequest, false, true);\n+        if (endStream && !additionalTrailers.isEmpty()) {\n+            mergeHeadersHttp1Server(streamId, additionalTrailers, outputHeaders, true, true);\n         }\n+        HttpUtil.setKeepAlive(outputHeaders, httpVersion, true);\n+    }\n \n-        if (!isRequest && endStream) {\n-            mergeHeadersHttp1(streamId, additionalTrailers, outputHeaders, false, isTrailer, true);\n+    /**\n+     * Translate and add HTTP/2 response headers to HTTP/1.x headers.\n+     *\n+     * @param streamId The stream associated with {@code sourceHeaders}.\n+     * @param inputHeaders The HTTP/2 response headers to convert.\n+     * @param additionalTrailers The additional trailers which will be merged.\n+     * @param outputHeaders The object which will contain the resulting HTTP/1.x headers..\n+     *                    when doing the conversion.\n+     * @param endStream {@code true} if {@code outputHeaders} will end streams.\n+     *                  {@code false} otherwise.\n+     *\n+     * @throws Http2Exception If not all HTTP/2 headers can be translated to HTTP/1.x.\n+     */\n+    public static void toNettyHttp1ServerTrailer(\n+            int streamId, HttpHeaders inputHeaders, HttpHeaders additionalTrailers,\n+            io.netty.handler.codec.http.HttpHeaders outputHeaders, boolean endStream) throws Http2Exception {\n+        mergeHeadersHttp1Server(streamId, inputHeaders, outputHeaders, true, false);\n+\n+        if (endStream) {\n+            mergeHeadersHttp1Server(streamId, additionalTrailers, outputHeaders, true, true);\n         }\n+    }\n \n-        if (!isTrailer) {\n-            HttpUtil.setKeepAlive(outputHeaders, httpVersion, true);\n+    private static void mergeHeadersHttp1Server(\n+            int streamId, HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n+            boolean isTrailer, boolean isAdditionalHeader) throws Http2Exception {\n+        try {\n+            final Set<AsciiString> removed = new HashSet<>();\n+            for (Entry<AsciiString, String> entry : inputHeaders) {\n+                final AsciiString name = entry.getKey();\n+                final String value = entry.getValue();\n+                final AsciiString translatedName = RESPONSE_HEADER_TRANSLATIONS.get(name);\n+                if (translatedName != null && !inputHeaders.contains(translatedName)) {\n+                    outputHeaders.add(translatedName, value);\n+                    continue;\n+                }\n+\n+                if (HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n+                    continue;\n+                }\n+\n+                if (isAdditionalHeader && ADDITIONAL_RESPONSE_HEADER_BLACKLIST.contains(name)) {\n+                    continue;\n+                }\n+\n+                if (isTrailer && isTrailerBlacklisted(name)) {\n+                    continue;\n+                }\n+\n+                if (removed.add(name)) {\n+                    outputHeaders.remove(name);\n+                }\n+                outputHeaders.add(name, value);\n+            }\n+        } catch (Throwable t) {\n+            throw streamError(streamId, PROTOCOL_ERROR, t, \"HTTP/2 to HTTP/1.x headers conversion error\");\n         }\n     }\n \n-    private static void mergeHeadersHttp1(\n-            int streamId,\n-            HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n-            boolean isRequest, boolean isTrailer, boolean isAdditionalHeader) throws Http2Exception {\n-        final CharSequenceMap translations = isRequest ? REQUEST_HEADER_TRANSLATIONS\n-                                                       : RESPONSE_HEADER_TRANSLATIONS;\n-        final Set<AsciiString> additionalHeaderBlackList = isRequest ? ADDITIONAL_REQUEST_HEADER_BLACKLIST\n-                                                                     : ADDITIONAL_RESPONSE_HEADER_BLACKLIST;\n+    /**\n+     * Translate and add HTTP/2 request headers to HTTP/1.x headers.\n+     *\n+     * @param streamId The stream associated with {@code sourceHeaders}.\n+     * @param inputHeaders The HTTP/2 request headers to convert.\n+     * @param additionalHeaders The additional headers which will be merged.\n+     * @param outputHeaders The object which will contain the resulting HTTP/1.x headers..\n+     * @param httpVersion What HTTP/1.x version {@code outputHeaders} should be treated as\n+     *                    when doing the conversion.\n+     *\n+     * @throws Http2Exception If not all HTTP/2 headers can be translated to HTTP/1.x.\n+     */\n+    public static void toNettyHttp1ClientHeader(\n+            int streamId, HttpHeaders inputHeaders, HttpHeaders additionalHeaders,\n+            io.netty.handler.codec.http.HttpHeaders outputHeaders,\n+            HttpVersion httpVersion) throws Http2Exception {\n \n+        mergeHeadersHttp1Client(streamId, inputHeaders, outputHeaders, false, false);\n+        mergeHeadersHttp1Client(streamId, additionalHeaders, outputHeaders, false, true);\n+        HttpUtil.setKeepAlive(outputHeaders, httpVersion, true);\n+    }\n+\n+    /**\n+     * Translate and add HTTP/2 request headers to HTTP/1.x headers.\n+     *\n+     * @param streamId The stream associated with {@code sourceHeaders}.\n+     * @param inputHeaders The HTTP/2 request headers to convert.\n+     * @param outputHeaders The object which will contain the resulting HTTP/1.x headers..\n+     *\n+     * @throws Http2Exception If not all HTTP/2 headers can be translated to HTTP/1.x.\n+     */\n+    public static void toNettyHttp1ClientTrailer(\n+            int streamId, HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders)\n+            throws Http2Exception {\n+        mergeHeadersHttp1Client(streamId, inputHeaders, outputHeaders, true, false);\n+    }\n+\n+    private static void mergeHeadersHttp1Client(\n+            int streamId, HttpHeaders inputHeaders, io.netty.handler.codec.http.HttpHeaders outputHeaders,\n+            boolean isTrailer, boolean isAdditionalHeader) throws Http2Exception {\n         StringJoiner cookieJoiner = null;\n \n         try {\n+            final Set<AsciiString> removed = new HashSet<>();\n             for (Entry<AsciiString, String> entry : inputHeaders) {\n                 final AsciiString name = entry.getKey();\n                 final String value = entry.getValue();\n-                final AsciiString translatedName = translations.get(name);\n+                final AsciiString translatedName = REQUEST_HEADER_TRANSLATIONS.get(name);\n                 if (translatedName != null && !inputHeaders.contains(translatedName)) {\n                     outputHeaders.add(translatedName, value);\n                     continue;\n                 }\n \n-                if (name.isEmpty() || HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n+                if (HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n-                if (isAdditionalHeader && additionalHeaderBlackList.contains(name)) {\n+                if (isAdditionalHeader && ADDITIONAL_REQUEST_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMTk4MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372211980", "body": "Ditto", "bodyText": "Ditto", "bodyHTML": "<p dir=\"auto\">Ditto</p>", "author": "trustin", "createdAt": "2020-01-29T06:44:42Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -871,19 +948,24 @@ public static void toNettyHttp1(\n                     continue;\n                 }\n \n+                if (isAdditionalHeader && additionalHeaderBlackList.contains(name)) {\n+                    continue;\n+                }\n+\n                 if (isTrailer && isTrailerBlacklisted(name)) {\n                     continue;\n                 }\n \n-                if (HttpHeaderNames.COOKIE.equals(name)) {\n+                if (isRequest && HttpHeaderNames.COOKIE.equals(name)) {\n                     // combine the cookie values into 1 header entry.\n                     // https://tools.ietf.org/html/rfc7540#section-8.1.2.5\n                     if (cookieJoiner == null) {\n                         cookieJoiner = new StringJoiner(COOKIE_SEPARATOR);\n                     }\n                     COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n                 } else {\n-                    outputHeaders.add(name, value);\n+                    outputHeaders.remove(name);\n+                    inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMDcwMw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373210703", "bodyText": "Thanks, I fixed it.", "author": "jyblue", "createdAt": "2020-01-30T21:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMTk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nindex 9ed11e22b..e5f212d41 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n", "chunk": "@@ -964,8 +964,10 @@ public final class ArmeriaHttpUtil {\n                     }\n                     COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n                 } else {\n-                    outputHeaders.remove(name);\n-                    inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));\n+                    if (removed.add(name)) {\n+                        outputHeaders.remove(name);\n+                    }\n+                    outputHeaders.add(name, value);\n                 }\n             }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex 9ed11e22b..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -964,8 +1107,10 @@ public final class ArmeriaHttpUtil {\n                     }\n                     COOKIE_SPLITTER.split(value).forEach(cookieJoiner::add);\n                 } else {\n-                    outputHeaders.remove(name);\n-                    inputHeaders.forEachValue(name, newValue -> outputHeaders.add(name, newValue));\n+                    if (removed.add(name)) {\n+                        outputHeaders.remove(name);\n+                    }\n+                    outputHeaders.add(name, value);\n                 }\n             }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMDUyMg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372210522", "body": "`Version.indentity` has been removed by #2398. Could you merge the master branch?", "bodyText": "Version.indentity has been removed by #2398. Could you merge the master branch?", "bodyHTML": "<p dir=\"auto\"><code>Version.indentity</code> has been removed by <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"549966745\" data-permission-text=\"Title is private\" data-url=\"https://github.com/line/armeria/issues/2398\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/line/armeria/pull/2398/hovercard\" href=\"https://github.com/line/armeria/pull/2398\">#2398</a>. Could you merge the master branch?</p>", "author": "ikhoon", "createdAt": "2020-01-29T06:38:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -212,6 +214,16 @@ public boolean equals(AsciiString a, AsciiString b) {\n         HTTP_TRAILER_BLACKLIST.add(HttpHeaderNames.TRAILER, EMPTY_STRING);\n     }\n \n+    private static final Set<AsciiString> ADDITIONAL_REQUEST_HEADER_BLACKLIST = ImmutableSet.of(\n+            HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD);\n+\n+    private static final Set<AsciiString> ADDITIONAL_RESPONSE_HEADER_BLACKLIST = ImmutableSet.of(\n+            HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD, HttpHeaderNames.PATH);\n+\n+    public static final String SERVER_HEADER =\n+            \"Armeria/\" + Version.identify(ArmeriaHttpUtil.class.getClassLoader()).get(\"armeria\")", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0OTY2OQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372649669", "bodyText": "Merged \ud83d\ude00", "author": "jyblue", "createdAt": "2020-01-29T21:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxMDUyMg=="}], "type": "inlineReview", "revised_code": {"commit": "7b7e2cc10b2a1a7e5270fad10b469067f3cdd39a", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 80%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex 9ed11e22b..33d7797ef 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -221,7 +225,7 @@ public final class ArmeriaHttpUtil {\n             HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD, HttpHeaderNames.PATH);\n \n     public static final String SERVER_HEADER =\n-            \"Armeria/\" + Version.identify(ArmeriaHttpUtil.class.getClassLoader()).get(\"armeria\")\n+            \"Armeria/\" + Version.getAll(ArmeriaHttpUtil.class.getClassLoader()).get(\"armeria\")\n                                 .artifactVersion();\n \n     /**\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex 9ed11e22b..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -221,7 +225,7 @@ public final class ArmeriaHttpUtil {\n             HttpHeaderNames.SCHEME, HttpHeaderNames.STATUS, HttpHeaderNames.METHOD, HttpHeaderNames.PATH);\n \n     public static final String SERVER_HEADER =\n-            \"Armeria/\" + Version.identify(ArmeriaHttpUtil.class.getClassLoader()).get(\"armeria\")\n+            \"Armeria/\" + Version.getAll(ArmeriaHttpUtil.class.getClassLoader()).get(\"armeria\")\n                                 .artifactVersion();\n \n     /**\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxNzU4NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372217585", "body": "Could be `static`?", "bodyText": "Could be static?", "bodyHTML": "<p dir=\"auto\">Could be <code>static</code>?</p>", "author": "ikhoon", "createdAt": "2020-01-29T07:07:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -180,15 +205,11 @@ private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted,\n     }\n \n     private HttpObject convertServerHeaders(", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0ODA0Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372648047", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-01-29T21:46:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIxNzU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 2ee986fb5..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -204,7 +204,7 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n         return f;\n     }\n \n-    private HttpObject convertServerHeaders(\n+    private static HttpObject convertServerHeaders(\n             int streamId, HttpHeaders headers, boolean endStream,\n             HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n             boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nsimilarity index 91%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 6f9bf297c..5c5388091 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -204,10 +203,9 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n         return f;\n     }\n \n-    private static HttpObject convertServerHeaders(\n+    private HttpObject convertServerHeaders(\n             int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n+            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) throws Http2Exception {\n \n         final String status = headers.get(HttpHeaderNames.STATUS);\n         final HttpResponse res;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 2ee986fb5..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,639 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n-                              sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convertClientHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, HttpHeaders.of(), outHeaders,\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-            outHeaders.add(HttpHeaderNames.HOST,\n-                           ArmeriaHttpUtil.authorityHeader(\n-                                   ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                   ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                   sessionProtocol.defaultPort()));\n-        }\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private LastHttpContent getLastHttpContent(HttpHeaders headers) {\n-        if (headers.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-        }\n-    }\n-\n-    private void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMTk0MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372221940", "body": "nit: \"https\" -> `SessionProtocol.HTTPS.uriText()`, \"http\" -> `SessionProtocol.HTTP.uriText()`", "bodyText": "nit: \"https\" -> SessionProtocol.HTTPS.uriText(), \"http\" -> SessionProtocol.HTTP.uriText()", "bodyHTML": "<p dir=\"auto\">nit: \"https\" -&gt; <code>SessionProtocol.HTTPS.uriText()</code>, \"http\" -&gt; <code>SessionProtocol.HTTP.uriText()</code></p>", "author": "ikhoon", "createdAt": "2020-01-29T07:18:35Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -69,9 +101,83 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        true, endStream, false);\n+\n+        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n+\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n+\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n+\n+        return outputHeaders;\n+    }\n+\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n+\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        false, endStream, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0ODMxMQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372648311", "bodyText": "Thank you, fixed it.", "author": "jyblue", "createdAt": "2020-01-29T21:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMTk0MA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 84572ffa9..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -160,14 +160,15 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n+            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                         : SessionProtocol.HTTP.uriText());\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n                                       sessionProtocol.defaultPort()));\n         }\n \n", "next_change": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 0e35d95d8..50544bbab 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -159,12 +155,12 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n             outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n                                                          : SessionProtocol.HTTP.uriText());\n         }\n \n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nsimilarity index 82%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 50544bbab..500cb0227 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -155,23 +157,23 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                  : SessionProtocol.HTTP.uriText());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n                                       remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n+                                      protocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n-    private Http2Headers convertClientTrailers(\n+    private static Http2Headers convertClientTrailers(\n             HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n         return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n                                             false, endStream, true);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 84572ffa9..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMjE0MQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372222141", "body": "We don't need `requireNonNull` in a private method. By the way, `SessionProtocol` seems nullable because the caller(doWriteHeaders) calls this method with nullable `SessionProtocol`.\r\n", "bodyText": "We don't need requireNonNull in a private method. By the way, SessionProtocol seems nullable because the caller(doWriteHeaders) calls this method with nullable SessionProtocol.", "bodyHTML": "<p dir=\"auto\">We don't need <code>requireNonNull</code> in a private method. By the way, <code>SessionProtocol</code> seems nullable because the caller(doWriteHeaders) calls this method with nullable <code>SessionProtocol</code>.</p>", "author": "ikhoon", "createdAt": "2020-01-29T07:19:16Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -69,9 +101,83 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        true, endStream, false);\n+\n+        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n+\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n+\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n+\n+        return outputHeaders;\n+    }\n+\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n+\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg1MjQ2Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r376852467", "bodyText": "Removed SessionProtocol by setting it when it constructed \ud83d\ude00", "author": "jyblue", "createdAt": "2020-02-10T03:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMjE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 84572ffa9..50544bbab 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -147,10 +146,7 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n \n     private Http2Headers convertClientHeaders(\n             HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n+            boolean endStream, @Nullable SessionProtocol sessionProtocol) {\n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n                                                                         false, endStream, false);\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nsimilarity index 82%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 50544bbab..500cb0227 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -146,7 +148,7 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n \n     private Http2Headers convertClientHeaders(\n             HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, @Nullable SessionProtocol sessionProtocol) {\n+            boolean endStream) {\n         final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n                                                                         additionalHeaders, additionalTrailers,\n                                                                         false, endStream, false);\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nsimilarity index 82%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 50544bbab..500cb0227 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -155,23 +157,23 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                  : SessionProtocol.HTTP.uriText());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n                                       remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n+                                      protocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n-    private Http2Headers convertClientTrailers(\n+    private static Http2Headers convertClientTrailers(\n             HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n         return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n                                             false, endStream, true);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 84572ffa9..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMzg3MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372223870", "body": "How about checking `!additionalTrailers.isEmpty()` first because I think `isEmpty` is cheaper and most of yours don't set trailers.\r\n```java\r\nif (!additionalTrailers.isEmpty() && outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) {\r\n  ...\r\n}\r\n```", "bodyText": "How about checking !additionalTrailers.isEmpty() first because I think isEmpty is cheaper and most of yours don't set trailers.\nif (!additionalTrailers.isEmpty() && outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) {\n  ...\n}", "bodyHTML": "<p dir=\"auto\">How about checking <code>!additionalTrailers.isEmpty()</code> first because I think <code>isEmpty</code> is cheaper and most of yours don't set trailers.</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (!additionalTrailers.isEmpty() &amp;&amp; outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) {\n  ...\n}\n\"><pre><span class=\"pl-k\">if</span> (<span class=\"pl-k\">!</span>additionalTrailers<span class=\"pl-k\">.</span>isEmpty() <span class=\"pl-k\">&amp;&amp;</span> outputHeaders<span class=\"pl-k\">.</span>contains(<span class=\"pl-smi\">HttpHeaderNames</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>CONTENT_LENGTH</span>) {\n  <span class=\"pl-c1\">...</span>\n}</pre></div>", "author": "ikhoon", "createdAt": "2020-01-29T07:25:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -69,9 +101,83 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        true, endStream, false);\n+\n+        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0OTE3Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372649176", "bodyText": "Fixed it. Thanks for education.", "author": "jyblue", "createdAt": "2020-01-29T21:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyMzg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 84572ffa9..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -120,8 +120,8 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n                                                                         additionalHeaders, additionalTrailers,\n                                                                         true, endStream, false);\n \n-        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n+        if (!additionalTrailers.isEmpty() &&\n+            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n             // We don't apply chunked encoding when the content-length header is set, which would\n             // prevent the trailers from being sent so we go ahead and remove content-length to force\n             // chunked encoding.\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 0e35d95d8..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,238 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 84572ffa9..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyNzQzMA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372227430", "body": "nit: Remove this blank line?", "bodyText": "nit: Remove this blank line?", "bodyHTML": "<p dir=\"auto\">nit: Remove this blank line?</p>", "author": "ikhoon", "createdAt": "2020-01-29T07:38:06Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -997,5 +1075,21 @@ public static boolean isTrailerBlacklisted(AsciiString name) {\n         }\n     }\n \n+    /**\n+     * Returns a authority header value of specified host and port.\n+     */\n+    public static String authorityHeader(String host, int port, int defaultPort) {\n+", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0ODgxNA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372648814", "bodyText": "Removed.", "author": "jyblue", "createdAt": "2020-01-29T21:47:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIyNzQzMA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nindex 9ed11e22b..c65f699d7 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n", "chunk": "@@ -1079,7 +1079,6 @@ public final class ArmeriaHttpUtil {\n      * Returns a authority header value of specified host and port.\n      */\n     public static String authorityHeader(String host, int port, int defaultPort) {\n-\n         if (port == defaultPort) {\n             return host;\n         } else {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex 9ed11e22b..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -1079,7 +1225,6 @@ public final class ArmeriaHttpUtil {\n      * Returns a authority header value of specified host and port.\n      */\n     public static String authorityHeader(String host, int port, int defaultPort) {\n-\n         if (port == defaultPort) {\n             return host;\n         } else {\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMzA2OA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372233068", "body": "Ditto, check `!additionalTrailers.isEmpty()` first", "bodyText": "Ditto, check !additionalTrailers.isEmpty() first", "bodyHTML": "<p dir=\"auto\">Ditto, check <code>!additionalTrailers.isEmpty()</code> first</p>", "author": "ikhoon", "createdAt": "2020-01-29T07:55:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -216,31 +239,78 @@ private HttpObject convertServerHeaders(\n         } else {\n             res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n             // Perform conversion.\n-            convert(streamId, headers, res.headers(), false, false);\n+            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n+                                  additionalHeaders, additionalTrailers,\n+                                  enableServerHeader, enableDateHeader);\n             setTransferEncoding(res);\n         }\n \n         return res;\n     }\n \n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream)\n-            throws Http2Exception {\n+    private void convertServerHeaders0(\n+            int streamId, HttpHeaders inHeaders,\n+            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n+            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n \n-        // Leading headers will always have :method, trailers will never have it.\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            return convertTrailingHeaders(streamId, headers);\n+        ArmeriaHttpUtil.toNettyHttp1(\n+                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n+                HttpVersion.HTTP_1_1, false, false, endStream);\n+\n+        removeHttpExtensionHeaders(outHeaders);\n+\n+        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0OTI2Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372649266", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-01-29T21:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMzA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nindex 2ee986fb5..6f9bf297c 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n", "chunk": "@@ -260,8 +260,8 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n \n         removeHttpExtensionHeaders(outHeaders);\n \n-        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n+        if (!additionalTrailers.isEmpty() &&\n+            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n             // We don't apply chunked encoding when the content-length header is set, which would\n             // prevent the trailers from being sent so we go ahead and remove content-length to\n             // force chunked encoding.\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 6f9bf297c..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private static HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private static void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(req.headers());\n-\n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 2ee986fb5..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,639 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        convertClientHeaders0(streamId, headers, req.headers(), endStream, additionalHeaders,\n-                              sessionProtocol);\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private void convertClientHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, HttpHeaders.of(), outHeaders,\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!outHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outHeaders.contains(HttpHeaderNames.HOST)) {\n-            outHeaders.add(HttpHeaderNames.HOST,\n-                           ArmeriaHttpUtil.authorityHeader(\n-                                   ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                   ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                   sessionProtocol.defaultPort()));\n-        }\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        final LastHttpContent lastContent = getLastHttpContent(inHeaders);\n-\n-        if (inHeaders.isEmpty()) {\n-            return lastContent;\n-        }\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private LastHttpContent getLastHttpContent(HttpHeaders headers) {\n-        if (headers.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        } else {\n-            return new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-        }\n-    }\n-\n-    private void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMzc5MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372233790", "body": "Introduce a local variable for `(InetSocketAddress) channel().remoteAddress()`?", "bodyText": "Introduce a local variable for (InetSocketAddress) channel().remoteAddress()?", "bodyHTML": "<p dir=\"auto\">Introduce a local variable for <code>(InetSocketAddress) channel().remoteAddress()</code>?</p>", "author": "ikhoon", "createdAt": "2020-01-29T07:57:41Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java", "diffHunk": "@@ -69,9 +101,83 @@ protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers\n             return newFailedFuture(ClosedPublisherException.get());\n         }\n \n+        if (!isTrailer) {\n+            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n+                                                    endStream, sessionProtocol);\n+        } else {\n+            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n+        }\n+\n         // Client starts a new stream.\n-        return encoder.writeHeaders(\n-                ctx, streamId, ArmeriaHttpUtil.toNettyHttp2(headers, server), 0, endStream, ctx.newPromise());\n+        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n+    }\n+\n+    private Http2Headers convertServerHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        true, endStream, false);\n+\n+        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n+            !additionalTrailers.isEmpty()) {\n+            // We don't apply chunked encoding when the content-length header is set, which would\n+            // prevent the trailers from being sent so we go ahead and remove content-length to force\n+            // chunked encoding.\n+            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n+        }\n+\n+        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n+            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n+        }\n+\n+        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n+            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n+        }\n+\n+        return outputHeaders;\n+    }\n+\n+    private Http2Headers convertServerTrailers(\n+            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n+        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n+                                            true, endStream, true);\n+    }\n+\n+    private Http2Headers convertClientHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+            boolean endStream, SessionProtocol sessionProtocol) {\n+\n+        requireNonNull(sessionProtocol);\n+\n+        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n+                                                                        additionalHeaders, additionalTrailers,\n+                                                                        false, endStream, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n+                              ArmeriaHttpUtil.authorityHeader(\n+                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n+                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0OTM5MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372649390", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-01-29T21:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjIzMzc5MA=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 84572ffa9..0e35d95d8 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -160,14 +160,15 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n+            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                         : SessionProtocol.HTTP.uriText());\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n+                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n                                       sessionProtocol.defaultPort()));\n         }\n \n", "next_change": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nindex 0e35d95d8..50544bbab 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n", "chunk": "@@ -159,12 +155,12 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n             outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n                                                          : SessionProtocol.HTTP.uriText());\n         }\n \n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nsimilarity index 82%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 50544bbab..500cb0227 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -155,23 +157,23 @@ public final class Http2ObjectEncoder extends HttpObjectEncoder {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                         : SessionProtocol.HTTP.uriText());\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                  : SessionProtocol.HTTP.uriText());\n         }\n \n-        if (sessionProtocol != null && !outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n+        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n             outputHeaders.add(HttpHeaderNames.AUTHORITY,\n                               ArmeriaHttpUtil.authorityHeader(\n                                       remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n+                                      protocol.defaultPort()));\n         }\n \n         return outputHeaders;\n     }\n \n-    private Http2Headers convertClientTrailers(\n+    private static Http2Headers convertClientTrailers(\n             HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n         return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n                                             false, endStream, true);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\ndeleted file mode 100644\nindex 84572ffa9..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http2ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,237 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n-import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Headers;\n-import io.netty.handler.codec.http2.Http2Stream;\n-import io.netty.util.ReferenceCountUtil;\n-\n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n-    private final ChannelHandlerContext ctx;\n-    private final Http2ConnectionEncoder encoder;\n-\n-    public Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n-        this.ctx = requireNonNull(ctx, \"ctx\");\n-        this.encoder = requireNonNull(encoder, \"encoder\");\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ctx.channel();\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        final Http2Connection conn = encoder.connection();\n-        final boolean server = conn.isServer();\n-        final boolean isTrailer = server ? !headers.contains(HttpHeaderNames.STATUS)\n-                                         : !headers.contains(HttpHeaderNames.METHOD);\n-        final Http2Headers convertedHeaders;\n-\n-        if (isStreamPresentAndWritable(streamId)) {\n-            if (server) {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertServerHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream,\n-                                                            enableServerHeader, enableDateHeader);\n-                } else {\n-                    convertedHeaders = convertServerTrailers(headers, additionalTrailers, endStream);\n-                }\n-            } else {\n-                if (!isTrailer) {\n-                    convertedHeaders = convertClientHeaders(headers,\n-                                                            additionalHeaders, additionalTrailers,\n-                                                            endStream, sessionProtocol);\n-                } else {\n-                    convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-                }\n-            }\n-\n-            // Writing to an existing stream.\n-            return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (server) {\n-            // One of the following cases:\n-            // - Stream has been closed already.\n-            // - (bug) Server tried to send a response HEADERS frame before receiving a request HEADERS frame.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (conn.local().mayHaveCreatedStream(streamId)) {\n-            // Stream has been closed.\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        if (!isTrailer) {\n-            convertedHeaders = convertClientHeaders(headers, additionalHeaders, additionalTrailers,\n-                                                    endStream, sessionProtocol);\n-        } else {\n-            convertedHeaders = convertClientTrailers(headers, additionalTrailers, endStream);\n-        }\n-\n-        // Client starts a new stream.\n-        return encoder.writeHeaders(ctx, streamId, convertedHeaders, 0, endStream, ctx.newPromise());\n-    }\n-\n-    private Http2Headers convertServerHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, boolean enableServerHeader, boolean enableDateHeader) {\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        true, endStream, false);\n-\n-        if (outputHeaders.contains(HttpHeaderNames.CONTENT_LENGTH) &&\n-            !additionalTrailers.isEmpty()) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to force\n-            // chunked encoding.\n-            outputHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outputHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outputHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outputHeaders.contains(HttpHeaderNames.DATE)) {\n-            outputHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertServerTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            true, endStream, true);\n-    }\n-\n-    private Http2Headers convertClientHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean endStream, SessionProtocol sessionProtocol) {\n-\n-        requireNonNull(sessionProtocol);\n-\n-        final Http2Headers outputHeaders = ArmeriaHttpUtil.toNettyHttp2(inputHeaders,\n-                                                                        additionalHeaders, additionalTrailers,\n-                                                                        false, endStream, false);\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(sessionProtocol.isTls() ? \"https\" : \"http\");\n-        }\n-\n-        if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n-            outputHeaders.add(HttpHeaderNames.AUTHORITY,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      ((InetSocketAddress) channel().remoteAddress()).getHostName(),\n-                                      ((InetSocketAddress) channel().remoteAddress()).getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        return outputHeaders;\n-    }\n-\n-    private Http2Headers convertClientTrailers(\n-            HttpHeaders inputHeaders, HttpHeaders additionalTrailers, boolean endStream) {\n-        return ArmeriaHttpUtil.toNettyHttp2(inputHeaders, HttpHeaders.of(), additionalTrailers,\n-                                            false, endStream, true);\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (isStreamPresentAndWritable(streamId)) {\n-            // Write to an existing stream.\n-            return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n-        }\n-\n-        if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n-            // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n-            return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n-                                  : newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n-        return newFailedFuture(new IllegalStateException(\n-                \"cannot start a new stream \" + streamId + \" with a DATA frame\"));\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        // Send a RST_STREAM frame only for an active stream which did not send a RST_STREAM frame already.\n-        if (stream != null && !stream.isResetSent()) {\n-            return encoder.writeRstStream(ctx, streamId, error.code(), ctx.newPromise());\n-        }\n-\n-        return ctx.writeAndFlush(Unpooled.EMPTY_BUFFER);\n-    }\n-\n-    /**\n-     * Returns {@code true} if the stream with the given {@code streamId} has been created and is writable.\n-     * Note that this method will return {@code false} for the stream which was not created yet.\n-     */\n-    private boolean isStreamPresentAndWritable(int streamId) {\n-        final Http2Stream stream = encoder.connection().stream(streamId);\n-        if (stream == null) {\n-            return false;\n-        }\n-\n-        switch (stream.state()) {\n-            case RESERVED_LOCAL:\n-            case OPEN:\n-            case HALF_CLOSED_REMOTE:\n-                return true;\n-            default:\n-                // The response has been sent already.\n-                return false;\n-        }\n-    }\n-\n-    @Override\n-    protected void doClose() {}\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI2NDAzMQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r372264031", "body": "nit: `false, false, null` are hard to understand. \ud83d\ude05 Add comment to null and false value for readability?\r\n```suggestion\r\n                HttpHeaders.of(), HttpHeaders.of(), false /* enableServerHeader */, false /* enableDateHeader */, null /* sessionProtocol */);\r\n```", "bodyText": "nit: false, false, null are hard to understand. \ud83d\ude05 Add comment to null and false value for readability?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            HttpHeaders.of(), HttpHeaders.of(), false, false, null);\n          \n          \n            \n                            HttpHeaders.of(), HttpHeaders.of(), false /* enableServerHeader */, false /* enableDateHeader */, null /* sessionProtocol */);", "bodyHTML": "<p dir=\"auto\">nit: <code>false, false, null</code> are hard to understand. <g-emoji class=\"g-emoji\" alias=\"sweat_smile\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f605.png\">\ud83d\ude05</g-emoji> Add comment to null and false value for readability?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-smi\">HttpHeaders</span><span class=\"pl-k\">.</span>of(), <span class=\"pl-smi\">HttpHeaders</span><span class=\"pl-k\">.</span>of(), <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">null</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-smi\">HttpHeaders</span><span class=\"pl-k\">.</span>of(), <span class=\"pl-smi\">HttpHeaders</span><span class=\"pl-k\">.</span>of(), <span class=\"pl-c1\">false</span><span class=\"x x-first\"> </span><span class=\"pl-c\"><span class=\"pl-c x\">/*</span><span class=\"x\"> enableServerHeader </span><span class=\"pl-c x x-last\">*/</span></span>, <span class=\"pl-c1\">false</span><span class=\"x x-first\"> </span><span class=\"pl-c\"><span class=\"pl-c x\">/*</span><span class=\"x\"> enableDateHeader </span><span class=\"pl-c x x-last\">*/</span></span>, <span class=\"pl-c1\">null</span><span class=\"x x-first\"> </span><span class=\"pl-c\"><span class=\"pl-c x\">/*</span><span class=\"x\"> sessionProtocol </span><span class=\"pl-c x x-last\">*/</span></span>);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ikhoon", "createdAt": "2020-01-29T09:12:39Z", "path": "core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java", "diffHunk": "@@ -539,7 +540,8 @@ private ChannelFuture respond(ServiceRequestContext reqCtx, boolean addKeepAlive\n \n         final ResponseHeaders immutableResHeaders = resHeaders.build();\n         ChannelFuture future = responseEncoder.writeHeaders(\n-                req.id(), req.streamId(), immutableResHeaders, !hasContent);\n+                req.id(), req.streamId(), immutableResHeaders, !hasContent,\n+                HttpHeaders.of(), HttpHeaders.of(), false, false, null);", "originalCommit": "73262810023e267bc4ae2e8d809c1a4b701ee252", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIxMTEyNA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373211124", "bodyText": "Thanks, I fixed it.", "author": "jyblue", "createdAt": "2020-01-30T21:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjI2NDAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "a27fa1390d57112ed924c3e1433020753ec9c925", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\nindex 4837366ee..542d5a377 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n", "chunk": "@@ -541,7 +541,8 @@ final class HttpServerHandler extends ChannelInboundHandlerAdapter implements Ht\n         final ResponseHeaders immutableResHeaders = resHeaders.build();\n         ChannelFuture future = responseEncoder.writeHeaders(\n                 req.id(), req.streamId(), immutableResHeaders, !hasContent,\n-                HttpHeaders.of(), HttpHeaders.of(), false, false, null);\n+                HttpHeaders.of(), HttpHeaders.of(),\n+                false /* enableServerHeader */, false /* enableDateHeader */, null /* sessionProtocol */);\n         logBuilder.responseHeaders(immutableResHeaders);\n         if (hasContent) {\n             logBuilder.increaseResponseLength(resContent);\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\nindex 542d5a377..dd9a6fb3b 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n", "chunk": "@@ -541,8 +554,7 @@ final class HttpServerHandler extends ChannelInboundHandlerAdapter implements Ht\n         final ResponseHeaders immutableResHeaders = resHeaders.build();\n         ChannelFuture future = responseEncoder.writeHeaders(\n                 req.id(), req.streamId(), immutableResHeaders, !hasContent,\n-                HttpHeaders.of(), HttpHeaders.of(),\n-                false /* enableServerHeader */, false /* enableDateHeader */, null /* sessionProtocol */);\n+                HttpHeaders.of(), HttpHeaders.of());\n         logBuilder.responseHeaders(immutableResHeaders);\n         if (hasContent) {\n             logBuilder.increaseResponseLength(resContent);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\nindex 4837366ee..bba13fad3 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n", "chunk": "@@ -541,7 +556,7 @@ final class HttpServerHandler extends ChannelInboundHandlerAdapter implements Ht\n         final ResponseHeaders immutableResHeaders = resHeaders.build();\n         ChannelFuture future = responseEncoder.writeHeaders(\n                 req.id(), req.streamId(), immutableResHeaders, !hasContent,\n-                HttpHeaders.of(), HttpHeaders.of(), false, false, null);\n+                HttpHeaders.of(), HttpHeaders.of());\n         logBuilder.responseHeaders(immutableResHeaders);\n         if (hasContent) {\n             logBuilder.increaseResponseLength(resContent);\n", "next_change": {"commit": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\nindex bba13fad3..19943d6fa 100644\n--- a/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n+++ b/core/src/main/java/com/linecorp/armeria/server/HttpServerHandler.java\n", "chunk": "@@ -555,8 +554,7 @@ final class HttpServerHandler extends ChannelInboundHandlerAdapter implements Ht\n \n         final ResponseHeaders immutableResHeaders = resHeaders.build();\n         ChannelFuture future = responseEncoder.writeHeaders(\n-                req.id(), req.streamId(), immutableResHeaders, !hasContent,\n-                HttpHeaders.of(), HttpHeaders.of());\n+                req.id(), req.streamId(), immutableResHeaders, !hasContent);\n         logBuilder.responseHeaders(immutableResHeaders);\n         if (hasContent) {\n             logBuilder.increaseResponseLength(resContent);\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "a459ca6584aa7142a3f007c4ed87dc2e80c7dc34", "committedDate": "2020-03-25 20:09:01 +0900", "message": "Make `ClosedSessionException` extend `ClosedStreamException` (#2616)"}, {"oid": "987b99f52cd6c443b1682b163176fc484575bbd4", "committedDate": "2020-03-26 01:30:18 +0900", "message": "Add `ServiceConfig.defaultLogName()` (#2626)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "ee9652dfbb6b6d31b52d72e28c8e51cb793557d6", "committedDate": "2020-06-19 23:45:28 +0900", "message": "Introduce Pooled* versions of APIs which delegate to the stand\u2026 (#2448)"}, {"oid": "e68cb7f0af2c79f31ff373937e3a60dbac982871", "committedDate": "2020-07-09 15:35:13 +0900", "message": "Revert the `Pooled*` API (#2882)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "198c247f2e9092601e920f900412f3cd1c70d7e0", "committedDate": "2020-11-25 17:45:36 +0900", "message": "Do not collect metrics of the requests to `TransientService` by default (#3081)"}, {"oid": "32eabd2eb1f1be73f03a6425fa193631064cf2db", "committedDate": "2021-03-09 20:46:08 +0900", "message": "Use datatracker.ietf.org when referring to IETF RFCs and drafts (#3374)"}, {"oid": "214ae3bcf18bdf8fd0cb29196ac5b9542e13b397", "committedDate": "2021-04-05 18:10:59 +0900", "message": "Add ExceptionHandler to send a different response depending on the Ex\u2026 (#3413)"}, {"oid": "dbfc1cdbbacb7c15d8128b5b40972de28a82930e", "committedDate": "2021-04-28 16:12:44 +0900", "message": "Cancel a `ArmeriaServerCall` when an `HttpRequest` is closed. (#3455)"}, {"oid": "1b6c3b7eeaaa473290fcc9222ce2f9d92c9c5690", "committedDate": "2021-06-01 16:07:35 +0900", "message": "Use `EmptyFixedHttpRequest` for an empty body request (#3585)"}, {"oid": "cc495bcae11a37dfc8a2d2e166dbf8c1f57fb552", "committedDate": "2021-06-21 21:37:52 +0900", "message": "Dynamic reconfiguration of Server (#3362)"}, {"oid": "54b70906bcd813f0b9b2c6715ad4086160ac49b2", "committedDate": "2021-08-02 11:06:25 +0900", "message": "Make HttpHeaders more cacheable (#3714)"}, {"oid": "ed021f3d0fcb8160032a89f6a625bd2fbb0ae542", "committedDate": "2021-08-03 14:30:08 +0900", "message": "Provide a way to recover a failed `StreamMessage` (#3674)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "7626562204bd4311a1205df9d733203324355a96", "committedDate": "2021-10-05 16:37:40 +0900", "message": "Support port-based virtual hosts (#3833)"}, {"oid": "f651842426c52ea799a5cda5cacbec77d32093f4", "committedDate": "2021-10-06 11:40:43 +0900", "message": "Wrap `HttpResponse` from `ExceptionHandler` with the raised exception (#3823)"}, {"oid": "2920a1ddc2188f150a0d8b77de1d4e2e409997cf", "committedDate": "2021-10-06 16:34:55 +0900", "message": "Replace `ExceptionHandler` with `ServerErrorHandler` (#3853)"}, {"oid": "871d87297e4d051241589cb1ae95641cbc83f880", "committedDate": "2022-03-23 07:58:10 +0900", "message": "Provide a way to enable/disable streaming for a request or response (#3956)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "49054ad7f22a7f2d64faaeb694674b0df09ad165", "committedDate": "2022-07-05 15:28:12 +0900", "message": "Support `ExchangeType` for the response of annotated service (#4177)"}, {"oid": "ff11efdb672c3751ae87a40ddc2425f0ca39ebc3", "committedDate": "2022-08-01 15:03:13 +0900", "message": "Fix a bug where request duration is incorrectly recoded. (#4372)"}, {"oid": "aa3c6e1acfd41c8ab4f15f2eff2051a87bc8cc18", "committedDate": "2022-08-04 17:49:10 +0900", "message": "Introduce a way to unwrap `RequestContext`s (#4308)"}, {"oid": "9e7c016e45be91d2b0a48c1ff258e100e9c655c5", "committedDate": "2022-10-05 11:04:21 +0900", "message": "Return cached aggregated message for following withPooledObjects call (#4449)"}, {"oid": "cae3b6da373101c0976e2d00f1f3cbb706d07e00", "committedDate": "2022-10-31 14:32:41 +0900", "message": "Do not set request cause if request is aborted after response is complete (#4494)"}, {"oid": "deee635ca2857e973a7bf5d344596d677ad770a9", "committedDate": "2022-11-07 15:19:13 +0900", "message": "Fix a bug where a connection is closed before a response is written in HTTP/1.x (#4508)"}, {"oid": "ab206410ff1ce5602573b4e6009e0930e650b756", "committedDate": "2022-11-10 14:42:46 +0900", "message": "Fix `ConcurrentModificationException` in `HttpServerHandler` (#4524)"}, {"oid": "20af1955a62f088daed57bbbefc219bf36f6272f", "committedDate": "2023-03-08 07:09:06 +0000", "message": "Allow sending `Connection: close` header (#4531)"}, {"oid": "8aebaf475eeee1ee3fec6c7c876456878a8b423e", "committedDate": "2023-03-10 00:17:11 +0900", "message": "#Issue4362 Provide a way to generate RequestId from Request information (#4691)"}, {"oid": "a9b1e9aeab174c00fab5bab0a2b5cca19c771a20", "committedDate": "2023-03-26 18:29:24 +0900", "message": "Allow configuring requestIdGenerator on per-service basis (#4752)"}, {"oid": "b16bc8d926e3b4ebb07b86b66a09cd1126121574", "committedDate": "2023-03-31 13:56:53 +0900", "message": "Add ServiceErrorHandler (#4716)"}, {"oid": "ce03ff4333de56c3facf515bf0587245ca36aa4d", "committedDate": "2023-04-07 14:21:48 +0900", "message": "Handle a fragment in a client-side URI properly (#4789)"}, {"oid": "b78d9515dc8b4b997dd65787f717443b38a21869", "committedDate": "2023-05-18 12:14:53 +0900", "message": "Add WebSocketService (#3904)"}, {"oid": "9a8c0a05f6426992b0ed5298d52b6a19e312ea93", "committedDate": "2023-06-08 15:58:31 +0900", "message": "Add Unix domain socket support (#4846)"}, {"oid": "0ce077ee0dab4192b709b6fe824d89768209aaf1", "committedDate": "2023-06-09 18:00:31 +0900", "message": "Use responseCause instead of CapturedServiceException (#4914)"}]}, {"oid": "a27fa1390d57112ed924c3e1433020753ec9c925", "url": "https://github.com/line/armeria/commit/a27fa1390d57112ed924c3e1433020753ec9c925", "message": "Add comments", "committedDate": "2020-01-29T21:41:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4OTgxNg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373289816", "body": "IIRC this check can be removed.", "bodyText": "IIRC this check can be removed.", "bodyHTML": "<p dir=\"auto\">IIRC this check can be removed.</p>", "author": "trustin", "createdAt": "2020-01-31T02:20:47Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -801,63 +814,131 @@ private static void addHttp2Scheme(io.netty.handler.codec.http.HttpHeaders in, U\n \n     /**\n      * Converts the specified Armeria HTTP/2 headers into Netty HTTP/2 headers.\n+     *\n+     * @param inputHeaders The HTTP/2 headers to convert.\n+     * @param additionalHeaders The additional headers which will be merged.\n+     * @param additionalTrailers The additional trailers which will be merged.\n+     * @param server    {@code true} if the returned headers will be used in a response message.\n+     *                  {@code false} for request message.\n+     * @param endStream {@code true} if returned headers will end streams.\n+     *                  {@code false} otherwise.\n+     * @param isTrailer {@code true} if returned headers should be treated as trailers.\n+     *                  {@code false} otherwise.\n      */\n-    public static Http2Headers toNettyHttp2(HttpHeaders in, boolean server) {\n-        final Http2Headers out = new DefaultHttp2Headers(false, in.size());\n+    public static Http2Headers toNettyHttp2(HttpHeaders inputHeaders,\n+                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                            boolean server, boolean endStream, boolean isTrailer) {\n+        final int headerSizeHint = inputHeaders.size() + additionalHeaders.size() + additionalTrailers.size();\n+        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n \n-        // Trailers if it does not have :status.\n-        if (server && !in.contains(HttpHeaderNames.STATUS)) {\n-            for (Entry<AsciiString, String> entry : in) {\n-                final AsciiString name = entry.getKey();\n-                final String value = entry.getValue();\n-                if (name.isEmpty() || isTrailerBlacklisted(name)) {\n-                    continue;\n-                }\n-                out.add(name, value);\n-            }\n-        } else {\n-            in.forEach((BiConsumer<AsciiString, String>) out::add);\n-            out.remove(HttpHeaderNames.CONNECTION);\n-            out.remove(HttpHeaderNames.TRANSFER_ENCODING);\n+        mergeHeadersHttp2(inputHeaders, outputHeaders, !server, isTrailer, false);\n+\n+        if (!isTrailer) {\n+            mergeHeadersHttp2(additionalHeaders, outputHeaders, !server, false, true);\n         }\n \n-        if (!out.contains(HttpHeaderNames.COOKIE)) {\n-            return out;\n+        if (server && endStream) {\n+            mergeHeadersHttp2(additionalTrailers, outputHeaders, false, isTrailer, true);\n+        }\n+\n+        outputHeaders.remove(HttpHeaderNames.CONNECTION);\n+        outputHeaders.remove(HttpHeaderNames.TRANSFER_ENCODING);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.COOKIE)) {\n+            return outputHeaders;\n         }\n \n         // Split up cookies to allow for better compression.\n         // https://tools.ietf.org/html/rfc7540#section-8.1.2.5\n-        final List<CharSequence> cookies = out.getAllAndRemove(HttpHeaderNames.COOKIE);\n+        final List<CharSequence> cookies = outputHeaders.getAllAndRemove(HttpHeaderNames.COOKIE);\n         for (CharSequence c : cookies) {\n-            out.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n+            outputHeaders.add(HttpHeaderNames.COOKIE, COOKIE_SPLITTER.split(c));\n         }\n \n-        return out;\n+        return outputHeaders;\n+    }\n+\n+    private static void mergeHeadersHttp2(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n+                                          boolean isRequest, boolean isTrailer, boolean isAdditionalHeaders) {\n+        final Set<AsciiString> additionalHeaderBlackList = isRequest ? ADDITIONAL_REQUEST_HEADER_BLACKLIST\n+                                                                     : ADDITIONAL_RESPONSE_HEADER_BLACKLIST;\n+        final Set<AsciiString> removed = new HashSet<>();\n+        for (Entry<AsciiString, String> entry : inputHeaders) {\n+            final AsciiString name = entry.getKey();\n+            final String value = entry.getValue();\n+            if (name.isEmpty()) {\n+                continue;\n+            }", "originalCommit": "20770207e8c9db61e31aae76a26fe631ce997f20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MTg3OA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373291878", "bodyText": "Pushed a fix to your branch.", "author": "trustin", "createdAt": "2020-01-31T02:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4OTgxNg=="}], "type": "inlineReview", "revised_code": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nindex cf7d82b8f..e5f212d41 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n", "chunk": "@@ -866,10 +866,6 @@ public final class ArmeriaHttpUtil {\n         for (Entry<AsciiString, String> entry : inputHeaders) {\n             final AsciiString name = entry.getKey();\n             final String value = entry.getValue();\n-            if (name.isEmpty()) {\n-                continue;\n-            }\n-\n             if (isAdditionalHeaders && additionalHeaderBlackList.contains(name)) {\n                 continue;\n             }\n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 86%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex e5f212d41..6da3f0b9f 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -858,15 +884,37 @@ public final class ArmeriaHttpUtil {\n         return outputHeaders;\n     }\n \n-    private static void mergeHeadersHttp2(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n-                                          boolean isRequest, boolean isTrailer, boolean isAdditionalHeaders) {\n-        final Set<AsciiString> additionalHeaderBlackList = isRequest ? ADDITIONAL_REQUEST_HEADER_BLACKLIST\n-                                                                     : ADDITIONAL_RESPONSE_HEADER_BLACKLIST;\n+    /**\n+     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n+     *\n+     * @param inputHeaders The HTTP/2 request headers to convert.\n+     * @param additionalHeaders The additional headers which will be merged.\n+     * @param additionalTrailers The additional trailers which will be merged.\n+     * @param isTrailer {@code true} if returned headers should be treated as trailers.\n+     *                  {@code false} otherwise.\n+     */\n+    public static Http2Headers toNettyHttp2Client(HttpHeaders inputHeaders,\n+                                                  HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                                  boolean isTrailer) {\n+        final int headerSizeHint = inputHeaders.size() + additionalHeaders.size() + additionalTrailers.size();\n+        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n+\n+        mergeHeadersHttp2Client(inputHeaders, outputHeaders, isTrailer, false);\n+\n+        if (!isTrailer) {\n+            mergeHeadersHttp2Client(additionalHeaders, outputHeaders, false, true);\n+        }\n+\n+        return toNettyHttp2(outputHeaders);\n+    }\n+\n+    private static void mergeHeadersHttp2Client(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n+                                                boolean isTrailer, boolean isAdditionalHeaders) {\n         final Set<AsciiString> removed = new HashSet<>();\n         for (Entry<AsciiString, String> entry : inputHeaders) {\n             final AsciiString name = entry.getKey();\n             final String value = entry.getValue();\n-            if (isAdditionalHeaders && additionalHeaderBlackList.contains(name)) {\n+            if (isAdditionalHeaders && ADDITIONAL_REQUEST_HEADER_BLACKLIST.contains(name)) {\n                 continue;\n             }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex cf7d82b8f..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -858,19 +894,44 @@ public final class ArmeriaHttpUtil {\n         return outputHeaders;\n     }\n \n-    private static void mergeHeadersHttp2(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n-                                          boolean isRequest, boolean isTrailer, boolean isAdditionalHeaders) {\n-        final Set<AsciiString> additionalHeaderBlackList = isRequest ? ADDITIONAL_REQUEST_HEADER_BLACKLIST\n-                                                                     : ADDITIONAL_RESPONSE_HEADER_BLACKLIST;\n+    /**\n+     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n+     *\n+     * @param inputHeaders The HTTP/2 request headers to convert.\n+     * @param additionalHeaders The additional headers which will be merged.\n+     */\n+    public static Http2Headers toNettyHttp2ClientHeader(HttpHeaders inputHeaders,\n+                                                        HttpHeaders additionalHeaders) {\n+        final int headerSizeHint = inputHeaders.size() + additionalHeaders.size();\n+        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n+\n+        mergeHeadersHttp2Client(inputHeaders, outputHeaders, false, false);\n+        mergeHeadersHttp2Client(additionalHeaders, outputHeaders, false, true);\n+\n+        return toNettyHttp2(outputHeaders);\n+    }\n+\n+    /**\n+     * Converts the specified Armeria HTTP/2 request headers into Netty HTTP/2 headers.\n+     *\n+     * @param inputHeaders The HTTP/2 request headers to convert.\n+     */\n+    public static Http2Headers toNettyHttp2ClientTrailer(HttpHeaders inputHeaders) {\n+        final int headerSizeHint = inputHeaders.size();\n+        final Http2Headers outputHeaders = new DefaultHttp2Headers(false, headerSizeHint);\n+\n+        mergeHeadersHttp2Client(inputHeaders, outputHeaders, true, false);\n+\n+        return toNettyHttp2(outputHeaders);\n+    }\n+\n+    private static void mergeHeadersHttp2Client(HttpHeaders inputHeaders, Http2Headers outputHeaders,\n+                                                boolean isTrailer, boolean isAdditionalHeaders) {\n         final Set<AsciiString> removed = new HashSet<>();\n         for (Entry<AsciiString, String> entry : inputHeaders) {\n             final AsciiString name = entry.getKey();\n             final String value = entry.getValue();\n-            if (name.isEmpty()) {\n-                continue;\n-            }\n-\n-            if (isAdditionalHeaders && additionalHeaderBlackList.contains(name)) {\n+            if (isAdditionalHeaders && ADDITIONAL_REQUEST_HEADER_BLACKLIST.contains(name)) {\n                 continue;\n             }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4OTk3MA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373289970", "body": "This `name.isEmpty()` check can be removed as well.", "bodyText": "This name.isEmpty() check can be removed as well.", "bodyHTML": "<p dir=\"auto\">This <code>name.isEmpty()</code> check can be removed as well.</p>", "author": "trustin", "createdAt": "2020-01-31T02:21:31Z", "path": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java", "diffHunk": "@@ -871,18 +952,25 @@ public static void toNettyHttp1(\n                     continue;\n                 }", "originalCommit": "20770207e8c9db61e31aae76a26fe631ce997f20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MTg2Mg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373291862", "bodyText": "Pushed a fix to your branch.", "author": "trustin", "createdAt": "2020-01-31T02:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4OTk3MA=="}], "type": "inlineReview", "revised_code": {"commit": "3f101f4bff4fe737a307a54418e445c14a57b69d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nindex cf7d82b8f..e5f212d41 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n", "chunk": "@@ -948,7 +944,7 @@ public final class ArmeriaHttpUtil {\n                     continue;\n                 }\n \n-                if (name.isEmpty() || HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n+                if (HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n", "next_change": {"commit": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 86%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex e5f212d41..6da3f0b9f 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -948,7 +1059,7 @@ public final class ArmeriaHttpUtil {\n                     continue;\n                 }\n \n-                if (isAdditionalHeader && additionalHeaderBlackList.contains(name)) {\n+                if (isAdditionalHeader && ADDITIONAL_REQUEST_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\nindex cf7d82b8f..d3714787b 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/ArmeriaHttpUtil.java\n", "chunk": "@@ -942,17 +1081,17 @@ public final class ArmeriaHttpUtil {\n             for (Entry<AsciiString, String> entry : inputHeaders) {\n                 final AsciiString name = entry.getKey();\n                 final String value = entry.getValue();\n-                final AsciiString translatedName = translations.get(name);\n+                final AsciiString translatedName = REQUEST_HEADER_TRANSLATIONS.get(name);\n                 if (translatedName != null && !inputHeaders.contains(translatedName)) {\n                     outputHeaders.add(translatedName, value);\n                     continue;\n                 }\n \n-                if (name.isEmpty() || HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n+                if (HTTP2_TO_HTTP_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n-                if (isAdditionalHeader && additionalHeaderBlackList.contains(name)) {\n+                if (isAdditionalHeader && ADDITIONAL_REQUEST_HEADER_BLACKLIST.contains(name)) {\n                     continue;\n                 }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"oid": "3f101f4bff4fe737a307a54418e445c14a57b69d", "url": "https://github.com/line/armeria/commit/3f101f4bff4fe737a307a54418e445c14a57b69d", "message": "Remove unnecessary `name.isEmpty()` checks", "committedDate": "2020-01-31T12:54:47Z", "type": "forcePushed"}, {"oid": "ccbd58921ed1428c164f8f67e0818803214b90e6", "url": "https://github.com/line/armeria/commit/ccbd58921ed1428c164f8f67e0818803214b90e6", "message": "Fix merge conflict", "committedDate": "2020-01-31T15:31:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2Mjk5NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373762995", "body": "I think we can set `requestSessionProtocol` when creating `Http*ObjectEncoder`.\r\nhttps://github.com/line/armeria/blob/dcc56ab86adefd1ab98cc3a0b79d012f600a0d02/core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java#L276-L283", "bodyText": "I think we can set requestSessionProtocol when creating Http*ObjectEncoder.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java\n    \n    \n        Lines 276 to 283\n      in\n      dcc56ab\n    \n    \n    \n    \n\n        \n          \n           final SessionProtocol protocol = (SessionProtocol) evt; \n        \n\n        \n          \n           this.protocol = protocol; \n        \n\n        \n          \n           if (protocol == H1 || protocol == H1C) { \n        \n\n        \n          \n               requestEncoder = new Http1ObjectEncoder(channel, false, protocol.isTls()); \n        \n\n        \n          \n               responseDecoder = ctx.pipeline().get(Http1ResponseDecoder.class); \n        \n\n        \n          \n           } else if (protocol == H2 || protocol == H2C) { \n        \n\n        \n          \n               final Http2ConnectionHandler handler = ctx.pipeline().get(Http2ConnectionHandler.class); \n        \n\n        \n          \n               requestEncoder = new Http2ObjectEncoder(ctx, handler.encoder());", "bodyHTML": "<p dir=\"auto\">I think we can set <code>requestSessionProtocol</code> when creating <code>Http*ObjectEncoder</code>.<br>\n<div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/line/armeria/blob/dcc56ab86adefd1ab98cc3a0b79d012f600a0d02/core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java#L276-L283\">armeria/core/src/main/java/com/linecorp/armeria/client/HttpSessionHandler.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 276 to 283\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/line/armeria/commit/dcc56ab86adefd1ab98cc3a0b79d012f600a0d02\">dcc56ab</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L276\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"276\"></td>\n          <td id=\"LC276\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">SessionProtocol</span> protocol <span class=\"pl-k\">=</span> (<span class=\"pl-smi\">SessionProtocol</span>) evt; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L277\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"277\"></td>\n          <td id=\"LC277\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>protocol <span class=\"pl-k\">=</span> protocol; </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L278\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"278\"></td>\n          <td id=\"LC278\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">if</span> (protocol <span class=\"pl-k\">==</span> <span class=\"pl-c1\">H1</span> <span class=\"pl-k\">||</span> protocol <span class=\"pl-k\">==</span> <span class=\"pl-c1\">H1C</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L279\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"279\"></td>\n          <td id=\"LC279\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     requestEncoder <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Http1ObjectEncoder</span>(channel, <span class=\"pl-c1\">false</span>, protocol<span class=\"pl-k\">.</span>isTls()); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L280\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"280\"></td>\n          <td id=\"LC280\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     responseDecoder <span class=\"pl-k\">=</span> ctx<span class=\"pl-k\">.</span>pipeline()<span class=\"pl-k\">.</span>get(<span class=\"pl-smi\">Http1ResponseDecoder</span><span class=\"pl-k\">.</span>class); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L281\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"281\"></td>\n          <td id=\"LC281\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> } <span class=\"pl-k\">else</span> <span class=\"pl-k\">if</span> (protocol <span class=\"pl-k\">==</span> <span class=\"pl-c1\">H2</span> <span class=\"pl-k\">||</span> protocol <span class=\"pl-k\">==</span> <span class=\"pl-c1\">H2C</span>) { </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L282\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"282\"></td>\n          <td id=\"LC282\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Http2ConnectionHandler</span> handler <span class=\"pl-k\">=</span> ctx<span class=\"pl-k\">.</span>pipeline()<span class=\"pl-k\">.</span>get(<span class=\"pl-smi\">Http2ConnectionHandler</span><span class=\"pl-k\">.</span>class); </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L283\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"283\"></td>\n          <td id=\"LC283\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">     requestEncoder <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">Http2ObjectEncoder</span>(ctx, handler<span class=\"pl-k\">.</span>encoder()); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>", "author": "ikhoon", "createdAt": "2020-02-01T06:55:05Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java", "diffHunk": "@@ -181,59 +174,15 @@ private void writeFirstHeader() {\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true);\n+            write0(firstHeaders, true, true,\n+                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);", "originalCommit": "ccbd58921ed1428c164f8f67e0818803214b90e6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "309a438d6933530b98fcdd3ba68d781bce1c3858", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 13e03114e..7b5d0948e 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -169,7 +168,6 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n-        logBuilder.startRequest(ch, protocol);\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n", "next_change": {"commit": "b4b283b256532e2a20c3fa0d85159767b522cc57", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 7b5d0948e..78294af91 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -164,7 +164,6 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         }\n \n         final RequestHeaders firstHeaders = request.headers();\n-        final SessionProtocol requestSessionProtocol = reqCtx.sessionProtocol();\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n", "next_change": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,11 +167,18 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n", "next_change": {"commit": "d13565c88bd382876ad62fb24d1fada977338188", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 684f01987..59c9fa016 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,8 +184,9 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": null}]}}]}}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 7b5d0948e..78294af91 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -172,12 +171,10 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n+            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n+            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n     }\n \n", "next_change": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,11 +167,18 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n", "next_change": {"commit": "d13565c88bd382876ad62fb24d1fada977338188", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 684f01987..59c9fa016 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,8 +184,9 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 13e03114e..19b094480 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -165,29 +160,33 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         }\n \n         final RequestHeaders firstHeaders = request.headers();\n-        final SessionProtocol requestSessionProtocol = reqCtx.sessionProtocol();\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n-        logBuilder.startRequest(ch, protocol);\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true,\n-                   reqCtx.additionalRequestHeaders(), requestSessionProtocol);\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": {"commit": "711cea08b59286f5f847e5c4f17aedec5ada97de", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,7 +207,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            fail(new IllegalArgumentException(\n+            failAndReset(new IllegalArgumentException(\n                     \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n             return;\n         }\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -212,29 +76,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             return;\n         }\n \n-        boolean endOfStream = o.isEndOfStream();\n-        switch (state) {\n+        switch (state()) {\n             case NEEDS_DATA_OR_TRAILERS: {\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -195,7 +218,8 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        fail(new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(\n+                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "ec336fa661ddc4308e8a831b99c959f939533f99", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..365f7dd67 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -218,8 +228,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 365f7dd67..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,18 +85,17 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "711cea08b59286f5f847e5c4f17aedec5ada97de", "committedDate": "2020-03-19 13:54:44 +0900", "message": "Assign stream ID right before writing RequestHeaders (#2597)"}, {"oid": "6d21bfd5d5ac863d7d68420873190b4dc5f8f018", "committedDate": "2020-03-23 11:00:30 +0900", "message": "Wrap ProxyConnectException with UnprocessedRequestException (#2609)"}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ac3440be28a34d436e4382257d46bbf2cbdbca8a", "committedDate": "2020-05-14 15:15:17 +0900", "message": "Fix a bug where a response cause is not propagated when retrying a fa\u2026 (#2709)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "e5cea5e9ba7afc6a3b2c38d0663b8b1e3334ad37", "committedDate": "2020-06-26 19:10:34 +0900", "message": "Wrap `DnsTimeoutException` with `UnprocessedRequestException` (#2836)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "223c7c1cc4f98f1e56f1a95351f99155f7c365da", "committedDate": "2021-05-27 16:37:18 +0900", "message": "HttpRequestSubscriber should update RequestLogBuilder with all sent request headers (#3581)"}, {"oid": "6449551d515e2a612b0291f9b72c1c0d368364f2", "committedDate": "2021-07-28 16:43:35 +0900", "message": "Make `GrpcStatusFunction` access `RequestContext` (#3693)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "f777f14714f363656b1c12d1601dce12173394e9", "committedDate": "2022-06-01 16:24:20 +0900", "message": "Correctly throw `WriteTimeoutException` for requests without content (#4259)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "5382f15db770d545434cabb41cf8f9f4e5315e62", "committedDate": "2023-03-23 11:31:17 +0900", "message": "Provide a way to disconnect gracefully connection using `RequestContext` (#4708)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc2MzM4Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r373763386", "body": "`enableServerHeader`, `enableDateHeader` is immutable after building `Server`.\r\nHow about setting these flags when creating `Http*ObjectEncoder`?\r\nIt would be cleaner to get these immutable flags from class fields than method passing. ", "bodyText": "enableServerHeader, enableDateHeader is immutable after building Server.\nHow about setting these flags when creating Http*ObjectEncoder?\nIt would be cleaner to get these immutable flags from class fields than method passing.", "bodyHTML": "<p dir=\"auto\"><code>enableServerHeader</code>, <code>enableDateHeader</code> is immutable after building <code>Server</code>.<br>\nHow about setting these flags when creating <code>Http*ObjectEncoder</code>?<br>\nIt would be cleaner to get these immutable flags from class fields than method passing.</p>", "author": "ikhoon", "createdAt": "2020-02-01T07:05:42Z", "path": "core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java", "diffHunk": "@@ -116,31 +120,43 @@ protected Channel channel() {\n     }\n \n     @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) {\n+    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n+                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n+                                           boolean enableServerHeader, boolean enableDateHeader,", "originalCommit": "ccbd58921ed1428c164f8f67e0818803214b90e6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "309a438d6933530b98fcdd3ba68d781bce1c3858", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nsimilarity index 97%\nrename from core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 6f9bf297c..054583e8d 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -124,7 +126,7 @@ public final class Http1ObjectEncoder extends HttpObjectEncoder {\n                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n                                            boolean enableServerHeader, boolean enableDateHeader,\n                                            @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n+        if (!isWritable(id)) {\n             return newClosedSessionFuture();\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\ndeleted file mode 100644\nindex 6f9bf297c..000000000\n--- a/core/src/main/java/com/linecorp/armeria/internal/Http1ObjectEncoder.java\n+++ /dev/null\n", "chunk": "@@ -1,622 +0,0 @@\n-/*\n- * Copyright 2016 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.internal;\n-\n-import static java.util.Objects.requireNonNull;\n-\n-import java.net.InetSocketAddress;\n-import java.util.AbstractMap.SimpleImmutableEntry;\n-import java.util.ArrayDeque;\n-import java.util.Map.Entry;\n-import java.util.Queue;\n-\n-import javax.annotation.Nullable;\n-\n-import com.linecorp.armeria.common.ClosedSessionException;\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaderNames;\n-import com.linecorp.armeria.common.HttpHeaders;\n-import com.linecorp.armeria.common.HttpStatus;\n-import com.linecorp.armeria.common.HttpStatusClass;\n-import com.linecorp.armeria.common.SessionProtocol;\n-import com.linecorp.armeria.common.stream.ClosedPublisherException;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.buffer.ByteBufHolder;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelFuture;\n-import io.netty.channel.ChannelFutureListener;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n-import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n-import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n-import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n-import io.netty.util.ReferenceCountUtil;\n-import io.netty.util.collection.IntObjectHashMap;\n-import io.netty.util.collection.IntObjectMap;\n-\n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n-\n-    /**\n-     * The maximum allowed length of an HTTP chunk when TLS is enabled.\n-     * <ul>\n-     *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n-     *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n-     * </ul>\n-     *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n-     * but it is not worth adding complexity to be that precise.\n-     */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n-\n-    /**\n-     * A non-last empty {@link HttpContent}.\n-     */\n-    private static final HttpContent EMPTY_CONTENT = new DefaultHttpContent(Unpooled.EMPTY_BUFFER);\n-\n-    private final Channel ch;\n-    private final boolean server;\n-    private final boolean isTls;\n-\n-    /**\n-     * The ID of the request which is at its turn to send a response.\n-     */\n-    private int currentId = 1;\n-\n-    /**\n-     * The minimum ID of the request whose stream has been closed/reset.\n-     */\n-    private int minClosedId = Integer.MAX_VALUE;\n-\n-    /**\n-     * The maximum known ID with pending writes.\n-     */\n-    private int maxIdWithPendingWrites = Integer.MIN_VALUE;\n-\n-    /**\n-     * The map which maps a request ID to its related pending response.\n-     */\n-    private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n-\n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n-        this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n-    }\n-\n-    @Override\n-    protected Channel channel() {\n-        return ch;\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-                                           boolean enableServerHeader, boolean enableDateHeader,\n-                                           @Nullable SessionProtocol sessionProtocol) {\n-        if (id >= minClosedId) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream,\n-                                               additionalHeaders, additionalTrailers,\n-                                               enableServerHeader, enableDateHeader)\n-                          : writeClientHeaders(id, streamId, headers, endStream, additionalHeaders,\n-                                               sessionProtocol);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            converted = convertServerTrailers(streamId, headers, endStream, additionalTrailers);\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        converted = convertServerHeaders(streamId, headers, endStream, additionalHeaders, additionalTrailers,\n-                                         enableServerHeader, enableDateHeader);\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders,\n-            @Nullable SessionProtocol sessionProtocol) throws Http2Exception {\n-\n-        final HttpObject converted;\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        if (method == null) {\n-            converted = convertClientTrailers(streamId, headers, endStream);\n-        } else {\n-            converted = convertClientHeaders(streamId, headers, endStream, additionalHeaders, sessionProtocol);\n-        }\n-\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n-        ChannelFuture f;\n-        if (converted instanceof LastHttpContent) {\n-            assert endStream;\n-            f = write(id, converted, true);\n-        } else {\n-            f = write(id, converted, false);\n-            if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-        }\n-\n-        ch.flush();\n-        return f;\n-    }\n-\n-    private static HttpObject convertServerHeaders(\n-            int streamId, HttpHeaders headers, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        final HttpResponse res;\n-        final int statusCode = Integer.parseInt(status);\n-        final boolean informational = HttpStatusClass.INFORMATIONAL.contains(statusCode);\n-        final HttpResponseStatus nettyStatus = HttpResponseStatus.valueOf(statusCode);\n-\n-        if (endStream || informational) {\n-\n-            res = new DefaultFullHttpResponse(\n-                    HttpVersion.HTTP_1_1, nettyStatus,\n-                    Unpooled.EMPTY_BUFFER, false);\n-\n-            final io.netty.handler.codec.http.HttpHeaders outHeaders = res.headers();\n-            convertServerHeaders0(streamId, headers, outHeaders, endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-\n-            if (HttpStatus.isContentAlwaysEmpty(statusCode)) {\n-                outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-            } else if (!headers.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-                // NB: Set the 'content-length' only when not set rather than always setting to 0.\n-                //     It's because a response to a HEAD request can have empty content while having\n-                //     non-zero 'content-length' header.\n-                //     However, this also opens the possibility of sending a non-zero 'content-length'\n-                //     header even when it really has to be zero. e.g. a response to a non-HEAD request\n-                outHeaders.setInt(HttpHeaderNames.CONTENT_LENGTH, 0);\n-            }\n-        } else {\n-            res = new DefaultHttpResponse(HttpVersion.HTTP_1_1, nettyStatus, false);\n-            // Perform conversion.\n-            convertServerHeaders0(streamId, headers, res.headers(), endStream,\n-                                  additionalHeaders, additionalTrailers,\n-                                  enableServerHeader, enableDateHeader);\n-            setTransferEncoding(res);\n-        }\n-\n-        return res;\n-    }\n-\n-    private static void convertServerHeaders0(\n-            int streamId, HttpHeaders inHeaders,\n-            io.netty.handler.codec.http.HttpHeaders outHeaders, boolean endStream,\n-            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers,\n-            boolean enableServerHeader, boolean enableDateHeader) throws Http2Exception {\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, additionalHeaders, additionalTrailers, outHeaders,\n-                HttpVersion.HTTP_1_1, false, false, endStream);\n-\n-        removeHttpExtensionHeaders(outHeaders);\n-\n-        if (!additionalTrailers.isEmpty() &&\n-            outHeaders.contains(HttpHeaderNames.CONTENT_LENGTH)) {\n-            // We don't apply chunked encoding when the content-length header is set, which would\n-            // prevent the trailers from being sent so we go ahead and remove content-length to\n-            // force chunked encoding.\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-\n-        if (enableServerHeader && !outHeaders.contains(HttpHeaderNames.SERVER)) {\n-            outHeaders.add(HttpHeaderNames.SERVER, ArmeriaHttpUtil.SERVER_HEADER);\n-        }\n-\n-        if (enableDateHeader && !outHeaders.contains(HttpHeaderNames.DATE)) {\n-            outHeaders.add(HttpHeaderNames.DATE, HttpTimestampSupplier.currentTime());\n-        }\n-    }\n-\n-    private LastHttpContent convertServerTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream,\n-            HttpHeaders additionalTrailers) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), additionalTrailers, lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, false, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return lastContent;\n-    }\n-\n-    private HttpObject convertClientHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders,\n-                                            SessionProtocol sessionProtocol) throws Http2Exception {\n-        requireNonNull(sessionProtocol);\n-\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(\n-                HttpVersion.HTTP_1_1,\n-                HttpMethod.valueOf(method),\n-                path, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, headers, additionalHeaders, HttpHeaders.of(), req.headers(),\n-                HttpVersion.HTTP_1_1, false, true, endStream);\n-\n-        removeHttpExtensionHeaders(req.headers());\n-\n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n-        }\n-\n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n-            final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST,\n-                              ArmeriaHttpUtil.authorityHeader(\n-                                      remoteAddress.getHostName(), remoteAddress.getPort(),\n-                                      sessionProtocol.defaultPort()));\n-        }\n-\n-        if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-\n-            // Set or remove the 'content-length' header depending on request method.\n-            // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n-            //\n-            // > A user agent SHOULD send a Content-Length in a request message when\n-            // > no Transfer-Encoding is sent and the request method defines a meaning\n-            // > for an enclosed payload body.  For example, a Content-Length header\n-            // > field is normally sent in a POST request even when the value is 0\n-            // > (indicating an empty payload body).  A user agent SHOULD NOT send a\n-            // > Content-Length header field when the request message does not contain\n-            // > a payload body and the method semantics do not anticipate such a\n-            // > body.\n-            switch (method) {\n-                case \"POST\":\n-                case \"PUT\":\n-                case \"PATCH\":\n-                    req.headers().set(HttpHeaderNames.CONTENT_LENGTH, \"0\");\n-                    break;\n-                default:\n-                    req.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n-            }\n-        } else if (HttpUtil.getContentLength(req, -1L) >= 0) {\n-            // Avoid the case where both 'content-length' and 'transfer-encoding' are set.\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n-        } else {\n-            req.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-        }\n-\n-        return req;\n-    }\n-\n-    private LastHttpContent convertClientTrailers(\n-            int streamId, HttpHeaders inHeaders, boolean endStream) throws Http2Exception {\n-\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1(\n-                streamId, inHeaders, HttpHeaders.of(), HttpHeaders.of(), lastContent.trailingHeaders(),\n-                HttpVersion.HTTP_1_1, true, true, endStream);\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-\n-        return  lastContent;\n-    }\n-\n-    private static void removeHttpExtensionHeaders(io.netty.handler.codec.http.HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n-    }\n-\n-    private static void setTransferEncoding(HttpMessage out) {\n-        final io.netty.handler.codec.http.HttpHeaders outHeaders = out.headers();\n-        final long contentLength = HttpUtil.getContentLength(out, -1L);\n-        if (contentLength < 0) {\n-            // Use chunked encoding.\n-            outHeaders.set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n-            outHeaders.remove(HttpHeaderNames.CONTENT_LENGTH);\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n-        if (id >= minClosedId) {\n-            ReferenceCountUtil.safeRelease(data);\n-            return newClosedSessionFuture();\n-        }\n-\n-        final int length = data.length();\n-        if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n-            final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n-            final ChannelFuture future = write(id, content, endStream);\n-            ch.flush();\n-            return future;\n-        }\n-\n-        try {\n-            if (!isTls || length <= MAX_TLS_DATA_LENGTH) {\n-                // Cleartext connection or data.length() <= MAX_TLS_DATA_LENGTH\n-                return doWriteUnsplitData(id, data, endStream);\n-            } else {\n-                // TLS and data.length() > MAX_TLS_DATA_LENGTH\n-                return doWriteSplitData(id, data, endStream);\n-            }\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture doWriteUnsplitData(int id, HttpData data, boolean endStream) {\n-        final ByteBuf buf = toByteBuf(data);\n-        boolean handled = false;\n-        try {\n-            final HttpContent content;\n-            if (endStream) {\n-                content = new DefaultLastHttpContent(buf);\n-            } else {\n-                content = new DefaultHttpContent(buf);\n-            }\n-\n-            final ChannelFuture future = write(id, content, endStream);\n-            handled = true;\n-            ch.flush();\n-            return future;\n-        } finally {\n-            if (!handled) {\n-                ReferenceCountUtil.safeRelease(buf);\n-            }\n-        }\n-    }\n-\n-    private ChannelFuture doWriteSplitData(int id, HttpData data, boolean endStream) {\n-        try {\n-            int offset = 0;\n-            int remaining = data.length();\n-            ChannelFuture lastFuture;\n-            for (;;) {\n-                // Ensure an HttpContent does not exceed the maximum length of a cleartext TLS record.\n-                final int chunkSize = Math.min(MAX_TLS_DATA_LENGTH, remaining);\n-                lastFuture = write(id, new DefaultHttpContent(dataChunk(data, offset, chunkSize)), false);\n-                remaining -= chunkSize;\n-                if (remaining == 0) {\n-                    break;\n-                }\n-                offset += chunkSize;\n-            }\n-\n-            if (endStream) {\n-                lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n-            }\n-\n-            ch.flush();\n-            return lastFuture;\n-        } finally {\n-            ReferenceCountUtil.safeRelease(data);\n-        }\n-    }\n-\n-    private static ByteBuf dataChunk(HttpData data, int offset, int chunkSize) {\n-        if (data instanceof ByteBufHolder) {\n-            final ByteBuf buf = ((ByteBufHolder) data).content();\n-            return buf.retainedSlice(offset, chunkSize);\n-        } else {\n-            return Unpooled.wrappedBuffer(data.array(), offset, chunkSize);\n-        }\n-    }\n-\n-    private ChannelFuture write(int id, HttpObject obj, boolean endStream) {\n-        if (id < currentId) {\n-            // Attempted to write something on a finished request/response; discard.\n-            // e.g. the request already timed out.\n-            ReferenceCountUtil.safeRelease(obj);\n-            return newFailedFuture(ClosedPublisherException.get());\n-        }\n-\n-        final PendingWrites currentPendingWrites = pendingWritesMap.get(id);\n-        if (id == currentId) {\n-            if (currentPendingWrites != null) {\n-                pendingWritesMap.remove(id);\n-                flushPendingWrites(currentPendingWrites);\n-            }\n-\n-            final ChannelFuture future = ch.write(obj);\n-            if (endStream) {\n-                currentId++;\n-\n-                // The next PendingWrites might be complete already.\n-                for (;;) {\n-                    final PendingWrites nextPendingWrites = pendingWritesMap.get(currentId);\n-                    if (nextPendingWrites == null) {\n-                        break;\n-                    }\n-\n-                    flushPendingWrites(nextPendingWrites);\n-                    if (!nextPendingWrites.isEndOfStream()) {\n-                        break;\n-                    }\n-\n-                    pendingWritesMap.remove(currentId);\n-                    currentId++;\n-                }\n-            }\n-\n-            return future;\n-        } else {\n-            final ChannelPromise promise = ch.newPromise();\n-            final Entry<HttpObject, ChannelPromise> entry = new SimpleImmutableEntry<>(obj, promise);\n-            final PendingWrites pendingWrites;\n-            if (currentPendingWrites == null) {\n-                pendingWrites = new PendingWrites();\n-                maxIdWithPendingWrites = Math.max(maxIdWithPendingWrites, id);\n-                pendingWritesMap.put(id, pendingWrites);\n-            } else {\n-                pendingWrites = currentPendingWrites;\n-            }\n-\n-            pendingWrites.add(entry);\n-\n-            if (endStream) {\n-                pendingWrites.setEndOfStream();\n-            }\n-\n-            return promise;\n-        }\n-    }\n-\n-    private void flushPendingWrites(PendingWrites pendingWrites) {\n-        for (;;) {\n-            final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-            if (e == null) {\n-                break;\n-            }\n-\n-            ch.write(e.getKey(), e.getValue());\n-        }\n-    }\n-\n-    @Override\n-    protected ChannelFuture doWriteReset(int id, int streamId, Http2Error error) {\n-        // NB: this.minClosedId can be overwritten more than once when 3+ pipelined requests are received\n-        //     and they are handled by different threads simultaneously.\n-        //     e.g. when the 3rd request triggers a reset and then the 2nd one triggers another.\n-        minClosedId = Math.min(minClosedId, id);\n-        for (int i = minClosedId; i <= maxIdWithPendingWrites; i++) {\n-            final PendingWrites pendingWrites = pendingWritesMap.remove(i);\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = pendingWrites.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-                e.getValue().tryFailure(ClosedSessionException.get());\n-            }\n-        }\n-\n-        final ChannelFuture f = ch.write(Unpooled.EMPTY_BUFFER);\n-        if (currentId >= minClosedId) {\n-            f.addListener(ChannelFutureListener.CLOSE);\n-        }\n-\n-        return f;\n-    }\n-\n-    @Override\n-    protected void doClose() {\n-        if (pendingWritesMap.isEmpty()) {\n-            return;\n-        }\n-\n-        final ClosedSessionException cause = ClosedSessionException.get();\n-        for (Queue<Entry<HttpObject, ChannelPromise>> queue : pendingWritesMap.values()) {\n-            for (;;) {\n-                final Entry<HttpObject, ChannelPromise> e = queue.poll();\n-                if (e == null) {\n-                    break;\n-                }\n-\n-                e.getValue().tryFailure(cause);\n-            }\n-        }\n-\n-        pendingWritesMap.clear();\n-    }\n-\n-    private static final class PendingWrites extends ArrayDeque<Entry<HttpObject, ChannelPromise>> {\n-\n-        private static final long serialVersionUID = 4241891747461017445L;\n-\n-        private boolean endOfStream;\n-\n-        PendingWrites() {\n-            super(4);\n-        }\n-\n-        @Override\n-        public boolean add(Entry<HttpObject, ChannelPromise> httpObjectChannelPromiseEntry) {\n-            return isEndOfStream() ? false : super.add(httpObjectChannelPromiseEntry);\n-        }\n-\n-        boolean isEndOfStream() {\n-            return endOfStream;\n-        }\n-\n-        void setEndOfStream() {\n-            endOfStream = true;\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"oid": "309a438d6933530b98fcdd3ba68d781bce1c3858", "url": "https://github.com/line/armeria/commit/309a438d6933530b98fcdd3ba68d781bce1c3858", "message": "Make some methods static", "committedDate": "2020-02-08T00:23:09Z", "type": "forcePushed"}, {"oid": "b4b283b256532e2a20c3fa0d85159767b522cc57", "url": "https://github.com/line/armeria/commit/b4b283b256532e2a20c3fa0d85159767b522cc57", "message": "Clean up", "committedDate": "2020-02-12T18:56:48Z", "type": "forcePushed"}, {"oid": "8c25a0e3c608c41a66e84bd436f926ba5fa41554", "url": "https://github.com/line/armeria/commit/8c25a0e3c608c41a66e84bd436f926ba5fa41554", "message": "WIP", "committedDate": "2020-02-23T10:01:28Z", "type": "forcePushed"}, {"oid": "3e66cee7f8b88efc518911e3b1e4a0aca8d19904", "url": "https://github.com/line/armeria/commit/3e66cee7f8b88efc518911e3b1e4a0aca8d19904", "message": "WIP", "committedDate": "2020-02-24T22:33:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzODE4NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384238185", "body": "Could be `final` with package-private?\r\n```suggestion\r\n    final ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\r\n```", "bodyText": "Could be final with package-private?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n          \n          \n            \n                final ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {", "bodyHTML": "<p dir=\"auto\">Could be <code>final</code> with package-private?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k x x-first x-last\">protected</span> <span class=\"pl-smi\">ChannelFuture</span> writeNonInformationalHeaders(<span class=\"pl-k\">int</span> id, <span class=\"pl-smi\">HttpObject</span> converted, <span class=\"pl-k\">boolean</span> endStream) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k x x-first x-last\">final</span> <span class=\"pl-smi\">ChannelFuture</span> writeNonInformationalHeaders(<span class=\"pl-k\">int</span> id, <span class=\"pl-smi\">HttpObject</span> converted, <span class=\"pl-k\">boolean</span> endStream) {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ikhoon", "createdAt": "2020-02-26T02:06:14Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java", "diffHunk": "@@ -104,65 +89,17 @@\n      */\n     private final IntObjectMap<PendingWrites> pendingWritesMap = new IntObjectHashMap<>();\n \n-    public Http1ObjectEncoder(Channel ch, boolean server, boolean isTls) {\n+    protected Http1ObjectEncoder(Channel ch, SessionProtocol protocol) {\n         this.ch = requireNonNull(ch, \"ch\");\n-        this.server = server;\n-        this.isTls = isTls;\n+        this.protocol = requireNonNull(protocol, \"protocol\");\n     }\n \n     @Override\n     protected Channel channel() {\n         return ch;\n     }\n \n-    @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) {\n-        if (!isWritable(id)) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            return server ? writeServerHeaders(id, streamId, headers, endStream)\n-                          : writeClientHeaders(id, streamId, headers, endStream);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private ChannelFuture writeServerHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream) throws Http2Exception {\n-\n-        final HttpObject converted = convertServerHeaders(streamId, headers, endStream);\n-        final String status = headers.get(HttpHeaderNames.STATUS);\n-        if (status == null) {\n-            // Trailers\n-            final ChannelFuture f = write(id, converted, endStream);\n-            ch.flush();\n-            return f;\n-        }\n-\n-        if (!status.isEmpty() && status.charAt(0) == '1') {\n-            // Informational status headers.\n-            final ChannelFuture f = write(id, converted, false);\n-            if (endStream) {\n-                // Can't end a stream with informational status in HTTP/1.\n-                f.addListener(ChannelFutureListener.CLOSE);\n-            }\n-            ch.flush();\n-            return f;\n-        }\n-\n-        // Non-informational status headers.\n-        return writeNonInformationalHeaders(id, converted, endStream);\n-    }\n-\n-    private ChannelFuture writeClientHeaders(\n-            int id, int streamId, HttpHeaders headers, boolean endStream) throws Http2Exception {\n-\n-        return writeNonInformationalHeaders(id, convertClientHeaders(streamId, headers, endStream), endStream);\n-    }\n-\n-    private ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n+    protected ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {", "originalCommit": "dcb40799eef7e1c605950c26f329a9e050826258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyODcwNw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r386028707", "bodyText": "I revert this to move ServerHttp1ObjectEncoder to armeria.internal.server package and ClientHttp1ObjectEncoder to armeria.internal.client.", "author": "jyblue", "createdAt": "2020-02-29T13:33:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzODE4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "39edd429593ac1a12fdf95c897223dd7e0455788", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 348bbe492..7cc3c31b2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -95,12 +95,12 @@ public abstract class Http1ObjectEncoder extends HttpObjectEncoder {\n     }\n \n     @Override\n-    protected Channel channel() {\n+    protected final Channel channel() {\n         return ch;\n     }\n \n-    protected ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n+    protected final ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted,\n+                                                               boolean endStream) {\n         ChannelFuture f;\n         if (converted instanceof LastHttpContent) {\n             assert endStream;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 348bbe492..2488aa0ff 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -95,12 +95,12 @@ public abstract class Http1ObjectEncoder extends HttpObjectEncoder {\n     }\n \n     @Override\n-    protected Channel channel() {\n+    protected final Channel channel() {\n         return ch;\n     }\n \n-    protected ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted, boolean endStream) {\n-\n+    protected final ChannelFuture writeNonInformationalHeaders(int id, HttpObject converted,\n+                                                               boolean endStream) {\n         ChannelFuture f;\n         if (converted instanceof LastHttpContent) {\n             assert endStream;\n", "next_change": {"commit": "c7a85030c224aac256d1d9dd4c9fb08b09abe8cf", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 2488aa0ff..0ac49c523 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -108,28 +115,65 @@ public abstract class Http1ObjectEncoder extends HttpObjectEncoder {\n         } else {\n             f = write(id, converted, false);\n             if (endStream) {\n-                f = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n+                final ChannelFuture lastFuture = write(id, LastHttpContent.EMPTY_LAST_CONTENT, true);\n+                if (Flags.verboseExceptionSampler().isSampled(Http1VerboseWriteException.class)) {\n+                    f = combine(f, lastFuture);\n+                } else {\n+                    f = lastFuture;\n+                }\n             }\n         }\n         ch.flush();\n         return f;\n     }\n \n-    protected static void removeHttpExtensionHeaders(HttpHeaders outHeaders) {\n-        outHeaders.remove(ExtensionHeaderNames.STREAM_ID.text());\n-        outHeaders.remove(ExtensionHeaderNames.PATH.text());\n+    private ChannelPromise combine(ChannelFuture first, ChannelFuture second) {\n+        final ChannelPromise promise = channel().newPromise();\n+        final FutureListener<Void> listener = new FutureListener<Void>() {\n+            private int remaining = 2;\n+\n+            @Override\n+            public void operationComplete(Future<Void> ignore) throws Exception {\n+                remaining--;\n+                if (remaining == 0) {\n+                    final Throwable firstCause = first.cause();\n+                    final Throwable secondCause = second.cause();\n+\n+                    Throwable combinedCause = null;\n+                    if (firstCause != null) {\n+                        combinedCause = firstCause;\n+                    }\n+                    if (secondCause != null) {\n+                        if (combinedCause == null) {\n+                            combinedCause = secondCause;\n+                        } else {\n+                            combinedCause.addSuppressed(secondCause);\n+                        }\n+                    }\n+\n+                    if (combinedCause != null) {\n+                        promise.setFailure(combinedCause);\n+                    } else {\n+                        promise.setSuccess();\n+                    }\n+                }\n+            }\n+        };\n+        first.addListener(listener);\n+        second.addListener(listener);\n+        return promise;\n     }\n \n     @Override\n-    protected final ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n+    public final ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (!isWritable(id)) {\n-            ReferenceCountUtil.safeRelease(data);\n+            data.close();\n             return newClosedSessionFuture();\n         }\n \n         final int length = data.length();\n         if (length == 0) {\n-            ReferenceCountUtil.safeRelease(data);\n+            data.close();\n             final HttpContent content = endStream ? LastHttpContent.EMPTY_LAST_CONTENT : EMPTY_CONTENT;\n             final ChannelFuture future = write(id, content, endStream);\n             ch.flush();\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "0bb591d252884ec471af00e2757032ae57196d5e", "committedDate": "2020-07-21 16:29:34 +0900", "message": "Add a bunch of `final` keywords (#2927)"}, {"oid": "ca795928079dbea9b283ff1389cc6cadb0c9338e", "committedDate": "2021-01-27 18:51:21 +0900", "message": "Provide a way to limit max number of requests and max connection age for client (#3267)"}, {"oid": "37d7eaaff5348948a68144127067465c834134c4", "committedDate": "2021-10-26 01:21:56 +0900", "message": "Fix content corruption in a chunked response on TLS (#3894)"}, {"oid": "43a675859a705d415e452ce5d7d6c60e5e5f0715", "committedDate": "2021-11-23 16:19:37 +0900", "message": "Fix a bug where protocol violation errors trigger duplicate headers writes (#3914)"}, {"oid": "c7a85030c224aac256d1d9dd4c9fb08b09abe8cf", "committedDate": "2022-03-23 18:55:26 +0900", "message": "Show more information when Http1ObjectEncoder writing header at endStream failed (#4149)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "03645e92d02781712040d263f9b7b69848d79cfc", "committedDate": "2022-08-04 17:08:34 +0900", "message": "Use ClosedSessionException and ClosedStreamException correctly (#4380)"}, {"oid": "deee635ca2857e973a7bf5d344596d677ad770a9", "committedDate": "2022-11-07 15:19:13 +0900", "message": "Fix a bug where a connection is closed before a response is written in HTTP/1.x (#4508)"}, {"oid": "f4781d52a34f874e9459994afd8de763c9608480", "committedDate": "2022-12-19 11:41:29 +0900", "message": "Fix a deadlock when a late response are written first in HTTP/1 pipelining (#4536)"}, {"oid": "3713d52f39fdc0dc99bb93b8039e00cfe88e1609", "committedDate": "2023-02-08 21:47:28 +0900", "message": "Fix a bug where `ClosedSessionException` is set to `responseCause` for a success response. (#4632)"}, {"oid": "508fa96cb763fdbb60b56ec2814c4b1758f0dc1f", "committedDate": "2023-03-23 20:48:29 +0900", "message": "Prevent self reference in addSuppressed (#4758)"}, {"oid": "b78d9515dc8b4b997dd65787f717443b38a21869", "committedDate": "2023-05-18 12:14:53 +0900", "message": "Add WebSocketService (#3904)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzOTY5Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384239696", "body": "Remove `remoteAdress` field of class? It seems not to use anymore.", "bodyText": "Remove remoteAdress field of class? It seems not to use anymore.", "bodyHTML": "<p dir=\"auto\">Remove <code>remoteAdress</code> field of class? It seems not to use anymore.</p>", "author": "ikhoon", "createdAt": "2020-02-26T02:12:22Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java", "diffHunk": "@@ -172,65 +163,19 @@ private void writeFirstHeader() {\n             return;\n         }\n \n-        final RequestHeaders firstHeaders = autoFillHeaders();\n+        final RequestHeaders firstHeaders = request.headers();\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true);\n+            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true);\n-        }\n-    }\n-\n-    private RequestHeaders autoFillHeaders() {\n-        final RequestHeaders oldHeaders = request.headers();\n-        final RequestHeadersBuilder newHeaders = oldHeaders.toBuilder();\n-\n-        final HttpHeaders additionalHeaders = reqCtx.additionalRequestHeaders();\n-        if (!additionalHeaders.isEmpty()) {\n-            for (AsciiString name : additionalHeaders.names()) {\n-                if (!ADDITIONAL_HEADER_BLACKLIST.contains(name)) {\n-                    newHeaders.remove(name);\n-                    additionalHeaders.forEachValue(name, value -> newHeaders.add(name, value));\n-                }\n-            }\n-        }\n-\n-        if (!newHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            newHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n-\n-        // :scheme and :authority are auto-filled in the beginning of decorator chain,\n-        // but a decorator might have removed them, so we check again.\n-        final SessionProtocol sessionProtocol = reqCtx.sessionProtocol();\n-        if (newHeaders.scheme() == null) {\n-            newHeaders.scheme(sessionProtocol);\n-        }\n-\n-        if (newHeaders.authority() == null) {\n-            final String hostname = remoteAddress.getHostName();", "originalCommit": "dcb40799eef7e1c605950c26f329a9e050826258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MTE3Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384781176", "bodyText": "Removed. I also removed `HttpSessionHandler.removeAddress' too.", "author": "jyblue", "createdAt": "2020-02-26T21:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIzOTY5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,11 +167,18 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n", "next_change": {"commit": "d13565c88bd382876ad62fb24d1fada977338188", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 684f01987..59c9fa016 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,8 +184,9 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..19b094480 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,18 +167,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": {"commit": "711cea08b59286f5f847e5c4f17aedec5ada97de", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,7 +207,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            fail(new IllegalArgumentException(\n+            failAndReset(new IllegalArgumentException(\n                     \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n             return;\n         }\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -212,29 +76,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             return;\n         }\n \n-        boolean endOfStream = o.isEndOfStream();\n-        switch (state) {\n+        switch (state()) {\n             case NEEDS_DATA_OR_TRAILERS: {\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -195,7 +218,8 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        fail(new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(\n+                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "ec336fa661ddc4308e8a831b99c959f939533f99", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..365f7dd67 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -218,8 +228,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 365f7dd67..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,18 +85,17 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "711cea08b59286f5f847e5c4f17aedec5ada97de", "committedDate": "2020-03-19 13:54:44 +0900", "message": "Assign stream ID right before writing RequestHeaders (#2597)"}, {"oid": "6d21bfd5d5ac863d7d68420873190b4dc5f8f018", "committedDate": "2020-03-23 11:00:30 +0900", "message": "Wrap ProxyConnectException with UnprocessedRequestException (#2609)"}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ac3440be28a34d436e4382257d46bbf2cbdbca8a", "committedDate": "2020-05-14 15:15:17 +0900", "message": "Fix a bug where a response cause is not propagated when retrying a fa\u2026 (#2709)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "e5cea5e9ba7afc6a3b2c38d0663b8b1e3334ad37", "committedDate": "2020-06-26 19:10:34 +0900", "message": "Wrap `DnsTimeoutException` with `UnprocessedRequestException` (#2836)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "223c7c1cc4f98f1e56f1a95351f99155f7c365da", "committedDate": "2021-05-27 16:37:18 +0900", "message": "HttpRequestSubscriber should update RequestLogBuilder with all sent request headers (#3581)"}, {"oid": "6449551d515e2a612b0291f9b72c1c0d368364f2", "committedDate": "2021-07-28 16:43:35 +0900", "message": "Make `GrpcStatusFunction` access `RequestContext` (#3693)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "f777f14714f363656b1c12d1601dce12173394e9", "committedDate": "2022-06-01 16:24:20 +0900", "message": "Correctly throw `WriteTimeoutException` for requests without content (#4259)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "5382f15db770d545434cabb41cf8f9f4e5315e62", "committedDate": "2023-03-23 11:31:17 +0900", "message": "Provide a way to disconnect gracefully connection using `RequestContext` (#4708)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTQ1NQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384241455", "body": "nit: I'm not strong here, but could simplify a little. \ud83d\ude00\r\n```java\r\nif (request.isEmpty()) {\r\n    state = State.DONE;\r\n} else {\r\n    state = State.NEEDS_DATA_OR_TRAILERS;\r\n}\r\nwrite0(firstHeaders, request.isEmpty(), true, reqCtx.additionalRequestHeaders());\r\n```", "bodyText": "nit: I'm not strong here, but could simplify a little. \ud83d\ude00\nif (request.isEmpty()) {\n    state = State.DONE;\n} else {\n    state = State.NEEDS_DATA_OR_TRAILERS;\n}\nwrite0(firstHeaders, request.isEmpty(), true, reqCtx.additionalRequestHeaders());", "bodyHTML": "<p dir=\"auto\">nit: I'm not strong here, but could simplify a little. <g-emoji class=\"g-emoji\" alias=\"grinning\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f600.png\">\ud83d\ude00</g-emoji></p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (request.isEmpty()) {\n    state = State.DONE;\n} else {\n    state = State.NEEDS_DATA_OR_TRAILERS;\n}\nwrite0(firstHeaders, request.isEmpty(), true, reqCtx.additionalRequestHeaders());\n\"><pre><span class=\"pl-k\">if</span> (request<span class=\"pl-k\">.</span>isEmpty()) {\n    state <span class=\"pl-k\">=</span> <span class=\"pl-smi\">State</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>DONE</span>;\n} <span class=\"pl-k\">else</span> {\n    state <span class=\"pl-k\">=</span> <span class=\"pl-smi\">State</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>NEEDS_DATA_OR_TRAILERS</span>;\n}\nwrite0(firstHeaders, request<span class=\"pl-k\">.</span>isEmpty(), <span class=\"pl-c1\">true</span>, reqCtx<span class=\"pl-k\">.</span>additionalRequestHeaders());</pre></div>", "author": "ikhoon", "createdAt": "2020-02-26T02:19:26Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java", "diffHunk": "@@ -172,65 +163,19 @@ private void writeFirstHeader() {\n             return;\n         }\n \n-        final RequestHeaders firstHeaders = autoFillHeaders();\n+        final RequestHeaders firstHeaders = request.headers();\n \n         final SessionProtocol protocol = session.protocol();\n         assert protocol != null;\n         logBuilder.requestHeaders(firstHeaders);\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true);\n+            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true);\n-        }\n-    }\n-\n-    private RequestHeaders autoFillHeaders() {\n-        final RequestHeaders oldHeaders = request.headers();\n-        final RequestHeadersBuilder newHeaders = oldHeaders.toBuilder();\n-\n-        final HttpHeaders additionalHeaders = reqCtx.additionalRequestHeaders();\n-        if (!additionalHeaders.isEmpty()) {\n-            for (AsciiString name : additionalHeaders.names()) {\n-                if (!ADDITIONAL_HEADER_BLACKLIST.contains(name)) {\n-                    newHeaders.remove(name);\n-                    additionalHeaders.forEachValue(name, value -> newHeaders.add(name, value));\n-                }\n-            }\n-        }\n-\n-        if (!newHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n-            newHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());", "originalCommit": "dcb40799eef7e1c605950c26f329a9e050826258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MDIyOQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384780229", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-02-26T21:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,11 +167,18 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n", "next_change": {"commit": "d13565c88bd382876ad62fb24d1fada977338188", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 684f01987..59c9fa016 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,8 +184,9 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 78294af91..19b094480 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -171,18 +167,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n \n         if (request.isEmpty()) {\n             state = State.DONE;\n-            write0(firstHeaders, true, true, reqCtx.additionalRequestHeaders());\n         } else {\n             state = State.NEEDS_DATA_OR_TRAILERS;\n-            write0(firstHeaders, false, true, reqCtx.additionalRequestHeaders());\n         }\n+\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future = encoder.writeHeaders(id, streamId(), firstHeaders, request.isEmpty(),\n+                                                          reqCtx.additionalRequestHeaders(), HttpHeaders.of());\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            throw newIllegalStateException(\n-                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o);\n+            fail(new IllegalArgumentException(\n+                    \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n+            return;\n         }\n \n         boolean endOfStream = o.isEndOfStream();\n", "next_change": {"commit": "711cea08b59286f5f847e5c4f17aedec5ada97de", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -184,7 +207,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onNext(HttpObject o) {\n         if (!(o instanceof HttpData) && !(o instanceof HttpHeaders)) {\n-            fail(new IllegalArgumentException(\n+            failAndReset(new IllegalArgumentException(\n                     \"published an HttpObject that's neither Http2Headers nor Http2Data: \" + o));\n             return;\n         }\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -212,29 +76,26 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             return;\n         }\n \n-        boolean endOfStream = o.isEndOfStream();\n-        switch (state) {\n+        switch (state()) {\n             case NEEDS_DATA_OR_TRAILERS: {\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -195,7 +218,8 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        fail(new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(\n+                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "ec336fa661ddc4308e8a831b99c959f939533f99", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..365f7dd67 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -218,8 +228,7 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                 if (o instanceof HttpHeaders) {\n                     final HttpHeaders trailers = (HttpHeaders) o;\n                     if (trailers.contains(HttpHeaderNames.STATUS)) {\n-                        failAndReset(\n-                                new IllegalArgumentException(\"published a trailers with status: \" + o));\n+                        failAndReset(new IllegalArgumentException(\"published a trailers with status: \" + o));\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 365f7dd67..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,18 +85,17 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n                         return;\n                     }\n                     // Trailers always end the stream even if not explicitly set.\n-                    endOfStream = true;\n-                    logBuilder.requestTrailers(trailers);\n+                    writeTrailers(trailers);\n                 } else {\n-                    logBuilder.increaseRequestLength((HttpData) o);\n+                    writeData((HttpData) o);\n                 }\n-                write(o, endOfStream);\n+                channel().flush();\n                 break;\n             }\n             case DONE:\n                 // Cancel the subscription if any message comes here after the state has been changed to DONE.\n-                cancelSubscription();\n-                ReferenceCountUtil.safeRelease(o);\n+                cancel();\n+                PooledObjects.close(o);\n                 break;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "711cea08b59286f5f847e5c4f17aedec5ada97de", "committedDate": "2020-03-19 13:54:44 +0900", "message": "Assign stream ID right before writing RequestHeaders (#2597)"}, {"oid": "6d21bfd5d5ac863d7d68420873190b4dc5f8f018", "committedDate": "2020-03-23 11:00:30 +0900", "message": "Wrap ProxyConnectException with UnprocessedRequestException (#2609)"}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ac3440be28a34d436e4382257d46bbf2cbdbca8a", "committedDate": "2020-05-14 15:15:17 +0900", "message": "Fix a bug where a response cause is not propagated when retrying a fa\u2026 (#2709)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "e5cea5e9ba7afc6a3b2c38d0663b8b1e3334ad37", "committedDate": "2020-06-26 19:10:34 +0900", "message": "Wrap `DnsTimeoutException` with `UnprocessedRequestException` (#2836)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "223c7c1cc4f98f1e56f1a95351f99155f7c365da", "committedDate": "2021-05-27 16:37:18 +0900", "message": "HttpRequestSubscriber should update RequestLogBuilder with all sent request headers (#3581)"}, {"oid": "6449551d515e2a612b0291f9b72c1c0d368364f2", "committedDate": "2021-07-28 16:43:35 +0900", "message": "Make `GrpcStatusFunction` access `RequestContext` (#3693)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "f777f14714f363656b1c12d1601dce12173394e9", "committedDate": "2022-06-01 16:24:20 +0900", "message": "Correctly throw `WriteTimeoutException` for requests without content (#4259)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "5382f15db770d545434cabb41cf8f9f4e5315e62", "committedDate": "2023-03-23 11:31:17 +0900", "message": "Provide a way to disconnect gracefully connection using `RequestContext` (#4708)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384249054", "body": "How about reviving `writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream)` and offering two versions of writerHeaders?\r\nBecause 1) we don't need to merge HTTP headers if there's no additional headers or tailers so it makes our code easy to optimize the performance. And 2) don't have to pass empty headers here(https://github.com/line/armeria/pull/2372/files#diff-f4134a31b2a8d080bf8fa97afccc2880R240)\r\n\r\n```java\r\n// for empty additional headers and tailers.\r\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) { \r\n    // skip merging logic, directly convert to Netty headers\r\n    ... \r\n}\r\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\r\n\tif (addtionalHeaders.isEmpty() && additionalTrailers.isEmpty()) {\r\n\t\treturn writeHeaders(id, streamId, headers);\r\n    }\r\n    ... \r\n}\r\n```\r\n   \r\n", "bodyText": "How about reviving writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) and offering two versions of writerHeaders?\nBecause 1) we don't need to merge HTTP headers if there's no additional headers or tailers so it makes our code easy to optimize the performance. And 2) don't have to pass empty headers here(https://github.com/line/armeria/pull/2372/files#diff-f4134a31b2a8d080bf8fa97afccc2880R240)\n// for empty additional headers and tailers.\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) { \n    // skip merging logic, directly convert to Netty headers\n    ... \n}\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n\tif (addtionalHeaders.isEmpty() && additionalTrailers.isEmpty()) {\n\t\treturn writeHeaders(id, streamId, headers);\n    }\n    ... \n}", "bodyHTML": "<p dir=\"auto\">How about reviving <code>writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream)</code> and offering two versions of writerHeaders?<br>\nBecause 1) we don't need to merge HTTP headers if there's no additional headers or tailers so it makes our code easy to optimize the performance. And 2) don't have to pass empty headers here(<a href=\"https://github.com/line/armeria/pull/2372/files#diff-f4134a31b2a8d080bf8fa97afccc2880R240\">https://github.com/line/armeria/pull/2372/files#diff-f4134a31b2a8d080bf8fa97afccc2880R240</a>)</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"// for empty additional headers and tailers.\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) { \n    // skip merging logic, directly convert to Netty headers\n    ... \n}\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n\tif (addtionalHeaders.isEmpty() &amp;&amp; additionalTrailers.isEmpty()) {\n\t\treturn writeHeaders(id, streamId, headers);\n    }\n    ... \n}\n\"><pre><span class=\"pl-c\"><span class=\"pl-c\">//</span> for empty additional headers and tailers.</span>\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">ChannelFuture</span> writeHeaders(<span class=\"pl-k\">int</span> id, <span class=\"pl-k\">int</span> streamId, <span class=\"pl-smi\">HttpHeaders</span> headers, <span class=\"pl-k\">boolean</span> endStream) { \n    <span class=\"pl-c\"><span class=\"pl-c\">//</span> skip merging logic, directly convert to Netty headers</span>\n    <span class=\"pl-c1\">...</span> \n}\n<span class=\"pl-k\">public</span> <span class=\"pl-k\">final</span> <span class=\"pl-smi\">ChannelFuture</span> writeHeaders(<span class=\"pl-k\">int</span> id, <span class=\"pl-k\">int</span> streamId, <span class=\"pl-smi\">HttpHeaders</span> headers, <span class=\"pl-k\">boolean</span> endStream, <span class=\"pl-smi\">HttpHeaders</span> additionalHeaders, <span class=\"pl-smi\">HttpHeaders</span> additionalTrailers) {\n\t<span class=\"pl-k\">if</span> (addtionalHeaders<span class=\"pl-k\">.</span>isEmpty() <span class=\"pl-k\">&amp;&amp;</span> additionalTrailers<span class=\"pl-k\">.</span>isEmpty()) {\n\t\t<span class=\"pl-k\">return</span> writeHeaders(id, streamId, headers);\n    }\n    <span class=\"pl-c1\">...</span> \n}</pre></div>", "author": "ikhoon", "createdAt": "2020-02-26T02:51:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java", "diffHunk": "@@ -45,19 +45,21 @@ protected EventLoop eventLoop() {\n     /**\n      * Writes an {@link HttpHeaders}.\n      */\n-    public final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream) {\n-\n+    public final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n+                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {", "originalCommit": "dcb40799eef7e1c605950c26f329a9e050826258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5ODcxNg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384798716", "bodyText": "Yes, I think it's good idea. I will update this soon \ud83d\ude00", "author": "jyblue", "createdAt": "2020-02-26T22:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MDg0Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384940847", "bodyText": "It seems weird to me that this writeHeaders method has both additionalHeaders and additionalTrailers which cannot be used at the same time.\nHow about splitting writeHeaders to writeHeaders and writeTrailers?", "author": "minwoox", "createdAt": "2020-02-27T06:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyNTk3Nw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r386025977", "bodyText": "I think additionalHeaders and additionalTrailers can be used at the same time when request headers end with additional trailers. (Do I understand correctly? \ud83e\udd14 )\nIt seems that it may happens here now.\n\n  \n    \n      armeria/core/src/main/java/com/linecorp/armeria/server/HttpResponseSubscriber.java\n    \n    \n         Line 174\n      in\n      48f4132\n    \n    \n    \n    \n\n        \n          \n           fillAdditionalTrailers(newHeaders, additionalTrailers); \n        \n    \n  \n\n\nDo you think we need all possible overrides for this method?\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream)\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders)\npublic final ChannelFuture writeTrailers(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalTrailers)\npublic final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers)", "author": "jyblue", "createdAt": "2020-02-29T12:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODAyNjU3NA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r388026574", "bodyText": "It seems that it may happens here now.\n\nI think it's a bug so I fixed it. \ud83d\ude04\n#2544\nAfter this is merged, I think we can split the method to writeHeaders and writeTrailers. Sorry about the bug. \ud83d\ude09", "author": "minwoox", "createdAt": "2020-03-05T01:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NjMxMg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r390086312", "bodyText": "#2544 has been fixed. @jyblue, could you rebase and squash into a single commit, since the history is getting pretty large?", "author": "trustin", "createdAt": "2020-03-10T04:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYzNTU2Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r390635563", "bodyText": "I squashed and rebase commit. I will also split writeHeaders methods soon. \ud83d\ude47\u200d\u2642\ufe0f", "author": "jyblue", "createdAt": "2020-03-10T21:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0OTA1NA=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\nindex 7f5de45de..958d0ab61 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n", "chunk": "@@ -32,43 +32,37 @@ import io.netty.util.ReferenceCountUtil;\n /**\n  * Converts an {@link HttpObject} into a protocol-specific object and writes it into a {@link Channel}.\n  */\n-public abstract class HttpObjectEncoder {\n+public interface HttpObjectEncoder {\n \n-    private volatile boolean closed;\n+    Channel channel();\n \n-    protected abstract Channel channel();\n-\n-    protected EventLoop eventLoop() {\n+    default EventLoop eventLoop() {\n         return channel().eventLoop();\n     }\n \n     /**\n-     * Writes an {@link HttpHeaders}.\n+     * Writes an HTTP trailers.\n      */\n-    public final ChannelFuture writeHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+    default ChannelFuture writeTrailers(int id, int streamId, HttpHeaders headers) {\n         assert eventLoop().inEventLoop();\n \n-        if (closed) {\n+        if (isClosed()) {\n             return newClosedSessionFuture();\n         }\n \n-        return doWriteHeaders(id, streamId, headers, endStream, additionalHeaders, additionalTrailers);\n+        return doWriteTrailers(id, streamId, headers);\n     }\n \n-    protected abstract ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers,\n-                                                    boolean endStream,\n-                                                    HttpHeaders additionalHeaders,\n-                                                    HttpHeaders additionalTrailers);\n+    ChannelFuture doWriteTrailers(int id, int streamId, HttpHeaders headers);\n \n     /**\n      * Writes an {@link HttpData}.\n      */\n-    public final ChannelFuture writeData(int id, int streamId, HttpData data, boolean endStream) {\n+    default ChannelFuture writeData(int id, int streamId, HttpData data, boolean endStream) {\n \n         assert eventLoop().inEventLoop();\n \n-        if (closed) {\n+        if (isClosed()) {\n             ReferenceCountUtil.safeRelease(data);\n             return newClosedSessionFuture();\n         }\n", "next_change": {"commit": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\nindex 958d0ab61..52a55e15a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/HttpObjectEncoder.java\n", "chunk": "@@ -63,7 +67,7 @@ public interface HttpObjectEncoder {\n         assert eventLoop().inEventLoop();\n \n         if (isClosed()) {\n-            ReferenceCountUtil.safeRelease(data);\n+            data.close();\n             return newClosedSessionFuture();\n         }\n \n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "ca795928079dbea9b283ff1389cc6cadb0c9338e", "committedDate": "2021-01-27 18:51:21 +0900", "message": "Provide a way to limit max number of requests and max connection age for client (#3267)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI1MzAzOA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384253038", "body": "Could Move these to under if condition?\r\n```java\r\nif (isStreamPresentAndWritable(streamId)) {\r\n    final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\r\n    final Http2Headers convertedHeaders;\r\n```", "bodyText": "Could Move these to under if condition?\nif (isStreamPresentAndWritable(streamId)) {\n    final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n    final Http2Headers convertedHeaders;", "bodyHTML": "<p dir=\"auto\">Could Move these to under if condition?</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (isStreamPresentAndWritable(streamId)) {\n    final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n    final Http2Headers convertedHeaders;\n\"><pre><span class=\"pl-k\">if</span> (isStreamPresentAndWritable(streamId)) {\n    <span class=\"pl-k\">final</span> <span class=\"pl-k\">boolean</span> isTrailer <span class=\"pl-k\">=</span> <span class=\"pl-k\">!</span>headers<span class=\"pl-k\">.</span>contains(<span class=\"pl-smi\">HttpHeaderNames</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>STATUS</span>);\n    <span class=\"pl-k\">final</span> <span class=\"pl-smi\">Http2Headers</span> convertedHeaders;</pre></div>", "author": "ikhoon", "createdAt": "2020-02-26T03:08:51Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.stream.ClosedStreamException;\n+import com.linecorp.armeria.internal.common.util.HttpTimestampSupplier;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n+import io.netty.handler.codec.http2.Http2Headers;\n+\n+public final class ServerHttp2ObjectEncoder extends Http2ObjectEncoder {\n+    private final boolean enableServerHeader;\n+    private final boolean enableDateHeader;\n+\n+    public ServerHttp2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder,\n+                                       boolean enableServerHeader, boolean enableDateHeader) {\n+        super(ctx, encoder);\n+        this.enableServerHeader = enableServerHeader;\n+        this.enableDateHeader = enableDateHeader;\n+    }\n+\n+    @Override\n+    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n+                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+        final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n+        final Http2Headers convertedHeaders;", "originalCommit": "dcb40799eef7e1c605950c26f329a9e050826258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4MDAzMw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384780033", "bodyText": "Fixed it.", "author": "jyblue", "createdAt": "2020-02-26T21:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI1MzAzOA=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nsimilarity index 93%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nindex a5dfc6c79..044fbec51 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\n", "chunk": "@@ -40,10 +42,9 @@ public final class ServerHttp2ObjectEncoder extends Http2ObjectEncoder {\n     @Override\n     protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n-        final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n-        final Http2Headers convertedHeaders;\n-\n         if (isStreamPresentAndWritable(streamId)) {\n+            final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n+            final Http2Headers convertedHeaders;\n             if (!isTrailer) {\n                 convertedHeaders = convertHeaders(headers, additionalHeaders, additionalTrailers, endStream);\n             } else {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nsimilarity index 76%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nindex a5dfc6c79..c02e850dd 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\n", "chunk": "@@ -40,14 +42,14 @@ public final class ServerHttp2ObjectEncoder extends Http2ObjectEncoder {\n     @Override\n     protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n                                            HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n-        final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n-        final Http2Headers convertedHeaders;\n-\n         if (isStreamPresentAndWritable(streamId)) {\n+            final boolean isTrailer = !headers.contains(HttpHeaderNames.STATUS);\n+            final Http2Headers convertedHeaders;\n             if (!isTrailer) {\n                 convertedHeaders = convertHeaders(headers, additionalHeaders, additionalTrailers, endStream);\n             } else {\n-                convertedHeaders = convertTrailers(headers, additionalTrailers, endStream);\n+                convertedHeaders = ArmeriaHttpUtil.toNettyHttp2ServerTrailer(headers, additionalTrailers,\n+                                                                             endStream);\n             }\n             // Writing to an existing stream.\n             return encoder().writeHeaders(ctx(), streamId, convertedHeaders, 0, endStream,\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODA2OQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384938069", "body": "Time flies! :wink: ", "bodyText": "Time flies! \ud83d\ude09", "bodyHTML": "<p dir=\"auto\">Time flies! <g-emoji class=\"g-emoji\" alias=\"wink\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f609.png\">\ud83d\ude09</g-emoji></p>", "author": "trustin", "createdAt": "2020-02-27T06:42:04Z", "path": "benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2019 LINE Corporation", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM5MjI3Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385392276", "bodyText": "Should I update all modified files or just newly created one? \ud83e\udd14", "author": "jyblue", "createdAt": "2020-02-27T21:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2MDQwNA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385460404", "bodyText": "newly created one. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-02-28T01:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0OTkyNQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385949925", "bodyText": "Thank you, fixed it.", "author": "jyblue", "createdAt": "2020-02-28T22:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODA2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\nindex b66416874..9a893c3a5 100644\n--- a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n+++ b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n", "chunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 LINE Corporation\n+ * Copyright 2020 LINE Corporation\n  *\n  * LINE Corporation licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\nindex b66416874..9a893c3a5 100644\n--- a/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n+++ b/benchmarks/src/jmh/java/com/linecorp/armeria/common/HttpRequestHeaderConversionBenchmark.java\n", "chunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 LINE Corporation\n+ * Copyright 2020 LINE Corporation\n  *\n  * LINE Corporation licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "2caa0f8812e7435b7141136da95b5fd1f3efa2be", "committedDate": "2021-09-28 19:45:27 +0900", "message": "Add a benchmark that measures gRPC server performance with `ghz` (#3814)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODM0Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384938343", "body": "Could we move this to `armeria.internal.client`?", "bodyText": "Could we move this to armeria.internal.client?", "bodyHTML": "<p dir=\"auto\">Could we move this to <code>armeria.internal.client</code>?</p>", "author": "trustin", "createdAt": "2020-02-27T06:43:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java", "diffHunk": "@@ -14,25 +14,20 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.client;\n+package com.linecorp.armeria.internal;", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MDIzOQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385950239", "bodyText": "Moved to armeria.internal.client package.", "author": "jyblue", "createdAt": "2020-02-28T22:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nsimilarity index 96%\nrename from core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nindex 2671e0ff3..8927fac0d 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\n", "chunk": "@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal;\n+package com.linecorp.armeria.internal.client;\n \n import com.linecorp.armeria.common.util.Version;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nsimilarity index 96%\nrename from core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\nrename to core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\nindex 2671e0ff3..8927fac0d 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/HttpHeaderUtil.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/HttpHeaderUtil.java\n", "chunk": "@@ -14,7 +14,7 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal;\n+package com.linecorp.armeria.internal.client;\n \n import com.linecorp.armeria.common.util.Version;\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODg2Mg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384938862", "body": "How about using `add()` instead of shortcut methods for better performance?", "bodyText": "How about using add() instead of shortcut methods for better performance?", "bodyHTML": "<p dir=\"auto\">How about using <code>add()</code> instead of shortcut methods for better performance?</p>", "author": "trustin", "createdAt": "2020-02-27T06:45:02Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.common.stream.ClosedStreamException;\n+import com.linecorp.armeria.internal.HttpHeaderUtil;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.http2.Http2Connection;\n+import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n+import io.netty.handler.codec.http2.Http2Headers;\n+\n+public final class ClientHttp2ObjectEncoder extends Http2ObjectEncoder {\n+    private final SessionProtocol protocol;\n+\n+    public ClientHttp2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder,\n+                                       SessionProtocol protocol) {\n+        super(ctx, encoder);\n+        this.protocol = requireNonNull(protocol, \"protocol\");\n+    }\n+\n+    @Override\n+    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n+                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+        final Http2Connection conn = encoder().connection();\n+        final boolean isTrailer = !headers.contains(HttpHeaderNames.METHOD);\n+        final Http2Headers convertedHeaders;\n+\n+        if (isStreamPresentAndWritable(streamId)) {\n+            if (!isTrailer) {\n+                convertedHeaders = convertHeaders(headers, additionalHeaders, additionalTrailers);\n+            } else {\n+                convertedHeaders = convertTrailers(headers, additionalTrailers);\n+            }\n+            // Writing to an existing stream.\n+            return encoder().writeHeaders(ctx(), streamId, convertedHeaders, 0, endStream,\n+                                          ctx().newPromise());\n+        }\n+\n+        if (conn.local().mayHaveCreatedStream(streamId)) {\n+            // Stream has been closed.\n+            return newFailedFuture(ClosedStreamException.get());\n+        }\n+\n+        if (!isTrailer) {\n+            convertedHeaders = convertHeaders(headers, additionalHeaders, additionalTrailers);\n+        } else {\n+            convertedHeaders = convertTrailers(headers, additionalTrailers);\n+        }\n+\n+        // Client starts a new stream.\n+        return encoder().writeHeaders(ctx(), streamId, convertedHeaders, 0, endStream,\n+                                      ctx().newPromise());\n+    }\n+\n+    private Http2Headers convertHeaders(\n+            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+        final Http2Headers outputHeaders =\n+                ArmeriaHttpUtil.toNettyHttp2Client(inputHeaders, additionalHeaders, additionalTrailers, false);\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        }\n+\n+        if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n+            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MDAzMQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385950031", "bodyText": "Fixed it \ud83d\udc4d", "author": "jyblue", "createdAt": "2020-02-28T22:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzODg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\nsimilarity index 91%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\nindex 65d7bcabe..3fde983fd 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\n", "chunk": "@@ -85,8 +86,8 @@ public final class ClientHttp2ObjectEncoder extends Http2ObjectEncoder {\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                  : SessionProtocol.HTTP.uriText());\n+            outputHeaders.add(HttpHeaderNames.SCHEME, protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                                       : SessionProtocol.HTTP.uriText());\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\nsimilarity index 67%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\nindex 65d7bcabe..3559a1c8d 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ClientHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp2ObjectEncoder.java\n", "chunk": "@@ -75,18 +86,17 @@ public final class ClientHttp2ObjectEncoder extends Http2ObjectEncoder {\n                                       ctx().newPromise());\n     }\n \n-    private Http2Headers convertHeaders(\n-            HttpHeaders inputHeaders, HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+    private Http2Headers convertHeaders(HttpHeaders inputHeaders, HttpHeaders additionalHeaders) {\n         final Http2Headers outputHeaders =\n-                ArmeriaHttpUtil.toNettyHttp2Client(inputHeaders, additionalHeaders, additionalTrailers, false);\n+                ArmeriaHttpUtil.toNettyHttp2ClientHeader(inputHeaders, additionalHeaders);\n \n         if (!outputHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n             outputHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.SCHEME)) {\n-            outputHeaders.scheme(protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n-                                                  : SessionProtocol.HTTP.uriText());\n+            outputHeaders.add(HttpHeaderNames.SCHEME, protocol.isTls() ? SessionProtocol.HTTPS.uriText()\n+                                                                       : SessionProtocol.HTTP.uriText());\n         }\n \n         if (!outputHeaders.contains(HttpHeaderNames.AUTHORITY)) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzOTIzNg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384939236", "body": "Could be `armeria.internal.server`", "bodyText": "Could be armeria.internal.server", "bodyHTML": "<p dir=\"auto\">Could be <code>armeria.internal.server</code></p>", "author": "trustin", "createdAt": "2020-02-27T06:46:24Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MDY4OQ==", "url": "https://github.com/line/armeria/pull/2372#discussion_r385950689", "bodyText": "Moved ServerHttp1ObjectEncoder, ServerHttp2ObjectEncoder to armeria.internal.server package.\nAnd also moved ClientHttp1ObjectEncoder, ClientHttp2ObjectEncoder to armeria.internal.client.", "author": "jyblue", "createdAt": "2020-02-28T22:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzOTIzNg=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\nsimilarity index 97%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\nindex df9c49bd1..c1530bce5 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\n", "chunk": "@@ -14,13 +14,15 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal.common;\n+package com.linecorp.armeria.internal.server;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.HttpStatusClass;\n import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.internal.common.Http1ObjectEncoder;\n import com.linecorp.armeria.internal.common.util.HttpTimestampSupplier;\n \n import io.netty.buffer.Unpooled;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\nsimilarity index 84%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\nindex df9c49bd1..fde85de0a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp1ObjectEncoder.java\n", "chunk": "@@ -14,13 +14,15 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal.common;\n+package com.linecorp.armeria.internal.server;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.HttpStatusClass;\n import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.internal.common.Http1ObjectEncoder;\n import com.linecorp.armeria.internal.common.util.HttpTimestampSupplier;\n \n import io.netty.buffer.Unpooled;\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzOTMxMg==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384939312", "body": "Ditto", "bodyText": "Ditto", "bodyHTML": "<p dir=\"auto\">Ditto</p>", "author": "trustin", "createdAt": "2020-02-27T06:46:39Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nsimilarity index 96%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nindex a2200a8b8..044fbec51 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\n", "chunk": "@@ -14,11 +14,13 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal.common;\n+package com.linecorp.armeria.internal.server;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.stream.ClosedStreamException;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.internal.common.Http2ObjectEncoder;\n import com.linecorp.armeria.internal.common.util.HttpTimestampSupplier;\n \n import io.netty.channel.ChannelFuture;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nsimilarity index 79%\nrename from core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\nrename to core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\nindex a2200a8b8..c02e850dd 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/ServerHttp2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/server/ServerHttp2ObjectEncoder.java\n", "chunk": "@@ -14,11 +14,13 @@\n  * under the License.\n  */\n \n-package com.linecorp.armeria.internal.common;\n+package com.linecorp.armeria.internal.server;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.stream.ClosedStreamException;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.internal.common.Http2ObjectEncoder;\n import com.linecorp.armeria.internal.common.util.HttpTimestampSupplier;\n \n import io.netty.channel.ChannelFuture;\n", "next_change": null}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MjA2OA==", "url": "https://github.com/line/armeria/pull/2372#discussion_r384942068", "body": "It seems weird to me that the `write0` is called with `HttpData` and trailers(even though it's empty.)\r\nHow about just inlining `write0` method? We can extract the common part to another method then. \ud83e\udd14 ", "bodyText": "It seems weird to me that the write0 is called with HttpData and trailers(even though it's empty.)\nHow about just inlining write0 method? We can extract the common part to another method then. \ud83e\udd14", "bodyHTML": "<p dir=\"auto\">It seems weird to me that the <code>write0</code> is called with <code>HttpData</code> and trailers(even though it's empty.)<br>\nHow about just inlining <code>write0</code> method? We can extract the common part to another method then. <g-emoji class=\"g-emoji\" alias=\"thinking\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f914.png\">\ud83e\udd14</g-emoji></p>", "author": "minwoox", "createdAt": "2020-02-27T06:56:50Z", "path": "core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java", "diffHunk": "@@ -292,10 +232,10 @@ private void write(HttpObject o, boolean endOfStream, boolean flush) {\n             state = State.DONE;\n         }\n \n-        write0(o, endOfStream, flush);\n+        write0(o, endOfStream, flush, HttpHeaders.of());", "originalCommit": "59e88e87c0c81fed094a8e6154e6c148bc27f598", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyNjE1Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r386026156", "bodyText": "I inlined write0() and extracted some common lines to another method. PTAL.", "author": "jyblue", "createdAt": "2020-02-29T12:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk0MjA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 717d891d5..684f01987 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,10 +240,23 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             state = State.DONE;\n         }\n \n-        write0(o, endOfStream, flush, HttpHeaders.of());\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future;\n+        if (o instanceof HttpHeaders) {\n+            future = encoder.writeHeaders(id, streamId(), (HttpHeaders) o, endOfStream,\n+                                          HttpHeaders.of(), HttpHeaders.of());\n+        } else {\n+            future = encoder.writeData(id, streamId(), (HttpData) o, endOfStream);\n+        }\n+\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n-    private void write0(HttpObject o, boolean endOfStream, boolean flush, HttpHeaders additionalHeaders) {\n+    private boolean isStreamOrSessionClosed() {\n         // Make sure that a stream exists before writing data if first bytes were transferred.\n         // The following situation may cause the data to be written to a closed stream.\n         // 1. A connection that has pending outbound buffers receives GOAWAY frame.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 717d891d5..19b094480 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -232,10 +242,23 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n             state = State.DONE;\n         }\n \n-        write0(o, endOfStream, flush, HttpHeaders.of());\n+        if (isStreamOrSessionClosed()) {\n+            return;\n+        }\n+\n+        final ChannelFuture future;\n+        if (o instanceof HttpHeaders) {\n+            future = encoder.writeHeaders(id, streamId(), (HttpHeaders) o, endOfStream,\n+                                          HttpHeaders.of(), HttpHeaders.of());\n+        } else {\n+            future = encoder.writeData(id, streamId(), (HttpData) o, endOfStream);\n+        }\n+\n+        future.addListener(this);\n+        ch.flush();\n     }\n \n-    private void write0(HttpObject o, boolean endOfStream, boolean flush, HttpHeaders additionalHeaders) {\n+    private boolean isStreamOrSessionClosed() {\n         // Make sure that a stream exists before writing data if first bytes were transferred.\n         // The following situation may cause the data to be written to a closed stream.\n         // 1. A connection that has pending outbound buffers receives GOAWAY frame.\n", "next_change": {"commit": "711cea08b59286f5f847e5c4f17aedec5ada97de", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 19b094480..03a3a001a 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -265,11 +295,11 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n         // 2. AbstractHttp2ConnectionHandler.close() clears and flushes all active streams.\n         // 3. After successfully flushing, operationComplete() requests next data and\n         //    the subscriber attempts to write the next data to the stream closed at 2).\n-        if (loggedRequestFirstBytesTransferred && !encoder.isWritable(id, streamId())) {\n-            if (reqCtx.sessionProtocol().isMultiplex()) {\n-                fail(ClosedStreamException.get());\n+        if (!encoder.isWritable(id, streamId())) {\n+            if (ctx.sessionProtocol().isMultiplex()) {\n+                failAndReset(ClosedStreamException.get());\n             } else {\n-                fail(ClosedSessionException.get());\n+                failAndReset(ClosedSessionException.get());\n             }\n             return true;\n         }\n", "next_change": {"commit": "435aeedcb007382250e4ee71311a5ff2c56615ae", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\nindex 03a3a001a..6d5ff5059 100644\n--- a/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n+++ b/core/src/main/java/com/linecorp/armeria/client/HttpRequestSubscriber.java\n", "chunk": "@@ -242,126 +103,34 @@ final class HttpRequestSubscriber implements Subscriber<HttpObject>, ChannelFutu\n     @Override\n     public void onError(Throwable cause) {\n         isSubscriptionCompleted = true;\n-        if (id >= 0) { // onSubscribe is called.\n-            failAndReset(cause);\n-        } else {\n-            // No need to send RST because we didn't send any packet.\n-            fail(new UnprocessedRequestException(cause));\n-        }\n+        failRequest(cause);\n     }\n \n     @Override\n     public void onComplete() {\n         isSubscriptionCompleted = true;\n-        cancelTimeout();\n \n-        if (state != State.DONE) {\n-            write(HttpData.empty(), true);\n+        if (state() != State.DONE) {\n+            writeData(EMPTY_EOS);\n+            channel().flush();\n         }\n     }\n \n-    private void write(HttpObject o, boolean endOfStream) {\n-        if (!ch.isActive()) {\n-            ReferenceCountUtil.safeRelease(o);\n-            fail(ClosedSessionException.get());\n-            return;\n-        }\n-\n-        if (endOfStream) {\n-            state = State.DONE;\n-        }\n-\n-        if (isStreamOrSessionClosed()) {\n-            return;\n-        }\n-\n-        final ChannelFuture future;\n-        if (o instanceof HttpHeaders) {\n-            // trailers\n-            future = encoder.writeHeaders(id, streamId(), (HttpHeaders) o, endOfStream,\n-                                          HttpHeaders.of(), HttpHeaders.of());\n-        } else {\n-            future = encoder.writeData(id, streamId(), (HttpData) o, endOfStream);\n-        }\n-\n-        future.addListener(this);\n-        ch.flush();\n-    }\n-\n-    private boolean isStreamOrSessionClosed() {\n-        // Make sure that a stream exists before writing data if first bytes were transferred.\n-        // The following situation may cause the data to be written to a closed stream.\n-        // 1. A connection that has pending outbound buffers receives GOAWAY frame.\n-        // 2. AbstractHttp2ConnectionHandler.close() clears and flushes all active streams.\n-        // 3. After successfully flushing, operationComplete() requests next data and\n-        //    the subscriber attempts to write the next data to the stream closed at 2).\n-        if (!encoder.isWritable(id, streamId())) {\n-            if (ctx.sessionProtocol().isMultiplex()) {\n-                failAndReset(ClosedStreamException.get());\n-            } else {\n-                failAndReset(ClosedSessionException.get());\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private int streamId() {\n-        return (id << 1) + 1;\n-    }\n-\n-    private void fail(Throwable cause) {\n-        state = State.DONE;\n-        cancelSubscription();\n-        logBuilder.endRequest(cause);\n-        if (responseWrapper != null) {\n-            if (responseWrapper.isOpen()) {\n-                responseWrapper.close(cause);\n-            } else {\n-                // To make it sure that the log is complete.\n-                logBuilder.endResponse(cause);\n-            }\n-        } else {\n-            originalRes.close(cause);\n-            logBuilder.endResponse(cause);\n+    @Override\n+    void onWriteSuccess() {\n+        // Request more messages regardless whether the state is DONE. It makes the producer have\n+        // a chance to produce the last call such as 'onComplete' and 'onError' when there are\n+        // no more messages it can produce.\n+        if (!isSubscriptionCompleted) {\n+            assert subscription != null;\n+            subscription.request(1);\n         }\n     }\n \n-    private void cancelSubscription() {\n+    @Override\n+    void cancel() {\n         isSubscriptionCompleted = true;\n         assert subscription != null;\n         subscription.cancel();\n     }\n-\n-    private void failAndReset(Throwable cause) {\n-        fail(cause);\n-\n-        final Http2Error error;\n-        if (Exceptions.isStreamCancelling(cause)) {\n-            error = Http2Error.CANCEL;\n-        } else {\n-            error = Http2Error.INTERNAL_ERROR;\n-        }\n-\n-        if (error.code() != Http2Error.CANCEL.code()) {\n-            Exceptions.logIfUnexpected(logger, ch,\n-                                       HttpSession.get(ch).protocol(),\n-                                       \"a request publisher raised an exception\", cause);\n-        }\n-\n-        if (ch.isActive()) {\n-            encoder.writeReset(id, streamId(), error);\n-            ch.flush();\n-        }\n-    }\n-\n-    private boolean cancelTimeout() {\n-        final ScheduledFuture<?> timeoutFuture = this.timeoutFuture;\n-        if (timeoutFuture == null) {\n-            return true;\n-        }\n-\n-        this.timeoutFuture = null;\n-        return timeoutFuture.cancel(false);\n-    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "711cea08b59286f5f847e5c4f17aedec5ada97de", "committedDate": "2020-03-19 13:54:44 +0900", "message": "Assign stream ID right before writing RequestHeaders (#2597)"}, {"oid": "6d21bfd5d5ac863d7d68420873190b4dc5f8f018", "committedDate": "2020-03-23 11:00:30 +0900", "message": "Wrap ProxyConnectException with UnprocessedRequestException (#2609)"}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "ac3440be28a34d436e4382257d46bbf2cbdbca8a", "committedDate": "2020-05-14 15:15:17 +0900", "message": "Fix a bug where a response cause is not propagated when retrying a fa\u2026 (#2709)"}, {"oid": "ec336fa661ddc4308e8a831b99c959f939533f99", "committedDate": "2020-06-05 13:34:18 +0900", "message": "Provide a way to close a connection when exceeding the maximum age on server-side (#2747)"}, {"oid": "e5cea5e9ba7afc6a3b2c38d0663b8b1e3334ad37", "committedDate": "2020-06-26 19:10:34 +0900", "message": "Wrap `DnsTimeoutException` with `UnprocessedRequestException` (#2836)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "187ad54872e90f7eea3085f5a717460f3fec2daa", "committedDate": "2020-07-31 16:30:55 +0900", "message": "Add `when*TimingOut` and `when*TimedOut` to `{Service,Client}RequestContext` (#2939)"}, {"oid": "223c7c1cc4f98f1e56f1a95351f99155f7c365da", "committedDate": "2021-05-27 16:37:18 +0900", "message": "HttpRequestSubscriber should update RequestLogBuilder with all sent request headers (#3581)"}, {"oid": "6449551d515e2a612b0291f9b72c1c0d368364f2", "committedDate": "2021-07-28 16:43:35 +0900", "message": "Make `GrpcStatusFunction` access `RequestContext` (#3693)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "f777f14714f363656b1c12d1601dce12173394e9", "committedDate": "2022-06-01 16:24:20 +0900", "message": "Correctly throw `WriteTimeoutException` for requests without content (#4259)"}, {"oid": "435aeedcb007382250e4ee71311a5ff2c56615ae", "committedDate": "2022-07-01 13:06:08 +0900", "message": "Support `ExchangeType` on the client side (#4236)"}, {"oid": "5382f15db770d545434cabb41cf8f9f4e5315e62", "committedDate": "2023-03-23 11:31:17 +0900", "message": "Provide a way to disconnect gracefully connection using `RequestContext` (#4708)"}]}, {"oid": "de3ea3c0e525c6621d715d1d4221b455e020ca06", "url": "https://github.com/line/armeria/commit/de3ea3c0e525c6621d715d1d4221b455e020ca06", "message": "Inline `HttpRequestSubscriber.write0()`", "committedDate": "2020-02-28T22:16:21Z", "type": "forcePushed"}, {"oid": "d13565c88bd382876ad62fb24d1fada977338188", "url": "https://github.com/line/armeria/commit/d13565c88bd382876ad62fb24d1fada977338188", "message": "Inline `HttpRequestSubscriber.write0()`", "committedDate": "2020-02-28T22:21:11Z", "type": "forcePushed"}, {"oid": "7b7e2cc10b2a1a7e5270fad10b469067f3cdd39a", "url": "https://github.com/line/armeria/commit/7b7e2cc10b2a1a7e5270fad10b469067f3cdd39a", "message": "Split more methods", "committedDate": "2020-02-29T13:22:48Z", "type": "forcePushed"}, {"oid": "8958c66695a451c930feb5e71a59f3c506a72dee", "url": "https://github.com/line/armeria/commit/8958c66695a451c930feb5e71a59f3c506a72dee", "message": "Split more methods", "committedDate": "2020-02-29T13:38:24Z", "type": "forcePushed"}, {"oid": "5e5f53d43e07c5ba0559b944c89ab10548e22a86", "url": "https://github.com/line/armeria/commit/5e5f53d43e07c5ba0559b944c89ab10548e22a86", "message": "Split more methods", "committedDate": "2020-02-29T15:12:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyMDc2Mw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r388320763", "body": "Please make all `protected` methods in this class `final` if possible.", "bodyText": "Please make all protected methods in this class final if possible.", "bodyHTML": "<p dir=\"auto\">Please make all <code>protected</code> methods in this class <code>final</code> if possible.</p>", "author": "trustin", "createdAt": "2020-03-05T14:18:17Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java", "diffHunk": "@@ -38,30 +35,19 @@\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelFutureListener;\n import io.netty.channel.ChannelPromise;\n-import io.netty.handler.codec.http.DefaultFullHttpResponse;\n import io.netty.handler.codec.http.DefaultHttpContent;\n-import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultHttpResponse;\n import io.netty.handler.codec.http.DefaultLastHttpContent;\n import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaderValues;\n-import io.netty.handler.codec.http.HttpMessage;\n-import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpHeaders;\n import io.netty.handler.codec.http.HttpObject;\n-import io.netty.handler.codec.http.HttpRequest;\n-import io.netty.handler.codec.http.HttpResponse;\n-import io.netty.handler.codec.http.HttpResponseStatus;\n-import io.netty.handler.codec.http.HttpUtil;\n-import io.netty.handler.codec.http.HttpVersion;\n import io.netty.handler.codec.http.LastHttpContent;\n import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.Http2Exception;\n import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n import io.netty.util.ReferenceCountUtil;\n import io.netty.util.collection.IntObjectHashMap;\n import io.netty.util.collection.IntObjectMap;\n \n-public final class Http1ObjectEncoder extends HttpObjectEncoder {\n+public abstract class Http1ObjectEncoder extends HttpObjectEncoder {", "originalCommit": "edad787c4db66b736258527dcb2605601b30b8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex 348bbe492..a87b186de 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -38,16 +39,14 @@ import io.netty.channel.ChannelPromise;\n import io.netty.handler.codec.http.DefaultHttpContent;\n import io.netty.handler.codec.http.DefaultLastHttpContent;\n import io.netty.handler.codec.http.HttpContent;\n-import io.netty.handler.codec.http.HttpHeaders;\n import io.netty.handler.codec.http.HttpObject;\n import io.netty.handler.codec.http.LastHttpContent;\n import io.netty.handler.codec.http2.Http2Error;\n-import io.netty.handler.codec.http2.HttpConversionUtil.ExtensionHeaderNames;\n import io.netty.util.ReferenceCountUtil;\n import io.netty.util.collection.IntObjectHashMap;\n import io.netty.util.collection.IntObjectMap;\n \n-public abstract class Http1ObjectEncoder extends HttpObjectEncoder {\n+public abstract class Http1ObjectEncoder implements HttpObjectEncoder {\n \n     /**\n      * The maximum allowed length of an HTTP chunk when TLS is enabled.\n", "next_change": {"commit": "37d7eaaff5348948a68144127067465c834134c4", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\nindex a87b186de..34768a365 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http1ObjectEncoder.java\n", "chunk": "@@ -53,12 +52,16 @@ public abstract class Http1ObjectEncoder implements HttpObjectEncoder {\n      * <ul>\n      *   <li>16384 - The maximum length of a cleartext TLS record.</li>\n      *   <li>6 - The maximum header length of an HTTP chunk. i.e. \"4000\\r\\n\".length()</li>\n+     *   <li>2 - The trailing \"\\r\\n\".</li>\n      * </ul>\n      *\n-     * <p>To be precise, we have a chance of wasting 6 bytes because we may not use chunked encoding,\n+     * <p>To be precise, we have a chance of wasting 8 bytes because we may not use chunked encoding,\n      * but it is not worth adding complexity to be that precise.\n+     *\n+     * <p>TODO(trustin): Remove this field as well as {@link #doWriteSplitData(int, HttpData, boolean)}\n+     *                   once https://github.com/netty/netty/issues/11792 is fixed.\n      */\n-    private static final int MAX_TLS_DATA_LENGTH = 16384 - 6;\n+    private static final int MAX_TLS_DATA_LENGTH = 16384 - 8;\n \n     /**\n      * A non-last empty {@link HttpContent}.\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "0bb591d252884ec471af00e2757032ae57196d5e", "committedDate": "2020-07-21 16:29:34 +0900", "message": "Add a bunch of `final` keywords (#2927)"}, {"oid": "ca795928079dbea9b283ff1389cc6cadb0c9338e", "committedDate": "2021-01-27 18:51:21 +0900", "message": "Provide a way to limit max number of requests and max connection age for client (#3267)"}, {"oid": "37d7eaaff5348948a68144127067465c834134c4", "committedDate": "2021-10-26 01:21:56 +0900", "message": "Fix content corruption in a chunked response on TLS (#3894)"}, {"oid": "43a675859a705d415e452ce5d7d6c60e5e5f0715", "committedDate": "2021-11-23 16:19:37 +0900", "message": "Fix a bug where protocol violation errors trigger duplicate headers writes (#3914)"}, {"oid": "c7a85030c224aac256d1d9dd4c9fb08b09abe8cf", "committedDate": "2022-03-23 18:55:26 +0900", "message": "Show more information when Http1ObjectEncoder writing header at endStream failed (#4149)"}, {"oid": "93313390c1d6e870b9d68685e034d1b61c008cfc", "committedDate": "2022-04-18 18:56:17 +0900", "message": "Fix a bug where a `HeaderListSizeException` is not propagated to a client (#4180)"}, {"oid": "03645e92d02781712040d263f9b7b69848d79cfc", "committedDate": "2022-08-04 17:08:34 +0900", "message": "Use ClosedSessionException and ClosedStreamException correctly (#4380)"}, {"oid": "deee635ca2857e973a7bf5d344596d677ad770a9", "committedDate": "2022-11-07 15:19:13 +0900", "message": "Fix a bug where a connection is closed before a response is written in HTTP/1.x (#4508)"}, {"oid": "f4781d52a34f874e9459994afd8de763c9608480", "committedDate": "2022-12-19 11:41:29 +0900", "message": "Fix a deadlock when a late response are written first in HTTP/1 pipelining (#4536)"}, {"oid": "3713d52f39fdc0dc99bb93b8039e00cfe88e1609", "committedDate": "2023-02-08 21:47:28 +0900", "message": "Fix a bug where `ClosedSessionException` is set to `responseCause` for a success response. (#4632)"}, {"oid": "508fa96cb763fdbb60b56ec2814c4b1758f0dc1f", "committedDate": "2023-03-23 20:48:29 +0900", "message": "Prevent self reference in addSuppressed (#4758)"}, {"oid": "b78d9515dc8b4b997dd65787f717443b38a21869", "committedDate": "2023-05-18 12:14:53 +0900", "message": "Add WebSocketService (#3904)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyMTA1Ng==", "url": "https://github.com/line/armeria/pull/2372#discussion_r388321056", "body": "Please make all `protected` methods in this class `final` if possible.", "bodyText": "Please make all protected methods in this class final if possible.", "bodyHTML": "<p dir=\"auto\">Please make all <code>protected</code> methods in this class <code>final</code> if possible.</p>", "author": "trustin", "createdAt": "2020-03-05T14:18:45Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java", "diffHunk": "@@ -19,25 +19,22 @@\n import static java.util.Objects.requireNonNull;\n \n import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.stream.ClosedStreamException;\n \n import io.netty.buffer.Unpooled;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n import io.netty.channel.ChannelHandlerContext;\n-import io.netty.handler.codec.http2.Http2Connection;\n import io.netty.handler.codec.http2.Http2ConnectionEncoder;\n import io.netty.handler.codec.http2.Http2Error;\n import io.netty.handler.codec.http2.Http2Stream;\n import io.netty.util.ReferenceCountUtil;\n \n-public final class Http2ObjectEncoder extends HttpObjectEncoder {\n-\n+public abstract class Http2ObjectEncoder extends HttpObjectEncoder {", "originalCommit": "edad787c4db66b736258527dcb2605601b30b8ae", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 66e107906..ed59f6bb0 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -30,22 +30,24 @@ import io.netty.handler.codec.http2.Http2Error;\n import io.netty.handler.codec.http2.Http2Stream;\n import io.netty.util.ReferenceCountUtil;\n \n-public abstract class Http2ObjectEncoder extends HttpObjectEncoder {\n+public abstract class Http2ObjectEncoder implements HttpObjectEncoder {\n     private final ChannelHandlerContext ctx;\n     private final Http2ConnectionEncoder encoder;\n \n+    private volatile boolean closed;\n+\n     protected Http2ObjectEncoder(ChannelHandlerContext ctx, Http2ConnectionEncoder encoder) {\n         this.ctx = requireNonNull(ctx, \"ctx\");\n         this.encoder = requireNonNull(encoder, \"encoder\");\n     }\n \n     @Override\n-    protected Channel channel() {\n+    public final Channel channel() {\n         return ctx.channel();\n     }\n \n     @Override\n-    protected ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n+    public final ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (isStreamPresentAndWritable(streamId)) {\n             // Write to an existing stream.\n             return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n", "next_change": {"commit": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex ed59f6bb0..9a7ba310a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -49,6 +48,10 @@ public abstract class Http2ObjectEncoder implements HttpObjectEncoder {\n     @Override\n     public final ChannelFuture doWriteData(int id, int streamId, HttpData data, boolean endStream) {\n         if (isStreamPresentAndWritable(streamId)) {\n+            final KeepAliveHandler keepAliveHandler = keepAliveHandler();\n+            if (keepAliveHandler != null) {\n+                keepAliveHandler.onReadOrWrite();\n+            }\n             // Write to an existing stream.\n             return encoder.writeData(ctx, streamId, toByteBuf(data), 0, endStream, ctx.newPromise());\n         }\n", "next_change": {"commit": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\nindex 9a7ba310a..e8de86f28 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/Http2ObjectEncoder.java\n", "chunk": "@@ -58,13 +57,13 @@ public abstract class Http2ObjectEncoder implements HttpObjectEncoder {\n \n         if (encoder.connection().local().mayHaveCreatedStream(streamId)) {\n             // Can't write to an outdated (closed) stream.\n-            ReferenceCountUtil.safeRelease(data);\n+            data.close();\n             return data.isEmpty() ? ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)\n                                   : newFailedFuture(ClosedStreamException.get());\n         }\n \n         // Cannot start a new stream with a DATA frame. It must start with a HEADERS frame.\n-        ReferenceCountUtil.safeRelease(data);\n+        data.close();\n         return newFailedFuture(new IllegalStateException(\n                 \"Trying to write data to the closed stream \" + streamId +\n                 \" or start a new stream with a DATA frame\"));\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}, {"oid": "744098d4ed83a65c6668fd863afebae14f5e2a1c", "committedDate": "2020-07-17 19:44:36 +0900", "message": "Make `HttpData` closeable and support more `ByteBuf` conversions (#2892)"}, {"oid": "ca795928079dbea9b283ff1389cc6cadb0c9338e", "committedDate": "2021-01-27 18:51:21 +0900", "message": "Provide a way to limit max number of requests and max connection age for client (#3267)"}, {"oid": "2920a1ddc2188f150a0d8b77de1d4e2e409997cf", "committedDate": "2021-10-06 16:34:55 +0900", "message": "Replace `ExceptionHandler` with `ServerErrorHandler` (#3853)"}, {"oid": "deee635ca2857e973a7bf5d344596d677ad770a9", "committedDate": "2022-11-07 15:19:13 +0900", "message": "Fix a bug where a connection is closed before a response is written in HTTP/1.x (#4508)"}]}, {"oid": "39edd429593ac1a12fdf95c897223dd7e0455788", "url": "https://github.com/line/armeria/commit/39edd429593ac1a12fdf95c897223dd7e0455788", "message": "WIP", "committedDate": "2020-03-08T20:18:34Z", "type": "forcePushed"}, {"oid": "3136f3185cd7bd0321308b0db8262e15e710224a", "url": "https://github.com/line/armeria/commit/3136f3185cd7bd0321308b0db8262e15e710224a", "message": "Streamline HTTP header/trailer validation and conversion\n\nMotivation:\n* Related #2096\n\nModifications:\n* Move and merge response header conversion process\nfrom `HttpResponseSubscriber`\nto `ArmeriaHttpUtil.toNettyHttp1()/ArmeriaHttpUtil.toNettyHttp2()`\n* Move and merge request header conversion process\nfrom `HttpRequestSubscriber`\nto `ArmeriaHttpUtil.toNettyHttp1()/ArmeriaHttpUtil.toNettyHttp2()`\n* Add parameters to `HttpObjectEncoder.writeHeaders()`\n`HttpHeaders additionalHeaders`,`HttpHeaders additionalTrailers`,\n`boolean enableServerHeader`,`boolean enableDateHeader`,\n`@Nullable SessionProtocol sessionProtocol`,\n`@Nullable String authorityHeader`, `@Nullable String userAgentHeader`\n\nResult:\n* Better HTTP header validation/conversion performance", "committedDate": "2020-03-10T21:52:50Z", "type": "forcePushed"}, {"oid": "e1d05976115ac412a9cd2cfd0b6df43ad943c0c7", "url": "https://github.com/line/armeria/commit/e1d05976115ac412a9cd2cfd0b6df43ad943c0c7", "message": "Streamline HTTP header/trailer validation and conversion\n\nMotivation:\n\nCurrently, user-provided HTTP headers and trailers are consumer by\n`HttpRequestSubscriber` and `HttpResponseSubscriber`. The following is\nthe basic header/trailer validation and conversion process:\n\n1. `Http*Subscriber` merges the `Request/ResponseHeaders` and\n   `ctx.additional*Headers()` while excluding some prohibited headers.\n2. `Http*Subscriber` passs the merged headers to `HttpObjectEncoder`.\n3. `HttpObjectEncoder` converts the merged headers while excluding some\n   more prohibited headers, using `ArmeriaHttpUtil`.\n\n(Pretty much same for trailers)\n\nInstead, we could streamline and optimize this process like the following:\n\n1. `Http*Subscriber` passes `Request/ResponseHeaders` and\n   `ctx.additional*Headers()`, without any validation or exclusion.\n2. `HttpObjectEncoder` converts the given headers while excluding\n   prohibited headers and merging `Request/ResponseHeaders` and\n   `ctx.additional*Headers()`.\n\nThis way, we could reduce the number of unnecessary instantiation of\nimmutable headers and their builders.\n\nModifications:\n\n- Move and merge response header conversion process from\n  `HttpResponseSubscriber` to `ArmeriaHttpUtil.toNettyHttp1/2()`\n- Move and merge request header conversion process from\n  `HttpRequestSubscriber` to `ArmeriaHttpUtil.toNettyHttp1/2()`\n- Add parameters to `HttpObjectEncoder.writeHeaders()`:\n  - `HttpHeaders additionalHeaders`\n  - `HttpHeaders additionalTrailers`\n- Split `Http1ObjectEncoder` into:\n  - `ServerHttp1ObjectEncoder`\n  - `ClientHttp1ObjectEncoder`\n- Split `Http2ObjectEncoder` into:\n  - `ServerHttp2ObjectEncoder`\n  - `ClientHttp2ObjectEncoder`\n- Split `ArmeriaHttpUtil.toNettyHttp1()` into:\n  - `toNettyHttp1ServerHeader()`\n  - `toNettyHttp1ServerTrailer()`\n  - `toNettyHttp1ClientHeader()`\n  - `toNettyHttp1ClientTrailer()`\n- Split `ArmeriaHttpUtil.toNettyHttp2()` into:\n  - `toNettyHttp2ServerHeader()`\n  - `toNettyHttp2ServerTrailer()`\n  - `toNettyHttp2ClientHeader()`\n  - `toNettyHttp2ClientTrailer()`\n\nResult:\n\n- Better HTTP header validation/conversion performance\n- Fixes #2096", "committedDate": "2020-03-17T07:12:24Z", "type": "commit"}, {"oid": "e1d05976115ac412a9cd2cfd0b6df43ad943c0c7", "url": "https://github.com/line/armeria/commit/e1d05976115ac412a9cd2cfd0b6df43ad943c0c7", "message": "Streamline HTTP header/trailer validation and conversion\n\nMotivation:\n\nCurrently, user-provided HTTP headers and trailers are consumer by\n`HttpRequestSubscriber` and `HttpResponseSubscriber`. The following is\nthe basic header/trailer validation and conversion process:\n\n1. `Http*Subscriber` merges the `Request/ResponseHeaders` and\n   `ctx.additional*Headers()` while excluding some prohibited headers.\n2. `Http*Subscriber` passs the merged headers to `HttpObjectEncoder`.\n3. `HttpObjectEncoder` converts the merged headers while excluding some\n   more prohibited headers, using `ArmeriaHttpUtil`.\n\n(Pretty much same for trailers)\n\nInstead, we could streamline and optimize this process like the following:\n\n1. `Http*Subscriber` passes `Request/ResponseHeaders` and\n   `ctx.additional*Headers()`, without any validation or exclusion.\n2. `HttpObjectEncoder` converts the given headers while excluding\n   prohibited headers and merging `Request/ResponseHeaders` and\n   `ctx.additional*Headers()`.\n\nThis way, we could reduce the number of unnecessary instantiation of\nimmutable headers and their builders.\n\nModifications:\n\n- Move and merge response header conversion process from\n  `HttpResponseSubscriber` to `ArmeriaHttpUtil.toNettyHttp1/2()`\n- Move and merge request header conversion process from\n  `HttpRequestSubscriber` to `ArmeriaHttpUtil.toNettyHttp1/2()`\n- Add parameters to `HttpObjectEncoder.writeHeaders()`:\n  - `HttpHeaders additionalHeaders`\n  - `HttpHeaders additionalTrailers`\n- Split `Http1ObjectEncoder` into:\n  - `ServerHttp1ObjectEncoder`\n  - `ClientHttp1ObjectEncoder`\n- Split `Http2ObjectEncoder` into:\n  - `ServerHttp2ObjectEncoder`\n  - `ClientHttp2ObjectEncoder`\n- Split `ArmeriaHttpUtil.toNettyHttp1()` into:\n  - `toNettyHttp1ServerHeader()`\n  - `toNettyHttp1ServerTrailer()`\n  - `toNettyHttp1ClientHeader()`\n  - `toNettyHttp1ClientTrailer()`\n- Split `ArmeriaHttpUtil.toNettyHttp2()` into:\n  - `toNettyHttp2ServerHeader()`\n  - `toNettyHttp2ServerTrailer()`\n  - `toNettyHttp2ClientHeader()`\n  - `toNettyHttp2ClientTrailer()`\n\nResult:\n\n- Better HTTP header validation/conversion performance\n- Fixes #2096", "committedDate": "2020-03-17T07:12:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQ2MTgyNw==", "url": "https://github.com/line/armeria/pull/2372#discussion_r391461827", "body": "```suggestion\r\n        return lastContent;\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return  lastContent;\n          \n          \n            \n                    return lastContent;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> <span class=\"x x-first x-last\"> </span>lastContent;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> lastContent;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "ikhoon", "createdAt": "2020-03-12T08:24:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.client;\n+\n+import java.net.InetSocketAddress;\n+\n+import com.linecorp.armeria.common.HttpHeaderNames;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.SessionProtocol;\n+import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n+import com.linecorp.armeria.internal.common.Http1ObjectEncoder;\n+\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.handler.codec.http.DefaultHttpRequest;\n+import io.netty.handler.codec.http.DefaultLastHttpContent;\n+import io.netty.handler.codec.http.HttpHeaderValues;\n+import io.netty.handler.codec.http.HttpMethod;\n+import io.netty.handler.codec.http.HttpObject;\n+import io.netty.handler.codec.http.HttpRequest;\n+import io.netty.handler.codec.http.HttpUtil;\n+import io.netty.handler.codec.http.HttpVersion;\n+import io.netty.handler.codec.http.LastHttpContent;\n+import io.netty.handler.codec.http2.Http2Exception;\n+\n+public final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder {\n+    public ClientHttp1ObjectEncoder(Channel ch, SessionProtocol protocol) {\n+        super(ch, protocol);\n+    }\n+\n+    @Override\n+    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n+                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n+        if (!isWritable(id)) {\n+            return newClosedSessionFuture();\n+        }\n+\n+        try {\n+            final HttpObject converted;\n+            final String method = headers.get(HttpHeaderNames.METHOD);\n+            if (method == null) {\n+                converted = convertTrailers(streamId, headers);\n+            } else {\n+                converted = convertHeaders(streamId, headers, endStream, additionalHeaders);\n+            }\n+            return writeNonInformationalHeaders(id, converted, endStream);\n+        } catch (Throwable t) {\n+            return newFailedFuture(t);\n+        }\n+    }\n+\n+    private static LastHttpContent convertTrailers(int streamId, HttpHeaders inHeaders) throws Http2Exception {\n+        if (inHeaders.isEmpty()) {\n+            return LastHttpContent.EMPTY_LAST_CONTENT;\n+        }\n+        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n+\n+        ArmeriaHttpUtil.toNettyHttp1ClientTrailer(streamId, inHeaders, lastContent.trailingHeaders());\n+\n+        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n+        return  lastContent;", "originalCommit": "3136f3185cd7bd0321308b0db8262e15e710224a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d67229d0647fd658b3c946763f5a5819b87b76cd", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\nindex add3efb18..c2ad1984e 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n", "chunk": "@@ -73,7 +73,7 @@ public final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(streamId, inHeaders, lastContent.trailingHeaders());\n \n         removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-        return  lastContent;\n+        return lastContent;\n     }\n \n     private HttpObject convertHeaders(int streamId, HttpHeaders headers, boolean endStream,\n", "next_change": null}]}, "revised_code_in_main": {"commit": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\nindex add3efb18..c2ad1984e 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n", "chunk": "@@ -73,7 +73,7 @@ public final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder {\n         ArmeriaHttpUtil.toNettyHttp1ClientTrailer(streamId, inHeaders, lastContent.trailingHeaders());\n \n         removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-        return  lastContent;\n+        return lastContent;\n     }\n \n     private HttpObject convertHeaders(int streamId, HttpHeaders headers, boolean endStream,\n", "next_change": {"commit": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\nindex c2ad1984e..7a692f218 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n", "chunk": "@@ -20,87 +20,52 @@ import java.net.InetSocketAddress;\n \n import com.linecorp.armeria.common.HttpHeaderNames;\n import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.RequestHeaders;\n import com.linecorp.armeria.common.SessionProtocol;\n import com.linecorp.armeria.internal.common.ArmeriaHttpUtil;\n import com.linecorp.armeria.internal.common.Http1ObjectEncoder;\n \n-import io.netty.buffer.Unpooled;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelFuture;\n import io.netty.handler.codec.http.DefaultHttpRequest;\n-import io.netty.handler.codec.http.DefaultLastHttpContent;\n import io.netty.handler.codec.http.HttpHeaderValues;\n import io.netty.handler.codec.http.HttpMethod;\n import io.netty.handler.codec.http.HttpObject;\n import io.netty.handler.codec.http.HttpRequest;\n import io.netty.handler.codec.http.HttpUtil;\n import io.netty.handler.codec.http.HttpVersion;\n-import io.netty.handler.codec.http.LastHttpContent;\n-import io.netty.handler.codec.http2.Http2Exception;\n \n-public final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder {\n+public final class ClientHttp1ObjectEncoder extends Http1ObjectEncoder implements ClientHttpObjectEncoder {\n+\n     public ClientHttp1ObjectEncoder(Channel ch, SessionProtocol protocol) {\n         super(ch, protocol);\n     }\n \n     @Override\n-    protected ChannelFuture doWriteHeaders(int id, int streamId, HttpHeaders headers, boolean endStream,\n-                                           HttpHeaders additionalHeaders, HttpHeaders additionalTrailers) {\n-        if (!isWritable(id)) {\n-            return newClosedSessionFuture();\n-        }\n-\n-        try {\n-            final HttpObject converted;\n-            final String method = headers.get(HttpHeaderNames.METHOD);\n-            if (method == null) {\n-                converted = convertTrailers(streamId, headers);\n-            } else {\n-                converted = convertHeaders(streamId, headers, endStream, additionalHeaders);\n-            }\n-            return writeNonInformationalHeaders(id, converted, endStream);\n-        } catch (Throwable t) {\n-            return newFailedFuture(t);\n-        }\n-    }\n-\n-    private static LastHttpContent convertTrailers(int streamId, HttpHeaders inHeaders) throws Http2Exception {\n-        if (inHeaders.isEmpty()) {\n-            return LastHttpContent.EMPTY_LAST_CONTENT;\n-        }\n-        final LastHttpContent lastContent = new DefaultLastHttpContent(Unpooled.EMPTY_BUFFER, false);\n-\n-        ArmeriaHttpUtil.toNettyHttp1ClientTrailer(streamId, inHeaders, lastContent.trailingHeaders());\n-\n-        removeHttpExtensionHeaders(lastContent.trailingHeaders());\n-        return lastContent;\n+    public ChannelFuture doWriteHeaders(int id, int streamId, RequestHeaders headers, boolean endStream) {\n+        return writeNonInformationalHeaders(id, convertHeaders(headers, endStream), endStream);\n     }\n \n-    private HttpObject convertHeaders(int streamId, HttpHeaders headers, boolean endStream,\n-                                      HttpHeaders additionalHeaders) throws Http2Exception {\n-        final String method = headers.get(HttpHeaderNames.METHOD);\n-        final String path = headers.get(HttpHeaderNames.PATH);\n-        assert path != null;\n-        final HttpRequest req = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.valueOf(method), path,\n-                                                       false);\n-        ArmeriaHttpUtil.toNettyHttp1ClientHeader(streamId, headers, additionalHeaders, req.headers(),\n-                                                 HttpVersion.HTTP_1_1);\n-\n-        removeHttpExtensionHeaders(req.headers());\n+    private HttpObject convertHeaders(RequestHeaders headers, boolean endStream) {\n+        final String method = headers.method().name();\n+        final HttpRequest req = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.valueOf(method),\n+                                                       headers.path(), false);\n+        final io.netty.handler.codec.http.HttpHeaders nettyHeaders = req.headers();\n+        ArmeriaHttpUtil.toNettyHttp1ClientHeader(headers, nettyHeaders);\n \n-        if (!req.headers().contains(HttpHeaderNames.USER_AGENT)) {\n-            req.headers().add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n+        if (!nettyHeaders.contains(HttpHeaderNames.USER_AGENT)) {\n+            nettyHeaders.add(HttpHeaderNames.USER_AGENT, HttpHeaderUtil.USER_AGENT.toString());\n         }\n \n-        if (!req.headers().contains(HttpHeaderNames.HOST)) {\n+        if (!nettyHeaders.contains(HttpHeaderNames.HOST)) {\n             final InetSocketAddress remoteAddress = (InetSocketAddress) channel().remoteAddress();\n-            req.headers().add(HttpHeaderNames.HOST, ArmeriaHttpUtil.authorityHeader(remoteAddress.getHostName(),\n-                                                                                    remoteAddress.getPort(),\n-                                                                                    protocol().defaultPort()));\n+            nettyHeaders.add(HttpHeaderNames.HOST, ArmeriaHttpUtil.authorityHeader(remoteAddress.getHostName(),\n+                                                                                   remoteAddress.getPort(),\n+                                                                                   protocol().defaultPort()));\n         }\n \n         if (endStream) {\n-            req.headers().remove(HttpHeaderNames.TRANSFER_ENCODING);\n+            nettyHeaders.remove(HttpHeaderNames.TRANSFER_ENCODING);\n \n             // Set or remove the 'content-length' header depending on request method.\n             // See: https://tools.ietf.org/html/rfc7230#section-3.3.2\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1d499c658027a0f80faee6ffd6a1f0be66399c0b", "message": "Merge commit", "committedDate": null}, {"oid": "79cda1df1dd4b7d5056ad385e5484d384ed72a14", "committedDate": "2020-03-25 15:29:07 +0900", "message": "Fix the ResponseHeaders log to contain additional headers (#2620)"}, {"oid": "fec9fb833275eba59eb9afaf25fc8b7c28132f80", "committedDate": "2020-04-14 18:10:29 +0900", "message": "Add HTTP/1 PING(`OPTIONS *`) (#2636)"}]}, {"oid": "d67229d0647fd658b3c946763f5a5819b87b76cd", "url": "https://github.com/line/armeria/commit/d67229d0647fd658b3c946763f5a5819b87b76cd", "message": "Update core/src/main/java/com/linecorp/armeria/internal/client/ClientHttp1ObjectEncoder.java\n\nCo-Authored-By: Ikhun Um <ih.pert@gmail.com>", "committedDate": "2020-03-17T09:07:54Z", "type": "commit"}]}