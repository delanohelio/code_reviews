{"pr_number": 3038, "pr_title": "Provide a way to consume headers and data separately from HttpResponse", "pr_author": "ikhoon", "pr_createdAt": "2020-08-31T13:42:38Z", "pr_url": "https://github.com/line/armeria/pull/3038", "merge_commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "timeline": [{"oid": "d05fcb1d6104fd656e25a64ca0cfe16f13b42fe7", "url": "https://github.com/line/armeria/commit/d05fcb1d6104fd656e25a64ca0cfe16f13b42fe7", "message": "Provide a way to consume headers and data separately from HttpResponse\n\nMotivation:\n\n`HttpResponse` publishes HTTP headers and payloads in a single `Publisher`.\nWhen subscribing `HttpResponse`, users should distinguish `HttpHeaders` and HttpData manually.\nThe single stream is also inconvenient when integrating Armeria client with others.\nSome clients only takes pre-materialized headers and body stream.\n`ArmeriaHttpClientResponseSubscriber` is a example.\nhttps://github.com/line/armeria/blob/fbe90f0f2a952578012a552c26b3f4f8bdb33c8c/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpClientResponseSubscriber.java#46\n\nModifications:\n\n- Add `HttpResponseBodyStream` that publishes `HttpData` and completes `HttpHeaders` using `CompletableFuture`\n- Add `HttpResponse.toBodyStream` for easy conversion.\n\nResult:\n\nYou can now split HTTP headers from `HttpResponse` convenientely using `HttpResponse.toBodyStream`\n\nTODO:\n- Migrate ArmeriaHttpClientResponseSubscriber to use `HttpResponse.toBodyStream`", "committedDate": "2020-08-31T13:40:36Z", "type": "commit"}, {"oid": "b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "url": "https://github.com/line/armeria/commit/b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "message": "Fetch headers early", "committedDate": "2020-09-01T06:55:50Z", "type": "commit"}, {"oid": "b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "url": "https://github.com/line/armeria/commit/b63f0b2a0499604c22c80d8ff0b9029a6a41a3de", "message": "Fetch headers early", "committedDate": "2020-09-01T06:55:50Z", "type": "forcePushed"}, {"oid": "2eada31e6bf07fbc65118dab528777b83339fb0a", "url": "https://github.com/line/armeria/commit/2eada31e6bf07fbc65118dab528777b83339fb0a", "message": "Checkstyle", "committedDate": "2020-09-01T07:43:36Z", "type": "commit"}, {"oid": "f5875796ff63163a414888d58b132b494bcf1555", "url": "https://github.com/line/armeria/commit/f5875796ff63163a414888d58b132b494bcf1555", "message": "Fix flaky test", "committedDate": "2020-09-01T10:18:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MDQxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481560414", "body": "`{@linkplain HttpHeaders trailers}`?", "bodyText": "{@linkplain HttpHeaders trailers}?", "bodyHTML": "<p dir=\"auto\"><code>{@linkplain HttpHeaders trailers}</code>?</p>", "author": "minwoox", "createdAt": "2020-09-02T02:20:27Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nindex dde766c36..66964a593 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n", "chunk": "@@ -45,9 +45,9 @@ public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n-     * with an {@link HttpHeaders#of() empty headers}.\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n+     * an {@linkplain HttpHeaders#of() empty headers}.\n      */\n     CompletableFuture<HttpHeaders> trailers();\n \n", "next_change": {"commit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 66964a593..a7dc57810 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -19,45 +19,39 @@ package com.linecorp.armeria.common;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-import org.reactivestreams.Subscriber;\n+import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n \n /**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n  * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n  * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n  */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+public interface SplitHttpResponse {\n+\n     /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n+     * Returns a {@link CompletableFuture} completed with a list of\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n      * </a> {@link ResponseHeaders}.\n      */\n     CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n      */\n-    CompletableFuture<HttpHeaders> trailers();\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n \n     /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n+    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\ndeleted file mode 100644\nindex dde766c36..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-\n-import org.reactivestreams.Subscriber;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-/**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n- */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n-     * with an {@link HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n-\n-    /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n-     */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MDg2Nw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481560867", "body": "ditto", "bodyText": "ditto", "bodyHTML": "<p dir=\"auto\">ditto</p>", "author": "minwoox", "createdAt": "2020-09-02T02:21:06Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n+     * with an {@link HttpHeaders#of() empty headers}.", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nindex dde766c36..66964a593 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n", "chunk": "@@ -45,9 +45,9 @@ public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n-     * with an {@link HttpHeaders#of() empty headers}.\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n+     * an {@linkplain HttpHeaders#of() empty headers}.\n      */\n     CompletableFuture<HttpHeaders> trailers();\n \n", "next_change": {"commit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 66964a593..a7dc57810 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -19,45 +19,39 @@ package com.linecorp.armeria.common;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-import org.reactivestreams.Subscriber;\n+import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n \n /**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n  * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n  * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n  */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+public interface SplitHttpResponse {\n+\n     /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n+     * Returns a {@link CompletableFuture} completed with a list of\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n      * </a> {@link ResponseHeaders}.\n      */\n     CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n      */\n-    CompletableFuture<HttpHeaders> trailers();\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n \n     /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n+    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\ndeleted file mode 100644\nindex dde766c36..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-\n-import org.reactivestreams.Subscriber;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-/**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n- */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a {@link HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} completes\n-     * with an {@link HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n-\n-    /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n-     */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2MjUzNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481562534", "body": "nit: `requireNonNull(executor, \"executor\");`", "bodyText": "nit: requireNonNull(executor, \"executor\");", "bodyHTML": "<p dir=\"auto\">nit: <code>requireNonNull(executor, \"executor\");</code></p>", "author": "minwoox", "createdAt": "2020-09-02T02:23:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nindex db6c6ec66..97a0e0999 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -85,13 +83,10 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n \n     DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n                                   SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n \n         response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n     }\n \n     @Override\n", "next_change": {"commit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\nsimilarity index 87%\nrename from core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\nindex 97a0e0999..b94d4e971 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -81,8 +90,8 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n     private volatile HeadersFuture<HttpHeaders> trailersFuture;\n     private volatile boolean wroteAny;\n \n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n+    public DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                         SubscriptionOption... options) {\n         this.response = requireNonNull(response, \"response\");\n         this.executor = requireNonNull(executor, \"executor\");\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\ndeleted file mode 100644\nindex db6c6ec66..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-\n-    static {\n-        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n-        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n-\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor executor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n-\n-        response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n-    }\n-\n-    @Override\n-    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n-        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n-        if (informationalHeadersFuture != null) {\n-            return informationalHeadersFuture;\n-        }\n-\n-        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.informationalHeadersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<HttpHeaders> trailers() {\n-        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.trailersFuture;\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        @Nullable\n-        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n-        @Nullable\n-        private Throwable cause;\n-        private boolean completing;\n-\n-        private boolean sawLeadingHeaders;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        volatile Subscription upstream;\n-        private volatile long pendingRequests;\n-        private volatile boolean cancelCalled;\n-\n-        private void setDownStream(Subscriber<? super HttpData> downstream) {\n-            try {\n-                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n-                    downstream.onSubscribe(NoopSubscription.get());\n-                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-                    return;\n-                }\n-                downstream.onSubscribe(this);\n-                if (cause != null) {\n-                    downstream.onError(cause);\n-                } else if (completing) {\n-                    downstream.onComplete();\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n-            maybeCompleteHeaders();\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n-        }\n-\n-        @Override\n-        public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n-            if (httpObject instanceof ResponseHeaders) {\n-                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n-                final HttpStatus status = headers.status();\n-                if (status.isInformational()) {\n-                    if (!sawLeadingHeaders) {\n-                        if (informationalHeadersBuilder == null) {\n-                            informationalHeadersBuilder = ImmutableList.builder();\n-                        }\n-                        informationalHeadersBuilder.add(headers);\n-                    }\n-                    upstream.request(1);\n-                } else {\n-                    sawLeadingHeaders = true;\n-                    completeInformationHeaders();\n-                    completeHeaders(headers);\n-                }\n-                return;\n-            }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n-\n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n-            }\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                cause = t;\n-            } else {\n-                downstream.onError(t);\n-            }\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n-        }\n-\n-        private void maybeCompleteHeaders() {\n-            completeInformationHeaders();\n-            completeHeaders(HEADERS_WITH_UNKNOWN_STATUS);\n-            if (trailersFuture == null) {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this, null, EMPTY_TRAILERS);\n-            }\n-        }\n-    }\n-\n-    private static final class HeadersFuture<T> extends UnmodifiableFuture<T> {\n-        @Override\n-        protected void doComplete(@Nullable T value) {\n-            super.doComplete(value);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2NDM0Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481564346", "body": "How about doing this is the `bodySubscriber`? (e.g. setting `pendingRequests` to 1, etc.)", "bodyText": "How about doing this is the bodySubscriber? (e.g. setting pendingRequests to 1, etc.)", "bodyHTML": "<p dir=\"auto\">How about doing this is the <code>bodySubscriber</code>? (e.g. setting <code>pendingRequests</code> to 1, etc.)</p>", "author": "minwoox", "createdAt": "2020-09-02T02:26:26Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nindex db6c6ec66..97a0e0999 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -85,13 +83,10 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n \n     DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n                                   SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n \n         response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n     }\n \n     @Override\n", "next_change": {"commit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\nsimilarity index 87%\nrename from core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\nindex 97a0e0999..b94d4e971 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -81,8 +90,8 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n     private volatile HeadersFuture<HttpHeaders> trailersFuture;\n     private volatile boolean wroteAny;\n \n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n+    public DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                         SubscriptionOption... options) {\n         this.response = requireNonNull(response, \"response\");\n         this.executor = requireNonNull(executor, \"executor\");\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\ndeleted file mode 100644\nindex db6c6ec66..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-\n-    static {\n-        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n-        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n-\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor executor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n-\n-        response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n-    }\n-\n-    @Override\n-    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n-        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n-        if (informationalHeadersFuture != null) {\n-            return informationalHeadersFuture;\n-        }\n-\n-        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.informationalHeadersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<HttpHeaders> trailers() {\n-        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.trailersFuture;\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        @Nullable\n-        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n-        @Nullable\n-        private Throwable cause;\n-        private boolean completing;\n-\n-        private boolean sawLeadingHeaders;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        volatile Subscription upstream;\n-        private volatile long pendingRequests;\n-        private volatile boolean cancelCalled;\n-\n-        private void setDownStream(Subscriber<? super HttpData> downstream) {\n-            try {\n-                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n-                    downstream.onSubscribe(NoopSubscription.get());\n-                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-                    return;\n-                }\n-                downstream.onSubscribe(this);\n-                if (cause != null) {\n-                    downstream.onError(cause);\n-                } else if (completing) {\n-                    downstream.onComplete();\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n-            maybeCompleteHeaders();\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n-        }\n-\n-        @Override\n-        public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n-            if (httpObject instanceof ResponseHeaders) {\n-                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n-                final HttpStatus status = headers.status();\n-                if (status.isInformational()) {\n-                    if (!sawLeadingHeaders) {\n-                        if (informationalHeadersBuilder == null) {\n-                            informationalHeadersBuilder = ImmutableList.builder();\n-                        }\n-                        informationalHeadersBuilder.add(headers);\n-                    }\n-                    upstream.request(1);\n-                } else {\n-                    sawLeadingHeaders = true;\n-                    completeInformationHeaders();\n-                    completeHeaders(headers);\n-                }\n-                return;\n-            }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n-\n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n-            }\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                cause = t;\n-            } else {\n-                downstream.onError(t);\n-            }\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n-        }\n-\n-        private void maybeCompleteHeaders() {\n-            completeInformationHeaders();\n-            completeHeaders(HEADERS_WITH_UNKNOWN_STATUS);\n-            if (trailersFuture == null) {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this, null, EMPTY_TRAILERS);\n-            }\n-        }\n-    }\n-\n-    private static final class HeadersFuture<T> extends UnmodifiableFuture<T> {\n-        @Override\n-        protected void doComplete(@Nullable T value) {\n-            super.doComplete(value);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU2Nzk1MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481567951", "body": "Do we need `upstreamUpdater`? Can't we just use the `subscription`?", "bodyText": "Do we need upstreamUpdater? Can't we just use the subscription?", "bodyHTML": "<p dir=\"auto\">Do we need <code>upstreamUpdater</code>? Can't we just use the <code>subscription</code>?</p>", "author": "minwoox", "createdAt": "2020-09-02T02:32:03Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nindex db6c6ec66..97a0e0999 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -195,13 +193,12 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+            if (cancelCalled || upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n         }\n \n         @Override\n", "next_change": {"commit": "a0168fed0656db0477de77679f64adb69499d0e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nsimilarity index 64%\nrename from core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 97a0e0999..0639afc02 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -193,11 +192,15 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (cancelCalled || upstream != null) {\n+            if (upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n             upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n             subscription.request(pendingRequests);\n         }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\ndeleted file mode 100644\nindex db6c6ec66..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-\n-    static {\n-        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n-        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n-\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor executor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n-\n-        response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n-    }\n-\n-    @Override\n-    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n-        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n-        if (informationalHeadersFuture != null) {\n-            return informationalHeadersFuture;\n-        }\n-\n-        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.informationalHeadersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<HttpHeaders> trailers() {\n-        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.trailersFuture;\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        @Nullable\n-        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n-        @Nullable\n-        private Throwable cause;\n-        private boolean completing;\n-\n-        private boolean sawLeadingHeaders;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        volatile Subscription upstream;\n-        private volatile long pendingRequests;\n-        private volatile boolean cancelCalled;\n-\n-        private void setDownStream(Subscriber<? super HttpData> downstream) {\n-            try {\n-                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n-                    downstream.onSubscribe(NoopSubscription.get());\n-                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-                    return;\n-                }\n-                downstream.onSubscribe(this);\n-                if (cause != null) {\n-                    downstream.onError(cause);\n-                } else if (completing) {\n-                    downstream.onComplete();\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n-            maybeCompleteHeaders();\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n-        }\n-\n-        @Override\n-        public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n-            if (httpObject instanceof ResponseHeaders) {\n-                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n-                final HttpStatus status = headers.status();\n-                if (status.isInformational()) {\n-                    if (!sawLeadingHeaders) {\n-                        if (informationalHeadersBuilder == null) {\n-                            informationalHeadersBuilder = ImmutableList.builder();\n-                        }\n-                        informationalHeadersBuilder.add(headers);\n-                    }\n-                    upstream.request(1);\n-                } else {\n-                    sawLeadingHeaders = true;\n-                    completeInformationHeaders();\n-                    completeHeaders(headers);\n-                }\n-                return;\n-            }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n-\n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n-            }\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                cause = t;\n-            } else {\n-                downstream.onError(t);\n-            }\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n-        }\n-\n-        private void maybeCompleteHeaders() {\n-            completeInformationHeaders();\n-            completeHeaders(HEADERS_WITH_UNKNOWN_STATUS);\n-            if (trailersFuture == null) {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this, null, EMPTY_TRAILERS);\n-            }\n-        }\n-    }\n-\n-    private static final class HeadersFuture<T> extends UnmodifiableFuture<T> {\n-        @Override\n-        protected void doComplete(@Nullable T value) {\n-            super.doComplete(value);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481571580", "body": "I think there's a race with the `request` method.\r\nFor example:\r\n- A thread is in the line between 215 and 216\r\n- B thread calls `subscription.request(pendingRequests);`\r\n- A thread does `pendingRequests = LongMath.saturatedAdd(n, pendingRequests);` ", "bodyText": "I think there's a race with the request method.\nFor example:\n\nA thread is in the line between 215 and 216\nB thread calls subscription.request(pendingRequests);\nA thread does pendingRequests = LongMath.saturatedAdd(n, pendingRequests);", "bodyHTML": "<p dir=\"auto\">I think there's a race with the <code>request</code> method.<br>\nFor example:</p>\n<ul dir=\"auto\">\n<li>A thread is in the line between 215 and 216</li>\n<li>B thread calls <code>subscription.request(pendingRequests);</code></li>\n<li>A thread does <code>pendingRequests = LongMath.saturatedAdd(n, pendingRequests);</code></li>\n</ul>", "author": "minwoox", "createdAt": "2020-09-02T02:37:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            if (pendingRequests != 0) {", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MjE4Mw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481572183", "bodyText": "How about just using the single thread to avoid this problem?", "author": "minwoox", "createdAt": "2020-09-02T02:38:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY1NTU3OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481655578", "bodyText": "How about just using the single thread to avoid this problem?\n\nThat's sounds good. It is no additional threading because the upstream.request() already is executed subscription.executor().", "author": "ikhoon", "createdAt": "2020-09-02T04:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MTU4MA=="}], "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nindex db6c6ec66..97a0e0999 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -195,13 +193,12 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+            if (cancelCalled || upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n         }\n \n         @Override\n", "next_change": {"commit": "a0168fed0656db0477de77679f64adb69499d0e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nsimilarity index 64%\nrename from core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 97a0e0999..0639afc02 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -193,11 +192,15 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (cancelCalled || upstream != null) {\n+            if (upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n             upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n             subscription.request(pendingRequests);\n         }\n \n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\ndeleted file mode 100644\nindex db6c6ec66..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-\n-    static {\n-        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n-        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n-\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor executor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n-\n-        response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n-    }\n-\n-    @Override\n-    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n-        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n-        if (informationalHeadersFuture != null) {\n-            return informationalHeadersFuture;\n-        }\n-\n-        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.informationalHeadersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<HttpHeaders> trailers() {\n-        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.trailersFuture;\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        @Nullable\n-        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n-        @Nullable\n-        private Throwable cause;\n-        private boolean completing;\n-\n-        private boolean sawLeadingHeaders;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        volatile Subscription upstream;\n-        private volatile long pendingRequests;\n-        private volatile boolean cancelCalled;\n-\n-        private void setDownStream(Subscriber<? super HttpData> downstream) {\n-            try {\n-                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n-                    downstream.onSubscribe(NoopSubscription.get());\n-                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-                    return;\n-                }\n-                downstream.onSubscribe(this);\n-                if (cause != null) {\n-                    downstream.onError(cause);\n-                } else if (completing) {\n-                    downstream.onComplete();\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n-            maybeCompleteHeaders();\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n-        }\n-\n-        @Override\n-        public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n-            if (httpObject instanceof ResponseHeaders) {\n-                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n-                final HttpStatus status = headers.status();\n-                if (status.isInformational()) {\n-                    if (!sawLeadingHeaders) {\n-                        if (informationalHeadersBuilder == null) {\n-                            informationalHeadersBuilder = ImmutableList.builder();\n-                        }\n-                        informationalHeadersBuilder.add(headers);\n-                    }\n-                    upstream.request(1);\n-                } else {\n-                    sawLeadingHeaders = true;\n-                    completeInformationHeaders();\n-                    completeHeaders(headers);\n-                }\n-                return;\n-            }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n-\n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n-            }\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                cause = t;\n-            } else {\n-                downstream.onError(t);\n-            }\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n-        }\n-\n-        private void maybeCompleteHeaders() {\n-            completeInformationHeaders();\n-            completeHeaders(HEADERS_WITH_UNKNOWN_STATUS);\n-            if (trailersFuture == null) {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this, null, EMPTY_TRAILERS);\n-            }\n-        }\n-    }\n-\n-    private static final class HeadersFuture<T> extends UnmodifiableFuture<T> {\n-        @Override\n-        protected void doComplete(@Nullable T value) {\n-            super.doComplete(value);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3MzE5OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r481573199", "body": "could assign `downstream` to a local variable so that we remove IntelliJ warning", "bodyText": "could assign downstream to a local variable so that we remove IntelliJ warning", "bodyHTML": "<p dir=\"auto\">could assign <code>downstream</code> to a local variable so that we remove IntelliJ warning</p>", "author": "minwoox", "createdAt": "2020-09-02T02:40:16Z", "path": "core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n+\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n+                                  SubscriptionOption... options) {\n+        requireNonNull(response, \"response\");\n+        this.response = response;\n+        this.executor = executor;\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+        // Prefetch headers\n+        bodySubscriber.request(1);\n+    }\n+\n+    @Override\n+    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+        private boolean completing;\n+\n+        private boolean sawLeadingHeaders;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        volatile Subscription upstream;\n+        private volatile long pendingRequests;\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            if (pendingRequests != 0) {\n+                subscription.request(pendingRequests);\n+            }\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders();\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    if (!sawLeadingHeaders) {\n+                        if (informationalHeadersBuilder == null) {\n+                            informationalHeadersBuilder = ImmutableList.builder();\n+                        }\n+                        informationalHeadersBuilder.add(headers);\n+                    }\n+                    upstream.request(1);\n+                } else {\n+                    sawLeadingHeaders = true;\n+                    completeInformationHeaders();\n+                    completeHeaders(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            assert downstream != null;", "originalCommit": "f5875796ff63163a414888d58b132b494bcf1555", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1701763f874be6949c4b8f78b289206e316b6f0e", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nindex db6c6ec66..97a0e0999 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n", "chunk": "@@ -261,6 +267,7 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n                 return;\n             }\n \n+            final Subscriber<? super HttpData> downstream = this.downstream;\n             assert downstream != null;\n             assert httpObject instanceof HttpData;\n             final HttpData data = (HttpData) httpObject;\n", "next_change": {"commit": "c7e887d681cf03a9372ea3de830d602776fc1064", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nsimilarity index 66%\nrename from core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 97a0e0999..57daadad2 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -275,64 +266,38 @@ final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n             downstream.onNext(data);\n         }\n \n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n         /**\n          * Completes the specified trailers.\n          */\n         private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n+            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n             if (trailersFuture != null) {\n                 trailersFuture.doComplete(trailers);\n+                return;\n+            }\n+\n+            trailersFuture = new HeadersFuture<>();\n+            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n+                trailersFuture.doComplete(trailers);\n             } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n+                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n             }\n         }\n \n         @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n+        public void onError(Throwable cause) {\n+            maybeCompleteHeaders(cause);\n             final Subscriber<? super HttpData> downstream = this.downstream;\n             if (downstream == null) {\n-                cause = t;\n+                this.cause = cause;\n             } else {\n-                downstream.onError(t);\n+                downstream.onError(cause);\n             }\n         }\n \n         @Override\n         public void onComplete() {\n-            maybeCompleteHeaders();\n+            maybeCompleteHeaders(null);\n             final Subscriber<? super HttpData> downstream = this.downstream;\n             if (downstream == null) {\n                 completing = true;\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\ndeleted file mode 100644\nindex db6c6ec66..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/DefaultHttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,352 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n-\n-import org.reactivestreams.Subscriber;\n-import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import com.google.common.collect.ImmutableList;\n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-final class DefaultHttpResponseBodyStream implements HttpResponseBodyStream {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultHttpResponseBodyStream.class);\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscription> upstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscription.class, \"upstream\");\n-\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-\n-    static {\n-        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n-        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n-\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"informationalHeadersFuture\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultHttpResponseBodyStream, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultHttpResponseBodyStream.class, HeadersFuture.class, \"trailersFuture\");\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor executor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    DefaultHttpResponseBodyStream(HttpResponse response, EventExecutor executor,\n-                                  SubscriptionOption... options) {\n-        requireNonNull(response, \"response\");\n-        this.response = response;\n-        this.executor = executor;\n-\n-        response.subscribe(bodySubscriber, executor, options);\n-        // Prefetch headers\n-        bodySubscriber.request(1);\n-    }\n-\n-    @Override\n-    public CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n-        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n-        if (informationalHeadersFuture != null) {\n-            return informationalHeadersFuture;\n-        }\n-\n-        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.informationalHeadersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public CompletableFuture<HttpHeaders> trailers() {\n-        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n-        return this.trailersFuture;\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n-\n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n-    }\n-\n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        @Nullable\n-        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n-        @Nullable\n-        private Throwable cause;\n-        private boolean completing;\n-\n-        private boolean sawLeadingHeaders;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        volatile Subscription upstream;\n-        private volatile long pendingRequests;\n-        private volatile boolean cancelCalled;\n-\n-        private void setDownStream(Subscriber<? super HttpData> downstream) {\n-            try {\n-                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n-                    downstream.onSubscribe(NoopSubscription.get());\n-                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-                    return;\n-                }\n-                downstream.onSubscribe(this);\n-                if (cause != null) {\n-                    downstream.onError(cause);\n-                } else if (completing) {\n-                    downstream.onComplete();\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (!upstreamUpdater.compareAndSet(this, null, subscription) || cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            if (pendingRequests != 0) {\n-                subscription.request(pendingRequests);\n-            }\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n-            maybeCompleteHeaders();\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n-        }\n-\n-        @Override\n-        public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n-            if (httpObject instanceof ResponseHeaders) {\n-                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n-                final HttpStatus status = headers.status();\n-                if (status.isInformational()) {\n-                    if (!sawLeadingHeaders) {\n-                        if (informationalHeadersBuilder == null) {\n-                            informationalHeadersBuilder = ImmutableList.builder();\n-                        }\n-                        informationalHeadersBuilder.add(headers);\n-                    }\n-                    upstream.request(1);\n-                } else {\n-                    sawLeadingHeaders = true;\n-                    completeInformationHeaders();\n-                    completeHeaders(headers);\n-                }\n-                return;\n-            }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n-\n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultHttpResponseBodyStream.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n-            }\n-        }\n-\n-        /**\n-         * Completes the specified non-informational headers.\n-         */\n-        private void completeHeaders(ResponseHeaders headers) {\n-            if (headersFuture.isDone()) {\n-                return;\n-            }\n-\n-            headersFuture.doComplete(headers);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultHttpResponseBodyStream.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this,\n-                                                    null, new HeadersFuture<>());\n-                DefaultHttpResponseBodyStream.this.trailersFuture.doComplete(trailers);\n-            }\n-        }\n-\n-        @Override\n-        public void onError(Throwable t) {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                cause = t;\n-            } else {\n-                downstream.onError(t);\n-            }\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders();\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n-        }\n-\n-        private void maybeCompleteHeaders() {\n-            completeInformationHeaders();\n-            completeHeaders(HEADERS_WITH_UNKNOWN_STATUS);\n-            if (trailersFuture == null) {\n-                trailersFutureUpdater.compareAndSet(DefaultHttpResponseBodyStream.this, null, EMPTY_TRAILERS);\n-            }\n-        }\n-    }\n-\n-    private static final class HeadersFuture<T> extends UnmodifiableFuture<T> {\n-        @Override\n-        protected void doComplete(@Nullable T value) {\n-            super.doComplete(value);\n-        }\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"oid": "1701763f874be6949c4b8f78b289206e316b6f0e", "url": "https://github.com/line/armeria/commit/1701763f874be6949c4b8f78b289206e316b6f0e", "message": "Address comments by @minwoox", "committedDate": "2020-09-02T04:38:01Z", "type": "commit"}, {"oid": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "url": "https://github.com/line/armeria/commit/7b997183b9cdf9b878a0c247c02ab2f3720b074d", "message": "Migrate ArmeriaHttpClientResponseSubscriber to ArmeriaHttpResponseBodyStream", "committedDate": "2020-09-02T09:25:32Z", "type": "commit"}, {"oid": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "url": "https://github.com/line/armeria/commit/7b997183b9cdf9b878a0c247c02ab2f3720b074d", "message": "Migrate ArmeriaHttpClientResponseSubscriber to ArmeriaHttpResponseBodyStream", "committedDate": "2020-09-02T09:25:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNDEyOA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484204128", "body": "which completes -> that is completed with  (ditto for all Javadoc comments in this pull request)", "bodyText": "which completes -> that is completed with  (ditto for all Javadoc comments in this pull request)", "bodyHTML": "<p dir=\"auto\">which completes -&gt; that is completed with  (ditto for all Javadoc comments in this pull request)</p>", "author": "trustin", "createdAt": "2020-09-07T06:18:44Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.", "originalCommit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNzQ0NQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484207445", "bodyText": "'that is' could be omitted.", "author": "trustin", "createdAt": "2020-09-07T06:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNDEyOA=="}], "type": "inlineReview", "revised_code": {"commit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 66964a593..a7dc57810 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -19,45 +19,39 @@ package com.linecorp.armeria.common;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-import org.reactivestreams.Subscriber;\n+import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n \n /**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n  * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n  * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n  */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+public interface SplitHttpResponse {\n+\n     /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n+     * Returns a {@link CompletableFuture} completed with a list of\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n      * </a> {@link ResponseHeaders}.\n      */\n     CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n      */\n-    CompletableFuture<HttpHeaders> trailers();\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n \n     /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n+    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\ndeleted file mode 100644\nindex 66964a593..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-\n-import org.reactivestreams.Subscriber;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-/**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n- */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n-\n-    /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n-     */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDIwNTQ3OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r484205478", "body": "If this is the case, how about making `toBodyStream` return a tuple of `(CompletableFuture<informational headers>, CompletableFuture<headers>, `StreamMessage<HttpData>`, CompletableFuture<trailers>)`, for reduced ambiguity? (We'll have to rename `toBodyStream()` and `HttpResponseBodyStream` into something else, though.)", "bodyText": "If this is the case, how about making toBodyStream return a tuple of (CompletableFuture<informational headers>, CompletableFuture<headers>, StreamMessage, CompletableFuture<trailers>), for reduced ambiguity? (We'll have to rename toBodyStream() and HttpResponseBodyStream into something else, though.)", "bodyHTML": "<p dir=\"auto\">If this is the case, how about making <code>toBodyStream</code> return a tuple of <code>(CompletableFuture&lt;informational headers&gt;, CompletableFuture&lt;headers&gt;, </code>StreamMessage<code>, CompletableFuture&lt;trailers&gt;)</code>, for reduced ambiguity? (We'll have to rename <code>toBodyStream()</code> and <code>HttpResponseBodyStream</code> into something else, though.)</p>", "author": "trustin", "createdAt": "2020-09-07T06:22:33Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+/**\n+ * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n+     * an {@linkplain HttpHeaders#of() empty headers}.\n+     */\n+    CompletableFuture<HttpHeaders> trailers();\n+\n+    /**\n+     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n+     * instead.\n+     */\n+    @Override\n+    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                           SubscriptionOption... options) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");", "originalCommit": "7b997183b9cdf9b878a0c247c02ab2f3720b074d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nsimilarity index 57%\nrename from core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\nrename to core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 66964a593..a7dc57810 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -19,45 +19,39 @@ package com.linecorp.armeria.common;\n import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-import org.reactivestreams.Subscriber;\n+import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n \n /**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n  * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n  * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n  */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n+public interface SplitHttpResponse {\n+\n     /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n+     * Returns a {@link CompletableFuture} completed with a list of\n      * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n      * </a> {@link ResponseHeaders}.\n      */\n     CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n \n     /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n      */\n-    CompletableFuture<HttpHeaders> trailers();\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n \n     /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n+    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\ndeleted file mode 100644\nindex 66964a593..000000000\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponseBodyStream.java\n+++ /dev/null\n", "chunk": "@@ -1,63 +0,0 @@\n-/*\n- * Copyright 2020 LINE Corporation\n- *\n- * LINE Corporation licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   https://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package com.linecorp.armeria.common;\n-\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-\n-import org.reactivestreams.Subscriber;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-\n-import io.netty.util.concurrent.EventExecutor;\n-\n-/**\n- * An HTTP response body stream which publishes HTTP payloads as a stream of {@link HttpData}.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n- */\n-public interface HttpResponseBodyStream extends StreamMessage<HttpData> {\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a non-informational {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} which completes a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will complete\n-     * an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n-\n-    /**\n-     * Unsupported operation, use {@link HttpResponse#toBodyStream(EventExecutor, SubscriptionOption...)}\n-     * instead.\n-     */\n-    @Override\n-    default void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                           SubscriptionOption... options) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.toBodyStream(executor, options)' instead\");\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}]}, {"oid": "f10eb5060b5e0594bc9e29029bdc50802dd37587", "url": "https://github.com/line/armeria/commit/f10eb5060b5e0594bc9e29029bdc50802dd37587", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-09-09T08:14:39Z", "type": "commit"}, {"oid": "b32036ba629320db66f2109ec3a38ce32c1a7615", "url": "https://github.com/line/armeria/commit/b32036ba629320db66f2109ec3a38ce32c1a7615", "message": "Address comments by @trustin / Need more ideas for method and class name", "committedDate": "2020-09-09T14:49:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NzYwNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r485997605", "body": "nit: an HttpResponse", "bodyText": "nit: an HttpResponse", "bodyHTML": "<p dir=\"auto\">nit: an HttpResponse</p>", "author": "minwoox", "createdAt": "2020-09-10T00:44:35Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface SplitHttpResponse {\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<ResponseHeaders> headers();\n+\n+    /**\n+     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n+     */\n+    @CheckReturnValue\n+    StreamMessage<HttpData> body();\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n+     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex a7dc57810..0cfcf9f71 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -50,7 +50,7 @@ public interface SplitHttpResponse {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n      * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n     CompletableFuture<HttpHeaders> trailers();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex a7dc57810..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -50,7 +49,7 @@ public interface SplitHttpResponse {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If a {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n+     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n      * completed with an {@linkplain HttpHeaders#of() empty headers}.\n      */\n     CompletableFuture<HttpHeaders> trailers();\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex b3e7cc1b9..365fb2a98 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -20,37 +20,19 @@ import java.util.concurrent.CompletableFuture;\n \n import org.reactivestreams.Subscriber;\n \n-import com.google.errorprone.annotations.CheckReturnValue;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-\n /**\n  * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n  * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n- * {@link #trailers()} might not complete until the entire response body is consumed completely.\n  *\n  * <p>Note that\n  * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n  * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n  * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n-public interface SplitHttpResponse {\n+public interface SplitHttpResponse extends SplitHttpMessage {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n-     */\n-    @CheckReturnValue\n-    StreamMessage<HttpData> body();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n-     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwMDE4MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486000181", "body": "If so, how about rasing an exception?", "bodyText": "If so, how about rasing an exception?", "bodyHTML": "<p dir=\"auto\">If so, how about rasing an exception?</p>", "author": "minwoox", "createdAt": "2020-09-10T00:54:20Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 00ff538b9..c9284e049 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -159,8 +167,7 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n                           SubscriptionOption... unused) {\n-        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.\n-        subscribe(subscriber, executor);\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n     }\n \n     @Override\n", "next_change": {"commit": "2f5a5791685d692b512407a8c38fc2c416ab7767", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex c9284e049..858d93d5a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -155,19 +127,28 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n+        subscribe(subscriber, executor, EMPTY_OPTIONS);\n     }\n \n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... unused) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+                          SubscriptionOption... options) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(options, \"options\");\n+\n+        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n+            subscriber.onSubscribe(NoopSubscription.get());\n+            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+            return;\n+        }\n+\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.initDownstream(subscriber, executor, options);\n+        } else {\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n+        }\n     }\n \n     @Override\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 00ff538b9..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -147,20 +128,28 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n+        subscribe(subscriber, executor, EMPTY_OPTIONS);\n     }\n \n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... unused) {\n-        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.\n-        subscribe(subscriber, executor);\n+                          SubscriptionOption... options) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(options, \"options\");\n+\n+        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n+            subscriber.onSubscribe(NoopSubscription.get());\n+            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+            return;\n+        }\n+\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.initDownstream(subscriber, executor, options);\n+        } else {\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,252 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n \n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n-\n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n-\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n-\n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n \n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNTcxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486005714", "body": "How about creating `HeadersFuture` first and complete it if this CAS succeeds?", "bodyText": "How about creating HeadersFuture first and complete it if this CAS succeeds?", "bodyHTML": "<p dir=\"auto\">How about creating <code>HeadersFuture</code> first and complete it if this CAS succeeds?</p>", "author": "minwoox", "createdAt": "2020-09-10T01:15:18Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            informationalHeadersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"informationalHeadersFuture\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<List<ResponseHeaders>> EMPTY_INFORMATIONAL_HEADERS;\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_INFORMATIONAL_HEADERS = new HeadersFuture<>();\n+        EMPTY_INFORMATIONAL_HEADERS.doComplete(ImmutableList.of());\n+\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture;\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<List<ResponseHeaders>> informationalHeaders() {\n+        final HeadersFuture<List<ResponseHeaders>> informationalHeadersFuture = this.informationalHeadersFuture;\n+        if (informationalHeadersFuture != null) {\n+            return informationalHeadersFuture;\n+        }\n+\n+        informationalHeadersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.informationalHeadersFuture;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        final HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFutureUpdater.compareAndSet(this, null, new HeadersFuture<>());\n+        return this.trailersFuture;\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        // 'SubscriptionOption's are ignored, should specify the 'SubscriptionOption's when creating this class.\n+        subscribe(subscriber, executor);\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private ImmutableList.Builder<ResponseHeaders> informationalHeadersBuilder;\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        private boolean sawLeadingHeaders;\n+\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    if (!sawLeadingHeaders) {\n+                        if (informationalHeadersBuilder == null) {\n+                            informationalHeadersBuilder = ImmutableList.builder();\n+                        }\n+                        informationalHeadersBuilder.add(headers);\n+                    }\n+                    upstream.request(1);\n+                } else {\n+                    sawLeadingHeaders = true;\n+                    completeInformationHeaders();\n+                    headersFuture.doComplete(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            assert downstream != null;\n+            assert httpObject instanceof HttpData;\n+            final HttpData data = (HttpData) httpObject;\n+            wroteAny = true;\n+            downstream.onNext(data);\n+        }\n+\n+        /**\n+         * Completes informational headers received so far.\n+         */\n+        private void completeInformationHeaders() {\n+            if (informationalHeadersBuilder == null) {\n+                if (!informationalHeadersFutureUpdater\n+                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n+                                       EMPTY_INFORMATIONAL_HEADERS)) {\n+                    informationalHeadersFuture.doComplete(ImmutableList.of());\n+                }\n+            } else {\n+                informationalHeadersFutureUpdater", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 00ff538b9..c9284e049 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -308,10 +315,20 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                     informationalHeadersFuture.doComplete(ImmutableList.of());\n                 }\n             } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n+                final List<ResponseHeaders> informationalHeaders = informationalHeadersBuilder.build();\n+                HeadersFuture<List<ResponseHeaders>> headersFuture = informationalHeadersFuture;\n+                if (headersFuture != null) {\n+                    headersFuture.doComplete(informationalHeaders);\n+                    return;\n+                }\n+\n+                headersFuture = new HeadersFuture<>();\n+                if (informationalHeadersFutureUpdater\n+                        .compareAndSet(DefaultSplitHttpResponse.this, null, headersFuture)) {\n+                    headersFuture.doComplete(informationalHeaders);\n+                } else {\n+                    informationalHeadersFuture.doComplete(informationalHeaders);\n+                }\n             }\n         }\n \n", "next_change": {"commit": "c7e887d681cf03a9372ea3de830d602776fc1064", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex c9284e049..57daadad2 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -304,34 +266,6 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n             downstream.onNext(data);\n         }\n \n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n-            } else {\n-                final List<ResponseHeaders> informationalHeaders = informationalHeadersBuilder.build();\n-                HeadersFuture<List<ResponseHeaders>> headersFuture = informationalHeadersFuture;\n-                if (headersFuture != null) {\n-                    headersFuture.doComplete(informationalHeaders);\n-                    return;\n-                }\n-\n-                headersFuture = new HeadersFuture<>();\n-                if (informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultSplitHttpResponse.this, null, headersFuture)) {\n-                    headersFuture.doComplete(informationalHeaders);\n-                } else {\n-                    informationalHeadersFuture.doComplete(informationalHeaders);\n-                }\n-            }\n-        }\n-\n         /**\n          * Completes the specified trailers.\n          */\n", "next_change": {"commit": "2f5a5791685d692b512407a8c38fc2c416ab7767", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 57daadad2..858d93d5a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -261,9 +286,23 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n             final Subscriber<? super HttpData> downstream = this.downstream;\n             assert downstream != null;\n             assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n+\n+            final EventExecutor executor = this.executor;\n+            if (executor.inEventLoop()) {\n+                onNext0((HttpData) httpObject);\n+            } else {\n+                executor.execute(() ->onNext0((HttpData) httpObject));\n+            }\n+        }\n+\n+        private void onNext0(HttpData httpData) {\n             wroteAny = true;\n-            downstream.onNext(data);\n+            if (!usePooledObject) {\n+                try (HttpData pooled = httpData) {\n+                    httpData = HttpData.wrap(pooled.array());\n+                }\n+            }\n+            downstream.onNext(httpData);\n         }\n \n         /**\n", "next_change": {"commit": "bfc30e38c80f9534e16473d7eb65196cabe0d360", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 858d93d5a..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -291,16 +292,14 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n             if (executor.inEventLoop()) {\n                 onNext0((HttpData) httpObject);\n             } else {\n-                executor.execute(() ->onNext0((HttpData) httpObject));\n+                executor.execute(() -> onNext0((HttpData) httpObject));\n             }\n         }\n \n         private void onNext0(HttpData httpData) {\n             wroteAny = true;\n             if (!usePooledObject) {\n-                try (HttpData pooled = httpData) {\n-                    httpData = HttpData.wrap(pooled.array());\n-                }\n+                httpData = PooledObjects.copyAndClose(httpData);\n             }\n             downstream.onNext(httpData);\n         }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 00ff538b9..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -292,40 +287,37 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n             final Subscriber<? super HttpData> downstream = this.downstream;\n             assert downstream != null;\n             assert httpObject instanceof HttpData;\n-            final HttpData data = (HttpData) httpObject;\n-            wroteAny = true;\n-            downstream.onNext(data);\n-        }\n \n-        /**\n-         * Completes informational headers received so far.\n-         */\n-        private void completeInformationHeaders() {\n-            if (informationalHeadersBuilder == null) {\n-                if (!informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n-                                       EMPTY_INFORMATIONAL_HEADERS)) {\n-                    informationalHeadersFuture.doComplete(ImmutableList.of());\n-                }\n+            final EventExecutor executor = this.executor;\n+            if (executor.inEventLoop()) {\n+                onNext0((HttpData) httpObject);\n             } else {\n-                informationalHeadersFutureUpdater\n-                        .compareAndSet(DefaultSplitHttpResponse.this, null,\n-                                       new HeadersFuture<>());\n-                informationalHeadersFuture.doComplete(informationalHeadersBuilder.build());\n+                executor.execute(() -> onNext0((HttpData) httpObject));\n+            }\n+        }\n+\n+        private void onNext0(HttpData httpData) {\n+            wroteAny = true;\n+            if (!usePooledObject) {\n+                httpData = PooledObjects.copyAndClose(httpData);\n             }\n+            downstream.onNext(httpData);\n         }\n \n         /**\n          * Completes the specified trailers.\n          */\n         private void completeTrailers(HttpHeaders trailers) {\n-            final HeadersFuture<HttpHeaders> trailersFuture =\n-                    DefaultSplitHttpResponse.this.trailersFuture;\n+            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n             if (trailersFuture != null) {\n                 trailersFuture.doComplete(trailers);\n+                return;\n+            }\n+\n+            trailersFuture = new HeadersFuture<>();\n+            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n+                trailersFuture.doComplete(trailers);\n             } else {\n-                trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this,\n-                                                    null, new HeadersFuture<>());\n                 DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n             }\n         }\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -271,102 +71,19 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 final HttpStatus status = headers.status();\n                 if (status.isInformational()) {\n                     // Ignore informational headers\n+                    final Subscription upstream = upstream();\n+                    assert upstream != null;\n                     upstream.request(1);\n                 } else {\n                     headersFuture.doComplete(headers);\n                 }\n                 return;\n             }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-\n-            final EventExecutor executor = this.executor;\n-            if (executor.inEventLoop()) {\n-                onNext0((HttpData) httpObject);\n-            } else {\n-                executor.execute(() -> onNext0((HttpData) httpObject));\n-            }\n-        }\n-\n-        private void onNext0(HttpData httpData) {\n-            wroteAny = true;\n-            if (!usePooledObject) {\n-                httpData = PooledObjects.copyAndClose(httpData);\n-            }\n-            downstream.onNext(httpData);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-                return;\n-            }\n-\n-            trailersFuture = new HeadersFuture<>();\n-            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n-            }\n+            super.onNext(httpObject);\n         }\n \n         @Override\n-        public void onError(Throwable cause) {\n-            maybeCompleteHeaders(cause);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (executor == null || downstream == null) {\n-                this.cause = cause;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onError0(cause, downstream);\n-            } else {\n-                executor.execute(() -> onError0(cause, downstream));\n-            }\n-        }\n-\n-        private void onError0(Throwable cause, Subscriber<? super HttpData> downstream) {\n-            downstream.onError(cause);\n-            this.downstream = NoopSubscriber.get();\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders(null);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-\n-            if (executor == null || downstream == null) {\n-                completing = true;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onComplete0(downstream);\n-            } else {\n-                executor.execute(() -> onComplete0(downstream));\n-            }\n-        }\n-\n-        private void onComplete0(Subscriber<? super HttpData> downstream) {\n-            downstream.onComplete();\n-        }\n-\n-        private void maybeCompleteHeaders(@Nullable Throwable cause) {\n+        protected void doOnCompletion(@Nullable Throwable cause) {\n             if (!headersFuture.isDone()) {\n                 if (cause != null && !(cause instanceof CancelledSubscriptionException) &&\n                     !(cause instanceof AbortedStreamException)) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNjExNw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486006117", "body": "2020. \ud83e\udd23 ", "bodyText": "\ud83e\udd23", "bodyHTML": "<ol start=\"2020\" dir=\"auto\">\n<li><g-emoji class=\"g-emoji\" alias=\"rofl\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f923.png\">\ud83e\udd23</g-emoji></li>\n</ol>", "author": "minwoox", "createdAt": "2020-09-10T01:16:59Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2018 LINE Corporation", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\nindex 63037304b..785e5866c 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n", "chunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 LINE Corporation\n+ * Copyright 2020 LINE Corporation\n  *\n  * LINE Corporation licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\nindex 63037304b..785e5866c 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n", "chunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2018 LINE Corporation\n+ * Copyright 2020 LINE Corporation\n  *\n  * LINE Corporation licenses this file to you under the Apache License,\n  * version 2.0 (the \"License\"); you may not use this file except in compliance\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "57295d3ed82748dc6949f825910705a6c17d098f", "committedDate": "2023-03-28 18:18:16 +0900", "message": "Add Spring Boot 3 integration modules (#4574)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwNzA2Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486007066", "body": "We used CAS above but not here. I think we should use the same approach.", "bodyText": "We used CAS above but not here. I think we should use the same approach.", "bodyHTML": "<p dir=\"auto\">We used CAS above but not here. I think we should use the same approach.</p>", "author": "minwoox", "createdAt": "2020-09-10T01:20:27Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2018 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.spring.web.reactive;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.internal.common.DefaultSplitHttpResponse;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+import reactor.core.publisher.Mono;\n+\n+final class ArmeriaHttpResponseBodyStream extends DefaultSplitHttpResponse {\n+\n+    private static final AtomicIntegerFieldUpdater<ArmeriaHttpResponseBodyStream> subscribedUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(ArmeriaHttpResponseBodyStream.class, \"subscribed\");\n+\n+    private volatile int subscribed;\n+\n+    @Nullable\n+    private Publisher<HttpData> publisherForLateSubscribers;\n+\n+    ArmeriaHttpResponseBodyStream(HttpResponse httpResponse, EventExecutor executor) {\n+        super(httpResponse, executor);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> s) {\n+        if (subscribedUpdater.compareAndSet(this, 0, 1)) {\n+            // The first subscriber.\n+            super.subscribe(s);\n+        } else {\n+            // The other subscribers - notify whether completed successfully only.\n+            if (publisherForLateSubscribers == null) {\n+                @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+                final Publisher<HttpData> newPublisher =\n+                        (Publisher) Mono.fromFuture(whenComplete());\n+                publisherForLateSubscribers = newPublisher;", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\nindex 63037304b..785e5866c 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n", "chunk": "@@ -50,13 +55,20 @@ final class ArmeriaHttpResponseBodyStream extends DefaultSplitHttpResponse {\n             super.subscribe(s);\n         } else {\n             // The other subscribers - notify whether completed successfully only.\n-            if (publisherForLateSubscribers == null) {\n-                @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-                final Publisher<HttpData> newPublisher =\n-                        (Publisher) Mono.fromFuture(whenComplete());\n-                publisherForLateSubscribers = newPublisher;\n+            final Publisher<HttpData> publisherForLateSubscribers = this.publisherForLateSubscribers;\n+            if (publisherForLateSubscribers != null) {\n+                publisherForLateSubscribers.subscribe(s);\n+                return;\n+            }\n+\n+            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+            final Publisher<HttpData> newPublisher =\n+                    (Publisher) Mono.fromFuture(whenComplete());\n+            if (publisherForLateSubscribersUpdater.compareAndSet(this, null, newPublisher)) {\n+                newPublisher.subscribe(s);\n+            } else {\n+                this.publisherForLateSubscribers.subscribe(s);\n             }\n-            publisherForLateSubscribers.subscribe(s);\n         }\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\nindex 63037304b..785e5866c 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaHttpResponseBodyStream.java\n", "chunk": "@@ -50,13 +55,20 @@ final class ArmeriaHttpResponseBodyStream extends DefaultSplitHttpResponse {\n             super.subscribe(s);\n         } else {\n             // The other subscribers - notify whether completed successfully only.\n-            if (publisherForLateSubscribers == null) {\n-                @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-                final Publisher<HttpData> newPublisher =\n-                        (Publisher) Mono.fromFuture(whenComplete());\n-                publisherForLateSubscribers = newPublisher;\n+            final Publisher<HttpData> publisherForLateSubscribers = this.publisherForLateSubscribers;\n+            if (publisherForLateSubscribers != null) {\n+                publisherForLateSubscribers.subscribe(s);\n+                return;\n+            }\n+\n+            @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+            final Publisher<HttpData> newPublisher =\n+                    (Publisher) Mono.fromFuture(whenComplete());\n+            if (publisherForLateSubscribersUpdater.compareAndSet(this, null, newPublisher)) {\n+                newPublisher.subscribe(s);\n+            } else {\n+                this.publisherForLateSubscribers.subscribe(s);\n             }\n-            publisherForLateSubscribers.subscribe(s);\n         }\n     }\n }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "57295d3ed82748dc6949f825910705a6c17d098f", "committedDate": "2023-03-28 18:18:16 +0900", "message": "Add Spring Boot 3 integration modules (#4574)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwOTEzMw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r486009133", "body": "Can we use the eventLoop that is used for sending a request?\r\nIf not, how about just using `response.defaultSubscriberExecutor()` in `DefaultSplitHttpResponse`?", "bodyText": "Can we use the eventLoop that is used for sending a request?\nIf not, how about just using response.defaultSubscriberExecutor() in DefaultSplitHttpResponse?", "bodyHTML": "<p dir=\"auto\">Can we use the eventLoop that is used for sending a request?<br>\nIf not, how about just using <code>response.defaultSubscriberExecutor()</code> in <code>DefaultSplitHttpResponse</code>?</p>", "author": "minwoox", "createdAt": "2020-09-10T01:28:13Z", "path": "spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java", "diffHunk": "@@ -110,8 +109,10 @@ private ArmeriaClientHttpRequest createRequest(HttpMethod method, URI uri) {\n         return new ArmeriaClientHttpRequest(builder.build(), method, pathAndQuery, uri, factoryWrapper);\n     }\n \n-    private ArmeriaClientHttpResponse createResponse(ResponseHeaders headers,\n-                                                     ArmeriaHttpClientResponseSubscriber s) {\n-        return new ArmeriaClientHttpResponse(headers, s.toResponseBodyPublisher(), factoryWrapper);\n+    private CompletableFuture<ArmeriaClientHttpResponse> createResponse(HttpResponse response) {\n+        final ArmeriaHttpResponseBodyStream bodyStream =\n+                new ArmeriaHttpResponseBodyStream(response, CommonPools.workerGroup().next());", "originalCommit": "b32036ba629320db66f2109ec3a38ce32c1a7615", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyMzkwMA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r494123900", "bodyText": "It is difficult to capture or pass RequestContext at this point. Let me use response.defaultSubscriberExecutor() :-)", "author": "ikhoon", "createdAt": "2020-09-24T08:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwOTEzMw=="}], "type": "inlineReview", "revised_code": {"commit": "541878edafb7051422354f928f86484b9af83211", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\nindex 4889c0d39..ccb0042ee 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\n", "chunk": "@@ -111,7 +110,7 @@ final class ArmeriaClientHttpConnector implements ClientHttpConnector {\n \n     private CompletableFuture<ArmeriaClientHttpResponse> createResponse(HttpResponse response) {\n         final ArmeriaHttpResponseBodyStream bodyStream =\n-                new ArmeriaHttpResponseBodyStream(response, CommonPools.workerGroup().next());\n+                new ArmeriaHttpResponseBodyStream(response, response.defaultSubscriberExecutor());\n         return bodyStream.headers().thenApply(\n                 headers -> new ArmeriaClientHttpResponse(headers, bodyStream, factoryWrapper));\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\nindex 4889c0d39..ccb0042ee 100644\n--- a/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\n+++ b/spring/boot2-webflux-autoconfigure/src/main/java/com/linecorp/armeria/spring/web/reactive/ArmeriaClientHttpConnector.java\n", "chunk": "@@ -111,7 +110,7 @@ final class ArmeriaClientHttpConnector implements ClientHttpConnector {\n \n     private CompletableFuture<ArmeriaClientHttpResponse> createResponse(HttpResponse response) {\n         final ArmeriaHttpResponseBodyStream bodyStream =\n-                new ArmeriaHttpResponseBodyStream(response, CommonPools.workerGroup().next());\n+                new ArmeriaHttpResponseBodyStream(response, response.defaultSubscriberExecutor());\n         return bodyStream.headers().thenApply(\n                 headers -> new ArmeriaClientHttpResponse(headers, bodyStream, factoryWrapper));\n     }\n", "next_change": null}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "ccf630c417bc2f9f78a90bad53a999cc7aa46314", "committedDate": "2022-01-27 17:33:43 +0900", "message": "Provide a way to fluently convert an response with `WebClient` and add `BlockingWebClient` (#4021)"}, {"oid": "6004c5219493d960c20897f7d6b4848a0f0118de", "committedDate": "2022-06-01 22:28:50 +0900", "message": "Reuse armeria's WebClient instance when using the integration for Spring webflux's WebClient (#4240)"}, {"oid": "57295d3ed82748dc6949f825910705a6c17d098f", "committedDate": "2023-03-28 18:18:16 +0900", "message": "Add Spring Boot 3 integration modules (#4574)"}]}, {"oid": "030b0643f9005ca07c7e022a1f656f7c15b684fc", "url": "https://github.com/line/armeria/commit/030b0643f9005ca07c7e022a1f656f7c15b684fc", "message": "Address comments by @minwoox", "committedDate": "2020-09-10T06:57:06Z", "type": "commit"}, {"oid": "a00b2634f69360ae338dcea56812ff52da6fef54", "url": "https://github.com/line/armeria/commit/a00b2634f69360ae338dcea56812ff52da6fef54", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-09-24T08:12:20Z", "type": "commit"}, {"oid": "541878edafb7051422354f928f86484b9af83211", "url": "https://github.com/line/armeria/commit/541878edafb7051422354f928f86484b9af83211", "message": "Address comments by @minwoox", "committedDate": "2020-09-24T08:15:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTcxNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585714", "body": "```suggestion\r\n * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n          \n          \n            \n             * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">An</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">HttpResponse</span>} which splits a stream of {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">HttpObject</span>} into <span class=\"pl-c1\">HTTP</span> headers and payloads.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> <span class=\"pl-smi\">An</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">HttpResponse</span>} which splits a stream of {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">HttpObject</span>}<span class=\"x x-first x-last\">s</span> into <span class=\"pl-c1\">HTTP</span> headers and payloads.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "trustin", "createdAt": "2020-11-01T07:12:59Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7e887d681cf03a9372ea3de830d602776fc1064", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex b3e7cc1b9..365fb2a98 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -20,37 +20,19 @@ import java.util.concurrent.CompletableFuture;\n \n import org.reactivestreams.Subscriber;\n \n-import com.google.errorprone.annotations.CheckReturnValue;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-\n /**\n  * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n  * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n- * {@link #trailers()} might not complete until the entire response body is consumed completely.\n  *\n  * <p>Note that\n  * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n  * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n  * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n-public interface SplitHttpResponse {\n+public interface SplitHttpResponse extends SplitHttpMessage {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n-     */\n-    @CheckReturnValue\n-    StreamMessage<HttpData> body();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n-     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTc2Mg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585762", "body": "```suggestion\r\n * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first {@link HttpData}.\r\n * {@link #trailers()} might not complete until the response body is consumed completely.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n          \n          \n            \n             * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n          \n          \n            \n             * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first {@link HttpData}.\n          \n          \n            \n             * {@link #trailers()} might not complete until the response body is consumed completely.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> #informationalHeaders()}, {<span class=\"pl-k\">@link</span> #headers()} will be completed before publishing the first <span class=\"x x-first x-last\">element of</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"> <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi x x-first\">HttpData</span><span class=\"x\">}</span><span class=\"pl-c1 x\">.</span><span class=\"x\"> {</span><span class=\"pl-k x\">@link</span><span class=\"x x-last\"> </span>#trailers()} might not complete until the <span class=\"x x-first\">entire {</span><span class=\"pl-k x\">@link</span><span class=\"x\"> </span><span class=\"pl-smi x\">HttpData</span><span class=\"x x-last\">} has been </span>consumed.</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> #informationalHeaders()}, {<span class=\"pl-k\">@link</span> #headers()} will be completed before publishing the first <span class=\"x x-first\">{</span><span class=\"pl-k x\">@link</span><span class=\"x\"> </span><span class=\"pl-smi x\">HttpData</span><span class=\"x\">}</span><span class=\"pl-c1 x x-last\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\"> <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> #trailers()} might not complete until the <span class=\"x x-first x-last\">response body is </span>consumed<span class=\"x x-first x-last\"> completely</span>.</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "trustin", "createdAt": "2020-11-01T07:13:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c7e887d681cf03a9372ea3de830d602776fc1064", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex b3e7cc1b9..365fb2a98 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -20,37 +20,19 @@ import java.util.concurrent.CompletableFuture;\n \n import org.reactivestreams.Subscriber;\n \n-import com.google.errorprone.annotations.CheckReturnValue;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-\n /**\n  * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n  * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n- * {@link #trailers()} might not complete until the entire response body is consumed completely.\n  *\n  * <p>Note that\n  * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n  * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n  * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n-public interface SplitHttpResponse {\n+public interface SplitHttpResponse extends SplitHttpMessage {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n-     */\n-    @CheckReturnValue\n-    StreamMessage<HttpData> body();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n-     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTg2OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r515585869", "body": "I guess we have a chance of having too many informational headers in memory. `StreamMessage<ResponseHeaders>` might solve the memory usage issue, but it'll make this not very user-friendly. Should we just drop all informational headers for simplicity?", "bodyText": "I guess we have a chance of having too many informational headers in memory. StreamMessage<ResponseHeaders> might solve the memory usage issue, but it'll make this not very user-friendly. Should we just drop all informational headers for simplicity?", "bodyHTML": "<p dir=\"auto\">I guess we have a chance of having too many informational headers in memory. <code>StreamMessage&lt;ResponseHeaders&gt;</code> might solve the memory usage issue, but it'll make this not very user-friendly. Should we just drop all informational headers for simplicity?</p>", "author": "trustin", "createdAt": "2020-11-01T07:14:43Z", "path": "core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.common;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+import com.google.errorprone.annotations.CheckReturnValue;\n+\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+\n+/**\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n+ * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n+ * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ */\n+public interface SplitHttpResponse {\n+\n+    /**\n+     * Returns a {@link CompletableFuture} completed with a list of\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+     * </a> {@link ResponseHeaders}.\n+     */\n+    CompletableFuture<List<ResponseHeaders>> informationalHeaders();", "originalCommit": "541878edafb7051422354f928f86484b9af83211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjcxODk2OA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r516718968", "bodyText": "Agreed. Most users are not interested in informational headers and if many informational headers are sent, List will grow infinitely.", "author": "ikhoon", "createdAt": "2020-11-03T14:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU4NTg2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c7e887d681cf03a9372ea3de830d602776fc1064", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex 0cfcf9f71..b3e7cc1b9 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -16,27 +16,26 @@\n \n package com.linecorp.armeria.common;\n \n-import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n+import org.reactivestreams.Subscriber;\n+\n import com.google.errorprone.annotations.CheckReturnValue;\n \n import com.linecorp.armeria.common.stream.StreamMessage;\n \n /**\n- * An {@link HttpResponse} which splits a stream of {@link HttpObject} into HTTP headers and payloads.\n- * {@link #informationalHeaders()}, {@link #headers()} will be completed before publishing the first element of\n- * {@link HttpData}. {@link #trailers()} might not complete until the entire {@link HttpData} has been consumed.\n+ * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n+ * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n+ * {@link #trailers()} might not complete until the entire response body is consumed completely.\n+ *\n+ * <p>Note that\n+ * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n+ * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n+ * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n public interface SplitHttpResponse {\n \n-    /**\n-     * Returns a {@link CompletableFuture} completed with a list of\n-     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n-     * </a> {@link ResponseHeaders}.\n-     */\n-    CompletableFuture<List<ResponseHeaders>> informationalHeaders();\n-\n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\nindex b3e7cc1b9..365fb2a98 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/SplitHttpResponse.java\n", "chunk": "@@ -20,37 +20,19 @@ import java.util.concurrent.CompletableFuture;\n \n import org.reactivestreams.Subscriber;\n \n-import com.google.errorprone.annotations.CheckReturnValue;\n-\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-\n /**\n  * An {@link HttpResponse} which splits a stream of {@link HttpObject}s into HTTP headers and payloads.\n  * {@link #headers()} will be completed before publishing the first {@link HttpData}.\n- * {@link #trailers()} might not complete until the entire response body is consumed completely.\n  *\n  * <p>Note that\n  * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational\n  * headers</a> are not collected by this {@link HttpResponse}. If you want to get informational headers,\n  * use {@link HttpResponse#subscribe(Subscriber)} instead.\n  */\n-public interface SplitHttpResponse {\n+public interface SplitHttpResponse extends SplitHttpMessage {\n \n     /**\n      * Returns a {@link CompletableFuture} completed with a non-informational {@link ResponseHeaders}.\n      */\n     CompletableFuture<ResponseHeaders> headers();\n-\n-    /**\n-     * Returns a {@link StreamMessage} publishes HTTP payloads as a stream of {@link HttpData}.\n-     */\n-    @CheckReturnValue\n-    StreamMessage<HttpData> body();\n-\n-    /**\n-     * Returns a {@link CompletableFuture} completed with a {@linkplain HttpHeaders trailers}.\n-     * If an {@link HttpResponse} does not contain trailers, the returned {@link CompletableFuture} will be\n-     * completed with an {@linkplain HttpHeaders#of() empty headers}.\n-     */\n-    CompletableFuture<HttpHeaders> trailers();\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"oid": "00db4d7daa4d04ea464665349450273136ad47c3", "url": "https://github.com/line/armeria/commit/00db4d7daa4d04ea464665349450273136ad47c3", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-11-03T14:00:27Z", "type": "commit"}, {"oid": "c7e887d681cf03a9372ea3de830d602776fc1064", "url": "https://github.com/line/armeria/commit/c7e887d681cf03a9372ea3de830d602776fc1064", "message": "Remove informational headers", "committedDate": "2020-11-03T15:07:35Z", "type": "commit"}, {"oid": "e035b459759229f6365dc4f452c92a1fe29f482c", "url": "https://github.com/line/armeria/commit/e035b459759229f6365dc4f452c92a1fe29f482c", "message": "Clean up", "committedDate": "2020-11-03T15:20:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mzg5NA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517083894", "body": "If thread A stay here at line 196 and the thread B executes the line 227~236, the cancel event is gone.\r\nSo I think we should:\r\n```java\r\nif (upstream != null) {\r\n    subscription.cancel();\r\n    return;\r\n}\r\nupstream = subscription;\r\nif (cancelCalled) {\r\n    subscription.cancel();\r\n    return;\r\n}\r\n```", "bodyText": "If thread A stay here at line 196 and the thread B executes the line 227~236, the cancel event is gone.\nSo I think we should:\nif (upstream != null) {\n    subscription.cancel();\n    return;\n}\nupstream = subscription;\nif (cancelCalled) {\n    subscription.cancel();\n    return;\n}", "bodyHTML": "<p dir=\"auto\">If thread A stay here at line 196 and the thread B executes the line 227~236, the cancel event is gone.<br>\nSo I think we should:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if (upstream != null) {\n    subscription.cancel();\n    return;\n}\nupstream = subscription;\nif (cancelCalled) {\n    subscription.cancel();\n    return;\n}\n\"><pre><span class=\"pl-k\">if</span> (upstream <span class=\"pl-k\">!=</span> <span class=\"pl-c1\">null</span>) {\n    subscription<span class=\"pl-k\">.</span>cancel();\n    <span class=\"pl-k\">return</span>;\n}\nupstream <span class=\"pl-k\">=</span> subscription;\n<span class=\"pl-k\">if</span> (cancelCalled) {\n    subscription<span class=\"pl-k\">.</span>cancel();\n    <span class=\"pl-k\">return</span>;\n}</pre></div>", "author": "minwoox", "createdAt": "2020-11-04T03:54:50Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0168fed0656db0477de77679f64adb69499d0e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..0639afc02 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -190,11 +192,15 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (cancelCalled || upstream != null) {\n+            if (upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n             upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n             subscription.request(pendingRequests);\n         }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -190,11 +212,15 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n         @Override\n         public void onSubscribe(Subscription subscription) {\n             requireNonNull(subscription, \"subscription\");\n-            if (cancelCalled || upstream != null) {\n+            if (upstream != null) {\n                 subscription.cancel();\n                 return;\n             }\n             upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n             subscription.request(pendingRequests);\n         }\n \n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,252 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n \n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n-\n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n-\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n-\n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n \n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NDU0MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517084541", "body": "I think we can remove this line not to access the memory when the `httpObject` is not an instance of `ResponseHeaders`", "bodyText": "I think we can remove this line not to access the memory when the httpObject is not an instance of ResponseHeaders", "bodyHTML": "<p dir=\"auto\">I think we can remove this line not to access the memory when the <code>httpObject</code> is not an instance of <code>ResponseHeaders</code></p>", "author": "minwoox", "createdAt": "2020-11-04T03:57:53Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            final Subscription upstream = this.upstream;", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a0168fed0656db0477de77679f64adb69499d0e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..0639afc02 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -238,7 +246,6 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n \n         @Override\n         public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n             if (httpObject instanceof ResponseHeaders) {\n                 final ResponseHeaders headers = (ResponseHeaders) httpObject;\n                 final HttpStatus status = headers.status();\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -238,7 +266,6 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n \n         @Override\n         public void onNext(HttpObject httpObject) {\n-            final Subscription upstream = this.upstream;\n             if (httpObject instanceof ResponseHeaders) {\n                 final ResponseHeaders headers = (ResponseHeaders) httpObject;\n                 final HttpStatus status = headers.status();\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,252 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n \n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n-\n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n-\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n-\n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n \n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}, {"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -271,102 +71,19 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 final HttpStatus status = headers.status();\n                 if (status.isInformational()) {\n                     // Ignore informational headers\n+                    final Subscription upstream = upstream();\n+                    assert upstream != null;\n                     upstream.request(1);\n                 } else {\n                     headersFuture.doComplete(headers);\n                 }\n                 return;\n             }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-\n-            final EventExecutor executor = this.executor;\n-            if (executor.inEventLoop()) {\n-                onNext0((HttpData) httpObject);\n-            } else {\n-                executor.execute(() -> onNext0((HttpData) httpObject));\n-            }\n-        }\n-\n-        private void onNext0(HttpData httpData) {\n-            wroteAny = true;\n-            if (!usePooledObject) {\n-                httpData = PooledObjects.copyAndClose(httpData);\n-            }\n-            downstream.onNext(httpData);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-                return;\n-            }\n-\n-            trailersFuture = new HeadersFuture<>();\n-            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n-            }\n+            super.onNext(httpObject);\n         }\n \n         @Override\n-        public void onError(Throwable cause) {\n-            maybeCompleteHeaders(cause);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (executor == null || downstream == null) {\n-                this.cause = cause;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onError0(cause, downstream);\n-            } else {\n-                executor.execute(() -> onError0(cause, downstream));\n-            }\n-        }\n-\n-        private void onError0(Throwable cause, Subscriber<? super HttpData> downstream) {\n-            downstream.onError(cause);\n-            this.downstream = NoopSubscriber.get();\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders(null);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-\n-            if (executor == null || downstream == null) {\n-                completing = true;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onComplete0(downstream);\n-            } else {\n-                executor.execute(() -> onComplete0(downstream));\n-            }\n-        }\n-\n-        private void onComplete0(Subscriber<? super HttpData> downstream) {\n-            downstream.onComplete();\n-        }\n-\n-        private void maybeCompleteHeaders(@Nullable Throwable cause) {\n+        protected void doOnCompletion(@Nullable Throwable cause) {\n             if (!headersFuture.isDone()) {\n                 if (cause != null && !(cause instanceof CancelledSubscriptionException) &&\n                     !(cause instanceof AbortedStreamException)) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517085081", "body": "Can't this be just `response.isEmpty()`?", "bodyText": "Can't this be just response.isEmpty()?", "bodyHTML": "<p dir=\"auto\">Can't this be just <code>response.isEmpty()</code>?</p>", "author": "minwoox", "createdAt": "2020-11-04T04:00:05Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE3NzY0OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517177649", "bodyText": "I wrote this code in August. Sorry, I don't remember why I added its own wroteAny. \ud83d\ude02\nLet me take some time to remind it. \ud83d\ude0e", "author": "ikhoon", "createdAt": "2020-11-04T08:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NjkyNg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517186926", "bodyText": "Now, I got it.\nDefaultSplitHttpResponse publishes only HttpData. wroteAny is set to true when a HttpData is received from upstream.\nAFAIK, wroteAny in DefaultStreamMessage which is super class of DefaultHttpResponse is set to true a headers is written.", "author": "ikhoon", "createdAt": "2020-11-04T08:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwMzMxNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517803315", "bodyText": "Thanks for the explanation. \ud83d\ude47", "author": "minwoox", "createdAt": "2020-11-05T05:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NTA4MQ=="}], "type": "inlineReview", "revised_code": null, "revised_code_in_main": {"commit": "3eef7032c7503c4525a73aa7c0148121859bab8b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..fb59b7da7 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -121,25 +122,39 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n         return !isOpen() && !wroteAny;\n     }\n \n+    @Override\n+    public long demand() {\n+        return response.demand();\n+    }\n+\n     @Override\n     public CompletableFuture<Void> whenComplete() {\n         return response.whenComplete();\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n+        subscribe(subscriber, executor, EMPTY_OPTIONS);\n     }\n \n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... unused) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+                          SubscriptionOption... options) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(options, \"options\");\n+\n+        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n+            subscriber.onSubscribe(NoopSubscription.get());\n+            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+            return;\n+        }\n+\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.initDownstream(subscriber, executor, options);\n+        } else {\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fb59b7da7..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,257 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n \n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public long demand() {\n-        return response.demand();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n-    }\n-\n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n \n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n-\n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n-\n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n-        }\n-\n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517086235", "body": "If subscribed with `SubscriptionOptions.NOTIFY_CANCELLATION`, the subscriber doesn't get notified because of this logic? Could you add a test for this?", "bodyText": "If subscribed with SubscriptionOptions.NOTIFY_CANCELLATION, the subscriber doesn't get notified because of this logic? Could you add a test for this?", "bodyHTML": "<p dir=\"auto\">If subscribed with <code>SubscriptionOptions.NOTIFY_CANCELLATION</code>, the subscriber doesn't get notified because of this logic? Could you add a test for this?</p>", "author": "minwoox", "createdAt": "2020-11-04T04:05:27Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,335 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (cancelCalled || upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            downstream = NoopSubscriber.get();", "originalCommit": "e035b459759229f6365dc4f452c92a1fe29f482c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxMDAyNA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517210024", "bodyText": "That's a good point. I've added this code to pass Reactive Streams TCK. Let me update this a lit. :-)", "author": "ikhoon", "createdAt": "2020-11-04T09:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgwMzk2OQ==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517803969", "bodyText": "question: Can't we just leave the downstream? (i.e. not assign the NoopSubscriber?)", "author": "minwoox", "createdAt": "2020-11-05T05:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg4MTk3NA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517881974", "bodyText": "AFAIK, if Subscription.cancel() called, the publisher should drop the subscriber's reference.\nhttps://github.com/reactive-streams/reactive-streams-jvm#3.13\nIf not, required_spec313_cancelMustMakeThePublisherEventuallyDropAllReferencesToTheSubscriber in TCK was failed.", "author": "ikhoon", "createdAt": "2020-11-05T08:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg4NDY4Mw==", "url": "https://github.com/line/armeria/pull/3038#discussion_r517884683", "bodyText": "Thanks for the explanation. \ud83d\ude04", "author": "minwoox", "createdAt": "2020-11-05T08:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjIzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "a0168fed0656db0477de77679f64adb69499d0e3", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..0639afc02 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -228,7 +234,9 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 return;\n             }\n             cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n+            if (!notifyCancellation) {\n+                downstream = NoopSubscriber.get();\n+            }\n             maybeCompleteHeaders(null);\n             final Subscription upstream = this.upstream;\n             if (upstream != null) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex a3ea69804..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -228,7 +254,9 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 return;\n             }\n             cancelCalled = true;\n-            downstream = NoopSubscriber.get();\n+            if (!notifyCancellation) {\n+                downstream = NoopSubscriber.get();\n+            }\n             maybeCompleteHeaders(null);\n             final Subscription upstream = this.upstream;\n             if (upstream != null) {\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,252 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n \n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n-\n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n-\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n-\n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n \n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"oid": "a0168fed0656db0477de77679f64adb69499d0e3", "url": "https://github.com/line/armeria/commit/a0168fed0656db0477de77679f64adb69499d0e3", "message": "Address comments by @minwoox", "committedDate": "2020-11-04T09:26:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NzA2Ng==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518547066", "body": "How about doing this after `downstreamUpdater.compareAndSet(this, null, downstream)`?", "bodyText": "How about doing this after downstreamUpdater.compareAndSet(this, null, downstream)?", "bodyHTML": "<p dir=\"auto\">How about doing this after <code>downstreamUpdater.compareAndSet(this, null, downstream)</code>?</p>", "author": "minwoox", "createdAt": "2020-11-06T06:27:04Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+    private final boolean notifyCancellation;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        notifyCancellation = containsNotifyCancellation(options);\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {", "originalCommit": "a0168fed0656db0477de77679f64adb69499d0e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 0639afc02..2e63a787f 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -131,10 +131,16 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n         requireNonNull(subscriber, \"subscriber\");\n+        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n+            subscriber.onSubscribe(NoopSubscription.get());\n+            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+            return;\n+        }\n+\n         if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n+            bodySubscriber.initDownstream(subscriber);\n         } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber));\n         }\n     }\n \n", "next_change": {"commit": "2f5a5791685d692b512407a8c38fc2c416ab7767", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 2e63a787f..858d93d5a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -138,18 +145,12 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n         }\n \n         if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber);\n+            bodySubscriber.initDownstream(subscriber, executor, options);\n         } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber));\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n         }\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... unused) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n-    }\n-\n     @Override\n     public void abort() {\n         response.abort();\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 0639afc02..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -129,19 +128,28 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.setDownStream(subscriber);\n-        } else {\n-            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n-        }\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n+        subscribe(subscriber, executor, EMPTY_OPTIONS);\n     }\n \n     @Override\n     public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... unused) {\n-        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+                          SubscriptionOption... options) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        requireNonNull(executor, \"executor\");\n+        requireNonNull(options, \"options\");\n+\n+        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n+            subscriber.onSubscribe(NoopSubscription.get());\n+            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+            return;\n+        }\n+\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.initDownstream(subscriber, executor, options);\n+        } else {\n+            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -16,252 +16,52 @@\n \n package com.linecorp.armeria.internal.common;\n \n-import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n-import static java.util.Objects.requireNonNull;\n-\n import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n-\n-import javax.annotation.Nullable;\n \n-import org.reactivestreams.Subscriber;\n import org.reactivestreams.Subscription;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n-import com.google.common.math.LongMath;\n-\n-import com.linecorp.armeria.common.HttpData;\n-import com.linecorp.armeria.common.HttpHeaders;\n import com.linecorp.armeria.common.HttpObject;\n import com.linecorp.armeria.common.HttpResponse;\n import com.linecorp.armeria.common.HttpStatus;\n import com.linecorp.armeria.common.ResponseHeaders;\n import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.annotation.Nullable;\n import com.linecorp.armeria.common.stream.AbortedStreamException;\n import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n-import com.linecorp.armeria.common.stream.NoopSubscriber;\n-import com.linecorp.armeria.common.stream.StreamMessage;\n-import com.linecorp.armeria.common.stream.SubscriptionOption;\n-import com.linecorp.armeria.common.util.UnmodifiableFuture;\n-import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n-import com.linecorp.armeria.unsafe.PooledObjects;\n \n import io.netty.util.concurrent.EventExecutor;\n \n-public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n-            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n-            trailersFutureUpdater = AtomicReferenceFieldUpdater\n-            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+public class DefaultSplitHttpResponse extends AbstractSplitHttpMessage implements SplitHttpResponse {\n \n     private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n-    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n-    private static final SubscriptionOption[] EMPTY_OPTIONS = {};\n-\n-    static {\n-        EMPTY_TRAILERS = new HeadersFuture<>();\n-        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n-    }\n-\n-    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n-    private final BodySubscriber bodySubscriber = new BodySubscriber();\n-    private final HttpResponse response;\n-    private final EventExecutor upstreamExecutor;\n-\n-    @Nullable\n-    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n-    private volatile boolean wroteAny;\n-\n-    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor) {\n-        this.response = requireNonNull(response, \"response\");\n-        upstreamExecutor = requireNonNull(executor, \"executor\");\n-\n-        response.subscribe(bodySubscriber, upstreamExecutor, SubscriptionOption.values());\n-    }\n-\n-    @Override\n-    public final CompletableFuture<ResponseHeaders> headers() {\n-        return headersFuture;\n-    }\n-\n-    @Override\n-    public final StreamMessage<HttpData> body() {\n-        return this;\n-    }\n-\n-    @Override\n-    public final CompletableFuture<HttpHeaders> trailers() {\n-        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n-        if (trailersFuture != null) {\n-            return trailersFuture;\n-        }\n-\n-        trailersFuture = new HeadersFuture<>();\n-        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n-            return trailersFuture;\n-        } else {\n-            return this.trailersFuture;\n-        }\n-    }\n-\n-    @Override\n-    public boolean isOpen() {\n-        return response.isOpen();\n-    }\n \n-    @Override\n-    public boolean isEmpty() {\n-        return !isOpen() && !wroteAny;\n-    }\n+    private final SplitHttpResponseBodySubscriber bodySubscriber;\n \n-    @Override\n-    public CompletableFuture<Void> whenComplete() {\n-        return response.whenComplete();\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor) {\n+        this(response, upstreamExecutor, new SplitHttpResponseBodySubscriber(response, upstreamExecutor));\n     }\n \n-    @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor) {\n-        subscribe(subscriber, executor, EMPTY_OPTIONS);\n+    private DefaultSplitHttpResponse(HttpResponse response, EventExecutor upstreamExecutor,\n+                                     SplitHttpResponseBodySubscriber bodySubscriber) {\n+        super(response, upstreamExecutor, bodySubscriber);\n+        this.bodySubscriber = bodySubscriber;\n     }\n \n     @Override\n-    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n-                          SubscriptionOption... options) {\n-        requireNonNull(subscriber, \"subscriber\");\n-        requireNonNull(executor, \"executor\");\n-        requireNonNull(options, \"options\");\n-\n-        if (!downstreamUpdater.compareAndSet(bodySubscriber, null, subscriber)) {\n-            subscriber.onSubscribe(NoopSubscription.get());\n-            subscriber.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n-            return;\n-        }\n-\n-        if (executor.inEventLoop()) {\n-            bodySubscriber.initDownstream(subscriber, executor, options);\n-        } else {\n-            executor.execute(() -> bodySubscriber.initDownstream(subscriber, executor, options));\n-        }\n-    }\n-\n-    @Override\n-    public void abort() {\n-        response.abort();\n-    }\n-\n-    @Override\n-    public void abort(Throwable cause) {\n-        response.abort(cause);\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return bodySubscriber.headersFuture();\n     }\n \n-    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n-\n-        private boolean completing;\n-        // 1 is used for prefetching headers\n-        private long pendingRequests = 1;\n-\n-        private volatile boolean notifyCancellation;\n-        private boolean usePooledObject;\n-\n-        @Nullable\n-        volatile Subscriber<? super HttpData> downstream;\n-        @Nullable\n-        private volatile Subscription upstream;\n-        @Nullable\n-        private volatile EventExecutor executor;\n-        @Nullable\n-        private volatile Throwable cause;\n-\n-        private volatile boolean cancelCalled;\n-\n-        private void initDownstream(Subscriber<? super HttpData> downstream, EventExecutor executor,\n-                                    SubscriptionOption... options) {\n-            assert executor.inEventLoop();\n-\n-            this.executor = executor;\n-            for (SubscriptionOption option : options) {\n-                if (option == SubscriptionOption.NOTIFY_CANCELLATION) {\n-                    notifyCancellation = true;\n-                } else if (option == SubscriptionOption.WITH_POOLED_OBJECTS) {\n-                    usePooledObject = true;\n-                }\n-            }\n-\n-            try {\n-                downstream.onSubscribe(this);\n-                final Throwable cause = this.cause;\n-                if (cause != null) {\n-                    onError0(cause, downstream);\n-                } else if (completing) {\n-                    onComplete0(downstream);\n-                }\n-            } catch (Throwable t) {\n-                throwIfFatal(t);\n-                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n-            }\n-        }\n-\n-        @Override\n-        public void onSubscribe(Subscription subscription) {\n-            requireNonNull(subscription, \"subscription\");\n-            if (upstream != null) {\n-                subscription.cancel();\n-                return;\n-            }\n-            upstream = subscription;\n-            if (cancelCalled) {\n-                subscription.cancel();\n-                return;\n-            }\n-            subscription.request(pendingRequests);\n-        }\n+    private static final class SplitHttpResponseBodySubscriber extends SplitHttpMessageSubscriber {\n \n-        @Override\n-        public void request(long n) {\n-            if (n <= 0) {\n-                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n-                response.abort(new IllegalArgumentException(\n-                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n-                return;\n-            }\n-            if (upstreamExecutor.inEventLoop()) {\n-                request0(n);\n-            } else {\n-                upstreamExecutor.execute(() -> request0(n));\n-            }\n-        }\n+        private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n \n-        private void request0(long n) {\n-            final Subscription upstream = this.upstream;\n-            if (upstream == null) {\n-                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n-            } else {\n-                upstream.request(n);\n-            }\n+        SplitHttpResponseBodySubscriber(HttpResponse response, EventExecutor upstreamExecutor) {\n+            super(1, response, upstreamExecutor);\n         }\n \n-        @Override\n-        public void cancel() {\n-            if (cancelCalled) {\n-                return;\n-            }\n-            cancelCalled = true;\n-            if (!notifyCancellation) {\n-                downstream = NoopSubscriber.get();\n-            }\n-            maybeCompleteHeaders(null);\n-            final Subscription upstream = this.upstream;\n-            if (upstream != null) {\n-                upstream.cancel();\n-            }\n+        CompletableFuture<ResponseHeaders> headersFuture() {\n+            return headersFuture;\n         }\n \n         @Override\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0ODUwNg==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518548506", "body": "Isn't this `if (notifyCancellation)` ?", "bodyText": "Isn't this if (notifyCancellation) ?", "bodyHTML": "<p dir=\"auto\">Isn't this <code>if (notifyCancellation)</code> ?</p>", "author": "minwoox", "createdAt": "2020-11-06T06:32:17Z", "path": "core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright 2020 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.linecorp.armeria.internal.common;\n+\n+import static com.linecorp.armeria.common.util.Exceptions.throwIfFatal;\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import javax.annotation.Nullable;\n+\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.math.LongMath;\n+\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpHeaders;\n+import com.linecorp.armeria.common.HttpObject;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.common.SplitHttpResponse;\n+import com.linecorp.armeria.common.stream.AbortedStreamException;\n+import com.linecorp.armeria.common.stream.CancelledSubscriptionException;\n+import com.linecorp.armeria.common.stream.NoopSubscriber;\n+import com.linecorp.armeria.common.stream.StreamMessage;\n+import com.linecorp.armeria.common.stream.SubscriptionOption;\n+import com.linecorp.armeria.common.util.UnmodifiableFuture;\n+import com.linecorp.armeria.internal.common.stream.NoopSubscription;\n+\n+import io.netty.util.concurrent.EventExecutor;\n+\n+public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitHttpResponse {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(DefaultSplitHttpResponse.class);\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<BodySubscriber, Subscriber> downstreamUpdater =\n+            AtomicReferenceFieldUpdater.newUpdater(BodySubscriber.class, Subscriber.class, \"downstream\");\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<DefaultSplitHttpResponse, HeadersFuture>\n+            trailersFutureUpdater = AtomicReferenceFieldUpdater\n+            .newUpdater(DefaultSplitHttpResponse.class, HeadersFuture.class, \"trailersFuture\");\n+\n+    private static final ResponseHeaders HEADERS_WITH_UNKNOWN_STATUS = ResponseHeaders.of(HttpStatus.UNKNOWN);\n+    private static final HeadersFuture<HttpHeaders> EMPTY_TRAILERS;\n+\n+    static {\n+        EMPTY_TRAILERS = new HeadersFuture<>();\n+        EMPTY_TRAILERS.doComplete(HttpHeaders.of());\n+    }\n+\n+    private final HeadersFuture<ResponseHeaders> headersFuture = new HeadersFuture<>();\n+    private final BodySubscriber bodySubscriber = new BodySubscriber();\n+    private final HttpResponse response;\n+    private final EventExecutor executor;\n+    private final boolean notifyCancellation;\n+\n+    @Nullable\n+    private volatile HeadersFuture<HttpHeaders> trailersFuture;\n+    private volatile boolean wroteAny;\n+\n+    public DefaultSplitHttpResponse(HttpResponse response, EventExecutor executor,\n+                                    SubscriptionOption... options) {\n+        this.response = requireNonNull(response, \"response\");\n+        this.executor = requireNonNull(executor, \"executor\");\n+        notifyCancellation = containsNotifyCancellation(options);\n+\n+        response.subscribe(bodySubscriber, executor, options);\n+    }\n+\n+    @Override\n+    public final CompletableFuture<ResponseHeaders> headers() {\n+        return headersFuture;\n+    }\n+\n+    @Override\n+    public final StreamMessage<HttpData> body() {\n+        return this;\n+    }\n+\n+    @Override\n+    public final CompletableFuture<HttpHeaders> trailers() {\n+        HeadersFuture<HttpHeaders> trailersFuture = this.trailersFuture;\n+        if (trailersFuture != null) {\n+            return trailersFuture;\n+        }\n+\n+        trailersFuture = new HeadersFuture<>();\n+        if (trailersFutureUpdater.compareAndSet(this, null, trailersFuture)) {\n+            return trailersFuture;\n+        } else {\n+            return this.trailersFuture;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return response.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return !isOpen() && !wroteAny;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> whenComplete() {\n+        return response.whenComplete();\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor unused) {\n+        requireNonNull(subscriber, \"subscriber\");\n+        if (executor.inEventLoop()) {\n+            bodySubscriber.setDownStream(subscriber);\n+        } else {\n+            executor.execute(() -> bodySubscriber.setDownStream(subscriber));\n+        }\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super HttpData> subscriber, EventExecutor executor,\n+                          SubscriptionOption... unused) {\n+        throw new UnsupportedOperationException(\"Use 'HttpResponse.split(executor, options)' instead.\");\n+    }\n+\n+    @Override\n+    public void abort() {\n+        response.abort();\n+    }\n+\n+    @Override\n+    public void abort(Throwable cause) {\n+        response.abort(cause);\n+    }\n+\n+    private final class BodySubscriber implements Subscriber<HttpObject>, Subscription {\n+\n+        @Nullable\n+        private Throwable cause;\n+\n+        private boolean completing;\n+        // 1 is used for prefetching headers\n+        private long pendingRequests = 1;\n+\n+        @Nullable\n+        volatile Subscriber<? super HttpData> downstream;\n+        @Nullable\n+        private volatile Subscription upstream;\n+\n+        private volatile boolean cancelCalled;\n+\n+        private void setDownStream(Subscriber<? super HttpData> downstream) {\n+            try {\n+                if (!downstreamUpdater.compareAndSet(this, null, downstream)) {\n+                    downstream.onSubscribe(NoopSubscription.get());\n+                    downstream.onError(new IllegalStateException(\"subscribed by other subscriber already\"));\n+                    return;\n+                }\n+                downstream.onSubscribe(this);\n+                if (cause != null) {\n+                    downstream.onError(cause);\n+                } else if (completing) {\n+                    downstream.onComplete();\n+                }\n+            } catch (Throwable t) {\n+                throwIfFatal(t);\n+                logger.warn(\"Subscriber should not throw an exception. subscriber: {}\", downstream, t);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            requireNonNull(subscription, \"subscription\");\n+            if (upstream != null) {\n+                subscription.cancel();\n+                return;\n+            }\n+            upstream = subscription;\n+            if (cancelCalled) {\n+                subscription.cancel();\n+                return;\n+            }\n+            subscription.request(pendingRequests);\n+        }\n+\n+        @Override\n+        public void request(long n) {\n+            if (n <= 0) {\n+                // Just abort the publisher so subscriber().onError(e) is called and resources are cleaned up.\n+                response.abort(new IllegalArgumentException(\n+                        \"n: \" + n + \" (expected: > 0, see Reactive Streams specification rule 3.9)\"));\n+                return;\n+            }\n+            if (executor.inEventLoop()) {\n+                request0(n);\n+            } else {\n+                executor.execute(() -> request0(n));\n+            }\n+        }\n+\n+        private void request0(long n) {\n+            final Subscription upstream = this.upstream;\n+            if (upstream == null) {\n+                pendingRequests = LongMath.saturatedAdd(n, pendingRequests);\n+            } else {\n+                upstream.request(n);\n+            }\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            if (cancelCalled) {\n+                return;\n+            }\n+            cancelCalled = true;\n+            if (!notifyCancellation) {\n+                downstream = NoopSubscriber.get();\n+            }\n+            maybeCompleteHeaders(null);\n+            final Subscription upstream = this.upstream;\n+            if (upstream != null) {\n+                upstream.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(HttpObject httpObject) {\n+            if (httpObject instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) httpObject;\n+                final HttpStatus status = headers.status();\n+                if (status.isInformational()) {\n+                    // Ignore informational headers\n+                    upstream.request(1);\n+                } else {\n+                    headersFuture.doComplete(headers);\n+                }\n+                return;\n+            }\n+\n+            if (httpObject instanceof HttpHeaders) {\n+                final HttpHeaders trailers = (HttpHeaders) httpObject;\n+                completeTrailers(trailers);\n+                return;\n+            }\n+\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            assert downstream != null;\n+            assert httpObject instanceof HttpData;\n+            final HttpData data = (HttpData) httpObject;\n+            wroteAny = true;\n+            downstream.onNext(data);\n+        }\n+\n+        /**\n+         * Completes the specified trailers.\n+         */\n+        private void completeTrailers(HttpHeaders trailers) {\n+            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n+            if (trailersFuture != null) {\n+                trailersFuture.doComplete(trailers);\n+                return;\n+            }\n+\n+            trailersFuture = new HeadersFuture<>();\n+            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n+                trailersFuture.doComplete(trailers);\n+            } else {\n+                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable cause) {\n+            maybeCompleteHeaders(cause);\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            if (downstream == null) {\n+                this.cause = cause;\n+            } else {\n+                downstream.onError(cause);\n+                if (cause instanceof CancelledSubscriptionException) {", "originalCommit": "a0168fed0656db0477de77679f64adb69499d0e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU1MjQ2MA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r518552460", "bodyText": "Yeah, I think that is the same effect. Otherwise, I think we can remove the if condition.\nThere is no harm to set NoopSubscriber to downstream after onError() is invoked.", "author": "ikhoon", "createdAt": "2020-11-06T06:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0ODUwNg=="}], "type": "inlineReview", "revised_code": {"commit": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 0639afc02..2e63a787f 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -298,9 +299,7 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 this.cause = cause;\n             } else {\n                 downstream.onError(cause);\n-                if (cause instanceof CancelledSubscriptionException) {\n-                    this.downstream = NoopSubscriber.get();\n-                }\n+                this.downstream = NoopSubscriber.get();\n             }\n         }\n \n", "next_change": {"commit": "2f5a5791685d692b512407a8c38fc2c416ab7767", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 2e63a787f..858d93d5a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -305,6 +346,15 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n \n         @Override\n         public void onComplete() {\n+            final EventExecutor executor = this.executor;\n+            if (executor.inEventLoop()) {\n+                onComplete0();\n+            } else {\n+                executor.execute(this::onComplete0);\n+            }\n+        }\n+\n+        private void onComplete0() {\n             maybeCompleteHeaders(null);\n             final Subscriber<? super HttpData> downstream = this.downstream;\n             if (downstream == null) {\n", "next_change": {"commit": "3b032bd18d0ba94d520b5c605a4b6f02b83bed9a", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 858d93d5a..ef2b52a0a 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -325,43 +325,46 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n \n         @Override\n         public void onError(Throwable cause) {\n+            maybeCompleteHeaders(cause);\n             final EventExecutor executor = this.executor;\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+            if (executor == null || downstream == null) {\n+                this.cause = cause;\n+                return;\n+            }\n+\n             if (executor.inEventLoop()) {\n-                onError0(cause);\n+                onError0(cause, downstream);\n             } else {\n-                executor.execute(() -> onError(cause));\n+                executor.execute(() -> onError0(cause, downstream));\n             }\n         }\n \n-        private void onError0(Throwable cause) {\n-            maybeCompleteHeaders(cause);\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                this.cause = cause;\n-            } else {\n-                downstream.onError(cause);\n-                this.downstream = NoopSubscriber.get();\n-            }\n+        private void onError0(Throwable cause, Subscriber<? super HttpData> downstream) {\n+            downstream.onError(cause);\n+            this.downstream = NoopSubscriber.get();\n         }\n \n         @Override\n         public void onComplete() {\n+            maybeCompleteHeaders(null);\n             final EventExecutor executor = this.executor;\n+            final Subscriber<? super HttpData> downstream = this.downstream;\n+\n+            if (executor == null || downstream == null) {\n+                completing = true;\n+                return;\n+            }\n+\n             if (executor.inEventLoop()) {\n-                onComplete0();\n+                onComplete0(downstream);\n             } else {\n-                executor.execute(this::onComplete0);\n+                executor.execute(() -> onComplete0(downstream));\n             }\n         }\n \n-        private void onComplete0() {\n-            maybeCompleteHeaders(null);\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n-                completing = true;\n-            } else {\n-                downstream.onComplete();\n-            }\n+        private void onComplete0(Subscriber<? super HttpData> downstream) {\n+            downstream.onComplete();\n         }\n \n         private void maybeCompleteHeaders(@Nullable Throwable cause) {\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex 0639afc02..fa48af3e6 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -293,28 +325,47 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n         @Override\n         public void onError(Throwable cause) {\n             maybeCompleteHeaders(cause);\n+            final EventExecutor executor = this.executor;\n             final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n+            if (executor == null || downstream == null) {\n                 this.cause = cause;\n+                return;\n+            }\n+\n+            if (executor.inEventLoop()) {\n+                onError0(cause, downstream);\n             } else {\n-                downstream.onError(cause);\n-                if (cause instanceof CancelledSubscriptionException) {\n-                    this.downstream = NoopSubscriber.get();\n-                }\n+                executor.execute(() -> onError0(cause, downstream));\n             }\n         }\n \n+        private void onError0(Throwable cause, Subscriber<? super HttpData> downstream) {\n+            downstream.onError(cause);\n+            this.downstream = NoopSubscriber.get();\n+        }\n+\n         @Override\n         public void onComplete() {\n             maybeCompleteHeaders(null);\n+            final EventExecutor executor = this.executor;\n             final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (downstream == null) {\n+\n+            if (executor == null || downstream == null) {\n                 completing = true;\n+                return;\n+            }\n+\n+            if (executor.inEventLoop()) {\n+                onComplete0(downstream);\n             } else {\n-                downstream.onComplete();\n+                executor.execute(() -> onComplete0(downstream));\n             }\n         }\n \n+        private void onComplete0(Subscriber<? super HttpData> downstream) {\n+            downstream.onComplete();\n+        }\n+\n         private void maybeCompleteHeaders(@Nullable Throwable cause) {\n             if (!headersFuture.isDone()) {\n                 if (cause != null && !(cause instanceof CancelledSubscriptionException) &&\n", "next_change": {"commit": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\nindex fa48af3e6..431f82971 100644\n--- a/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/internal/common/DefaultSplitHttpResponse.java\n", "chunk": "@@ -271,102 +71,19 @@ public class DefaultSplitHttpResponse implements StreamMessage<HttpData>, SplitH\n                 final HttpStatus status = headers.status();\n                 if (status.isInformational()) {\n                     // Ignore informational headers\n+                    final Subscription upstream = upstream();\n+                    assert upstream != null;\n                     upstream.request(1);\n                 } else {\n                     headersFuture.doComplete(headers);\n                 }\n                 return;\n             }\n-\n-            if (httpObject instanceof HttpHeaders) {\n-                final HttpHeaders trailers = (HttpHeaders) httpObject;\n-                completeTrailers(trailers);\n-                return;\n-            }\n-\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            assert downstream != null;\n-            assert httpObject instanceof HttpData;\n-\n-            final EventExecutor executor = this.executor;\n-            if (executor.inEventLoop()) {\n-                onNext0((HttpData) httpObject);\n-            } else {\n-                executor.execute(() -> onNext0((HttpData) httpObject));\n-            }\n-        }\n-\n-        private void onNext0(HttpData httpData) {\n-            wroteAny = true;\n-            if (!usePooledObject) {\n-                httpData = PooledObjects.copyAndClose(httpData);\n-            }\n-            downstream.onNext(httpData);\n-        }\n-\n-        /**\n-         * Completes the specified trailers.\n-         */\n-        private void completeTrailers(HttpHeaders trailers) {\n-            HeadersFuture<HttpHeaders> trailersFuture = DefaultSplitHttpResponse.this.trailersFuture;\n-            if (trailersFuture != null) {\n-                trailersFuture.doComplete(trailers);\n-                return;\n-            }\n-\n-            trailersFuture = new HeadersFuture<>();\n-            if (trailersFutureUpdater.compareAndSet(DefaultSplitHttpResponse.this, null, trailersFuture)) {\n-                trailersFuture.doComplete(trailers);\n-            } else {\n-                DefaultSplitHttpResponse.this.trailersFuture.doComplete(trailers);\n-            }\n+            super.onNext(httpObject);\n         }\n \n         @Override\n-        public void onError(Throwable cause) {\n-            maybeCompleteHeaders(cause);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-            if (executor == null || downstream == null) {\n-                this.cause = cause;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onError0(cause, downstream);\n-            } else {\n-                executor.execute(() -> onError0(cause, downstream));\n-            }\n-        }\n-\n-        private void onError0(Throwable cause, Subscriber<? super HttpData> downstream) {\n-            downstream.onError(cause);\n-            this.downstream = NoopSubscriber.get();\n-        }\n-\n-        @Override\n-        public void onComplete() {\n-            maybeCompleteHeaders(null);\n-            final EventExecutor executor = this.executor;\n-            final Subscriber<? super HttpData> downstream = this.downstream;\n-\n-            if (executor == null || downstream == null) {\n-                completing = true;\n-                return;\n-            }\n-\n-            if (executor.inEventLoop()) {\n-                onComplete0(downstream);\n-            } else {\n-                executor.execute(() -> onComplete0(downstream));\n-            }\n-        }\n-\n-        private void onComplete0(Subscriber<? super HttpData> downstream) {\n-            downstream.onComplete();\n-        }\n-\n-        private void maybeCompleteHeaders(@Nullable Throwable cause) {\n+        protected void doOnCompletion(@Nullable Throwable cause) {\n             if (!headersFuture.isDone()) {\n                 if (cause != null && !(cause instanceof CancelledSubscriptionException) &&\n                     !(cause instanceof AbortedStreamException)) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "890cad32b905edded5ad1a526efa8ed152a57d95", "committedDate": "2021-08-13 12:42:01 +0900", "message": "Ignore `CancelledSubscriptionException` when WebFlux's WebClient cancels the upstream (#3750)"}, {"oid": "5b384fbe27e7e6f9225d6db91cbb684d09dfbb5e", "committedDate": "2021-08-17 15:07:39 +0900", "message": "Introduce Armeria `@Nullable` to annotate type parameters (#3751)"}, {"oid": "f0818b990b47ef863bf82bad81f34c09eb2ad565", "committedDate": "2022-01-07 12:55:37 +0900", "message": "Add HttpRequest.split() (#3953)"}]}, {"oid": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "url": "https://github.com/line/armeria/commit/fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "message": "Address comments by @minwoox", "committedDate": "2020-11-06T06:50:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYyNjgzMA==", "url": "https://github.com/line/armeria/pull/3038#discussion_r519626830", "body": "I'm not sure we need to accept `SubscriptionOption` here. A user will have to specify them when retrieving the response body via `SplitHttpResponse.body()`. Otherwise, a user will have to specify the same option twice.\r\n\r\nWe could subscribe to `HttpResponse` with both `SubscriptionOption`s enabled internally, and then emulate the desired behavior based on what's specified in `body.subscribe()`, e.g.\r\n\r\n- Convert off-heap `HttpData` into heap `HttpData` if `WITH_POOLED_OBJECTS` option is off.\r\n- Propagate `CancelledSubscriptionException` to `onError()` only when `NOTIFY_CANCELLATION` option is on.\r\n\r\n", "bodyText": "I'm not sure we need to accept SubscriptionOption here. A user will have to specify them when retrieving the response body via SplitHttpResponse.body(). Otherwise, a user will have to specify the same option twice.\nWe could subscribe to HttpResponse with both SubscriptionOptions enabled internally, and then emulate the desired behavior based on what's specified in body.subscribe(), e.g.\n\nConvert off-heap HttpData into heap HttpData if WITH_POOLED_OBJECTS option is off.\nPropagate CancelledSubscriptionException to onError() only when NOTIFY_CANCELLATION option is on.", "bodyHTML": "<p dir=\"auto\">I'm not sure we need to accept <code>SubscriptionOption</code> here. A user will have to specify them when retrieving the response body via <code>SplitHttpResponse.body()</code>. Otherwise, a user will have to specify the same option twice.</p>\n<p dir=\"auto\">We could subscribe to <code>HttpResponse</code> with both <code>SubscriptionOption</code>s enabled internally, and then emulate the desired behavior based on what's specified in <code>body.subscribe()</code>, e.g.</p>\n<ul dir=\"auto\">\n<li>Convert off-heap <code>HttpData</code> into heap <code>HttpData</code> if <code>WITH_POOLED_OBJECTS</code> option is off.</li>\n<li>Propagate <code>CancelledSubscriptionException</code> to <code>onError()</code> only when <code>NOTIFY_CANCELLATION</code> option is on.</li>\n</ul>", "author": "trustin", "createdAt": "2020-11-09T08:25:50Z", "path": "core/src/main/java/com/linecorp/armeria/common/HttpResponse.java", "diffHunk": "@@ -548,4 +550,63 @@ default HttpResponseDuplicator toDuplicator(EventExecutor executor, long maxResp\n         requireNonNull(executor, \"executor\");\n         return new DefaultHttpResponseDuplicator(this, executor, maxResponseLength);\n     }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be\n+     * completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split() {\n+        return split(defaultSubscriberExecutor());\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     *\n+     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n+     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n+     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n+     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(SubscriptionOption... options) {\n+        return new DefaultSplitHttpResponse(this, defaultSubscriberExecutor(), options);\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(EventExecutor executor) {\n+        return new DefaultSplitHttpResponse(this, executor);\n+    }\n+\n+    /**\n+     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n+     * {@link HttpHeaders} and {@link HttpData}.\n+     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n+     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n+     * completely.\n+     *\n+     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n+     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n+     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n+     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n+     */\n+    @CheckReturnValue\n+    default SplitHttpResponse split(EventExecutor executor, SubscriptionOption... options) {", "originalCommit": "fdb9bb7ee3c5fa64880b279c81e2a4445dde5ca6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f5a5791685d692b512407a8c38fc2c416ab7767", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex 19046a9dc..d23cb81d6 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -592,21 +575,4 @@ public interface HttpResponse extends Response, StreamMessage<HttpObject> {\n     default SplitHttpResponse split(EventExecutor executor) {\n         return new DefaultSplitHttpResponse(this, executor);\n     }\n-\n-    /**\n-     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n-     * {@link HttpHeaders} and {@link HttpData}.\n-     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n-     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n-     * completely.\n-     *\n-     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n-     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n-     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n-     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n-     */\n-    @CheckReturnValue\n-    default SplitHttpResponse split(EventExecutor executor, SubscriptionOption... options) {\n-        return new DefaultSplitHttpResponse(this, executor, options);\n-    }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex 19046a9dc..d23cb81d6 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -592,21 +575,4 @@ public interface HttpResponse extends Response, StreamMessage<HttpObject> {\n     default SplitHttpResponse split(EventExecutor executor) {\n         return new DefaultSplitHttpResponse(this, executor);\n     }\n-\n-    /**\n-     * Returns a new {@link SplitHttpResponse} which splits a stream of {@link HttpObject}s into\n-     * {@link HttpHeaders} and {@link HttpData}.\n-     * {@link SplitHttpResponse#headers()} will be completed before publishing the first {@link HttpData}.\n-     * {@link SplitHttpResponse#trailers()} might not complete until the entire response body is consumed\n-     * completely.\n-     *\n-     * <p>(Advanced users only) If you want to get pooled objects from {@link SplitHttpResponse#body()},\n-     * you should call this method with {@link SubscriptionOption#WITH_POOLED_OBJECTS}.\n-     * Note that if you specify {@link SubscriptionOption}s when subscribing to\n-     * {@link SplitHttpResponse#body()}, {@link UnsupportedOperationException} will be raised.\n-     */\n-    @CheckReturnValue\n-    default SplitHttpResponse split(EventExecutor executor, SubscriptionOption... options) {\n-        return new DefaultSplitHttpResponse(this, executor, options);\n-    }\n }\n", "next_change": {"commit": "3eef7032c7503c4525a73aa7c0148121859bab8b", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex d23cb81d6..519fa2cbe 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -575,4 +542,10 @@ public interface HttpResponse extends Response, StreamMessage<HttpObject> {\n     default SplitHttpResponse split(EventExecutor executor) {\n         return new DefaultSplitHttpResponse(this, executor);\n     }\n+\n+    @Override\n+    default <T> StreamMessage<T> decode(HttpDecoder<T> decoder, ByteBufAllocator alloc,\n+                                        Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n+        return new DecodedHttpStreamMessage<>(this, decoder, alloc, byteBufConverter);\n+    }\n }\n", "next_change": {"commit": "81dcaa664ddf79d416873d9be881f51e385fb997", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex 519fa2cbe..f59edb3cf 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -548,4 +572,68 @@ public interface HttpResponse extends Response, HttpMessage {\n                                         Function<? super HttpData, ? extends ByteBuf> byteBufConverter) {\n         return new DecodedHttpStreamMessage<>(this, decoder, alloc, byteBufConverter);\n     }\n+\n+    /**\n+     * Transforms the\n+     * <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#Information_responses\">informational headers</a>\n+     * emitted by {@link HttpResponse} by applying the specified {@link Function}.\n+     */\n+    default HttpResponse mapInformational(\n+            Function<? super ResponseHeaders, ? extends ResponseHeaders> function) {\n+        requireNonNull(function, \"function\");\n+        final StreamMessage<HttpObject> stream = map(obj -> {\n+            if (obj instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                if (headers.status().isInformational()) {\n+                    return function.apply(headers);\n+                }\n+            }\n+            return obj;\n+        });\n+        return of(stream);\n+    }\n+\n+    /**\n+     * Transforms the non-informational {@link ResponseHeaders} emitted by {@link HttpResponse} by applying\n+     * the specified {@link Function}.\n+     */\n+    default HttpResponse mapHeaders(Function<? super ResponseHeaders, ? extends ResponseHeaders> function) {\n+        requireNonNull(function, \"function\");\n+        final StreamMessage<HttpObject> stream = map(obj -> {\n+            if (obj instanceof ResponseHeaders) {\n+                final ResponseHeaders headers = (ResponseHeaders) obj;\n+                if (!headers.status().isInformational()) {\n+                    return function.apply(headers);\n+                }\n+            }\n+            return obj;\n+        });\n+        return of(stream);\n+    }\n+\n+    /**\n+     * Transforms the {@link HttpData}s emitted by this {@link HttpRequest} by applying the specified\n+     * {@link Function}.\n+     */\n+    default HttpResponse mapData(Function<? super HttpData, ? extends HttpData> function) {\n+        requireNonNull(function, \"function\");\n+        final StreamMessage<HttpObject> stream =\n+                map(obj -> obj instanceof HttpData ? function.apply((HttpData) obj) : obj);\n+        return of(stream);\n+    }\n+\n+    /**\n+     * Transforms the {@linkplain HttpHeaders trailers} emitted by this {@link HttpResponse} by applying the\n+     * specified {@link Function}.\n+     */\n+    default HttpResponse mapTrailers(Function<? super HttpHeaders, ? extends HttpHeaders> function) {\n+        requireNonNull(function, \"function\");\n+        final StreamMessage<HttpObject> stream = map(obj -> {\n+            if (obj instanceof HttpHeaders && !(obj instanceof ResponseHeaders)) {\n+                return function.apply((HttpHeaders) obj);\n+            }\n+            return obj;\n+        });\n+        return of(stream);\n+    }\n }\n", "next_change": {"commit": "6758bc1871c2d1e33aee3d052a7c30f4533585da", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex f59edb3cf..129ce2d0a 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -636,4 +732,23 @@ public interface HttpResponse extends Response, HttpMessage {\n         });\n         return of(stream);\n     }\n+\n+    /**\n+     * Transforms an error emitted by this {@link HttpResponse} by applying the specified {@link Function}.\n+     *\n+     * <p>For example:<pre>{@code\n+     * HttpResponse response = HttpResponse.ofFailure(new IllegalStateException(\"Something went wrong.\");\n+     * HttpResponse transformed = response.mapError(cause -> {\n+     * if (cause instanceof IllegalStateException) {\n+     *     return new MyDomainException(ex);\n+     * } else {\n+     *     return ex;\n+     * });\n+     * }</pre>\n+     */\n+    @Override\n+    default HttpResponse mapError(Function<? super Throwable, ? extends Throwable> function) {\n+        requireNonNull(function, \"function\");\n+        return of(HttpMessage.super.mapError(function));\n+    }\n }\n", "next_change": {"commit": "ed021f3d0fcb8160032a89f6a625bd2fbb0ae542", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex 129ce2d0a..e45cb0565 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -751,4 +765,32 @@ public interface HttpResponse extends Response, HttpMessage {\n         requireNonNull(function, \"function\");\n         return of(HttpMessage.super.mapError(function));\n     }\n+\n+    /**\n+     * Recovers a failed {@link HttpResponse} by switching to a returned fallback {@link HttpResponse}\n+     * when any error occurs before a {@link ResponseHeaders} is written.\n+     * Note that the failed {@link HttpResponse} cannot be recovered from an error if a {@link ResponseHeaders}\n+     * was written already.\n+     *\n+     * <p>Example:<pre>{@code\n+     * HttpResponse response = HttpResponse.ofFailure(new IllegalStateException(\"Oops...\"));\n+     * // The failed HttpResponse will be recovered by the fallback function.\n+     * HttpResponse recovered = response.recover(cause -> HttpResponse.of(\"Fallback\"));\n+     * assert recovered.aggregate().join().contentUtf8().equals(\"Fallback\");\n+     *\n+     * // As HTTP headers and body were written already before an error occurred,\n+     * // the fallback function could not be applied for the failed HttpResponse.\n+     * HttpResponseWriter response = HttpResponse.streaming();\n+     * response.write(ResponseHeaders.of(HttpStatus.OK));\n+     * response.write(HttpData.ofUtf8(\"Hello\"));\n+     * response.close(new IllegalStateException(\"Oops...\"));\n+     * HttpResponse notRecovered = response.recover(cause -> HttpResponse.of(\"Fallback\"));\n+     * // The IllegalStateException will be raised even though a fallback function was added.\n+     * notRecovered.aggregate().join();\n+     * }</pre>\n+     */\n+    default HttpResponse recover(Function<? super Throwable, ? extends HttpResponse> function) {\n+        requireNonNull(function, \"function\");\n+        return of(new RecoverableStreamMessage<>(this, function, /* allowResuming */ false));\n+    }\n }\n", "next_change": {"commit": "bf792d4465756738f30937241403e02da1b1efd6", "changed_code": [{"header": "diff --git a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\nindex e45cb0565..6f30f4014 100644\n--- a/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n+++ b/core/src/main/java/com/linecorp/armeria/common/HttpResponse.java\n", "chunk": "@@ -793,4 +938,66 @@ public interface HttpResponse extends Response, HttpMessage {\n         requireNonNull(function, \"function\");\n         return of(new RecoverableStreamMessage<>(this, function, /* allowResuming */ false));\n     }\n+\n+    /**\n+     * Recovers a failed {@link HttpResponse} by switching to a returned fallback {@link HttpResponse}\n+     * when the thrown {@link Throwable} is the same type or a subtype of the\n+     * specified {@code causeClass}.\n+     *\n+     * <p>Example:<pre>{@code\n+     * HttpResponse response = HttpResponse.ofFailure(new IllegalStateException(\"Oops...\"));\n+     * // The failed HttpResponse will be recovered by the fallback function.\n+     * HttpResponse recovered =\n+     *     response.recover(IllegalStateException.class, cause -> HttpResponse.of(\"Fallback\"));\n+     * assert recovered.aggregate().join().contentUtf8().equals(\"Fallback\");\n+     *\n+     * // As HTTP headers and body were written already before an error occurred,\n+     * // the fallback function could not be applied for the failed HttpResponse.\n+     * HttpResponseWriter response = HttpResponse.streaming();\n+     * response.write(ResponseHeaders.of(HttpStatus.OK));\n+     * response.write(HttpData.ofUtf8(\"Hello\"));\n+     * response.close(new IllegalStateException(\"Oops...\"));\n+     * HttpResponse notRecovered =\n+     *     response.recover(IllegalStateException.class, cause -> HttpResponse.of(\"Fallback\"));\n+     * // The IllegalStateException will be raised even though a fallback function was added.\n+     * notRecovered.aggregate().join();\n+     *\n+     * HttpResponse response = HttpResponse.ofFailure(new IllegalStateException(\"Oops...\"));\n+     * // Use the shortcut recover method as a chain.\n+     * HttpResponse recoverChain =\n+     *     response.recover(RuntimeException.class, cause -> {\n+     *         final IllegalArgumentException ex = new IllegalArgumentException(\"Oops2...\");\n+     *         // If a failed response is returned from the first chain\n+     *         return HttpResponse.ofFailure(ex);\n+     *     })\n+     *     // If the shortcut exception type is correct, catch and recover in the second chain.\n+     *     .recover(IllegalArgumentException.class, cause -> HttpResponse.of(\"fallback\"));\n+     * recoverChain.aggregate().join();\n+     *\n+     * HttpResponse response = HttpResponse.ofFailure(new IllegalStateException(\"Oops...\"));\n+     * // If the exception type does not match\n+     * HttpResponse mismatchRecovered =\n+     *     response.recover(IllegalArgumentException.class, cause -> HttpResponse.of(\"Fallback\"));\n+     * // In this case, CompletionException is thrown. (can't recover exception)\n+     * mismatchRecovered.aggregate().join();\n+     * }</pre>\n+     */\n+    @UnstableApi\n+    default <T extends Throwable> HttpResponse recover(Class<T> causeClass,\n+                                                       Function<? super T, ? extends HttpResponse> function) {\n+        requireNonNull(causeClass, \"causeClass\");\n+        requireNonNull(function, \"function\");\n+        return recover(cause -> {\n+            if (!causeClass.isInstance(cause)) {\n+                return Exceptions.throwUnsafely(cause);\n+            }\n+            try {\n+                final HttpResponse recoveredResponse = function.apply((T) cause);\n+                requireNonNull(recoveredResponse, \"recoveredResponse\");\n+                return recoveredResponse;\n+            } catch (Throwable t) {\n+                return Exceptions.throwUnsafely(t);\n+            }\n+        });\n+    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6c7c7d65ef8f6cb231e9d42ce6ea1d84cd22b437", "message": "Merge commit", "committedDate": null}, {"oid": "3eef7032c7503c4525a73aa7c0148121859bab8b", "committedDate": "2020-12-28 16:30:59 +0900", "message": "Add `HttpMessage.decode()` and hide `HttpDeframer` from public API (#3215)"}, {"oid": "4d0aa3317fd88363370f430b91fcaae2dfa0310e", "committedDate": "2021-02-01 15:04:44 +0900", "message": "HttpResponse.of(ResponseHeaders,Publisher<HttpObject>) (#3237)"}, {"oid": "e22bc21167e65254be3c93c0aedc2a191f48c5d4", "committedDate": "2021-06-01 16:06:58 +0900", "message": "Optimize subscription path for `FixedStreamMessage` (#3584)"}, {"oid": "5bd7af09301dc1435a42428089d781b9fdbbd1d5", "committedDate": "2021-06-14 23:10:48 +0900", "message": "Respect `SubscriptionOption.WITH_POOLED_OBJECTS` in `PublisherBasedStreamMessage` (#3617)"}, {"oid": "81dcaa664ddf79d416873d9be881f51e385fb997", "committedDate": "2021-06-17 17:34:19 +0900", "message": "Provide a simpler way to transform the objects of `HttpRequest` and `HttpResponse` (#3624)"}, {"oid": "3588a5167689a4419d6018326db2d8e10f7b98c2", "committedDate": "2021-06-17 21:48:30 +0900", "message": "Add `StreamMessage.collect()` (#3603)"}, {"oid": "714786e03bbaf985b8deb4d91bff7722d5b47bf4", "committedDate": "2021-07-10 13:38:22 +0900", "message": "Add `HttpResponse.ofJson()` (#3662)"}, {"oid": "6758bc1871c2d1e33aee3d052a7c30f4533585da", "committedDate": "2021-07-12 16:40:54 +0900", "message": "Add `StreamMessage.mapError()` (#3668)"}, {"oid": "51f0b8ce2f2bcf31ac2fc623e330c8f9bb73823a", "committedDate": "2021-07-12 16:54:45 +0900", "message": "Fix typo in examples of mapError"}, {"oid": "3ed6abf430ab0f69769537d0e508f5ddd4df91ea", "committedDate": "2021-07-13 16:52:11 +0900", "message": "Use JDK 16 for building Armeria (#3418)"}, {"oid": "54b70906bcd813f0b9b2c6715ad4086160ac49b2", "committedDate": "2021-08-02 11:06:25 +0900", "message": "Make HttpHeaders more cacheable (#3714)"}, {"oid": "b152c65f94cd370c4e68c441cd00d514070e69e2", "committedDate": "2021-08-03 13:09:03 +0900", "message": "Support Sangria GraphQL for Scala (#3704)"}, {"oid": "ed021f3d0fcb8160032a89f6a625bd2fbb0ae542", "committedDate": "2021-08-03 14:30:08 +0900", "message": "Provide a way to recover a failed `StreamMessage` (#3674)"}, {"oid": "219ee3758b232ca9c47e03258a0a62f4cc4841c3", "committedDate": "2021-08-03 21:49:48 +0900", "message": "Add `JacksonObjectMapperProvider` (#3728)"}, {"oid": "6a1d7f8f908984b55f7c32e75ec994b410bb6cbc", "committedDate": "2021-09-28 19:42:45 +0900", "message": "Utility for scheduling a task and retrieving its CompletableFuture (#3770)"}, {"oid": "dda1a30d5af9e299a0ca6ff8af62c59c254d6abc", "committedDate": "2021-10-05 13:17:50 +0900", "message": "Automatically decompress a compressed file with `FileService` (#3810)"}, {"oid": "755dc71b27099152be8efa352a4b5be4b35c768e", "committedDate": "2021-10-05 18:28:47 +0900", "message": "Zero copy between Netty's `Http2Headers` and Armeria's `HttpHeaders` (#3817)"}, {"oid": "f651842426c52ea799a5cda5cacbec77d32093f4", "committedDate": "2021-10-06 11:40:43 +0900", "message": "Wrap `HttpResponse` from `ExceptionHandler` with the raised exception (#3823)"}, {"oid": "8cbbedf9992994c4fc080f8594568e751facc87b", "committedDate": "2021-10-15 13:09:32 +0900", "message": "Provide a easier way to create HttpResponse from a specific executor (#3864)"}, {"oid": "3ec1e4dcd0a89b495276a0f988c4083d01fe7aec", "committedDate": "2021-12-13 17:16:40 +0900", "message": "Add `StreamMessage.peek()` (#3949)"}, {"oid": "5c521cc47cf57ac17d22a2b87ffccf6ba036ee57", "committedDate": "2021-12-13 22:54:56 +0900", "message": "Add HttpResponseBuilder to fluently build `HttpResponse` (#3941)"}, {"oid": "b865beefeab3d31b09789ffca065a5de58101d9a", "committedDate": "2022-01-21 20:06:21 +0900", "message": "Add `peek` operators (#3988)"}, {"oid": "1aa5b32158b87485794edfd18de27869d23597d9", "committedDate": "2022-03-22 20:24:42 +0900", "message": "Add `StreamMessage.decode()` (#4152)"}, {"oid": "bf792d4465756738f30937241403e02da1b1efd6", "committedDate": "2022-07-05 15:26:25 +0900", "message": "Recover HttpResponse according to a specific exception class (#4283)"}, {"oid": "712cb0d8623f637cc241491815f912c11c90e63a", "committedDate": "2022-09-08 12:09:46 +0900", "message": "Cache an aggregated result of a `StreamMessage` for non-pooled objects (#4366)"}, {"oid": "9e7c016e45be91d2b0a48c1ff258e100e9c655c5", "committedDate": "2022-10-05 11:04:21 +0900", "message": "Return cached aggregated message for following withPooledObjects call (#4449)"}]}, {"oid": "2f5a5791685d692b512407a8c38fc2c416ab7767", "url": "https://github.com/line/armeria/commit/2f5a5791685d692b512407a8c38fc2c416ab7767", "message": "Address comments by @trustin / Remove subcription options from `split()`", "committedDate": "2020-11-13T07:08:25Z", "type": "commit"}, {"oid": "b3e0ae2d3bed932aaa025c2cb12a6818a0b04383", "url": "https://github.com/line/armeria/commit/b3e0ae2d3bed932aaa025c2cb12a6818a0b04383", "message": "Fix checkstyle", "committedDate": "2020-11-16T05:08:58Z", "type": "commit"}, {"oid": "c0f8108deaf18e5e4b395de3bf0f581c107f085c", "url": "https://github.com/line/armeria/commit/c0f8108deaf18e5e4b395de3bf0f581c107f085c", "message": "Merge branch 'master' into body-stream", "committedDate": "2020-11-16T09:20:29Z", "type": "commit"}, {"oid": "3b032bd18d0ba94d520b5c605a4b6f02b83bed9a", "url": "https://github.com/line/armeria/commit/3b032bd18d0ba94d520b5c605a4b6f02b83bed9a", "message": "Fix broken test", "committedDate": "2020-11-16T10:07:54Z", "type": "commit"}, {"oid": "bfc30e38c80f9534e16473d7eb65196cabe0d360", "url": "https://github.com/line/armeria/commit/bfc30e38c80f9534e16473d7eb65196cabe0d360", "message": "Address comments by @minwoox", "committedDate": "2020-11-16T12:16:22Z", "type": "commit"}]}