{"pr_number": 3869, "pr_title": "DB-9760 Make temporary tables local to their sessions", "pr_createdAt": "2020-07-20T16:18:40Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3869", "merge_commit": "bc05b26d7af4273926fb5932900faed3f8ec2593", "timeline": [{"oid": "7c51095f4ba09111b4eada3156ce4be4c10f1fe2", "url": "https://github.com/splicemachine/spliceengine/commit/7c51095f4ba09111b4eada3156ce4be4c10f1fe2", "message": "DB-9760 Make temporary tables local to their sessions", "committedDate": "2020-07-20T23:12:56Z", "type": "forcePushed"}, {"oid": "9b10842d89126273d5d2d0eae46939cb8dfb81ed", "url": "https://github.com/splicemachine/spliceengine/commit/9b10842d89126273d5d2d0eae46939cb8dfb81ed", "message": "DB-9760 Make temporary tables local to their sessions", "committedDate": "2020-07-21T09:29:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NjU4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r471856588", "body": "Remove this?", "bodyText": "Remove this?", "bodyHTML": "<p dir=\"auto\">Remove this?</p>", "author": "jyuanca", "createdAt": "2020-08-18T01:09:23Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -59,7 +57,7 @@\n {\n \tboolean\t\t\t\tunique;\n \tboolean\t\t\t\tuniqueWithDuplicateNulls;\n-\tDataDictionary\t\tdd = null;\n+//\tDataDictionary\t\tdd = null;\n \tProperties\t\t\tproperties;", "originalCommit": "9b10842d89126273d5d2d0eae46939cb8dfb81ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5MDY5Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r474690696", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-08-21T13:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NjU4OA=="}], "type": "inlineReview", "revised_code": {"commit": "a7bb26dbcb9bc02ba2a10d8846083892a1012eeb", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 6aa4dbec67..9fa2637262 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -57,7 +57,6 @@ public class CreateIndexNode extends DDLStatementNode\n {\n \tboolean\t\t\t\tunique;\n \tboolean\t\t\t\tuniqueWithDuplicateNulls;\n-//\tDataDictionary\t\tdd = null;\n \tProperties\t\t\tproperties;\n \tString\t\t\t\tindexType;\n \tTableName\t\t\tindexName;\n", "next_change": {"commit": "66c676e435459fd9a9e43be92eaae91deafff981", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 9fa2637262..6aa4dbec67 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -57,6 +57,7 @@ public class CreateIndexNode extends DDLStatementNode\n {\n \tboolean\t\t\t\tunique;\n \tboolean\t\t\t\tuniqueWithDuplicateNulls;\n+//\tDataDictionary\t\tdd = null;\n \tProperties\t\t\tproperties;\n \tString\t\t\t\tindexType;\n \tTableName\t\t\tindexName;\n", "next_change": {"commit": "bd881e2ffec2a8f4c2915e18b989fd15e2f65ff8", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 6aa4dbec67..9fa2637262 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -57,7 +57,6 @@ public class CreateIndexNode extends DDLStatementNode\n {\n \tboolean\t\t\t\tunique;\n \tboolean\t\t\t\tuniqueWithDuplicateNulls;\n-//\tDataDictionary\t\tdd = null;\n \tProperties\t\t\tproperties;\n \tString\t\t\t\tindexType;\n \tTableName\t\t\tindexName;\n", "next_change": {"commit": "47e6e56b01a9a55cb521becdd524f7a70a9518b2", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 9fa2637262..a3516b5b02 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -55,56 +62,61 @@ import java.util.Vector;\n \n public class CreateIndexNode extends DDLStatementNode\n {\n-\tboolean\t\t\t\tunique;\n-\tboolean\t\t\t\tuniqueWithDuplicateNulls;\n-\tProperties\t\t\tproperties;\n-\tString\t\t\t\tindexType;\n-\tTableName\t\t\tindexName;\n-\tTableName\t\t\ttableName;\n-\tVector\t\t\t\tcolumnNameList;\n-\tString[]\t\t\tcolumnNames = null;\n-\tboolean[]\t\t\tisAscending;\n-\tint[]\t\t\t\tboundColumnIDs;\n-\tboolean \t\t\texcludeNulls;\n-\tboolean\t\t\t\texcludeDefaults;\n-    boolean             preSplit;\n-\tboolean             isLogicalKey;\n-    boolean             sampling;\n-\tdouble              sampleFraction;\n-    String              splitKeyPath;\n-    String              hfilePath;\n-    String              columnDelimiter;\n-    String              characterDelimiter;\n-    String              timestampFormat;\n-    String              dateFormat;\n-    String              timeFormat;\n-\n-\n-\tTableDescriptor\t\ttd;\n-\n-\t/**\n-\t * Initializer for a CreateIndexNode\n-\t *\n-\t * @param unique\tTrue means it's a unique index\n-\t * @param indexType\tThe type of index\n-\t * @param indexName\tThe name of the index\n-\t * @param tableName\tThe name of the table the index will be on\n-\t * @param columnNameList\tA list of column names, in the order they\n-\t *\t\t\t\t\t\t\tappear in the index.\n-\t * @param properties\tThe optional properties list associated with the index.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void init(\n-\t\t\t\t\tObject unique,\n-\t\t\t\t\tObject indexType,\n-\t\t\t\t\tObject indexName,\n-\t\t\t\t\tObject tableName,\n-\t\t\t\t\tObject columnNameList,\n-\t\t\t\t\tObject excludeNulls,\n-\t\t\t\t\tObject excludeDefaults,\n+    boolean                 unique;\n+    boolean                 uniqueWithDuplicateNulls;\n+    DataDictionary          dd = null;\n+    Properties              properties;\n+    String                  indexType;\n+    TableName               indexName;\n+    TableName               tableName;\n+    Vector<IndexExpression> expressionList;\n+    String[]                involvedColumnNames = null;\n+    boolean[]               isAscending;\n+    int[]                   boundColumnIDs;\n+    boolean                 excludeNulls;\n+    boolean                 excludeDefaults;\n+    boolean                 preSplit;\n+    boolean                 isLogicalKey;\n+    boolean                 sampling;\n+    double                  sampleFraction;\n+    String                  splitKeyPath;\n+    String                  hfilePath;\n+    String                  columnDelimiter;\n+    String                  characterDelimiter;\n+    String                  timestampFormat;\n+    String                  dateFormat;\n+    String                  timeFormat;\n+    boolean                 onExpression;\n+    String[]                exprTexts;\n+    ByteArray[]             exprBytecode;\n+    String[]                generatedClassNames;\n+    DataTypeDescriptor[]    indexColumnTypes;\n+\n+    TableDescriptor         td;\n+\n+    /**\n+     * Initializer for a CreateIndexNode\n+     *\n+     * @param unique            True means it's a unique index\n+     * @param indexType         The type of index\n+     * @param indexName         The name of the index\n+     * @param tableName         The name of the table the index will be on\n+     * @param expressionList    A list of index key expressions, in the order they\n+     *                            appear in the index.\n+     * @param properties        The optional properties list associated with the index.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void init(\n+                    Object unique,\n+                    Object indexType,\n+                    Object indexName,\n+                    Object tableName,\n+                    Object expressionList,\n+                    Object excludeNulls,\n+                    Object excludeDefaults,\n                     Object preSplit,\n-\t\t\t\t\tObject isLogicalKey,\n+                    Object isLogicalKey,\n                     Object sampling,\n                     Object sampleFraction,\n                     Object splitKeyPath,\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "bc05b26d7af4273926fb5932900faed3f8ec2593", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 6aa4dbec67..a3516b5b02 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -55,57 +62,61 @@ import java.util.Vector;\n \n public class CreateIndexNode extends DDLStatementNode\n {\n-\tboolean\t\t\t\tunique;\n-\tboolean\t\t\t\tuniqueWithDuplicateNulls;\n-//\tDataDictionary\t\tdd = null;\n-\tProperties\t\t\tproperties;\n-\tString\t\t\t\tindexType;\n-\tTableName\t\t\tindexName;\n-\tTableName\t\t\ttableName;\n-\tVector\t\t\t\tcolumnNameList;\n-\tString[]\t\t\tcolumnNames = null;\n-\tboolean[]\t\t\tisAscending;\n-\tint[]\t\t\t\tboundColumnIDs;\n-\tboolean \t\t\texcludeNulls;\n-\tboolean\t\t\t\texcludeDefaults;\n-    boolean             preSplit;\n-\tboolean             isLogicalKey;\n-    boolean             sampling;\n-\tdouble              sampleFraction;\n-    String              splitKeyPath;\n-    String              hfilePath;\n-    String              columnDelimiter;\n-    String              characterDelimiter;\n-    String              timestampFormat;\n-    String              dateFormat;\n-    String              timeFormat;\n-\n-\n-\tTableDescriptor\t\ttd;\n-\n-\t/**\n-\t * Initializer for a CreateIndexNode\n-\t *\n-\t * @param unique\tTrue means it's a unique index\n-\t * @param indexType\tThe type of index\n-\t * @param indexName\tThe name of the index\n-\t * @param tableName\tThe name of the table the index will be on\n-\t * @param columnNameList\tA list of column names, in the order they\n-\t *\t\t\t\t\t\t\tappear in the index.\n-\t * @param properties\tThe optional properties list associated with the index.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void init(\n-\t\t\t\t\tObject unique,\n-\t\t\t\t\tObject indexType,\n-\t\t\t\t\tObject indexName,\n-\t\t\t\t\tObject tableName,\n-\t\t\t\t\tObject columnNameList,\n-\t\t\t\t\tObject excludeNulls,\n-\t\t\t\t\tObject excludeDefaults,\n+    boolean                 unique;\n+    boolean                 uniqueWithDuplicateNulls;\n+    DataDictionary          dd = null;\n+    Properties              properties;\n+    String                  indexType;\n+    TableName               indexName;\n+    TableName               tableName;\n+    Vector<IndexExpression> expressionList;\n+    String[]                involvedColumnNames = null;\n+    boolean[]               isAscending;\n+    int[]                   boundColumnIDs;\n+    boolean                 excludeNulls;\n+    boolean                 excludeDefaults;\n+    boolean                 preSplit;\n+    boolean                 isLogicalKey;\n+    boolean                 sampling;\n+    double                  sampleFraction;\n+    String                  splitKeyPath;\n+    String                  hfilePath;\n+    String                  columnDelimiter;\n+    String                  characterDelimiter;\n+    String                  timestampFormat;\n+    String                  dateFormat;\n+    String                  timeFormat;\n+    boolean                 onExpression;\n+    String[]                exprTexts;\n+    ByteArray[]             exprBytecode;\n+    String[]                generatedClassNames;\n+    DataTypeDescriptor[]    indexColumnTypes;\n+\n+    TableDescriptor         td;\n+\n+    /**\n+     * Initializer for a CreateIndexNode\n+     *\n+     * @param unique            True means it's a unique index\n+     * @param indexType         The type of index\n+     * @param indexName         The name of the index\n+     * @param tableName         The name of the table the index will be on\n+     * @param expressionList    A list of index key expressions, in the order they\n+     *                            appear in the index.\n+     * @param properties        The optional properties list associated with the index.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void init(\n+                    Object unique,\n+                    Object indexType,\n+                    Object indexName,\n+                    Object tableName,\n+                    Object expressionList,\n+                    Object excludeNulls,\n+                    Object excludeDefaults,\n                     Object preSplit,\n-\t\t\t\t\tObject isLogicalKey,\n+                    Object isLogicalKey,\n                     Object sampling,\n                     Object sampleFraction,\n                     Object splitKeyPath,\n", "next_change": null}]}, "commits_in_main": [{"oid": "bc05b26d7af4273926fb5932900faed3f8ec2593", "message": "Merge commit", "committedDate": null}, {"oid": "10e4e4f25d082d24e64b14bc02ad35f07a6c99cc", "committedDate": "2020-09-24 13:45:08 -0700", "message": "Revert \"DB-9760 Make temporary tables local to their sessions (#3869)\""}, {"oid": "32b7426ea26292537449ca4cd267334ec1f07676", "committedDate": "2020-09-29 10:07:43 -0700", "message": "Redo DB-9760 Make temporary tables local to their sessions and fix name clash check (#4189)"}, {"oid": "c41014bf2b27e6ce68d42de62f80062c98a88dda", "committedDate": "2020-12-08 15:34:59 -0600", "message": "DB-10972 Check duplicate expressions in creating an index on expressions (#4801)"}, {"oid": "79e71ee1e3434d7015d79299e7dccbe5b89ebfe3", "committedDate": "2021-02-04 21:41:18 -0600", "message": "DB-10968/DB-11156 SET_GLOBAL_DATABASE_PROPERTY should check existence of properties, restrict execution of GET_REGION_SERVER_CONFIG_INFO (#5063)"}, {"oid": "fac6aac9737565b427241295da9022c62c100d76", "committedDate": "2021-02-05 16:20:01 -0600", "message": "Revert \"DB-10968/DB-11156 SET_GLOBAL_DATABASE_PROPERTY should check existence of properties, restrict execution of GET_REGION_SERVER_CONFIG_INFO (#5063)\" (#5123)"}, {"oid": "ab9ee970b979d9ef3778d4580c1dd77296fd97d0", "committedDate": "2021-02-19 21:51:01 -0800", "message": "Redo DB-10968 SET_GLOBAL_DATABASE_PROPERTY should check existence of properties, restrict execution of GET_REGION_SERVER_CONFIG_INFO (#5139)"}, {"oid": "d3b221752d40496313e5cb0ac50f000d6dbb0d19", "committedDate": "2021-02-20 10:30:42 -0800", "message": "Revert \"Redo DB-10968 SET_GLOBAL_DATABASE_PROPERTY should check existence of properties, restrict execution of GET_REGION_SERVER_CONFIG_INFO (#5139)\""}, {"oid": "6f95be2e08ddbac6a492ad0f6a082100d258496a", "committedDate": "2021-02-25 20:05:53 +0000", "message": "Redo DB-10968 SET_GLOBAL_DATABASE_PROPERTY should check existence of properties, restrict execution of GET_REGION_SERVER_CONFIG_INFO (#5223)"}, {"oid": "e8a84ac5778f3d0a355e4c6bfecbf41eb310a48f", "committedDate": "2021-04-20 08:28:00 -0700", "message": "DB-11224 Don't set exclude null/default flags of an index when they have no effect (#5392)"}, {"oid": "a961bde921bbafbfd07333dca135822d8fd193d9", "committedDate": "2021-06-07 09:07:13 +0200", "message": "DB-10961 Get rid of the NodeFactory part 2 (#5483)"}, {"oid": "30b6ae8cbf9045a375e9da09feaf7c1138294cf6", "committedDate": "2021-06-15 23:32:08 +0200", "message": "DB-10193 Multidatabase support  (#4206)"}, {"oid": "e6da25601db3ca0ed4b326f0b659ce69966220c1", "committedDate": "2021-06-16 14:04:33 +0200", "message": "DB-10961 Get rid of the NodeFactory part 3 (#5534)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NjY2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r471856664", "body": "Same here", "bodyText": "Same here", "bodyHTML": "<p dir=\"auto\">Same here</p>", "author": "jyuanca", "createdAt": "2020-08-18T01:09:43Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -292,9 +297,9 @@ public ConstantAction\tmakeConstantAction() throws StandardException\n \t{\n \t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n \n-\t\tint columnCount = columnNames.length;\n+//\t\tint columnCount = columnNames.length;\n \t\tint approxLength = 0;\n-\t\tboolean index_has_long_column = false;\n+//\t\tboolean index_has_long_column = false;\n ", "originalCommit": "9b10842d89126273d5d2d0eae46939cb8dfb81ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5MTEwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r474691101", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-08-21T13:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NjY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "a7bb26dbcb9bc02ba2a10d8846083892a1012eeb", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 6aa4dbec67..9fa2637262 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -296,11 +295,7 @@ public class CreateIndexNode extends DDLStatementNode\n \tpublic ConstantAction\tmakeConstantAction() throws StandardException\n \t{\n \t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n-\n-//\t\tint columnCount = columnNames.length;\n \t\tint approxLength = 0;\n-//\t\tboolean index_has_long_column = false;\n-\n \n \t\t// bump the page size for the index,\n \t\t// if the approximate sizes of the columns in the key are\n", "next_change": {"commit": "66c676e435459fd9a9e43be92eaae91deafff981", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 9fa2637262..6aa4dbec67 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -295,7 +296,11 @@ public class CreateIndexNode extends DDLStatementNode\n \tpublic ConstantAction\tmakeConstantAction() throws StandardException\n \t{\n \t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n+\n+//\t\tint columnCount = columnNames.length;\n \t\tint approxLength = 0;\n+//\t\tboolean index_has_long_column = false;\n+\n \n \t\t// bump the page size for the index,\n \t\t// if the approximate sizes of the columns in the key are\n", "next_change": {"commit": "bd881e2ffec2a8f4c2915e18b989fd15e2f65ff8", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 6aa4dbec67..9fa2637262 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -296,11 +295,7 @@ public class CreateIndexNode extends DDLStatementNode\n \tpublic ConstantAction\tmakeConstantAction() throws StandardException\n \t{\n \t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n-\n-//\t\tint columnCount = columnNames.length;\n \t\tint approxLength = 0;\n-//\t\tboolean index_has_long_column = false;\n-\n \n \t\t// bump the page size for the index,\n \t\t// if the approximate sizes of the columns in the key are\n", "next_change": {"commit": "47e6e56b01a9a55cb521becdd524f7a70a9518b2", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\nindex 9fa2637262..a3516b5b02 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java\n", "chunk": "@@ -137,173 +150,274 @@ public class CreateIndexNode extends DDLStatementNode\n         this.dateFormat = dateFormat != null ? ((CharConstantNode)dateFormat).getString() : null;\n         this.timeFormat = timeFormat != null ? ((CharConstantNode)timeFormat).getString() : null;\n         this.hfilePath = hfilePath != null ? ((CharConstantNode)hfilePath).getString() : null;\n-\t}\n-\n-\t/**\n-\t * Convert this object to a String.  See comments in QueryTreeNode.java\n-\t * for how this should be done for tree printing.\n-\t *\n-\t * @return\tThis object as a String\n-\t */\n-\n-\tpublic String toString()\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\treturn super.toString() +\n-\t\t\t\t\"unique: \" + unique + \"\\n\" +\n-\t\t\t\t\"indexType: \" + indexType + \"\\n\" +\n-\t\t\t\t\"indexName: \" + indexName + \"\\n\" +\n-\t\t\t\t\"tableName: \" + tableName + \"\\n\" +\n-\t\t\t\t\"properties: \" + properties + \"\\n\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn \"\";\n-\t\t}\n-\t}\n-\n-\tpublic String statementToString()\n-\t{\n-\t\treturn \"CREATE INDEX\";\n-\t}\n-\n-\n-\tpublic\tboolean\t\t\t\tgetUniqueness() { return unique; }\n-\tpublic\tString\t\t\t\tgetIndexType() { return indexType; }\n-\tpublic\tTableName\t\t\tgetIndexName() { return indexName; }\n-\tpublic\tUUID\t\t\t\tgetBoundTableID() { return td.getUUID(); }\n-    public\tProperties\t\t\tgetProperties() { return properties; }\n-\tpublic  TableName\t\t\tgetIndexTableName() {return tableName; }\n-\tpublic  String[]\t\t\tgetColumnNames() { return columnNames; }\n-\n-\t// get 1-based column ids\n-\tpublic\tint[]\t\t\t\tgetKeyColumnIDs() { return boundColumnIDs; }\n-\tpublic\tboolean[]\t\t\tgetIsAscending() { return isAscending; }\n-\n-\t// We inherit the generate() method from DDLStatementNode.\n-\n-\t/**\n-\t * Bind this CreateIndexNode.  This means doing any static error\n-\t * checking that can be done before actually creating the table.\n-\t * For example, verifying that the column name list does not\n-\t * contain any duplicate column names.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\n-\tpublic void bindStatement() throws StandardException\n-\t{\n-\t\tint\tcolumnCount;\n-\n-/*\t\tSchemaDescriptor sd = getSchemaDescriptor(); */\n-\t\ttd = getTableDescriptor(tableName);\n-\n-\t\t//If total number of indexes on the table so far is more than 32767, then we need to throw an exception\n-/*\t\tif (td.getTotalNumberOfIndexes() > Limits.DB2_MAX_INDEXES_ON_TABLE)\n-\t\t{\n-\t\t\tthrow StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE,\n-\t\t\t\tString.valueOf(td.getTotalNumberOfIndexes()),\n-\t\t\t\ttableName,\n-\t\t\t\tString.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));\n-\t\t}\n+        this.onExpression = isIndexOnExpression();\n+        int exprSize = this.onExpression ? this.expressionList.size() : 0;\n+        this.exprTexts = new String[exprSize];\n+        this.exprBytecode = new ByteArray[exprSize];\n+        this.generatedClassNames = new String[exprSize];\n+        this.indexColumnTypes = new DataTypeDescriptor[exprSize];\n+    }\n+\n+    /**\n+     * Convert this object to a String.  See comments in QueryTreeNode.java\n+     * for how this should be done for tree printing.\n+     *\n+     * @return    This object as a String\n+     */\n+\n+    public String toString()\n+    {\n+        if (SanityManager.DEBUG)\n+        {\n+            return super.toString() +\n+                \"unique: \" + unique + \"\\n\" +\n+                \"indexType: \" + indexType + \"\\n\" +\n+                \"indexName: \" + indexName + \"\\n\" +\n+                \"tableName: \" + tableName + \"\\n\" +\n+                \"properties: \" + properties + \"\\n\";\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    public String statementToString()\n+    {\n+        return \"CREATE INDEX\";\n+    }\n+\n+\n+    public  boolean     getUniqueness()     { return unique; }\n+    public  String      getIndexType()      { return indexType; }\n+    public  TableName   getIndexName()      { return indexName; }\n+    public  UUID        getBoundTableID()   { return td.getUUID(); }\n+    public  Properties  getProperties()     { return properties; }\n+    public  TableName   getIndexTableName() { return tableName; }\n+    public  String[]    getColumnNames()    { return involvedColumnNames; }\n+\n+    // get 1-based column ids\n+    public  int[]       getKeyColumnIDs()   { return boundColumnIDs; }\n+    public  boolean[]   getIsAscending()    { return isAscending; }\n+\n+    // We inherit the generate() method from DDLStatementNode.\n+\n+    /**\n+     * Bind this CreateIndexNode.  This means doing any static error\n+     * checking that can be done before actually creating the table.\n+     * For example, verifying that the column name list does not\n+     * contain any duplicate column names.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public void bindStatement() throws StandardException\n+    {\n+        int columnCount;\n+        td = getTableDescriptor(tableName);\n+\n+        //If total number of indexes on the table so far is more than 32767, then we need to throw an exception\n+/*        if (td.getTotalNumberOfIndexes() > Limits.DB2_MAX_INDEXES_ON_TABLE)\n+        {\n+            throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE,\n+                String.valueOf(td.getTotalNumberOfIndexes()),\n+                tableName,\n+                String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));\n+        }\n */\n-\t\t/* Validate the column name list */\n-\t\tverifyAndGetUniqueNames();\n-\n-\t\tcolumnCount = columnNames.length;\n-\t\tboundColumnIDs = new int[ columnCount ];\n-\n-\t\t// Verify that the columns exist\n-\t\tfor (int i = 0; i < columnCount; i++)\n-\t\t{\n-\t\t\tColumnDescriptor\t\t\tcolumnDescriptor;\n-\n-\t\t\tcolumnDescriptor = td.getColumnDescriptor(columnNames[i]);\n-\t\t\tif (columnDescriptor == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumnNames[i],\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttableName);\n-\t\t\t}\n-\t\t\tboundColumnIDs[ i ] = columnDescriptor.getPosition();\n-\t\t\t\n-\t\t\t// set this only once -- if just one column does is missing \"not null\" constraint in schema\n-\t\t\tuniqueWithDuplicateNulls = (! uniqueWithDuplicateNulls && (unique && ! columnDescriptor.hasNonNullDefault()));\n-\n-\t\t\t// Don't allow a column to be created on a non-orderable type\n-\t\t\tif ( ! columnDescriptor.getType().getTypeId().\n-\t\t\t\t\t\t\t\t\t\t\t\torderable(getClassFactory()))\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION,\n-\t\t\t\t\tcolumnDescriptor.getType().getTypeId().getSQLTypeName());\n-\t\t\t}\n-\t\t}\n-\n-\t\t/* Check for number of key columns to be less than 16 to match DB2 */\n-/*\t\tif (columnCount > 16)\n-\t\t\tthrow StandardException.newException(SQLState.LANG_TOO_MANY_INDEX_KEY_COLS);\n+        /* Validate the column name list */\n+        verifyAndGetUniqueNames();\n+\n+        columnCount = involvedColumnNames.length;\n+        boundColumnIDs = new int[ columnCount ];\n+\n+        // Verify that the columns exist\n+        for (int i = 0; i < columnCount; i++)\n+        {\n+            ColumnDescriptor columnDescriptor;\n+\n+            columnDescriptor = td.getColumnDescriptor(involvedColumnNames[i]);\n+            if (columnDescriptor == null)\n+            {\n+                throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,\n+                        involvedColumnNames[i], tableName);\n+            }\n+            boundColumnIDs[ i ] = columnDescriptor.getPosition();\n+            \n+            // set this only once -- if just one column does is missing \"not null\" constraint in schema\n+            uniqueWithDuplicateNulls = (! uniqueWithDuplicateNulls && (unique && ! columnDescriptor.hasNonNullDefault()));\n+\n+            // Don't allow a column to be created on a non-orderable type\n+            if ( ! columnDescriptor.getType().getTypeId().orderable(getClassFactory()))\n+            {\n+                // Note that this exception is not SQL state 429BX, same as DB2 but not compatible.\n+                throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION,\n+                        columnDescriptor.getType().getTypeId().getSQLTypeName());\n+            }\n+        }\n+\n+        /* Check for number of key columns to be less than 16 to match DB2 */\n+/*        if (columnCount > 16)\n+            throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEX_KEY_COLS);\n */\n-\t\t/* See if the index already exists in this schema.\n-\t\t * NOTE: We still need to check at execution time\n-\t\t * since the index name is only unique to the schema,\n-\t\t * not the table.\n-\t\t */\n-//  \t\tif (dd.getConglomerateDescriptor(indexName.getTableName(), sd, false) != null)\n-//  \t\t{\n-//  \t\t\tthrow StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n-//  \t\t\t\t\t\t\t\t\t\t\t\t \"Index\",\n-//  \t\t\t\t\t\t\t\t\t\t\t\t indexName.getTableName(),\n-//  \t\t\t\t\t\t\t\t\t\t\t\t \"schema\",\n-//  \t\t\t\t\t\t\t\t\t\t\t\t sd.getSchemaName());\n-//  \t\t}\n-\n-\t\t/* Statement is dependent on the TableDescriptor */\n-\t\tgetCompilerContext().createDependency(td);\n-\n-\t}\n-\n-\t/**\n-\t * Return true if the node references SESSION schema tables (temporary or permanent)\n-\t *\n-\t * @return\ttrue if references SESSION schema tables, else false\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic boolean referencesSessionSchema()\n-\t\tthrows StandardException\n-\t{\n-\t\t//If create index is on a SESSION schema table, then return true.\n-\t\treturn isSessionSchema(td.getSchemaName());\n-\t}\n-\n-\t/**\n-\t * Return true if the node references temporary tables no matter under which schema\n-\t *\n-\t * @return true if references temporary tables, else false\n-\t */\n-\t@Override\n-\tpublic boolean referencesTemporaryTable() {\n-\t\treturn td.isTemporary();\n-\t}\n-\n-\t/**\n-\t * Create the Constant information that will drive the guts of Execution.\n-\t *\n-\t * @exception StandardException\t\tThrown on failure\n-\t */\n-\tpublic ConstantAction\tmakeConstantAction() throws StandardException\n-\t{\n-\t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n-\t\tint approxLength = 0;\n-\n-\t\t// bump the page size for the index,\n-\t\t// if the approximate sizes of the columns in the key are\n-\t\t// greater than the bump threshold.\n-\t\t// Ideally, we would want to have atleast 2 or 3 keys fit in one page\n-\t\t// With fix for beetle 5728, indexes on long types is not allowed\n-\t\t// so we do not have to consider key columns of long types\n-        for (String columnName : columnNames) {\n+        /* See if the index already exists in this schema.\n+         * NOTE: We still need to check at execution time\n+         * since the index name is only unique to the schema,\n+         * not the table.\n+         */\n+//          if (dd.getConglomerateDescriptor(indexName.getTableName(), sd, false) != null)\n+//          {\n+//              throw StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n+//                                                   \"Index\",\n+//                                                   indexName.getTableName(),\n+//                                                   \"schema\",\n+//                                                   sd.getSchemaName());\n+//          }\n+\n+        if (onExpression) {\n+            bindIndexExpressions();\n+        }\n+\n+        /* Statement is dependent on the TableDescriptor */\n+        getCompilerContext().createDependency(td);\n+\n+    }\n+\n+    private void bindIndexExpressions() throws StandardException {\n+        if (!onExpression)\n+            return;\n+\n+        // fake a FromList to bind index expressions\n+        FromList fromList = (FromList) getNodeFactory().getNode(\n+                C_NodeTypes.FROM_LIST,\n+                getNodeFactory().doJoinOrderOptimization(),\n+                getContextManager());\n+        FromTable fromTable = (FromTable) getNodeFactory().getNode(\n+                C_NodeTypes.FROM_BASE_TABLE,\n+                tableName,\n+                null, null, null, false, null,\n+                getContextManager());\n+        fromList.addFromTable(fromTable);\n+        fromList.bindTables(\n+                dd,\n+                (FromList) getNodeFactory().getNode(\n+                        C_NodeTypes.FROM_LIST,\n+                        getNodeFactory().doJoinOrderOptimization(),\n+                        getContextManager()\n+                )\n+        );\n+\n+        // The following checks are done based on DB2 documentation on CREATE INDEX statement:\n+        // https://www.ibm.com/support/knowledgecenter/en/SSEPGG_11.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000919.html\n+\n+        CollectingVisitor<QueryTreeNode> restrictionVisitor = new CollectingVisitor<>(\n+                Predicates.or(\n+                        Predicates.instanceOf(SubqueryNode.class),\n+                        Predicates.instanceOf(AggregateNode.class),\n+                        Predicates.instanceOf(StringAggregateNode.class),\n+                        Predicates.instanceOf(WrappedAggregateFunctionNode.class),\n+                        Predicates.instanceOf(WindowFunctionNode.class),\n+                        Predicates.instanceOf(CurrentDatetimeOperatorNode.class),  // current_time(), now(), etc.\n+                        Predicates.instanceOf(CurrentOfNode.class),                // current of cursor\n+                        Predicates.instanceOf(NextSequenceNode.class),\n+                        Predicates.instanceOf(SpecialFunctionNode.class),          // current session functions\n+                        Predicates.instanceOf(ParameterNode.class),\n+                        Predicates.instanceOf(LikeEscapeOperatorNode.class)        // like predicate\n+                ));\n+\n+        HashSet<String> notAllowedFunctions = Stream.of(\n+                \"rand\", \"random\", \"regexp_like\", \"instr\", \"locate\", \"stddev_pop\", \"stddev_samp\"\n+        ).collect(Collectors.toCollection(HashSet::new));\n+\n+        CollectingVisitor<QueryTreeNode> fnVisitor = new CollectingVisitor<>(\n+                Predicates.or(\n+                        Predicates.instanceOf(StaticMethodCallNode.class),\n+                        Predicates.instanceOf(TernaryOperatorNode.class)\n+                ));\n+\n+        for (int i = 0; i < expressionList.size(); i++) {\n+            IndexExpression ie = expressionList.elementAt(i);\n+            ie.expression.bindExpression(fromList, new SubqueryList(), new ArrayList<AggregateNode>() {});\n+\n+            // check invalid nodes\n+            ie.expression.accept(restrictionVisitor);\n+            if (!restrictionVisitor.getCollected().isEmpty()) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_INDEX_EXPRESSION, ie.exprText);\n+            }\n+            restrictionVisitor.getCollected().clear();\n+\n+            // check invalid functions (including UDFs)\n+            ie.expression.accept(fnVisitor);\n+            List<QueryTreeNode> fnList = fnVisitor.getCollected();\n+            for (QueryTreeNode fnNode : fnList) {\n+                if (fnNode instanceof StaticMethodCallNode) {\n+                    StaticMethodCallNode fn = (StaticMethodCallNode) fnNode;\n+                    if (!fn.isSystemFunction() || notAllowedFunctions.contains(fn.getMethodName().toLowerCase())) {\n+                        throw StandardException.newException(SQLState.LANG_INVALID_INDEX_EXPRESSION, ie.exprText);\n+                    }\n+                } else if (fnNode instanceof TernaryOperatorNode) {\n+                    TernaryOperatorNode fn = (TernaryOperatorNode) fnNode;\n+                    if (notAllowedFunctions.contains(fn.methodName.toLowerCase())) {\n+                        throw StandardException.newException(SQLState.LANG_INVALID_INDEX_EXPRESSION, ie.exprText);\n+                    }\n+                }\n+            }\n+            fnList.clear();\n+\n+            // check return type\n+            DataTypeDescriptor dtd = ie.expression.getTypeServices();\n+            if (!dtd.getTypeId().orderable(getClassFactory())) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_INDEX_EXPRESSION, ie.exprText);\n+            }\n+            indexColumnTypes[i] = dtd;\n+        }\n+    }\n+\n+    /**\n+     * Return true if the node references SESSION schema tables (temporary or permanent)\n+     *\n+     * @return    true if references SESSION schema tables, else false\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public boolean referencesSessionSchema()\n+        throws StandardException\n+    {\n+        //If create index is on a SESSION schema table, then return true.\n+        return isSessionSchema(td.getSchemaName());\n+    }\n+\n+    /**\n+     * Return true if the node references temporary tables no matter under which schema\n+     *\n+     * @return true if references temporary tables, else false\n+     */\n+    @Override\n+    public boolean referencesTemporaryTable() {\n+        return td.isTemporary();\n+    }\n+\n+    /**\n+     * Create the Constant information that will drive the guts of Execution.\n+     *\n+     * @exception StandardException        Thrown on failure\n+     */\n+    public ConstantAction    makeConstantAction() throws StandardException\n+    {\n+        SchemaDescriptor sd = getSchemaDescriptor();\n+        int approxLength = 0;\n+\n+        if (onExpression) {\n+            generateExecutableIndexExpression();\n+        }\n+\n+        // bump the page size for the index,\n+        // if the approximate sizes of the columns in the key are\n+        // greater than the bump threshold.\n+        // Ideally, we would want to have atleast 2 or 3 keys fit in one page\n+        // With fix for beetle 5728, indexes on long types is not allowed\n+        // so we do not have to consider key columns of long types\n+        for (String columnName : involvedColumnNames) {\n             ColumnDescriptor columnDescriptor = td.getColumnDescriptor(columnName);\n             DataTypeDescriptor dts = columnDescriptor.getType();\n             approxLength += dts.getTypeId().getApproximateLengthInBytes(dts);\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDcwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r471900702", "body": "Session schema is for storing global temporary tables.\r\nhttp://db.apache.org/derby/docs/10.0/manuals/reference/sqlj33.html\r\n\r\nHowever, it seems we never implement global temporary tables correctly. We may want to file a Jira and fix it.", "bodyText": "Session schema is for storing global temporary tables.\nhttp://db.apache.org/derby/docs/10.0/manuals/reference/sqlj33.html\nHowever, it seems we never implement global temporary tables correctly. We may want to file a Jira and fix it.", "bodyHTML": "<p dir=\"auto\">Session schema is for storing global temporary tables.<br>\n<a href=\"http://db.apache.org/derby/docs/10.0/manuals/reference/sqlj33.html\" rel=\"nofollow\">http://db.apache.org/derby/docs/10.0/manuals/reference/sqlj33.html</a></p>\n<p dir=\"auto\">However, it seems we never implement global temporary tables correctly. We may want to file a Jira and fix it.</p>", "author": "jyuanca", "createdAt": "2020-08-18T04:03:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/QueryTreeNode.java", "diffHunk": "@@ -1408,13 +1424,20 @@ protected final TableDescriptor getTableDescriptor(String tableName,\n         if(schema.getUUID()==null)\n             return null;\n \n+        //If not in session schema, look for local temporary table first.\n+        //If tables is not under SESSION schema, don't get it from LCC. Table version is not set there.", "originalCommit": "9b10842d89126273d5d2d0eae46939cb8dfb81ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5NDA1Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r474694057", "bodyText": "Yes, I had a discussion with Gene and Carol about this issue, and they think we should keep the current temporary tables implementation (not in SESSION schema) for now. This renders many places in derby useless since referencesSessionSchema() doesn't work for temporary tables. And it's the main reason that I introduce a new \"referencesTemporaryTables()\".", "author": "ascend1", "createdAt": "2020-08-21T13:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwMDcwMg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "a7bb26dbcb9bc02ba2a10d8846083892a1012eeb", "url": "https://github.com/splicemachine/spliceengine/commit/a7bb26dbcb9bc02ba2a10d8846083892a1012eeb", "message": "DB-9760 Address comments", "committedDate": "2020-08-21T13:42:31Z", "type": "forcePushed"}, {"oid": "66c676e435459fd9a9e43be92eaae91deafff981", "url": "https://github.com/splicemachine/spliceengine/commit/66c676e435459fd9a9e43be92eaae91deafff981", "message": "DB-9760 Make temporary tables local to their sessions", "committedDate": "2020-08-25T13:18:07Z", "type": "commit"}, {"oid": "bd881e2ffec2a8f4c2915e18b989fd15e2f65ff8", "url": "https://github.com/splicemachine/spliceengine/commit/bd881e2ffec2a8f4c2915e18b989fd15e2f65ff8", "message": "DB-9760 Address comments", "committedDate": "2020-08-25T13:18:07Z", "type": "commit"}, {"oid": "5377cf04dbe5ee201b03f4a5bf5d986bf4e1d3b8", "url": "https://github.com/splicemachine/spliceengine/commit/5377cf04dbe5ee201b03f4a5bf5d986bf4e1d3b8", "message": "DB-9760 Fix SpotBugs", "committedDate": "2020-08-25T13:35:43Z", "type": "commit"}, {"oid": "5377cf04dbe5ee201b03f4a5bf5d986bf4e1d3b8", "url": "https://github.com/splicemachine/spliceengine/commit/5377cf04dbe5ee201b03f4a5bf5d986bf4e1d3b8", "message": "DB-9760 Fix SpotBugs", "committedDate": "2020-08-25T13:35:43Z", "type": "forcePushed"}, {"oid": "1b58251a06a63731e7d1241b7405c4671387ac02", "url": "https://github.com/splicemachine/spliceengine/commit/1b58251a06a63731e7d1241b7405c4671387ac02", "message": "Merge branch 'master' into DB-9760", "committedDate": "2020-09-09T14:09:51Z", "type": "commit"}, {"oid": "48c041520ea001c74236dec86737d79924881211", "url": "https://github.com/splicemachine/spliceengine/commit/48c041520ea001c74236dec86737d79924881211", "message": "Merge branch 'master' into DB-9760", "committedDate": "2020-09-15T10:14:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NTk4OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r492645989", "body": "setValid() ?", "bodyText": "setValid() ?", "bodyHTML": "<p dir=\"auto\">setValid() ?</p>", "author": "martinrupp", "createdAt": "2020-09-22T10:59:36Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericPreparedStatement.java", "diffHunk": "@@ -905,7 +905,9 @@ public void completeCompile(StatementNode qt) throws StandardException {\n                 updateMode = cursorInfo.updateMode;\n             }\n         }\n-        isValid = true;\n+        synchronized (this) {\n+            isValid = true;\n+        }", "originalCommit": "48c041520ea001c74236dec86737d79924881211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY5NTM3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r493695374", "bodyText": "Second that.", "author": "OlegMazurov", "createdAt": "2020-09-23T15:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NTk4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDEyOTcwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3869#discussion_r494129702", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-09-24T08:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjY0NTk4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a6c9946193a35ce7faf3392567334b92326b33c3", "changed_code": [{"header": "diff --git a/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericPreparedStatement.java b/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericPreparedStatement.java\nindex 1bbeab3131..9cf6774a11 100644\n--- a/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericPreparedStatement.java\n+++ b/db-engine/src/main/java/com/splicemachine/db/impl/sql/GenericPreparedStatement.java\n", "chunk": "@@ -905,9 +907,7 @@ public class GenericPreparedStatement implements ExecPreparedStatement {\n                 updateMode = cursorInfo.updateMode;\n             }\n         }\n-        synchronized (this) {\n-            isValid = true;\n-        }\n+        setValid();\n     }\n \n     @Override\n", "next_change": null}]}}, {"oid": "fc2f814ce0cc8ede4089aa1beedb7e754b87eaf6", "url": "https://github.com/splicemachine/spliceengine/commit/fc2f814ce0cc8ede4089aa1beedb7e754b87eaf6", "message": "Merge branch 'master' into DB-9760", "committedDate": "2020-09-22T17:18:33Z", "type": "commit"}, {"oid": "f0b87efdd38309df1be9a58732648ee9e4b9f730", "url": "https://github.com/splicemachine/spliceengine/commit/f0b87efdd38309df1be9a58732648ee9e4b9f730", "message": "DB-9760 Fix new SpotBugs after merging latest head", "committedDate": "2020-09-22T18:55:12Z", "type": "commit"}, {"oid": "47e6e56b01a9a55cb521becdd524f7a70a9518b2", "url": "https://github.com/splicemachine/spliceengine/commit/47e6e56b01a9a55cb521becdd524f7a70a9518b2", "message": "Merge branch 'master' into DB-9760", "committedDate": "2020-09-23T09:00:16Z", "type": "commit"}, {"oid": "a6c9946193a35ce7faf3392567334b92326b33c3", "url": "https://github.com/splicemachine/spliceengine/commit/a6c9946193a35ce7faf3392567334b92326b33c3", "message": "DB-9760 Address comment", "committedDate": "2020-09-24T08:23:05Z", "type": "commit"}]}