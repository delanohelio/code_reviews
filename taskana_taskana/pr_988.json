{"pr_number": 988, "pr_title": "Tsk 1160", "pr_createdAt": "2020-03-24T14:33:10Z", "pr_url": "https://github.com/Taskana/taskana/pull/988", "merge_commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "timeline": [{"oid": "6cefb1a7f9612688d2315571fc14b9af5245c751", "url": "https://github.com/Taskana/taskana/commit/6cefb1a7f9612688d2315571fc14b9af5245c751", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due", "committedDate": "2020-03-26T10:10:36Z", "type": "commit"}, {"oid": "47c87cd6ba012fca2c3651e69420d2498aefa88f", "url": "https://github.com/Taskana/taskana/commit/47c87cd6ba012fca2c3651e69420d2498aefa88f", "message": "TSK-1143 UpdateTask with Planned sometimes fails", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "9b9335f41566846d89ba5723b8f6735e2a8db341", "url": "https://github.com/Taskana/taskana/commit/9b9335f41566846d89ba5723b8f6735e2a8db341", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "900aa2c5821f1a153acbf6b7d7565660a1e34623", "url": "https://github.com/Taskana/taskana/commit/900aa2c5821f1a153acbf6b7d7565660a1e34623", "message": "TSK-1143b - fix error in testcase UpdateObjectsUseUtcTimeStampsAccTest.", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "7bfa207d0836a1bb71ba650ae969af708d3853f7", "url": "https://github.com/Taskana/taskana/commit/7bfa207d0836a1bb71ba650ae969af708d3853f7", "message": "TSK-442 improve task refresh on classification update", "committedDate": "2020-03-26T10:10:37Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "commit"}, {"oid": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "url": "https://github.com/Taskana/taskana/commit/bd4c775504f5e3a173976af21226bad2b2f0e02e", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED", "committedDate": "2020-03-26T10:10:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398650777", "body": "Cancels a task.\r\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyText": "Cancels a task.\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.", "bodyHTML": "<p dir=\"auto\">Cancels a task.<br>\nCancellation means a task is obsolete from a business perspective an does not need to be completed anymore.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:12:02Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNTk1Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398715953", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MDc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -492,7 +492,8 @@ public interface TaskService {\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n+   * need to be completed anymore.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6bd6bd48386155644df0463edf8aeda473bd1a56", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -492,7 +492,8 @@ public interface TaskService {\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n+   * need to be completed anymore.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": {"commit": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a07c9a1cc..7d96879c1 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -468,52 +369,4 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n-\n-  /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n-   *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n-\n-  /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n-   *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n-   */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n-\n-  /**\n-   * Cancels a task. Cancellation means a task is obsolete from a business perspective an does not\n-   * need to be completed anymore.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n-\n-  /**\n-   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n-   * done by an administration to correct any technical issue.\n-   *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n-   */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7d96879c1..ae908e0c9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -369,4 +375,14 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n+\n+  /**\n+   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   *\n+   * @param owner the new owner of the tasks\n+   * @param taskIds the IDs of the tasks on which the owner is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   */\n+  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n+      String owner, List<String> taskIds);\n }\n", "next_change": {"commit": "02a6df6f73622e86684c6c30d8f320c84078b237", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex ae908e0c9..8640a8b26 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -381,8 +382,20 @@ public interface TaskService {\n    *\n    * @param owner the new owner of the tasks\n    * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n+\n+  /**\n+   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n+   * affected by this method. On each task, the corresponding due date is set according to the due\n+   * dates in the classification() of the task and the task's attachments.\n+   *\n+   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n+   * @return the result of the operations with Id and Exception for each failed task update.\n+   */\n+  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n+      Instant planned, List<String> taskIds);\n }\n", "next_change": {"commit": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 8640a8b26..7951634cb 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -392,7 +467,7 @@ public interface TaskService {\n    * affected by this method. On each task, the corresponding due date is set according to the due\n    * dates in the classification() of the task and the task's attachments.\n    *\n-   * @param planned   the new 'PLANNED\" property of the tasks\n+   * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n    * @return the result of the operations with Id and Exception for each failed task update.\n    */\n", "next_change": {"commit": "7deb9254113278ccf5872283c2abd202c3cf7af0", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 7951634cb..73e0e0ce4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -464,8 +479,8 @@ public interface TaskService {\n \n   /**\n    * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the due\n-   * dates in the classification() of the task and the task's attachments.\n+   * affected by this method. On each task, the corresponding due date is set according to the\n+   * shortest service level in the classifications of the task and the task's attachments.\n    *\n    * @param planned the new 'PLANNED\" property of the tasks\n    * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n", "next_change": {"commit": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 73e0e0ce4..15b67f6fe 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -488,4 +490,28 @@ public interface TaskService {\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task terminateTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n }\n", "next_change": {"commit": "b4e1f9bc315eb701d0dec0e34c38651672239566", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..48bac1ed4 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -21,496 +24,695 @@ import pro.taskana.task.api.models.Attachment;\n import pro.taskana.task.api.models.ObjectReference;\n import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskComment;\n+import pro.taskana.workbasket.api.WorkbasketPermission;\n import pro.taskana.workbasket.api.exceptions.WorkbasketNotFoundException;\n+import pro.taskana.workbasket.api.models.Workbasket;\n \n /** The Task Service manages all operations on tasks. */\n public interface TaskService {\n \n   /**\n-   * Claim an existing task for the current user.\n+   * Claim an existing {@linkplain Task} for the current user.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by some else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not {@linkplain TaskState#READY READY}\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by some else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task claim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Claim an existing task for the current user even if it is already claimed by someone else.\n+   * Claim an existing {@linkplain Task} for the current user even if it is already claimed by\n+   * someone else.\n    *\n-   * @param taskId the id of the task to be claimed\n-   * @return claimed Task\n-   * @throws TaskNotFoundException if the task with taskId was not found\n-   * @throws InvalidStateException if the state of the task with taskId is not READY\n-   * @throws InvalidOwnerException if the task with taskId is claimed by someone else\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be claimed\n+   * @return claimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId was not found\n+   * @throws InvalidStateException if the {@linkplain Task#getState() state} of the {@linkplain\n+   *     Task} with taskId is not READY\n+   * @throws InvalidOwnerException if the {@linkplain Task} with taskId is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task if it was claimed by the current user before.\n+   * Cancel the claim of an existing {@linkplain Task} if it was claimed by the current user before.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n+   * @param taskId {@linkplain Task#getId() id} of the task which should be unclaimed.\n    * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when the task is claimed by another user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}.\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the task is in\n    */\n   Task cancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Cancel the claim of an existing task even if it was claimed by another user.\n+   * Cancel the claim of an existing {@linkplain Task} even if it was claimed by another user.\n    *\n-   * @param taskId id of the task which should be unclaimed.\n-   * @return updated unclaimed task\n-   * @throws TaskNotFoundException if the task can\u00b4t be found or does not exist\n-   * @throws InvalidStateException when the task is already completed.\n-   * @throws InvalidOwnerException when forceCancel is false and the task is claimed by another\n-   *     user.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId id of the {@linkplain Task} which should be unclaimed.\n+   * @return updated unclaimed {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} can't be found or does not exist\n+   * @throws InvalidStateException if the {@linkplain Task} is already in an end {@linkplain\n+   *     Task#getState() state}\n+   * @throws InvalidOwnerException if forceCancel is false and the {@linkplain Task} is claimed by\n+   *     another user.\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCancelClaim(String taskId)\n       throws TaskNotFoundException, InvalidStateException, InvalidOwnerException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a claimed Task as owner/admin and update State and Timestamps. If task is already\n-   * completed, the task is returned as itself.\n+   * Complete a claimed {@linkplain Task} as owner/admin and update {@linkplain Task#getState()\n+   * state} and Timestamps. If {@linkplain Task} is already completed, the {@linkplain Task} is\n+   * returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task completeTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Complete a Task and update State and Timestamps in every case if the Task exists. If task is\n-   * already completed, the task is returned as itself.\n+   * Completes a {@linkplain Task} and updates {@linkplain Task#getState() state} and Timestamps in\n+   * every case if the {@linkplain Task} exists. If {@linkplain Task} is already completed, the\n+   * {@linkplain Task} is returned as itself.\n    *\n-   * @param taskId - Id of the Task which should be completed.\n-   * @return Task - updated task after completion.\n-   * @throws InvalidStateException when Task wasn\u00b4t claimed before.\n-   * @throws TaskNotFoundException if the given Task can\u00b4t be found in DB.\n+   * @param taskId - {@linkplain Task#getId() id} of the {@linkplain Task} which should be\n+   *     completed.\n+   * @return Task - updated {@linkplain Task} after completion.\n+   * @throws InvalidStateException if {@linkplain Task} wasn't claimed before.\n+   * @throws TaskNotFoundException if the given {@linkplain Task} can't be found in DB.\n    * @throws InvalidOwnerException if current user is not the task-owner or administrator.\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task forceCompleteTask(String taskId)\n       throws TaskNotFoundException, InvalidOwnerException, InvalidStateException,\n           NotAuthorizedException;\n \n   /**\n-   * Persists a not persisted Task which does not exist already.\n-   *\n-   * @param taskToCreate the transient task object to be persisted\n-   * @return the created and persisted task\n-   * @throws TaskAlreadyExistException when the Task does already exist.\n-   * @throws NotAuthorizedException thrown if the current user is not authorized to create that task\n-   * @throws WorkbasketNotFoundException thrown if the work basket referenced by the task is not\n-   *     found\n-   * @throws ClassificationNotFoundException thrown if the {@link Classification} referenced by the\n-   *     task is not found\n+   * Inserts a not existing {@linkplain Task}. <br>\n+   * The default values of the created {@linkplain Task} are:\n+   *\n+   * <ul>\n+   *   <li><b>{@linkplain Task#getId() id}</b> - generated by {@linkplain IdGenerator}\n+   *   <li><b>{@linkplain Task#getExternalId() externalId}</b> - generated by IdGenerator\n+   *   <li><b>{@linkplain Task#getBusinessProcessId() businessProcessId}</b> - generated by\n+   *       IdGenerator\n+   *   <li><b>{@linkplain Task#getName() name}</b> - name of its Classification\n+   *   <li><b>{@linkplain Task#getDescription() description}</b> - description of its Classification\n+   *   <li><b>{@linkplain Task#getCreator() creator}</b> - id of current user\n+   *   <li><b>{@linkplain Task#getState() state}</b> - 'READY'\n+   *   <li><b>{@linkplain Task#isRead() isRead}</b> - {@code false}\n+   *   <li><b>{@linkplain Task#isTransferred() isTransferred}</b> - {@code false}\n+   * </ul>\n+   *\n+   * @param taskToCreate the transient {@linkplain Task} object to be inserted\n+   * @return the created and inserted {@linkplain Task}\n+   * @throws TaskAlreadyExistException if the {@linkplain Task} does already exist.\n+   * @throws NotAuthorizedException thrown if the current user is not authorized to create that\n+   *     {@linkplain Task}\n+   * @throws WorkbasketNotFoundException thrown if the workbasket referenced by the {@linkplain\n+   *     Task} is not found\n+   * @throws ClassificationNotFoundException thrown if the Classification referenced by the\n+   *     {@linkplain Task} is not found\n    * @throws InvalidArgumentException thrown if the primary ObjectReference is invalid\n+   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n+   *     without using the task-methods\n+   * @throws ObjectReferencePersistenceException if an ObjectReference with ID will be added\n+   *     multiple times without using the task-methods\n    */\n   Task createTask(Task taskToCreate)\n       throws NotAuthorizedException, WorkbasketNotFoundException, ClassificationNotFoundException,\n-          TaskAlreadyExistException, InvalidArgumentException;\n+          TaskAlreadyExistException, InvalidArgumentException, AttachmentPersistenceException,\n+          ObjectReferencePersistenceException;\n \n   /**\n-   * Get the details of a task by Id without checking permissions.\n+   * Gets the details of a {@linkplain Task} by {@linkplain Task#getId() id} without checking\n+   * permissions.\n    *\n-   * @param taskId the id of the task\n-   * @return the Task\n-   * @throws TaskNotFoundException thrown of the {@link Task} with taskId is not found\n-   * @throws NotAuthorizedException if the current user has no READ permission for the workbasket\n-   *     the task is in.\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task}\n+   * @return the {@linkplain Task}\n+   * @throws TaskNotFoundException thrown of the {@linkplain Task} with taskId is not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission#READ\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in.\n    */\n   Task getTask(String taskId) throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param destinationWorkbasketId The Id of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * @see #transfer(String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String destinationWorkbasketId)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, destinationWorkbasketId, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the {@linkplain\n+   * Task#isTransferred() transfer} flag if {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the {@linkplain Task#getId()} of the {@linkplain Task} which should be\n+   *     transferred\n+   * @param destinationWorkbasketId the {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState() state} which does not allow transferring\n    */\n-  Task transfer(String taskId, String destinationWorkbasketId)\n+  Task transfer(String taskId, String destinationWorkbasketId, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Transfer a task to another work basket. The transfer sets the transferred flag and resets the\n-   * read flag.\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket} while always setting the\n+   * {@linkplain Task#isTransferred transfer} flag.\n+   *\n+   * @see #transfer(String, String, String, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default Task transfer(String taskId, String workbasketKey, String domain)\n+      throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n+          InvalidStateException {\n+    return transfer(taskId, workbasketKey, domain, true);\n+  }\n+\n+  /**\n+   * Transfers a {@linkplain Task} to another {@linkplain Workbasket}.\n    *\n-   * @param taskId The id of the {@link Task} to be transferred\n-   * @param workbasketKey The key of the target work basket\n-   * @param domain The domain of the target work basket\n-   * @return the transferred task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found.\n-   * @throws WorkbasketNotFoundException Thrown if the target work basket was not found.\n+   * <p>The transfer resets the {@linkplain Task#isRead() read} flag and sets the transfer flag if\n+   * {@code setTransferFlag} is {@code true}.\n+   *\n+   * @param taskId the id of the {@linkplain Task} which should be transferred\n+   * @param workbasketKey the key of the target {@linkplain Workbasket}\n+   * @param domain the domain of the target {@linkplain Workbasket}\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return the transferred {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found.\n+   * @throws WorkbasketNotFoundException Thrown if the target {@linkplain Workbasket} was not found.\n    * @throws NotAuthorizedException Thrown if the current user is not authorized to transfer this\n-   *     {@link Task} to the target work basket\n-   * @throws InvalidStateException Thrown if the task is in a state which does not allow\n-   *     transferring\n+   *     {@linkplain Task} to the target {@linkplain Workbasket}\n+   * @throws InvalidStateException Thrown if the {@linkplain Task} is in a {@linkplain\n+   *     Task#getState()} which does not allow transferring\n    */\n-  Task transfer(String taskId, String workbasketKey, String domain)\n+  Task transfer(String taskId, String workbasketKey, String domain, boolean setTransferFlag)\n       throws TaskNotFoundException, WorkbasketNotFoundException, NotAuthorizedException,\n           InvalidStateException;\n \n   /**\n-   * Marks a task as read.\n+   * Marks a {@linkplain Task} as read.\n    *\n-   * @param taskId the id of the task to be updated\n-   * @param isRead the new status of the read flag.\n-   * @return the updated Task\n-   * @throws TaskNotFoundException Thrown if the {@link Task} with taskId was not found\n-   * @throws NotAuthorizedException if the current user has no read permission for the workbasket\n-   *     the task is in\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to be updated\n+   * @param isRead the new status of the {@linkplain Task#isRead() read} flag\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException Thrown if the {@linkplain Task} with taskId was not found\n+   * @throws NotAuthorizedException if the current user has no {@linkplain WorkbasketPermission\n+   *     READ} permission for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task setTaskRead(String taskId, boolean isRead)\n       throws TaskNotFoundException, NotAuthorizedException;\n \n   /**\n-   * This method provides a query builder for quering the database.\n+   * Provides a query builder for querying the database.\n    *\n-   * @return a {@link TaskQuery}\n+   * @return a {@linkplain TaskQuery}\n    */\n   TaskQuery createTaskQuery();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}. The returned task has no workbasket Id set.\n-   * When createTask() is invoked for this task, TaskService will call the TaskRouting SPI to\n-   * determine a workbasket for the task. If the TaskRouting API is not active, e.g. because no\n-   * TaskRouter is registered, or the TaskRouter(s) don't find a workbasket, the task will not be\n-   * persisted.\n+   * This method provides a query builder for querying the database.\n+   *\n+   * @return a {@linkplain TaskCommentQuery}\n+   */\n+  TaskCommentQuery createTaskCommentQuery();\n+\n+  /**\n+   * Returns a not inserted instance of {@linkplain Task}. The returned {@linkplain Task} has no\n+   * {@linkplain Task#getWorkbasketSummary() w} set. When createTask() is invoked for this task,\n+   * TaskService will call the TaskRouting SPI to determine a workbasket for the task. If the\n+   * TaskRouting API is not active, e.g. because no TaskRouter is registered, or the TaskRouter(s)\n+   * don't find a workbasket, the task will not be inserted.\n    *\n    * @return an empty new Task\n    */\n   Task newTask();\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketId the id of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketId the {@linkplain Workbasket#getId() id} of the {@linkplain Workbasket} to\n+   *     which the task belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketId);\n \n   /**\n-   * Returns a not persisted instance of {@link Task}.\n+   * Returns a not inserted instance of {@linkplain Task}.\n    *\n-   * @param workbasketKey the key of the workbasket to which the task belongs\n-   * @param domain the domain of the workbasket to which the task belongs\n-   * @return an empty new Task\n+   * @param workbasketKey the {@linkplain Workbasket#getKey() key} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @param domain the {@linkplain Workbasket#getDomain() domain} of the {@linkplain Workbasket} to\n+   *     which the {@linkplain Task} belongs\n+   * @return an empty new {@linkplain Task}\n    */\n   Task newTask(String workbasketKey, String domain);\n \n   /**\n-   * Returns a not persisted instance of {@link TaskComment}.\n+   * Returns a not inserted instance of {@linkplain TaskComment}.\n    *\n-   * @param taskId The id of the task to which the task comment belongs\n-   * @return an empty new TaskComment\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to which the task\n+   *     comment belongs\n+   * @return an empty new {@linkplain TaskComment}\n    */\n   TaskComment newTaskComment(String taskId);\n \n   /**\n-   * Returns a not persisted instance of {@link Attachment}.\n+   * Returns a not inserted instance of {@linkplain Attachment}.\n    *\n-   * @return an empty new Attachment\n+   * @return an empty new {@linkplain Attachment}\n    */\n   Attachment newAttachment();\n \n   /**\n-   * Update a task.\n+   * Returns a not inserted instance of {@linkplain ObjectReference}.\n    *\n-   * @param task the task to be updated in the database\n-   * @return the updated task\n-   * @throws InvalidArgumentException if the task to be updated contains invalid properties like\n-   *     e.g. invalid object references\n-   * @throws TaskNotFoundException if the id of the task is not found in the database\n-   * @throws ConcurrencyException if the task has already been updated by another user\n-   * @throws ClassificationNotFoundException if the updated task refers to a classification that\n-   *     cannot be found\n-   * @throws NotAuthorizedException if the current user is not authorized to update the task\n-   * @throws AttachmentPersistenceException if an Attachment with ID will be added multiple times\n-   *     without using the task-methods\n-   * @throws InvalidStateException if an attempt is made to change the owner of the task and the\n-   *     task is not in state READY .\n+   * @return an empty new {@linkplain ObjectReference}\n+   */\n+  ObjectReference newObjectReference();\n+\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n+\n+  /**\n+   * Update a {@linkplain Task}.\n+   *\n+   * @param task the {@linkplain Task} to be updated in the database\n+   * @return the updated {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain Task} to be updated contains invalid\n+   *     properties like e.g. invalid {@linkplain ObjectReference}s\n+   * @throws TaskNotFoundException if the id of the {@linkplain Task} is not found in the database\n+   * @throws ConcurrencyException if the {@linkplain Task} has been updated by another user in the\n+   *     meantime; that's the case if the given modified timestamp differs from the one in the\n+   *     database\n+   * @throws ClassificationNotFoundException if the updated {@linkplain Task} refers to a {@link\n+   *     Classification} that cannot be found\n+   * @throws NotAuthorizedException if the current user is not authorized to update the {@linkplain\n+   *     Task}\n+   * @throws AttachmentPersistenceException if an {@linkplain Attachment} with ID will be added\n+   *     multiple times without using the Task-methods\n+   * @throws ObjectReferencePersistenceException if an {@linkplain ObjectReference} with ID will be\n+   *     added multiple times without using the Task-methods\n+   * @throws InvalidStateException if an attempt is made to change the owner of the {@linkplain\n+   *     Task} that state isn't READY.\n    */\n   Task updateTask(Task task)\n       throws InvalidArgumentException, TaskNotFoundException, ConcurrencyException,\n           ClassificationNotFoundException, NotAuthorizedException, AttachmentPersistenceException,\n-          InvalidStateException;\n+          ObjectReferencePersistenceException, InvalidStateException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n-   * in the end.\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred transfer} flag.\n    *\n-   * @param destinationWorkbasketId target workbasket id\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @see #transferTasks(String, List, boolean)\n    */\n-  BulkOperationResults<String, TaskanaException> transferTasks(\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n       String destinationWorkbasketId, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketId, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission} on the target or if the target\n+   * {@linkplain Workbasket} does not exist. Other Exceptions will be stored and returned in the\n+   * end.\n+   *\n+   * @param destinationWorkbasketId {@linkplain Workbasket#getId() id} of the target {@linkplain\n+   *     Workbasket}\n+   * @param taskIds list of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return Bulkresult with {@linkplain Task#getId() ids} and Error in it for failed transactions\n+   * @throws NotAuthorizedException if the caller has no permissions on target {@linkplain\n+   *     Workbasket}\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found\n+   */\n+  BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketId, List<String> taskIds, boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Transfers a list of tasks to an other workbasket. Exceptions will be thrown if the caller got\n-   * no permissions on the target or it doesn\u00b4t exist. Other Exceptions will be stored and returned\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket} while always\n+   * setting the {@linkplain Task#isTransferred} flag.\n+   *\n+   * @see #transferTasks(String, String, List, boolean)\n+   */\n+  @SuppressWarnings(\"checkstyle:JavadocMethod\")\n+  default BulkOperationResults<String, TaskanaException> transferTasks(\n+      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException {\n+    return transferTasks(destinationWorkbasketKey, destinationWorkbasketDomain, taskIds, true);\n+  }\n+\n+  /**\n+   * Transfers a list of {@linkplain Task Tasks} to another {@linkplain Workbasket}.\n+   *\n+   * <p>The transfer resets the {@linkplain Task#isRead() read flag} and sets the {@linkplain\n+   * Task#isTransferred() transfer flag} if {@code setTransferFlag} is {@code true}. Exceptions will\n+   * be thrown if the caller got no {@linkplain WorkbasketPermission Permission} on the target\n+   * {@linkplain Workbasket} or if it does not exist. Other Exceptions will be stored and returned\n    * in the end.\n    *\n-   * @param destinationWorkbasketKey target workbasket key\n-   * @param destinationWorkbasketDomain target workbasket domain\n-   * @param taskIds source task which will be moved\n-   * @return Bulkresult with ID and Error in it for failed transactions.\n-   * @throws NotAuthorizedException if the caller hasn\u00b4t permissions on tarket WB.\n-   * @throws InvalidArgumentException if the method paramesters are EMPTY or NULL.\n-   * @throws WorkbasketNotFoundException if the target WB can\u00b4t be found.\n+   * @param destinationWorkbasketKey target {@linkplain Workbasket#getKey()} Workbasket}\n+   * @param destinationWorkbasketDomain target {@linkplain Workbasket#getDomain() domain}\n+   * @param taskIds List of source {@linkplain Task Tasks} which will be moved\n+   * @param setTransferFlag the control about whether to set the {@linkplain Task#isTransferred()}\n+   *     flag or not\n+   * @return BulkResult with {@linkplain Task#getId() id} and Error in it for failed transactions.\n+   * @throws NotAuthorizedException if the caller has no {@linkplain WorkbasketPermission} on target\n+   *     {@linkplain Workbasket}.\n+   * @throws InvalidArgumentException if the method parameters are EMPTY or NULL.\n+   * @throws WorkbasketNotFoundException if the target {@linkplain Workbasket} can not be found.\n    */\n   BulkOperationResults<String, TaskanaException> transferTasks(\n-      String destinationWorkbasketKey, String destinationWorkbasketDomain, List<String> taskIds)\n+      String destinationWorkbasketKey,\n+      String destinationWorkbasketDomain,\n+      List<String> taskIds,\n+      boolean setTransferFlag)\n       throws NotAuthorizedException, InvalidArgumentException, WorkbasketNotFoundException;\n \n   /**\n-   * Deletes the task with the given Id.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the {@linkplain Task#getState() state} of the referenced\n+   *     {@linkplain Task} is not an end state.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void deleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes the task with the given Id even if it is not completed.\n+   * Deletes the {@linkplain Task} with the given {@linkplain Task#getId() id} even if it is not\n+   * completed.\n    *\n-   * @param taskId The Id of the task to delete.\n-   * @throws TaskNotFoundException If the given Id does not refer to an existing task.\n-   * @throws InvalidStateException If the state of the referenced task is not Completed and\n-   *     forceDelet is false.\n-   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n+   * @param taskId The {@linkplain Task#getId() id} of the {@linkplain Task} to delete.\n+   * @throws TaskNotFoundException If the given {@linkplain Task#getId() id} does not refer to an\n+   *     existing {@linkplain Task}.\n+   * @throws InvalidStateException If the state of the referenced {@linkplain Task} is not an end\n+   *     state and forceDelete is false.\n+   * @throws NotAuthorizedException if the current user is not member of role {@linkplain\n+   *     TaskanaRole#ADMIN}\n    */\n   void forceDeleteTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Deletes a list of tasks.\n+   * Selects and claims the first {@linkplain Task} which is returned by the {@linkplain TaskQuery}.\n    *\n-   * @param tasks the ids of the tasks to delete.\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param taskQuery the {@linkplain TaskQuery}.\n+   * @return the {@linkplain Task} that got selected and claimed\n+   * @throws InvalidOwnerException if the {@linkplain Task} is claimed by someone else\n+   * @throws NotAuthorizedException if the current user has no read permission for the Workbasket\n+   *     the {@linkplain Task} is in\n+   */\n+  Task selectAndClaim(TaskQuery taskQuery) throws NotAuthorizedException, InvalidOwnerException;\n+\n+  /**\n+   * Deletes a list of {@linkplain Task Tasks}.\n+   *\n+   * @param tasks the {@linkplain Task#getId() ids} of the tasks to delete.\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed task deletion.\n    * @throws InvalidArgumentException if the TaskIds parameter is NULL\n+   * @throws NotAuthorizedException if the current user is not member of role ADMIN\n    */\n   BulkOperationResults<String, TaskanaException> deleteTasks(List<String> tasks)\n-      throws InvalidArgumentException;\n+      throws InvalidArgumentException, NotAuthorizedException;\n \n   /**\n-   * Completes a list of tasks.\n+   * Completes a list of {@linkplain Task Tasks}.\n    *\n-   * @param taskIds of the tasks which should be completed.\n-   * @return the result of the operations with Id and Exception for each failed task completion.\n-   * @throws InvalidArgumentException If the taskId parameter is NULL.\n+   * @param taskIds {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with each {@linkplain Task#getId() id} and Exception for\n+   *     each failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n    */\n   BulkOperationResults<String, TaskanaException> completeTasks(List<String> taskIds)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with a matching {@link ObjectReference}.\n+   * Completes each existing {@linkplain Task} in the given List in every case, independent of the\n+   * {@linkplain Task#getOwner() owner} or {@linkplain Task#getState() state} of the {@linkplain\n+   * Task}. If the {@linkplain Task} is already {@linkplain TaskState#COMPLETED completed}, the\n+   * {@linkplain Task} stays unchanged.\n+   *\n+   * @see TaskService#forceCompleteTask\n+   * @param taskIds {@linkplain Task#getId() id} of the {@linkplain Task Tasks} which should be\n+   *     completed\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed completion\n+   * @throws InvalidArgumentException If the taskIds parameter is NULL\n+   */\n+  BulkOperationResults<String, TaskanaException> forceCompleteTasks(List<String> taskIds)\n+      throws InvalidArgumentException;\n+\n+  /**\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} of {@linkplain Task Tasks}\n+   * associated with the given {@linkplain ObjectReference}.\n    *\n-   * @param selectionCriteria the {@link ObjectReference} that is used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param selectionCriteria the {@linkplain ObjectReference} that is used to select the tasks\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that field\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given selectionCriteria is invalid or the given\n+   *     customFieldsToUpdate are NULL or empty\n    */\n   List<String> updateTasks(\n-      ObjectReference selectionCriteria, Map<String, String> customFieldsToUpdate)\n+      ObjectReference selectionCriteria, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Updates tasks with matching taskIds.\n+   * Updates specified {@linkplain TaskCustomField TaskCustomFields} for all given {@linkplain Task\n+   * Tasks}.\n    *\n-   * @param taskIds the taskIds that are used to select the tasks.\n-   * @param customFieldsToUpdate a {@link Map} that contains as key the identification of the custom\n-   *     field and as value the corresponding new value of that custom field. The key for\n-   *     identification of the custom field must be a String with value \"1\", \"2\" ... \"16\" as in the\n-   *     setCustomAttribute or getCustomAttribute method of {@link Task}\n-   * @return a list of the Ids of all modified tasks\n-   * @throws InvalidArgumentException If the customFieldsToUpdate map contains an invalid key or if\n-   *     the selectionCriteria is invalid\n+   * @param taskIds the {@linkplain Task#getId() taskIds} that are used to select the {@linkplain\n+   *     Task Tasks}.\n+   * @param customFieldsToUpdate a Map that contains as key the identification of the {@linkplain\n+   *     TaskCustomField} and as value the corresponding new value of that {@linkplain\n+   *     TaskCustomField}.\n+   * @return a list of the {@linkplain Task#getId() ids} of all modified {@linkplain Task Tasks}\n+   * @throws InvalidArgumentException if the given customFieldsToUpdate are NULL or empty.\n    */\n-  List<String> updateTasks(List<String> taskIds, Map<String, String> customFieldsToUpdate)\n+  List<String> updateTasks(List<String> taskIds, Map<TaskCustomField, String> customFieldsToUpdate)\n       throws InvalidArgumentException;\n \n   /**\n-   * Create a task comment.\n+   * Inserts the specified {@linkplain TaskComment} into the database.\n    *\n-   * @param taskComment the task comment to be created.\n-   * @return the created task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to create a task\n-   *     comment for the given taskId in the TaskComment or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     not null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be created\n+   * @return the created {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to create a {@link\n+   *     TaskComment} for the given taskId or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given {@linkplain TaskComment#getTaskId() taskId} does not\n+   *     refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the {@linkplain TaskComment#getId() id} of the provided\n+   *     {@link TaskComment} is not NULL or empty\n    */\n   TaskComment createTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Update a task comment.\n+   * Updates the specified {@linkplain TaskComment}.\n    *\n-   * @param taskComment the task comment to be updated in the database.\n-   * @return the updated task comment.\n-   * @throws NotAuthorizedException If the current user has no authorization to update a task\n-   *     comment or is not authorized to access the task.\n-   * @throws ConcurrencyException if an attempt is made to update the task comment and another user.\n-   *     updated it already.\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId from the provided task comment is\n-   *     null or empty\n+   * @param taskComment the {@linkplain TaskComment} to be updated in the database\n+   * @return the updated {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to update the\n+   *     {@linkplain TaskComment} or is not authorized to access the {@linkplain Task}\n+   * @throws ConcurrencyException if an attempt is made to update the {@linkplain TaskComment} and\n+   *     another user updated it already; that's the case if the given {} timestamp differs from the\n+   *     one in the database\n+   * @throws TaskCommentNotFoundException if the {@linkplain TaskComment#getId() is} of the\n+   *     specified {@linkplain TaskComment}does not refer to an existing {@linkplain TaskComment}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} does not refer\n+   *     to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given {@linkplain TaskComment#getId() id} is NULL or\n+   *     empty\n    */\n   TaskComment updateTaskComment(TaskComment taskComment)\n       throws NotAuthorizedException, ConcurrencyException, TaskCommentNotFoundException,\n           TaskNotFoundException, InvalidArgumentException;\n \n   /**\n-   * Deletes the task comment with the given Id.\n+   * Deletes the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment to delete.\n-   * @throws NotAuthorizedException If the current user has no authorization to delete a task\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment} to\n+   *     delete\n+   * @throws NotAuthorizedException if the current user has no authorization to delete a task\n    *     comment or is not authorized to access the task.\n-   * @throws InvalidArgumentException If the taskCommentId is null/empty\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n+   * @throws InvalidArgumentException if the taskCommentId is NULL or empty\n+   * @throws TaskCommentNotFoundException if the given taskCommentId in the TaskComment does not\n    *     refer to an existing taskComment.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}.\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   void deleteTaskComment(String taskCommentId)\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a task comment for a given taskCommentId.\n+   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n    *\n-   * @param taskCommentId The id of the task comment which should be retrieved\n-   * @return the task comment identified by taskCommentId\n-   * @throws TaskCommentNotFoundException If the given taskCommentId in the TaskComment does not\n-   *     refer to an existing taskComment.\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n-   * @throws InvalidArgumentException If the given taskCommentId is null or empty\n+   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n+   *     which should be retrieved\n+   * @return the {@linkplain TaskComment} identified by taskCommentId\n+   * @throws TaskCommentNotFoundException if the given taskCommentId does not refer to an existing\n+   *     {@linkplain TaskComment}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     {@linkplain TaskComment} from a certain {@linkplain Task} or is not authorized to access\n+   *     the {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n+   *     TaskComment does not refer to an existing {@linkplain Task}\n+   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n    */\n   TaskComment getTaskComment(String taskCommentId)\n       throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n           InvalidArgumentException;\n \n   /**\n-   * Retrieves a list of task comments for a given taskId.\n+   * Retrieves the List of {@linkplain TaskComment TaskComments} for the Task with given {@linkplain\n+   * Task#getId() id}.\n    *\n-   * @param taskId The id of the task for which all task comments should be retrieved\n-   * @return the list of task comments attached to task with id taskId\n-   * @throws NotAuthorizedException If the current user has no authorization to retrieve a\n-   *     taskComment from a certain task or is not authorized to access the task.\n-   * @throws TaskNotFoundException If the given taskId in the TaskComment does not refer to an\n-   *     existing task.\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all task\n+   *     comments should be retrieved\n+   * @return the List of task comments attached to the specified {@linkplain Task}\n+   * @throws NotAuthorizedException if the current user has no authorization to retrieve a\n+   *     taskComment from the {@linkplain Task} or is not authorized to access the {@linkplain Task}\n+   * @throws TaskNotFoundException if the given taskId does not refer to an existing {@linkplain\n+   *     Task}\n    */\n   List<TaskComment> getTaskComments(String taskId)\n       throws NotAuthorizedException, TaskNotFoundException;\n \n   /**\n-   * Sets the callback state on a list of tasks. Note: this method is primarily intended to be used\n-   * by the TaskanaAdapter\n+   * Sets the specified {@linkplain CallbackState} on a list of {@linkplain Task Tasks}. Note: this\n+   * method is primarily intended to be used by the TaskanaAdapter\n    *\n-   * @param externalIds the EXTERNAL_IDs of the tasks on which the callback state is set.\n-   * @param state the callback state that is to be set on the tasks\n-   * @return the result of the operations with Id and Exception for each failed task deletion.\n+   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n+   *     Tasks} on which the {@linkplain CallbackState} is set\n+   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed operation\n    */\n   BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n       List<String> externalIds, CallbackState state);\n \n   /**\n-   * Sets the owner on a list of tasks. The owner will only be set on tasks that are in state READY.\n+   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}. The\n+   * {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are in\n+   * state {@linkplain TaskState#READY}.\n    *\n-   * @param owner the new owner of the tasks\n-   * @param taskIds the IDs of the tasks on which the owner is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     {@linkplain Task#getOwner() owner} is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task}-update\n    */\n   BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n       String owner, List<String> taskIds);\n \n   /**\n-   * Sets the planned property on a list of tasks. Only tasks in state READY and CLAIMED will be\n-   * affected by this method. On each task, the corresponding due date is set according to the\n-   * shortest service level in the classifications of the task and the task's attachments.\n+   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n+   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n+   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n+   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n+   * its {@linkplain Task#getAttachments() Attachments}.\n    *\n-   * @param planned the new 'PLANNED\" property of the tasks\n-   * @param taskIds the IDs of the tasks on which the new planned property is to be set.\n-   * @return the result of the operations with Id and Exception for each failed task update.\n+   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n+   *     Tasks}\n+   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n+   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n+   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n+   *     failed {@linkplain Task Task} update.\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels a task.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n+   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n+   * anymore.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n+   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the task to cancel.\n-   * @return the updated task.\n-   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n-   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n-   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @return the updated {@linkplain Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n+   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n+   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n+   *     Task}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "a2e068119042fd305c3f494e43cd41fec80f1a30", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 48bac1ed4..a58ce2866 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -670,49 +744,53 @@ public interface TaskService {\n \n   /**\n    * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   * Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n+   *\n+   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n    * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due date} is set according to the shortest serviceLevel\n-   * in the {@linkplain Task#getClassificationSummary() Classification} of the {@linkplain Task} and\n-   * its {@linkplain Task#getAttachments() Attachments}.\n+   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n+   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n+   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n    *\n    * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n    *     Tasks}\n    * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n    *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() id} and Exception for each\n-   *     failed {@linkplain Task Task} update.\n+   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n+   *     failed {@linkplain Task} update\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}. Cancellation means a\n-   * {@linkplain Task} is obsolete from a business perspective and does not need to be completed\n-   * anymore.\n+   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n+   *\n+   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n+   * need to be completed anymore.\n    *\n    * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user has no {@linkplain\n+   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n    */\n   Task cancelTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n    * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}. This is typically done by administration to correct any technical issue.\n+   * {@linkplain Task}.\n+   *\n+   * <p>This is typically done by administration to correct any technical issue.\n    *\n-   * @param taskId the id of the {@linkplain Task} to cancel\n+   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n    * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId is not found\n-   * @throws InvalidStateException if the {@linkplain Task} is not in state {@linkplain\n-   *     TaskState#READY} or {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user is not authorized to see the {@linkplain\n-   *     Task}\n+   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n+   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n+   *     {@linkplain TaskState#CLAIMED}\n+   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n+   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n    */\n   Task terminateTask(String taskId)\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n", "next_change": {"commit": "33a88529954a490d2a042a34319cbf394ee15e9d", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex a58ce2866..6e357fdf2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -677,121 +853,55 @@ public interface TaskService {\n       throws NotAuthorizedException, TaskCommentNotFoundException, TaskNotFoundException,\n           InvalidArgumentException;\n \n-  /**\n-   * Retrieves the {@linkplain TaskComment} with the given {@linkplain TaskComment#getId() id}.\n-   *\n-   * @param taskCommentId the {@linkplain TaskComment#getId() id} of the {@linkplain TaskComment}\n-   *     which should be retrieved\n-   * @return the {@linkplain TaskComment} identified by taskCommentId\n-   * @throws TaskCommentNotFoundException if the given taskCommentId doesn't refer to an existing\n-   *     {@linkplain TaskComment}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the {@linkplain TaskComment#getTaskId() taskId} of the\n-   *     TaskComment doesn't refer to an existing {@linkplain Task}\n-   * @throws InvalidArgumentException if the given taskCommentId is NULL or empty\n-   */\n-  TaskComment getTaskComment(String taskCommentId)\n-      throws TaskCommentNotFoundException, NotAuthorizedException, TaskNotFoundException,\n-          InvalidArgumentException;\n+  // endregion\n \n-  /**\n-   * Retrieves the List of {@linkplain TaskComment TaskComments} for the {@linkplain Task} with\n-   * given {@linkplain Task#getId() id}.\n-   *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} for which all\n-   *     {@linkplain TaskComment TaskComments} should be retrieved\n-   * @return the List of {@linkplain TaskComment TaskComments} attached to the specified {@linkplain\n-   *     Task}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} of the commented {@linkplain\n-   *     Task}\n-   * @throws TaskNotFoundException if the given taskId doesn't refer to an existing {@linkplain\n-   *     Task}\n-   */\n-  List<TaskComment> getTaskComments(String taskId)\n-      throws NotAuthorizedException, TaskNotFoundException;\n+  // endregion\n \n   /**\n-   * Sets the specified {@linkplain CallbackState} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Note: this method is primarily intended to be used by the TaskanaAdapter\n+   * Instantiates a non-persistent/non-inserted {@linkplain Attachment}.\n    *\n-   * @param externalIds the {@linkplain Task#getExternalId() externalIds} of the {@linkplain Task\n-   *     Tasks} on which the {@linkplain CallbackState} is set\n-   * @param state the {@linkplain CallbackState} that is to be set on the {@linkplain Task Tasks}\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed operation\n+   * @return the instantiated {@linkplain Attachment}\n    */\n-  BulkOperationResults<String, TaskanaException> setCallbackStateForTasks(\n-      List<String> externalIds, CallbackState state);\n+  Attachment newAttachment();\n \n   /**\n-   * Sets the {@linkplain Task#getOwner() owner} on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>The {@linkplain Task#getOwner() owner} will only be set on {@linkplain Task Tasks} that are\n-   * in {@linkplain TaskState#READY}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param owner the new {@linkplain Task#getOwner() owner} of the {@linkplain Task Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     {@linkplain Task#getOwner() owner} is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task}-update\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference(String, String, String, String, String)\n    */\n-  BulkOperationResults<String, TaskanaException> setOwnerOfTasks(\n-      String owner, List<String> taskIds);\n+  ObjectReference newObjectReference();\n \n   /**\n-   * Sets the {@linkplain Task#getPlanned() planned} Instant on a List of {@linkplain Task Tasks}.\n-   *\n-   * <p>Only {@linkplain Task Tasks} in state {@linkplain TaskState#READY} and {@linkplain\n-   * TaskState#CLAIMED} will be affected by this method. On each {@linkplain Task}, the\n-   * corresponding {@linkplain Task#getDue() due} Instant is set according to the shortest\n-   * serviceLevel in the {@linkplain Task#getClassificationSummary() Classification} of the\n-   * {@linkplain Task} and its {@linkplain Task#getAttachments() Attachments}.\n+   * Instantiates a non-persistent/non-inserted {@linkplain ObjectReference}.\n    *\n-   * @param planned the new {@linkplain Task#getPlanned() planned} Instant of the {@linkplain Task\n-   *     Tasks}\n-   * @param taskIds the {@linkplain Task#getId() ids} of the {@linkplain Task Tasks} on which the\n-   *     new {@linkplain Task#getPlanned() planned} Instant is to be set\n-   * @return the result of the operations with {@linkplain Task#getId() ids} and Exception for each\n-   *     failed {@linkplain Task} update\n+   * @param company the {@linkplain ObjectReference#getCompany() company} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param system the {@linkplain ObjectReference#getSystem() system} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param systemInstance the {@linkplain ObjectReference#getSystemInstance() systemInstance} of\n+   *     the new {@linkplain ObjectReference}\n+   * @param type the {@linkplain ObjectReference#getType() type} of the new {@linkplain\n+   *     ObjectReference}\n+   * @param value the {@linkplain ObjectReference#getValue() value} of the new {@linkplain\n+   *     ObjectReference}\n+   * @return the instantiated {@linkplain ObjectReference}\n+   * @see #newObjectReference()\n    */\n-  BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n-      Instant planned, List<String> taskIds);\n+  ObjectReference newObjectReference(\n+      String company, String system, String systemInstance, String type, String value);\n \n   /**\n-   * Cancels the {@linkplain Task} with the given {@linkplain Task#getId() id}.\n-   *\n-   * <p>Cancellation means a {@linkplain Task} is obsolete from a business perspective and doesn't\n-   * need to be completed anymore.\n+   * Creates an empty {@linkplain TaskQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user has no {@linkplain\n-   *     WorkbasketPermission#READ} for the {@linkplain Workbasket} the {@linkplain Task} is in\n+   * @return a {@linkplain TaskQuery}\n    */\n-  Task cancelTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskQuery createTaskQuery();\n \n   /**\n-   * Terminates a {@linkplain Task}. Termination is an administrative action to complete a\n-   * {@linkplain Task}.\n-   *\n-   * <p>This is typically done by administration to correct any technical issue.\n+   * Creates an empty {@linkplain TaskCommentQuery}.\n    *\n-   * @param taskId the {@linkplain Task#getId() id} of the {@linkplain Task} to cancel\n-   * @return the updated {@linkplain Task}\n-   * @throws TaskNotFoundException if the {@linkplain Task} with taskId wasn't found\n-   * @throws InvalidStateException if the {@linkplain Task} isn't in {@linkplain TaskState#READY} or\n-   *     {@linkplain TaskState#CLAIMED}\n-   * @throws NotAuthorizedException if the current user isn't member of {@linkplain\n-   *     TaskanaRole#ADMIN} or {@linkplain TaskanaRole#BUSINESS_ADMIN}\n+   * @return a {@linkplain TaskCommentQuery}\n    */\n-  Task terminateTask(String taskId)\n-      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+  TaskCommentQuery createTaskCommentQuery();\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6bd6bd48386155644df0463edf8aeda473bd1a56", "message": "Merge commit", "committedDate": null}, {"oid": "3b13b9a95e4d7d1cf172f22fa0f2679ff1c5f79b", "committedDate": "2020-02-03 11:41:02 +0100", "message": "TSK-991 after initial refactoring"}, {"oid": "22ac25f5c9244bdc67752b7adcb9d98f4b8d6fa2", "committedDate": "2020-02-06 14:05:27 +0100", "message": "TSK-927 reserve a task via SetOwner"}, {"oid": "5c7d38451ce7cbea2ad52d3b84be72d49c474c71", "committedDate": "2020-02-13 15:09:39 +0100", "message": "TSK-1094 introduce models package for */api and */internal"}, {"oid": "ddb12a6ad15965ad6e87d0920c975d425c575249", "committedDate": "2020-02-14 12:04:52 +0100", "message": "TSK-1095"}, {"oid": "20bd0922dbc332efcf4e94a0d487b077c95c5a85", "committedDate": "2020-02-26 14:48:50 +0100", "message": "TSK-1131 updateOwner on multiple tasks"}, {"oid": "02a6df6f73622e86684c6c30d8f320c84078b237", "committedDate": "2020-02-28 10:46:45 +0100", "message": "TSK-1139 Bulk update of Planned timestamp"}, {"oid": "3b7da72d24beb1e0f6d528f575b1ae7029f10e7f", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Java-API for the administration of comments for tasks"}, {"oid": "7d464bd6cde263ad9b674e5d796fcf91e4a727bf", "committedDate": "2020-03-17 11:54:26 +0100", "message": "TSK-1150 Comments from Bernd Breier"}, {"oid": "7deb9254113278ccf5872283c2abd202c3cf7af0", "committedDate": "2020-03-19 14:43:16 +0100", "message": "TSK-1143 UpdateTask planned - comments from Holger"}, {"oid": "7b409451dcf7f12714b5c9739861c9b43541e275", "committedDate": "2020-03-25 08:44:18 +0100", "message": "TSK-1143C mismatch between forward and backward calculation between planned and due"}, {"oid": "2ce7f86456f99d522e001080e9504ae4cd6a80f4", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 TaskStates CANCELLED and TERMINATED"}, {"oid": "d6505284f780ec7a804adf7d6156726e85ddd4ef", "committedDate": "2020-03-30 13:21:06 +0200", "message": "TSK-1160 - terminate/cancel task Holger's comments"}, {"oid": "93a94f0458979e35cb92ee682be312532d1e5210", "committedDate": "2020-03-31 11:56:59 +0200", "message": "TSK-1150: added taskId as pathvariable to getTaskComment and deleteTaskComment"}, {"oid": "dffb139a822c55fcf12438e6e996fdef41b6f098", "committedDate": "2020-03-31 11:56:59 +0200", "message": "comments from Holger Hagen"}, {"oid": "1f13c2c33ac0ce2c8202a23f5d977c87717894a3", "committedDate": "2020-05-13 14:49:18 +0200", "message": "TSK-1195: Secure deleteTasks in TaskServiceImpl"}, {"oid": "496da17b3eec2490b68b27c4192b32c02935a2f0", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: refactored claimtasks in taskService and increased test coverage"}, {"oid": "6f12677b74a36ec04e282def79e8b549d48c1988", "committedDate": "2020-06-07 15:56:30 +0200", "message": "TSK-1257: implementes forceCompleteTasks"}, {"oid": "1dfe54c0b6fb05c6811573e38feba9212fdb6a9f", "committedDate": "2020-06-30 14:50:26 +0200", "message": "TSK-1275: Support select and claim in one API call"}, {"oid": "969d3eeff653d51eb7dcf5234aa4020333613ab3", "committedDate": "2020-06-30 14:50:26 +0200", "message": "review Findings"}, {"oid": "7cc5b00be617227dac2f8d1210554108d18bad4a", "committedDate": "2020-07-24 01:05:42 +0200", "message": "TSK-1345: replaced every customField API call with CustomField enums"}, {"oid": "3967e2900e8b35329b3675844ca3a8e059916c7e", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: rest api documentation is now build with spring-auto-restdocs"}, {"oid": "de57596ba8e816d3e751b21c949a3fe132b314f0", "committedDate": "2020-12-18 11:29:10 +0100", "message": "TSK-1436: reworked review comments."}, {"oid": "d57aeb3219f45e962d6a05b175f4397d296e819b", "committedDate": "2021-03-01 10:03:04 +0100", "message": "TSK-1524: Set the default service level to \"P0D\" (#1496)"}, {"oid": "ec822c116855052b32ef98cc496e4876c7f52fa6", "committedDate": "2021-03-02 10:34:30 +0100", "message": "TSK-1555: Initialize due of Cleanup Job based on firstRun (#1488)"}, {"oid": "0119999380b40fdc0f69677f96650de5c81bd2a5", "committedDate": "2021-03-09 18:58:51 +0100", "message": "TSK-1538: Added transfer method with control setTransferFlag (#1513)"}, {"oid": "1c83b7871f144cd07a912639b942d5938219e101", "committedDate": "2021-06-22 16:14:09 +0200", "message": "TSK-1646: Bugfix for creation / update of Task with invalid Attachment"}, {"oid": "34d2bbfa929ccaa9e9b93c173b8fa867154330bb", "committedDate": "2021-07-14 10:49:34 +0200", "message": "TSK-1647: Implemented an error key for every exception"}, {"oid": "375a92291d41c6c90b403055ac5228ccd309621a", "committedDate": "2021-07-15 14:03:00 +0200", "message": "TSK-1658: Created TaskQueryMapperSqlProvider"}, {"oid": "e264a203892c6d2111df4645abf7f373bf4ca86a", "committedDate": "2021-10-08 08:38:21 +0200", "message": "TSK-1726: Implemented option to include long name on Task / TaskComment / TaskHistoryEvent"}, {"oid": "967e59e012f94e116f2b327b6c426f44ae1bcbee", "committedDate": "2022-02-25 10:23:40 +0100", "message": "TSK-1800: add secondary object references"}, {"oid": "b4e1f9bc315eb701d0dec0e34c38651672239566", "committedDate": "2022-04-15 11:43:57 +0200", "message": "TSK-1532: Refactor names of entities in REST-Doc by capitalizing them; refactor Java-doc according to guidelines"}, {"oid": "a2e068119042fd305c3f494e43cd41fec80f1a30", "committedDate": "2022-05-31 16:01:49 +0200", "message": "TSK-1852: refactor JavaDoc in TaskService"}, {"oid": "ef875dd42a58b55bace25fb4f599d84e4d06b59b", "committedDate": "2022-08-06 14:30:59 +0200", "message": "TSK-1915: Add requestReview functionality"}, {"oid": "cc32b10d82b7888ed2eae438100d2e26fb508f0c", "committedDate": "2022-08-09 13:19:02 +0200", "message": "TSK-1916: Add requestChanges functionality"}, {"oid": "6997d640834819d21fe0325178d73bbf70de68fc", "committedDate": "2022-08-11 17:08:10 +0200", "message": "TSK-1943: added REST endpoint for force requesting changes on a Task"}, {"oid": "33a88529954a490d2a042a34319cbf394ee15e9d", "committedDate": "2022-08-18 00:02:18 +0300", "message": "TSK-1864: Reorder methods in TaskService"}, {"oid": "b9b49f47a13e748be20bf73ed605f0dfde7fcf70", "committedDate": "2022-10-20 14:20:24 +0200", "message": "TSK-1965: create endpoints for all state transitions (#2024)"}, {"oid": "20d389a7d524c156b063dfc91589bb22bebea0d7", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-1992 remove unnecessary ParentExceptions"}, {"oid": "d21eb47ffea4c2c9fff8f1d3435b77b805d03508", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2012: renamed Mismatched_Exceptions to NotAuthorizedExceptions"}, {"oid": "37280cc73b83e2d39ab4afddd40256719d64c50c", "committedDate": "2023-03-13 10:39:04 +0100", "message": "TSK-2013 selectAndClaim TasK return Optional and does not throw Exception if Task is notFound"}, {"oid": "55d939ca7b7720ab12f488ed8fc2a631ecc6f05c", "committedDate": "2023-03-13 19:02:53 +0100", "message": "format entire codebase with new google-java-format version"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398652586", "body": "Terminates a task.\r\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue. ", "bodyText": "Terminates a task.\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.", "bodyHTML": "<p dir=\"auto\">Terminates a task.<br>\nTermination is a administrative action to complete a task. This is typically done by an administration to correct any technical issue.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:14:16Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java", "diffHunk": "@@ -490,4 +490,28 @@ TaskComment getTaskComment(String taskCommentId)\n    */\n   BulkOperationResults<String, TaskanaException> setPlannedPropertyOfTasks(\n       Instant planned, List<String> taskIds);\n+\n+  /**\n+   * Cancels a task.\n+   *\n+   * @param taskId the id of the task to cancel.\n+   * @return the updated task.\n+   * @throws TaskNotFoundException if the Task with Id TaskId is not found\n+   * @throws InvalidStateException if the task is not in state READY or CLAIMED\n+   * @throws NotAuthorizedException if the current user is not authorized to see the task\n+   */\n+  Task cancelTask(String taskId)\n+      throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n+\n+  /**\n+   * Terminates a task.", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcxNjA1NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398716054", "bodyText": "I added the description", "author": "BerndBreier", "createdAt": "2020-03-26T16:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1MjU4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\nindex 15b67f6fe..a07c9a1cc 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskService.java\n", "chunk": "@@ -504,7 +505,8 @@ public interface TaskService {\n       throws TaskNotFoundException, InvalidStateException, NotAuthorizedException;\n \n   /**\n-   * Terminates a task.\n+   * Terminates a task. Termination is a administrative action to complete a task. This is typically\n+   * done by an administration to correct any technical issue.\n    *\n    * @param taskId the id of the task to cancel.\n    * @return the updated task.\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398654256", "body": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyText": "Maybe just \"in\" as it is a well known operator for this? Just an idea.", "bodyHTML": "<p dir=\"auto\">Maybe just \"in\" as it is a well known operator for this? Just an idea.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:16:25Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java", "diffHunk": "@@ -4,5 +4,20 @@\n public enum TaskState {\n   READY,\n   CLAIMED,\n-  COMPLETED\n+  COMPLETED,\n+  CANCELLED,\n+  TERMINATED;\n+\n+  public boolean isInStates(TaskState... states) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTM3OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161378", "bodyText": "You don't like that? Or you has overseen this ons?", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI4NzI0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399287247", "bodyText": "Ok, I didn't see this one. No problem, I'll change it to 'in'", "author": "BerndBreier", "createdAt": "2020-03-27T14:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NDI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\nindex fd7b87a38..7047e18e5 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/api/TaskState.java\n", "chunk": "@@ -8,7 +8,7 @@ public enum TaskState {\n   CANCELLED,\n   TERMINATED;\n \n-  public boolean isInStates(TaskState... states) {\n+  public boolean in(TaskState... states) {\n     for (TaskState currState : states) {\n       if (this.equals(currState)) {\n         return true;\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398655382", "body": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyText": "Why don't we provide the converter on engine level and initialize it during startup according to the configuration?", "bodyHTML": "<p dir=\"auto\">Why don't we provide the converter on engine level and initialize it during startup according to the configuration?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:17:49Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,14 +46,9 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n+    this.converter = WorkingDaysToDaysConverter.initialize();\n+    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0NzQ0OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398747448", "bodyText": "Apart from the DaysToWorkingDaysReportConverter, the converter is only needed in ServiceLevelHandler. I think, we should maintain and supply classes / objects there where they are needed. But if you insist to provide it on engine level, I can do that.\nWith respect to configuration: I introduce the configuration property taskana.german.holidays.enabled and set it to true in taskana.properties. Then I initialize this property in TaskanaEngineConfiguration and use it in the constructor of TaskanaEngineImpl to set that (static) property on WorkingDaysToDaysConverter.", "author": "BerndBreier", "createdAt": "2020-03-26T17:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NTM4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 743dbd9be..83d237766 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -47,9 +47,6 @@ class ServiceLevelHandler {\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n     this.converter = WorkingDaysToDaysConverter.initialize();\n-    if (taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled()) {\n-      WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(true);\n-    }\n   }\n \n   // use the same algorithm as setPlannedPropertyOfTasksImpl to refresh\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,6 +46,8 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n   }\n \n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657447", "body": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyText": "We should retain this timestamp even if the task is terminated/cancelled.", "bodyHTML": "<p dir=\"auto\">We should retain this timestamp even if the task is terminated/cancelled.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:22Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0ODU5Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398748596", "bodyText": "ok, retained the claimed timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1NzQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..47a6735b9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -994,8 +994,6 @@ public class TaskServiceImpl implements TaskService {\n     task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398657793", "body": "Why this. We don't know if the task has been read, do we?", "bodyText": "Why this. We don't know if the task has been read, do we?", "bodyHTML": "<p dir=\"auto\">Why this. We don't know if the task has been read, do we?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:20:47Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,29 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);\n+    task.setModified(now);\n+    task.setCompleted(now);\n+    task.setClaimed(null);\n+    task.setRead(true);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc0OTM3Mw==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398749373", "bodyText": "ok, retained also the read timestamp", "author": "BerndBreier", "createdAt": "2020-03-26T17:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY1Nzc5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 382c3861a..47a6735b9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -994,8 +994,6 @@ public class TaskServiceImpl implements TaskService {\n     task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n-    task.setClaimed(null);\n-    task.setRead(true);\n     task.setState(targetState);\n     taskMapper.update(task);\n     LOGGER.debug(\"Task '{}' cancelled by user '{}'.\", taskId, CurrentUserContext.getUserid());\n", "next_change": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398663321", "body": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyText": "Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?", "bodyHTML": "<p dir=\"auto\">Maybe we should add an assertion isEqualTo(5) before cancelTask to make it more clear?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:27:45Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelClaimedTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(19);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasks).isEqualTo(18);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NDgzNQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398754835", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-26T17:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MzMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398664598", "body": "Is it a good idea to do all these tests as admin?", "bodyText": "Is it a good idea to do all these tests as admin?", "bodyHTML": "<p dir=\"auto\">Is it a good idea to do all these tests as admin?</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:29:16Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2NjMwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398766301", "bodyText": "Changed it ...", "author": "BerndBreier", "createdAt": "2020-03-26T17:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDU5OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398666855", "body": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyText": "Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.", "bodyHTML": "<p dir=\"auto\">Did we decide that everybody is allowed to cancel a claimed task? I wonder if it would be better to allow only the owner to cancel claimed tasks.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:32:00Z", "path": "lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class CancelTaskAccTest extends AbstractAccTest {\n+  private TaskService taskService;\n+\n+  CancelTaskAccTest() {\n+    super();\n+    taskService = taskanaEngine.getTaskService();\n+  }\n+\n+  @BeforeEach\n+  public static void setupTest() throws Exception {\n+    resetDb(false);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"user_1_1\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testQeryCancelledTasks() {\n+    List<TaskSummary> taskSummaries =\n+        taskService.createTaskQuery().stateIn(TaskState.CANCELLED).list();\n+    assertThat(taskSummaries.size()).isEqualTo(5);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",\n+      groupNames = {\"group_1\"})\n+  @Test\n+  void testCancelReadyTask()\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    List<TaskSummary> taskSummaries = taskService.createTaskQuery().stateIn(TaskState.READY).list();\n+    assertThat(taskSummaries.size()).isEqualTo(47);\n+    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    taskService.cancelTask(taskSummaries.get(0).getId());\n+    long numTasks = taskService.createTaskQuery().stateIn(TaskState.READY).count();\n+    assertThat(numTasks).isEqualTo(46);\n+    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasks).isEqualTo(6);\n+  }\n+\n+  @WithAccessId(\n+      userName = \"admin\",", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2OTk5MA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398769990", "bodyText": "The ticket says : \" terminateTask() and cancelTask bay be called by every user that is allowed to see the task \"\nI agree, that it is strange that everybody is allowed to cancel / terminate a task. On the other hand, if you think about the adapter scenario: if a task has been cancelled / terminated in camunda, the adapter should be able to cancel / terminate it in taskana. And this without being the owner. And probably also without having admin authority. So before I change anything with respect to this, we should carefully think about what is the correct solution ....", "author": "BerndBreier", "createdAt": "2020-03-26T17:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2Njg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\nindex 0c9a90579..97d4bda87 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/CancelTaskAccTest.java\n", "chunk": "@@ -62,20 +60,23 @@ class CancelTaskAccTest extends AbstractAccTest {\n   }\n \n   @WithAccessId(\n-      userName = \"admin\",\n+      userName = \"user_1_2\",\n       groupNames = {\"group_1\"})\n   @Test\n   void testCancelClaimedTask()\n       throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n     List<TaskSummary> taskSummaries =\n         taskService.createTaskQuery().stateIn(TaskState.CLAIMED).list();\n-    assertThat(taskSummaries.size()).isEqualTo(19);\n-    Task task = taskService.getTask(taskSummaries.get(0).getId());\n+    assertThat(taskSummaries.size()).isEqualTo(16);\n+\n+    long numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(5);\n+\n     taskService.cancelTask(taskSummaries.get(0).getId());\n-    long numTasks = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n-    assertThat(numTasks).isEqualTo(18);\n-    numTasks = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n-    assertThat(numTasks).isEqualTo(6);\n+    long numTasksClaimed = taskService.createTaskQuery().stateIn(TaskState.CLAIMED).count();\n+    assertThat(numTasksClaimed).isEqualTo(15);\n+    numTasksCancelled = taskService.createTaskQuery().stateIn(TaskState.CANCELLED).count();\n+    assertThat(numTasksCancelled).isEqualTo(6);\n   }\n \n   @WithAccessId(\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398668066", "body": "See comments on cancel task test.", "bodyText": "See comments on cancel task test.", "bodyHTML": "<p dir=\"auto\">See comments on cancel task test.</p>", "author": "holgerhagen", "createdAt": "2020-03-26T15:33:35Z", "path": "lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package acceptance.task;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import acceptance.AbstractAccTest;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+\n+import pro.taskana.common.api.exceptions.NotAuthorizedException;\n+import pro.taskana.security.JaasExtension;\n+import pro.taskana.security.WithAccessId;\n+import pro.taskana.task.api.TaskService;\n+import pro.taskana.task.api.TaskState;\n+import pro.taskana.task.api.exceptions.InvalidStateException;\n+import pro.taskana.task.api.exceptions.TaskNotFoundException;\n+import pro.taskana.task.api.models.Task;\n+import pro.taskana.task.api.models.TaskSummary;\n+\n+/** Acceptance tests for all claim and complete scenarios. */\n+@ExtendWith(JaasExtension.class)\n+class TerminateTaskAccTest extends AbstractAccTest {", "originalCommit": "bd4c775504f5e3a173976af21226bad2b2f0e02e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc4MjcwMQ==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r398782701", "bodyText": "done", "author": "BerndBreier", "createdAt": "2020-03-26T18:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2ODA2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4c65a6087e83b85e44118a754cf749a23cac5250", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\nindex 50eca5337..f53402b4b 100644\n--- a/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n+++ b/lib/taskana-core/src/test/java/acceptance/task/TerminateTaskAccTest.java\n", "chunk": "@@ -16,7 +17,6 @@ import pro.taskana.task.api.TaskService;\n import pro.taskana.task.api.TaskState;\n import pro.taskana.task.api.exceptions.InvalidStateException;\n import pro.taskana.task.api.exceptions.TaskNotFoundException;\n-import pro.taskana.task.api.models.Task;\n import pro.taskana.task.api.models.TaskSummary;\n \n /** Acceptance tests for all claim and complete scenarios. */\n", "next_change": null}]}}, {"oid": "4c65a6087e83b85e44118a754cf749a23cac5250", "url": "https://github.com/Taskana/taskana/commit/4c65a6087e83b85e44118a754cf749a23cac5250", "message": "TSK-1160 - terminate/cancel task Holger's comments", "committedDate": "2020-03-26T18:22:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399161064", "body": "Why don't we move this to the engine as well?", "bodyText": "Why don't we move this to the engine as well?", "bodyHTML": "<p dir=\"auto\">Why don't we move this to the engine as well?</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:15:24Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java", "diffHunk": "@@ -48,15 +46,7 @@\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n-    DaysToWorkingDaysConverter.setGermanPublicHolidaysEnabled(\n-        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n-    try {\n-      converter = DaysToWorkingDaysConverter.initialize();\n-    } catch (InvalidArgumentException e) {\n-      LOGGER.error(ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER);\n-      throw new SystemException(\n-          ERROR_CANNOT_INITIALIZE_DAYS_TO_WORKING_DAYS_CONVERTER, e.getCause());\n-    }\n+    this.converter = WorkingDaysToDaysConverter.initialize();", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMwNzYzOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399307638", "bodyText": "The engine calls only WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled() which is a static method. The initialize() call is a factory method that creates an instance of WorkingDaysToDaysConverter.\nSince the WorkingDaysToDaysConverter is only needed inside ServiceLevelHandler, I made it an instance variable of this class.\nTo make things consistent, I'll also move the setGermanPublicHolidaysEnabled() call to the ctor of ServiceLevelHandler.", "author": "BerndBreier", "createdAt": "2020-03-27T14:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MTA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\nindex 83d237766..292aaa9d9 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/ServiceLevelHandler.java\n", "chunk": "@@ -46,6 +46,8 @@ class ServiceLevelHandler {\n     this.taskanaEngine = taskanaEngine;\n     this.taskMapper = taskMapper;\n     this.attachmentMapper = attachmentMapper;\n+    WorkingDaysToDaysConverter.setGermanPublicHolidaysEnabled(\n+        taskanaEngine.getEngine().getConfiguration().isGermanPublicHolidaysEnabled());\n     this.converter = WorkingDaysToDaysConverter.initialize();\n   }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399162008", "body": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyText": "Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.", "bodyHTML": "<p dir=\"auto\">Sorry, haven't seen this one right away. As we don't reset the claimed timestamp, we shouldn't reset the owner as well.</p>", "author": "holgerhagen", "createdAt": "2020-03-27T10:17:10Z", "path": "lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java", "diffHunk": "@@ -951,6 +979,27 @@ private TaskImpl checkConcurrencyAndSetModified(TaskImpl newTaskImpl, TaskImpl o\n     return newTaskImpl;\n   }\n \n+  private TaskImpl terminateCancelCommonActions(String taskId, TaskState targetState)\n+      throws NotAuthorizedException, TaskNotFoundException, InvalidStateException {\n+    if (taskId == null || taskId.isEmpty()) {\n+      throw new TaskNotFoundException(taskId, String.format(TASK_WITH_ID_WAS_NOT_FOUND, taskId));\n+    }\n+    TaskImpl task = (TaskImpl) getTask(taskId);\n+    TaskState state = task.getState();\n+    if (state.isEndState()) {\n+      throw new InvalidStateException(String.format(TASK_WITH_ID_IS_ALREADY_IN_END_STATE, taskId));\n+    }\n+\n+    Instant now = Instant.now();\n+    task.setOwner(null);", "originalCommit": "4c65a6087e83b85e44118a754cf749a23cac5250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI5NTQxOA==", "url": "https://github.com/Taskana/taskana/pull/988#discussion_r399295418", "bodyText": "Done", "author": "BerndBreier", "createdAt": "2020-03-27T14:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjAwOA=="}], "type": "inlineReview", "revised_code": {"commit": "62d58b32c908be3bf05b5068497e4be5a20002e6", "changed_code": [{"header": "diff --git a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\nindex 47a6735b9..fba7860b2 100644\n--- a/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n+++ b/lib/taskana-core/src/main/java/pro/taskana/task/internal/TaskServiceImpl.java\n", "chunk": "@@ -991,7 +991,6 @@ public class TaskServiceImpl implements TaskService {\n     }\n \n     Instant now = Instant.now();\n-    task.setOwner(null);\n     task.setModified(now);\n     task.setCompleted(now);\n     task.setState(targetState);\n", "next_change": null}]}}, {"oid": "62d58b32c908be3bf05b5068497e4be5a20002e6", "url": "https://github.com/Taskana/taskana/commit/62d58b32c908be3bf05b5068497e4be5a20002e6", "message": "TSK-1160 - terminate/cancel task more comments from Holger", "committedDate": "2020-03-27T14:36:46Z", "type": "commit"}]}