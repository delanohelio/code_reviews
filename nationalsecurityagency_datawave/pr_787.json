{"pr_number": 787, "pr_title": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions.", "pr_author": "apmoriarty", "pr_createdAt": "2020-03-20T16:10:48Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/787", "merge_commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "timeline": [{"oid": "727cb7d0be73169ed77f68e0c7cd4988c23b2409", "url": "https://github.com/NationalSecurityAgency/datawave/commit/727cb7d0be73169ed77f68e0c7cd4988c23b2409", "message": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions.", "committedDate": "2020-03-20T16:07:01Z", "type": "commit"}, {"oid": "17fd3e77ce8a8e1592b9af1a60374375dc405a8f", "url": "https://github.com/NationalSecurityAgency/datawave/commit/17fd3e77ce8a8e1592b9af1a60374375dc405a8f", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-03-30T16:43:44Z", "type": "commit"}, {"oid": "ecaea0e1d6bb95e534310194b0dc51f1f0135bfe", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ecaea0e1d6bb95e534310194b0dc51f1f0135bfe", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-04-02T13:48:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDU3Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402500572", "body": "I will have to say that a more robust solution here is to push this functionality into the function descriptor mechanism.  That way we can catch any function that might have a regex......", "bodyText": "I will have to say that a more robust solution here is to push this functionality into the function descriptor mechanism.  That way we can catch any function that might have a regex......", "bodyHTML": "<p dir=\"auto\">I will have to say that a more robust solution here is to push this functionality into the function descriptor mechanism.  That way we can catch any function that might have a regex......</p>", "author": "ivakegg", "createdAt": "2020-04-02T17:47:51Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java", "diffHunk": "@@ -69,22 +56,73 @@ public Object visit(ASTERNode node, Object data) {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n+        parseAndPutLiteral(node);\n+        return data;\n+    }\n+    \n+    @Override\n+    public Object visit(ASTFunctionNode node, Object data) {\n+        \n+        if (node.jjtGetNumChildren() >= 4) {", "originalCommit": "ecaea0e1d6bb95e534310194b0dc51f1f0135bfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMzY3MA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402503670", "bodyText": "The JexlArgumentDescriptor already has a regexArguments() method to determine if the literal arguments are to be treated as regexes.  We should use that along with fieldsForNormalization to determine which arguments to test.", "author": "ivakegg", "createdAt": "2020-04-02T17:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUxOTU2NQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402519565", "bodyText": "And then we can apply this to all functions that return true for regexArguments().....", "author": "ivakegg", "createdAt": "2020-04-02T18:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMzQ3Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402523472", "bodyText": "I took a look at some of the existing descriptors and see where you're going with this. Should have an update for this pr tomorow sometime", "author": "apmoriarty", "createdAt": "2020-04-02T18:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUzODYzMw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402538633", "bodyText": "An example of how to do this can be found in the datawave.query.jexl.visitors.FunctionNormalizationRebuildingVisitor.", "author": "ivakegg", "createdAt": "2020-04-02T18:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDU3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "a1a452d9207831004d03a274647efa87888c0959", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex ab1f8ae91..92065cbfa 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -56,73 +59,65 @@ public class ValidPatternVisitor extends BaseVisitor {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n-        parseAndPutLiteral(node);\n+        parseAndPutPattern(node);\n         return data;\n     }\n     \n+    /**\n+     * Visit an ASTFunctionNode to catch cases like #INCLUDE or #EXCLUDE that accept a regex as an argument\n+     * \n+     * @param node\n+     * @param data\n+     * @return\n+     */\n     @Override\n     public Object visit(ASTFunctionNode node, Object data) {\n         \n-        if (node.jjtGetNumChildren() >= 4) {\n-            \n-            // Should be a filter function.\n-            String functionType = JexlASTHelper.getIdentifier(node.jjtGetChild(0));\n-            if (functionType == null || !functionType.equals(\"filter\")) {\n-                return data;\n-            }\n-            \n-            // Filter should be includeRegex or excludeRegex.\n-            String filterType = JexlASTHelper.getIdentifier(node.jjtGetChild(1));\n-            if (filterType == null || !(filterType.equals(\"includeRegex\") || filterType.equals(\"excludeRegex\"))) {\n-                return data;\n-            }\n-            \n-            // Child 3 is the field to be included/excluded.\n-            // JexlNode child3 = node.jjtGetChild(2);\n-            \n-            // Child 4 is the field that *may* contain a regex.\n-            JexlNode child4 = node.jjtGetChild(3);\n-            if (child4 instanceof ASTReference) {\n-                \n-                JexlNode literalNode = child4.jjtGetChild(0);\n-                if (StringUtils.containsAny(literalNode.image, \"?.*^+-[]()\")) {\n-                    try {\n-                        parseAndPutLiteral(literalNode);\n-                    } catch (PatternSyntaxException e) {\n-                        String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n-                        String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n-                        throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n-                    }\n+        // Should pull back an EvaluationPhaseFilterFunctionsDescriptor\n+        JexlArgumentDescriptor descriptor = JexlFunctionArgumentDescriptorFactory.F.getArgumentDescriptor(node);\n+        if (descriptor == null) {\n+            throw new IllegalStateException(\"Could not get descriptor for ASTFunctionNode\");\n+        }\n+        \n+        if (descriptor.regexArguments()) {\n+            // Extract the args for this function\n+            FunctionJexlNodeVisitor functionVisitor = new FunctionJexlNodeVisitor();\n+            functionVisitor.visit(node, null);\n+            List<JexlNode> args = functionVisitor.args();\n+            for (JexlNode arg : args) {\n+                // Only take the literals\n+                if (arg instanceof ASTStringLiteral) {\n+                    parseAndPutPattern(arg);\n                 }\n             }\n         }\n-        \n         // Do not descend to children, the ValidPatternVisitor views a function node as a leaf node.\n         return data;\n     }\n     \n     /**\n      * Parse a literal value and put into the pattern cache if it does not exist.\n-     * \n+     *\n      * @param node\n      */\n-    public void parseAndPutLiteral(JexlNode node) {\n-        Object literalValue;\n-        \n+    public void parseAndPutPattern(JexlNode node) {\n         // Catch the situation where a user might enter FIELD1 !~ VALUE1\n-        try {\n-            literalValue = JexlASTHelper.getLiteralValue(node);\n-        } catch (NoSuchElementException e) {\n-            return;\n-        }\n-        \n+        Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            if (patternCache.containsKey(literalString)) {\n-                return;\n+            // Only parse literals that contain a regex char\n+            if (StringUtils.containsAny(literalString, \"?.*^+-_[](){}\")) {\n+                try {\n+                    if (patternCache.containsKey(literalString)) {\n+                        return;\n+                    }\n+                    patternCache.put(literalString, Pattern.compile(literalString));\n+                } catch (PatternSyntaxException e) {\n+                    String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n+                    String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n+                    throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n+                }\n             }\n-            patternCache.put(literalString, Pattern.compile(literalString));\n         }\n-        return;\n     }\n }\n", "next_change": {"commit": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex 92065cbfa..2c380b18f 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -105,18 +107,15 @@ public class ValidPatternVisitor extends BaseVisitor {\n         Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            // Only parse literals that contain a regex char\n-            if (StringUtils.containsAny(literalString, \"?.*^+-_[](){}\")) {\n-                try {\n-                    if (patternCache.containsKey(literalString)) {\n-                        return;\n-                    }\n-                    patternCache.put(literalString, Pattern.compile(literalString));\n-                } catch (PatternSyntaxException e) {\n-                    String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n-                    String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n-                    throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n+            try {\n+                if (patternCache.containsKey(literalString)) {\n+                    return;\n                 }\n+                patternCache.put(literalString, Pattern.compile(literalString));\n+            } catch (PatternSyntaxException e) {\n+                String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n+                String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n+                throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n             }\n         }\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex ab1f8ae91..2c380b18f 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -56,73 +59,64 @@ public class ValidPatternVisitor extends BaseVisitor {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n-        parseAndPutLiteral(node);\n+        parseAndPutPattern(node);\n         return data;\n     }\n     \n+    /**\n+     * Visit an ASTFunctionNode to catch cases like #INCLUDE or #EXCLUDE that accept a regex as an argument\n+     * \n+     * @param node\n+     *            - an ASTFunctionNode\n+     * @param data\n+     *            - the data\n+     * @return\n+     */\n     @Override\n     public Object visit(ASTFunctionNode node, Object data) {\n         \n-        if (node.jjtGetNumChildren() >= 4) {\n-            \n-            // Should be a filter function.\n-            String functionType = JexlASTHelper.getIdentifier(node.jjtGetChild(0));\n-            if (functionType == null || !functionType.equals(\"filter\")) {\n-                return data;\n-            }\n-            \n-            // Filter should be includeRegex or excludeRegex.\n-            String filterType = JexlASTHelper.getIdentifier(node.jjtGetChild(1));\n-            if (filterType == null || !(filterType.equals(\"includeRegex\") || filterType.equals(\"excludeRegex\"))) {\n-                return data;\n-            }\n-            \n-            // Child 3 is the field to be included/excluded.\n-            // JexlNode child3 = node.jjtGetChild(2);\n-            \n-            // Child 4 is the field that *may* contain a regex.\n-            JexlNode child4 = node.jjtGetChild(3);\n-            if (child4 instanceof ASTReference) {\n-                \n-                JexlNode literalNode = child4.jjtGetChild(0);\n-                if (StringUtils.containsAny(literalNode.image, \"?.*^+-[]()\")) {\n-                    try {\n-                        parseAndPutLiteral(literalNode);\n-                    } catch (PatternSyntaxException e) {\n-                        String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n-                        String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n-                        throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n-                    }\n+        // Should pull back an EvaluationPhaseFilterFunctionsDescriptor\n+        JexlArgumentDescriptor descriptor = JexlFunctionArgumentDescriptorFactory.F.getArgumentDescriptor(node);\n+        if (descriptor == null) {\n+            throw new IllegalStateException(\"Could not get descriptor for ASTFunctionNode\");\n+        }\n+        \n+        if (descriptor.regexArguments()) {\n+            // Extract the args for this function\n+            FunctionJexlNodeVisitor functionVisitor = new FunctionJexlNodeVisitor();\n+            functionVisitor.visit(node, null);\n+            List<JexlNode> args = functionVisitor.args();\n+            for (JexlNode arg : args) {\n+                // Only take the literals\n+                if (arg instanceof ASTStringLiteral) {\n+                    parseAndPutPattern(arg);\n                 }\n             }\n         }\n-        \n         // Do not descend to children, the ValidPatternVisitor views a function node as a leaf node.\n         return data;\n     }\n     \n     /**\n      * Parse a literal value and put into the pattern cache if it does not exist.\n-     * \n+     *\n      * @param node\n      */\n-    public void parseAndPutLiteral(JexlNode node) {\n-        Object literalValue;\n-        \n+    public void parseAndPutPattern(JexlNode node) {\n         // Catch the situation where a user might enter FIELD1 !~ VALUE1\n-        try {\n-            literalValue = JexlASTHelper.getLiteralValue(node);\n-        } catch (NoSuchElementException e) {\n-            return;\n-        }\n-        \n+        Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            if (patternCache.containsKey(literalString)) {\n-                return;\n+            try {\n+                if (patternCache.containsKey(literalString)) {\n+                    return;\n+                }\n+                patternCache.put(literalString, Pattern.compile(literalString));\n+            } catch (PatternSyntaxException e) {\n+                String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n+                String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n+                throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n             }\n-            patternCache.put(literalString, Pattern.compile(literalString));\n         }\n-        return;\n     }\n }\n", "next_change": {"commit": "73f547a03491c039865e3f32c97bfe9640f09889", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex 2c380b18f..8450ec0dc 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -119,4 +125,5 @@ public class ValidPatternVisitor extends BaseVisitor {\n             }\n         }\n     }\n+    \n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "message": "Merge commit", "committedDate": null}, {"oid": "04280fd405ecdc04e3f210955b40e68457dbbada", "committedDate": "2020-10-28 15:36:37 -0400", "message": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions. (#787)"}, {"oid": "57bd9c0e4ba1a0a941cad7df5222987ad3fcc769", "committedDate": "2020-11-09 20:08:44 +0000", "message": "Ensure we allow FIELD =~ FIELD"}, {"oid": "905ca25e0ccd1a8b9e1f39c786fb5f5bbfd8320c", "committedDate": "2020-11-09 20:52:07 +0000", "message": "formatting"}, {"oid": "73f547a03491c039865e3f32c97bfe9640f09889", "committedDate": "2022-08-18 11:56:17 -0400", "message": "Task/short circuit valid pattern 1498 (#1582)"}, {"oid": "86af570caa1acc856f8ecbc52188b4f41a1f9fd4", "committedDate": "2023-03-14 12:02:56 -0400", "message": "Fixing annotations on query-core docs (#1848)"}]}, {"oid": "a1a452d9207831004d03a274647efa87888c0959", "url": "https://github.com/NationalSecurityAgency/datawave/commit/a1a452d9207831004d03a274647efa87888c0959", "message": "Address PR comments.", "committedDate": "2020-04-03T12:34:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MTIzOQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402981239", "body": "Pretty sure this is the right place to put these constants, let me know if that needs to change.", "bodyText": "Pretty sure this is the right place to put these constants, let me know if that needs to change.", "bodyHTML": "<p dir=\"auto\">Pretty sure this is the right place to put these constants, let me know if that needs to change.</p>", "author": "apmoriarty", "createdAt": "2020-04-03T12:49:36Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java", "diffHunk": "@@ -22,6 +22,8 @@\n     public static final String OPTIONS_FUNCTION = \"options\";\n     public static final String UNIQUE_FUNCTION = \"unique\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n+    public static final String INCLUDE_FUNCTION = \"include\";\n+    public static final String EXCLUDE_FUNCTION = \"exclude\";\n     ", "originalCommit": "a1a452d9207831004d03a274647efa87888c0959", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNTYxMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411605612", "bodyText": "These are EvaluationPhaseFilterFunctions, not QueryFunctions", "author": "ivakegg", "createdAt": "2020-04-20T18:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MTIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNTk5OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411605998", "bodyText": "and the functions are called includeRegex and excludeRegex", "author": "ivakegg", "createdAt": "2020-04-20T18:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MTIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex ae1fa2a8b..0ce9e0a91 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -22,8 +22,6 @@ public class QueryFunctions {\n     public static final String OPTIONS_FUNCTION = \"options\";\n     public static final String UNIQUE_FUNCTION = \"unique\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n-    public static final String INCLUDE_FUNCTION = \"include\";\n-    public static final String EXCLUDE_FUNCTION = \"exclude\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex ae1fa2a8b..0ce9e0a91 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -22,8 +22,6 @@ public class QueryFunctions {\n     public static final String OPTIONS_FUNCTION = \"options\";\n     public static final String UNIQUE_FUNCTION = \"unique\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n-    public static final String INCLUDE_FUNCTION = \"include\";\n-    public static final String EXCLUDE_FUNCTION = \"exclude\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": {"commit": "36e4af7d305e933fa673e46b35fe35a362e2d18e", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex 0ce9e0a91..bfb120755 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -21,6 +21,9 @@ public class QueryFunctions {\n     public static final String QUERY_FUNCTION_NAMESPACE = \"f\";\n     public static final String OPTIONS_FUNCTION = \"options\";\n     public static final String UNIQUE_FUNCTION = \"unique\";\n+    public static final String UNIQUE_BY_DAY_FUNCTION = \"unique_by_day\";\n+    public static final String UNIQUE_BY_HOUR_FUNCTION = \"unique_by_hour\";\n+    public static final String UNIQUE_BY_MINUTE_FUNCTION = \"unique_by_minute\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n", "next_change": {"commit": "cbae731d09359f59134439d8134bf3993f4fab60", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex bfb120755..e71a270e9 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -25,6 +25,7 @@ public class QueryFunctions {\n     public static final String UNIQUE_BY_HOUR_FUNCTION = \"unique_by_hour\";\n     public static final String UNIQUE_BY_MINUTE_FUNCTION = \"unique_by_minute\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n+    public static final String EXCERPT_FIELDS_FUNCTION = \"excerpt_fields\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": {"commit": "948a020e143a78b66c7f28b569b0058ccdaa8f3d", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex e71a270e9..11f937c19 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -26,6 +32,7 @@ public class QueryFunctions {\n     public static final String UNIQUE_BY_MINUTE_FUNCTION = \"unique_by_minute\";\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n     public static final String EXCERPT_FIELDS_FUNCTION = \"excerpt_fields\";\n+    public static final String MATCH_REGEX = \"matchRegex\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": {"commit": "e81cc2fa499152f13a15a16a9790a6786515d489", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex 11f937c19..4fa750f52 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -33,6 +33,7 @@ public class QueryFunctions {\n     public static final String GROUPBY_FUNCTION = \"groupby\";\n     public static final String EXCERPT_FIELDS_FUNCTION = \"excerpt_fields\";\n     public static final String MATCH_REGEX = \"matchRegex\";\n+    public static final String INCLUDE_TEXT = \"includeText\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": {"commit": "94456377e46e95081ceb2068f0e0890fb91d4d1e", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\nindex 4fa750f52..7b785edd5 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctions.java\n", "chunk": "@@ -34,6 +34,7 @@ public class QueryFunctions {\n     public static final String EXCERPT_FIELDS_FUNCTION = \"excerpt_fields\";\n     public static final String MATCH_REGEX = \"matchRegex\";\n     public static final String INCLUDE_TEXT = \"includeText\";\n+    public static final String NO_EXPANSION = \"noExpansion\";\n     \n     protected static Logger log = Logger.getLogger(QueryFunctions.class);\n     \n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "message": "Merge commit", "committedDate": null}, {"oid": "38131bf6f3071b51b3862c0049546855d7e881f7", "committedDate": "2021-05-20 13:32:55 -0400", "message": "Bugfix/issue 887 - Add more null checks in JEXL functions (#1183)"}, {"oid": "36e4af7d305e933fa673e46b35fe35a362e2d18e", "committedDate": "2021-08-09 17:11:14 -0400", "message": "Add support for further granularity in #UNIQUE (#1197)"}, {"oid": "cbae731d09359f59134439d8134bf3993f4fab60", "committedDate": "2022-04-19 14:34:45 -0400", "message": "Add term frequency excerpts to results (#1482)"}, {"oid": "948a020e143a78b66c7f28b569b0058ccdaa8f3d", "committedDate": "2022-10-03 15:00:22 -0400", "message": "Create matchRegex function for index-only fields (#1535)"}, {"oid": "e81cc2fa499152f13a15a16a9790a6786515d489", "committedDate": "2022-10-04 10:44:21 -0400", "message": "Move includeText to QueryFunctions (#1534)"}, {"oid": "94456377e46e95081ceb2068f0e0890fb91d4d1e", "committedDate": "2022-10-04 13:23:42 -0400", "message": "Move #NO_EXPANSION to query functions (#1633)"}, {"oid": "f2b25f9fd729ecbe078da954d59482053ea478b1", "committedDate": "2022-12-07 09:58:54 -0500", "message": "Add Unique By Month Granularity, in addition to more Calendar class types (#1747)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MTg4MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r402981881", "body": "Tried to scope down the number of patterns that get parsed. Might not be necessary.", "bodyText": "Tried to scope down the number of patterns that get parsed. Might not be necessary.", "bodyHTML": "<p dir=\"auto\">Tried to scope down the number of patterns that get parsed. Might not be necessary.</p>", "author": "apmoriarty", "createdAt": "2020-04-03T12:50:46Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java", "diffHunk": "@@ -69,22 +59,65 @@ public Object visit(ASTERNode node, Object data) {\n      */\n     @Override\n     public Object visit(ASTNRNode node, Object data) {\n-        Object literalValue;\n+        parseAndPutPattern(node);\n+        return data;\n+    }\n+    \n+    /**\n+     * Visit an ASTFunctionNode to catch cases like #INCLUDE or #EXCLUDE that accept a regex as an argument\n+     * \n+     * @param node\n+     * @param data\n+     * @return\n+     */\n+    @Override\n+    public Object visit(ASTFunctionNode node, Object data) {\n         \n-        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n-        try {\n-            literalValue = JexlASTHelper.getLiteralValue(node);\n-        } catch (NoSuchElementException e) {\n-            return data;\n+        // Should pull back an EvaluationPhaseFilterFunctionsDescriptor\n+        JexlArgumentDescriptor descriptor = JexlFunctionArgumentDescriptorFactory.F.getArgumentDescriptor(node);\n+        if (descriptor == null) {\n+            throw new IllegalStateException(\"Could not get descriptor for ASTFunctionNode\");\n         }\n         \n+        if (descriptor.regexArguments()) {\n+            // Extract the args for this function\n+            FunctionJexlNodeVisitor functionVisitor = new FunctionJexlNodeVisitor();\n+            functionVisitor.visit(node, null);\n+            List<JexlNode> args = functionVisitor.args();\n+            for (JexlNode arg : args) {\n+                // Only take the literals\n+                if (arg instanceof ASTStringLiteral) {\n+                    parseAndPutPattern(arg);\n+                }\n+            }\n+        }\n+        // Do not descend to children, the ValidPatternVisitor views a function node as a leaf node.\n+        return data;\n+    }\n+    \n+    /**\n+     * Parse a literal value and put into the pattern cache if it does not exist.\n+     *\n+     * @param node\n+     */\n+    public void parseAndPutPattern(JexlNode node) {\n+        // Catch the situation where a user might enter FIELD1 !~ VALUE1\n+        Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            if (patternCache.containsKey(literalString)) {\n-                return data;\n+            // Only parse literals that contain a regex char\n+            if (StringUtils.containsAny(literalString, \"?.*^+-_[](){}\")) {", "originalCommit": "a1a452d9207831004d03a274647efa87888c0959", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwOTk2Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411609963", "bodyText": "I don't think this is necessary, and in fact could be problematic.  A Regex is not guaranteed to contain one of those characters.  Perhaps a better way to go is if the literal contains only alphanumeric characters.", "author": "ivakegg", "createdAt": "2020-04-20T18:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk4MTg4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex 92065cbfa..2c380b18f 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -105,18 +107,15 @@ public class ValidPatternVisitor extends BaseVisitor {\n         Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            // Only parse literals that contain a regex char\n-            if (StringUtils.containsAny(literalString, \"?.*^+-_[](){}\")) {\n-                try {\n-                    if (patternCache.containsKey(literalString)) {\n-                        return;\n-                    }\n-                    patternCache.put(literalString, Pattern.compile(literalString));\n-                } catch (PatternSyntaxException e) {\n-                    String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n-                    String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n-                    throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n+            try {\n+                if (patternCache.containsKey(literalString)) {\n+                    return;\n                 }\n+                patternCache.put(literalString, Pattern.compile(literalString));\n+            } catch (PatternSyntaxException e) {\n+                String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n+                String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n+                throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n             }\n         }\n     }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex 92065cbfa..2c380b18f 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -105,18 +107,15 @@ public class ValidPatternVisitor extends BaseVisitor {\n         Object literalValue = JexlASTHelper.getLiteralValue(node);\n         if (literalValue != null && String.class.equals(literalValue.getClass())) {\n             String literalString = (String) literalValue;\n-            // Only parse literals that contain a regex char\n-            if (StringUtils.containsAny(literalString, \"?.*^+-_[](){}\")) {\n-                try {\n-                    if (patternCache.containsKey(literalString)) {\n-                        return;\n-                    }\n-                    patternCache.put(literalString, Pattern.compile(literalString));\n-                } catch (PatternSyntaxException e) {\n-                    String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n-                    String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n-                    throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n+            try {\n+                if (patternCache.containsKey(literalString)) {\n+                    return;\n                 }\n+                patternCache.put(literalString, Pattern.compile(literalString));\n+            } catch (PatternSyntaxException e) {\n+                String builtNode = JexlStringBuildingVisitor.buildQueryWithoutParse(node);\n+                String errMsg = \"Invalid pattern found in filter function '\" + builtNode + \"'\";\n+                throw new PatternSyntaxException(errMsg, e.getPattern(), e.getIndex());\n             }\n         }\n     }\n", "next_change": {"commit": "73f547a03491c039865e3f32c97bfe9640f09889", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\nindex 2c380b18f..8450ec0dc 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/visitors/ValidPatternVisitor.java\n", "chunk": "@@ -119,4 +125,5 @@ public class ValidPatternVisitor extends BaseVisitor {\n             }\n         }\n     }\n+    \n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "message": "Merge commit", "committedDate": null}, {"oid": "04280fd405ecdc04e3f210955b40e68457dbbada", "committedDate": "2020-10-28 15:36:37 -0400", "message": "ValidPatternVisitor now checks #INCLUDE and #EXCLUDE functions. (#787)"}, {"oid": "57bd9c0e4ba1a0a941cad7df5222987ad3fcc769", "committedDate": "2020-11-09 20:08:44 +0000", "message": "Ensure we allow FIELD =~ FIELD"}, {"oid": "905ca25e0ccd1a8b9e1f39c786fb5f5bbfd8320c", "committedDate": "2020-11-09 20:52:07 +0000", "message": "formatting"}, {"oid": "73f547a03491c039865e3f32c97bfe9640f09889", "committedDate": "2022-08-18 11:56:17 -0400", "message": "Task/short circuit valid pattern 1498 (#1582)"}, {"oid": "86af570caa1acc856f8ecbc52188b4f41a1f9fd4", "committedDate": "2023-03-14 12:02:56 -0400", "message": "Fixing annotations on query-core docs (#1848)"}]}, {"oid": "7fab0fec7738b6d183dd14d5912617525ebc8f69", "url": "https://github.com/NationalSecurityAgency/datawave/commit/7fab0fec7738b6d183dd14d5912617525ebc8f69", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-04-03T14:16:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNjE0MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411606141", "body": "Wrong functions descriptor.", "bodyText": "Wrong functions descriptor.", "bodyHTML": "<p dir=\"auto\">Wrong functions descriptor.</p>", "author": "ivakegg", "createdAt": "2020-04-20T18:42:24Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java", "diffHunk": "@@ -138,6 +138,10 @@ private static void verify(String name, int numArgs) {\n             if (numArgs == 0) {\n                 throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n             }\n+        } else if (name.equals(QueryFunctions.INCLUDE_FUNCTION) || name.equals(QueryFunctions.EXCLUDE_FUNCTION)) {", "originalCommit": "7fab0fec7738b6d183dd14d5912617525ebc8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxOTA0NA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r415719044", "bodyText": "Got it.", "author": "apmoriarty", "createdAt": "2020-04-27T11:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNjE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\nindex ac54f56e0..839475444 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n", "chunk": "@@ -138,10 +138,6 @@ public class QueryFunctionsDescriptor implements JexlFunctionArgumentDescriptorF\n             if (numArgs == 0) {\n                 throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n             }\n-        } else if (name.equals(QueryFunctions.INCLUDE_FUNCTION) || name.equals(QueryFunctions.EXCLUDE_FUNCTION)) {\n-            if (numArgs < 2) {\n-                throw new IllegalArgumentException(\"Wrong number of arguments expected for \" + name + \" function\");\n-            }\n         } else {\n             throw new IllegalArgumentException(\"Unknown Query function: \" + name);\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\nindex ac54f56e0..839475444 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n", "chunk": "@@ -138,10 +138,6 @@ public class QueryFunctionsDescriptor implements JexlFunctionArgumentDescriptorF\n             if (numArgs == 0) {\n                 throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n             }\n-        } else if (name.equals(QueryFunctions.INCLUDE_FUNCTION) || name.equals(QueryFunctions.EXCLUDE_FUNCTION)) {\n-            if (numArgs < 2) {\n-                throw new IllegalArgumentException(\"Wrong number of arguments expected for \" + name + \" function\");\n-            }\n         } else {\n             throw new IllegalArgumentException(\"Unknown Query function: \" + name);\n         }\n", "next_change": {"commit": "c5ea032c4fa922ce784a2fc8c0e57f6a2dce68e9", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\nindex 839475444..eb742d48c 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n", "chunk": "@@ -134,7 +135,9 @@ public class QueryFunctionsDescriptor implements JexlFunctionArgumentDescriptorF\n             if (numArgs % 2 != 0) {\n                 throw new IllegalArgumentException(\"Expected even number of arguments to options function\");\n             }\n-        } else if (name.equals(QueryFunctions.UNIQUE_FUNCTION) || name.equals(QueryFunctions.GROUPBY_FUNCTION)) {\n+        } else if (name.equals(QueryFunctions.UNIQUE_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_DAY_FUNCTION)\n+                        || name.equals(QueryFunctions.UNIQUE_BY_HOUR_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_MINUTE_FUNCTION)\n+                        || name.equals(QueryFunctions.GROUPBY_FUNCTION)) {\n             if (numArgs == 0) {\n                 throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n             }\n", "next_change": {"commit": "cbae731d09359f59134439d8134bf3993f4fab60", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\nindex eb742d48c..f3a6d5c9f 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n", "chunk": "@@ -137,7 +137,7 @@ public class QueryFunctionsDescriptor implements JexlFunctionArgumentDescriptorF\n             }\n         } else if (name.equals(QueryFunctions.UNIQUE_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_DAY_FUNCTION)\n                         || name.equals(QueryFunctions.UNIQUE_BY_HOUR_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_MINUTE_FUNCTION)\n-                        || name.equals(QueryFunctions.GROUPBY_FUNCTION)) {\n+                        || name.equals(QueryFunctions.GROUPBY_FUNCTION) || name.equals(QueryFunctions.EXCERPT_FIELDS_FUNCTION)) {\n             if (numArgs == 0) {\n                 throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n             }\n", "next_change": {"commit": "948a020e143a78b66c7f28b569b0058ccdaa8f3d", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\nindex f3a6d5c9f..67aae3561 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/jexl/functions/QueryFunctionsDescriptor.java\n", "chunk": "@@ -123,26 +148,35 @@ public class QueryFunctionsDescriptor implements JexlFunctionArgumentDescriptorF\n     }\n     \n     private static void verify(String name, int numArgs) {\n-        if (name.equals(\"between\")) {\n-            if (numArgs != 3) {\n-                throw new IllegalArgumentException(\"Wrong number of arguments to between function\");\n-            }\n-        } else if (name.equals(\"length\")) {\n-            if (numArgs != 3) {\n-                throw new IllegalArgumentException(\"Wrong number of arguments to length function\");\n-            }\n-        } else if (name.equals(QueryFunctions.OPTIONS_FUNCTION)) {\n-            if (numArgs % 2 != 0) {\n-                throw new IllegalArgumentException(\"Expected even number of arguments to options function\");\n-            }\n-        } else if (name.equals(QueryFunctions.UNIQUE_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_DAY_FUNCTION)\n-                        || name.equals(QueryFunctions.UNIQUE_BY_HOUR_FUNCTION) || name.equals(QueryFunctions.UNIQUE_BY_MINUTE_FUNCTION)\n-                        || name.equals(QueryFunctions.GROUPBY_FUNCTION) || name.equals(QueryFunctions.EXCERPT_FIELDS_FUNCTION)) {\n-            if (numArgs == 0) {\n-                throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n-            }\n-        } else {\n-            throw new IllegalArgumentException(\"Unknown Query function: \" + name);\n+        switch (name) {\n+            case BETWEEN:\n+                if (numArgs != 3) {\n+                    throw new IllegalArgumentException(\"Wrong number of arguments to between function\");\n+                }\n+                break;\n+            case LENGTH:\n+                if (numArgs != 3) {\n+                    throw new IllegalArgumentException(\"Wrong number of arguments to length function\");\n+                }\n+                break;\n+            case QueryFunctions.OPTIONS_FUNCTION:\n+                if (numArgs % 2 != 0) {\n+                    throw new IllegalArgumentException(\"Expected even number of arguments to options function\");\n+                }\n+                break;\n+            case QueryFunctions.UNIQUE_FUNCTION:\n+            case QueryFunctions.UNIQUE_BY_DAY_FUNCTION:\n+            case QueryFunctions.UNIQUE_BY_HOUR_FUNCTION:\n+            case QueryFunctions.UNIQUE_BY_MINUTE_FUNCTION:\n+            case QueryFunctions.GROUPBY_FUNCTION:\n+            case QueryFunctions.EXCERPT_FIELDS_FUNCTION:\n+            case QueryFunctions.MATCH_REGEX:\n+                if (numArgs == 0) {\n+                    throw new IllegalArgumentException(\"Expected at least one argument to the \" + name + \" function\");\n+                }\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown Query function: \" + name);\n         }\n     }\n }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "message": "Merge commit", "committedDate": null}, {"oid": "fe4fdb45cbb61fcd4b9a88df73ee673caab13283", "committedDate": "2020-12-21 09:22:55 -0500", "message": "fixed #902: Change to mark bounded ranges in JEXL (#926)"}, {"oid": "c5ea032c4fa922ce784a2fc8c0e57f6a2dce68e9", "committedDate": "2022-01-25 11:54:30 -0500", "message": "Ensure unique_by_xxx functions are allowed (#1379)"}, {"oid": "cbae731d09359f59134439d8134bf3993f4fab60", "committedDate": "2022-04-19 14:34:45 -0400", "message": "Add term frequency excerpts to results (#1482)"}, {"oid": "948a020e143a78b66c7f28b569b0058ccdaa8f3d", "committedDate": "2022-10-03 15:00:22 -0400", "message": "Create matchRegex function for index-only fields (#1535)"}, {"oid": "e81cc2fa499152f13a15a16a9790a6786515d489", "committedDate": "2022-10-04 10:44:21 -0400", "message": "Move includeText to QueryFunctions (#1534)"}, {"oid": "94456377e46e95081ceb2068f0e0890fb91d4d1e", "committedDate": "2022-10-04 13:23:42 -0400", "message": "Move #NO_EXPANSION to query functions (#1633)"}, {"oid": "f2b25f9fd729ecbe078da954d59482053ea478b1", "committedDate": "2022-12-07 09:58:54 -0500", "message": "Add Unique By Month Granularity, in addition to more Calendar class types (#1747)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNzgwMg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411607802", "body": "I would leave this the way it was.", "bodyText": "I would leave this the way it was.", "bodyHTML": "<p dir=\"auto\">I would leave this the way it was.</p>", "author": "ivakegg", "createdAt": "2020-04-20T18:45:03Z", "path": "warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java", "diffHunk": "@@ -1,11 +1,12 @@\n package datawave.query.language.functions.jexl;\n \n+import datawave.query.jexl.functions.QueryFunctions;\n import datawave.query.language.functions.QueryFunction;\n import datawave.query.search.WildcardFieldedFilter;\n \n public class Exclude extends AbstractEvaluationPhaseFunction {\n     public Exclude() {\n-        super(\"exclude\");\n+        super(QueryFunctions.EXCLUDE_FUNCTION);", "originalCommit": "7fab0fec7738b6d183dd14d5912617525ebc8f69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNzk1MQ==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r411607951", "bodyText": "and ditto for the other language function classes", "author": "ivakegg", "createdAt": "2020-04-20T18:45:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNzgwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcxODc2Mg==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/787#discussion_r415718762", "bodyText": "I'll revert that to the way it was", "author": "apmoriarty", "createdAt": "2020-04-27T11:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNzgwMg=="}], "type": "inlineReview", "revised_code": {"commit": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java b/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\nindex fe4a380b5..1e2e66333 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\n", "chunk": "@@ -1,12 +1,11 @@\n package datawave.query.language.functions.jexl;\n \n-import datawave.query.jexl.functions.QueryFunctions;\n import datawave.query.language.functions.QueryFunction;\n import datawave.query.search.WildcardFieldedFilter;\n \n public class Exclude extends AbstractEvaluationPhaseFunction {\n     public Exclude() {\n-        super(QueryFunctions.EXCLUDE_FUNCTION);\n+        super(\"exclude\");\n     }\n     \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "changed_code": [{"header": "diff --git a/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java b/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\nindex fe4a380b5..1e2e66333 100644\n--- a/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\n+++ b/warehouse/query-core/src/main/java/datawave/query/language/functions/jexl/Exclude.java\n", "chunk": "@@ -1,12 +1,11 @@\n package datawave.query.language.functions.jexl;\n \n-import datawave.query.jexl.functions.QueryFunctions;\n import datawave.query.language.functions.QueryFunction;\n import datawave.query.search.WildcardFieldedFilter;\n \n public class Exclude extends AbstractEvaluationPhaseFunction {\n     public Exclude() {\n-        super(QueryFunctions.EXCLUDE_FUNCTION);\n+        super(\"exclude\");\n     }\n     \n     @Override\n", "next_change": null}]}, "commits_in_main": [{"oid": "6fe183a20091ceacdb7a2980a8598e28ce8a5750", "message": "Merge commit", "committedDate": null}]}, {"oid": "e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "url": "https://github.com/NationalSecurityAgency/datawave/commit/e974537d9a65a0b3b852c3c26a093e9fab4f31d2", "message": "Address PR comments.", "committedDate": "2020-04-27T11:04:31Z", "type": "commit"}, {"oid": "21b7ef85ca58edac4f2d11788be9b38922426c25", "url": "https://github.com/NationalSecurityAgency/datawave/commit/21b7ef85ca58edac4f2d11788be9b38922426c25", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-04-27T15:07:07Z", "type": "commit"}, {"oid": "c84bdf03c16dda41edaed20157881452bf6088d8", "url": "https://github.com/NationalSecurityAgency/datawave/commit/c84bdf03c16dda41edaed20157881452bf6088d8", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-05-06T16:29:22Z", "type": "commit"}, {"oid": "33ac86ef0fcad99399341805218b523a6368e1c2", "url": "https://github.com/NationalSecurityAgency/datawave/commit/33ac86ef0fcad99399341805218b523a6368e1c2", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-05-06T17:23:28Z", "type": "commit"}, {"oid": "c4dde231be16d1d7a3d5d3e00ccfb2f72056f888", "url": "https://github.com/NationalSecurityAgency/datawave/commit/c4dde231be16d1d7a3d5d3e00ccfb2f72056f888", "message": "Merge branch 'master' into task/ValidPatternVisitor_checkFunctions", "committedDate": "2020-05-14T10:45:39Z", "type": "commit"}]}