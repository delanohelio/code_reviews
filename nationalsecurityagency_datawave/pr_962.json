{"pr_number": 962, "pr_title": "Verify lineage for QueryModelVisitor", "pr_author": "lbschanno", "pr_createdAt": "2020-10-20T21:49:10Z", "pr_url": "https://github.com/NationalSecurityAgency/datawave/pull/962", "timeline": [{"oid": "ad8fc694681e6d791675c18e06794352fe7ab750", "url": "https://github.com/NationalSecurityAgency/datawave/commit/ad8fc694681e6d791675c18e06794352fe7ab750", "message": "Verify lineage for QueryModelVisitor\n\nAdd asserts to tests for QueryModelVisitor to verify that it returns a\nquery tree for valid lineage.\n\nPart of #880.", "committedDate": "2020-10-20T21:48:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMzU1Mw==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/962#discussion_r514633553", "body": "```suggestion\r\n        Set<List<JexlNode>> newSet = product.stream().map(list -> list.stream().map(RebuildingVisitor::copy).collect(Collectors.toList()))\r\n                        .collect(Collectors.toSet());\r\n```\r\n\r\nI like this change, but it had me wondering if we actually still needed the ProductTransformer.  After playing around with this a little, I settled on this implementation (which causes a ripple-effect of changes in a few places).\r\n\r\nThe transformer handled the case where one of the elements in the list is NOT a JexlNode.  However, after looking at all the ways we populate the 'left' and 'right' sets, we are only ever populating them with JexlNodes, so instead of typing everything as 'object', I typed everything as JexlNode, which simplified the ProductTransformer logic down to straight 'copy' on each sublist.  That's what is reflected here.  \r\n\r\nThis change led to a few method signature changes in JexlNodeFactory, namely:\r\n1) createNodeTreeFromPairs - the pairs argument changed to Set<List<JexlNode>> pairs\r\n2) buildUntypedBinaryNode - the left and right arguments changed to JexlNode\r\n\r\nBoth of those methods accept simple objects as inputs, but they don't actually work for anything that doesn't extend JexlNode, so it makes sense to me to be more specific with our typing.  I know that this isn't your code, and it may be a little outside the scope of this PR, but I think this would be a good change if you're up for it.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<List<Object>> newSet = product.stream().map(new ProductTransformer()::apply).collect(Collectors.toSet());\n          \n          \n            \n                    Set<List<JexlNode>> newSet = product.stream().map(list -> list.stream().map(RebuildingVisitor::copy).collect(Collectors.toList()))\n          \n          \n            \n                                    .collect(Collectors.toSet());\n          \n      \n    \n    \n  \n\nI like this change, but it had me wondering if we actually still needed the ProductTransformer.  After playing around with this a little, I settled on this implementation (which causes a ripple-effect of changes in a few places).\nThe transformer handled the case where one of the elements in the list is NOT a JexlNode.  However, after looking at all the ways we populate the 'left' and 'right' sets, we are only ever populating them with JexlNodes, so instead of typing everything as 'object', I typed everything as JexlNode, which simplified the ProductTransformer logic down to straight 'copy' on each sublist.  That's what is reflected here.\nThis change led to a few method signature changes in JexlNodeFactory, namely:\n\ncreateNodeTreeFromPairs - the pairs argument changed to Set<List> pairs\nbuildUntypedBinaryNode - the left and right arguments changed to JexlNode\n\nBoth of those methods accept simple objects as inputs, but they don't actually work for anything that doesn't extend JexlNode, so it makes sense to me to be more specific with our typing.  I know that this isn't your code, and it may be a little outside the scope of this PR, but I think this would be a good change if you're up for it.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">Set&lt;<span class=\"pl-k\">List&lt;<span class=\"pl-smi x x-first x-last\">Object</span>&gt;</span>&gt;</span> newSet <span class=\"pl-k\">=</span> product<span class=\"pl-k\">.</span>stream()<span class=\"pl-k\">.</span>map(<span class=\"pl-k x x-first\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">ProductTransformer</span><span class=\"x\">()</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">apply</span>)<span class=\"pl-k\">.</span>collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span><span class=\"x x-first x-last\">toSet</span>())<span class=\"x x-first x-last\">;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">Set&lt;<span class=\"pl-k\">List&lt;<span class=\"pl-smi x x-first x-last\">JexlNode</span>&gt;</span>&gt;</span> newSet <span class=\"pl-k\">=</span> product<span class=\"pl-k\">.</span>stream()<span class=\"pl-k\">.</span>map(<span class=\"x x-first\">list </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> list</span><span class=\"pl-k x\">.</span><span class=\"x\">stream()</span><span class=\"pl-k x\">.</span><span class=\"x\">map(</span><span class=\"pl-smi x\">RebuildingVisitor</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">copy</span>)<span class=\"pl-k\">.</span>collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span><span class=\"x x-first x-last\">toList</span>())<span class=\"x x-first x-last\">)</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        .collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span>toSet());</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">I like this change, but it had me wondering if we actually still needed the ProductTransformer.  After playing around with this a little, I settled on this implementation (which causes a ripple-effect of changes in a few places).</p>\n<p dir=\"auto\">The transformer handled the case where one of the elements in the list is NOT a JexlNode.  However, after looking at all the ways we populate the 'left' and 'right' sets, we are only ever populating them with JexlNodes, so instead of typing everything as 'object', I typed everything as JexlNode, which simplified the ProductTransformer logic down to straight 'copy' on each sublist.  That's what is reflected here.</p>\n<p dir=\"auto\">This change led to a few method signature changes in JexlNodeFactory, namely:</p>\n<ol dir=\"auto\">\n<li>createNodeTreeFromPairs - the pairs argument changed to Set&lt;List&gt; pairs</li>\n<li>buildUntypedBinaryNode - the left and right arguments changed to JexlNode</li>\n</ol>\n<p dir=\"auto\">Both of those methods accept simple objects as inputs, but they don't actually work for anything that doesn't extend JexlNode, so it makes sense to me to be more specific with our typing.  I know that this isn't your code, and it may be a little outside the scope of this PR, but I think this would be a good change if you're up for it.</p>", "author": "jwomeara", "createdAt": "2020-10-29T23:58:25Z", "path": "warehouse/query-core/src/main/java/datawave/query/jexl/visitors/QueryModelVisitor.java", "diffHunk": "@@ -395,20 +388,18 @@ protected JexlNode expandBinaryNodeFromModel(JexlNode node, Object data) {\n          * need to ensure that if we create a logical structure ( such as an or ) -- each literal references a unique identifier from the right. Otherwise,\n          * subsequent visitors will reference incorrection sub trees, and potentially negate the activity of the query model visitor\n          */\n-        Set<List<Object>> newSet = Sets.newHashSet(FluentIterable.from(product).transform(new ProductTransformer()));\n+        Set<List<Object>> newSet = product.stream().map(new ProductTransformer()::apply).collect(Collectors.toSet());", "originalCommit": "ad8fc694681e6d791675c18e06794352fe7ab750", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDcyMDU2OA==", "url": "https://github.com/NationalSecurityAgency/datawave/pull/962#discussion_r514720568", "bodyText": "@jwomeara I made the changes necessary to remove ProductTransformer.", "author": "lbschanno", "createdAt": "2020-10-30T02:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYzMzU1Mw=="}], "type": "inlineReview"}, {"oid": "fa94f3a4482a0d928e1abbcdc65cfc1cfbde3194", "url": "https://github.com/NationalSecurityAgency/datawave/commit/fa94f3a4482a0d928e1abbcdc65cfc1cfbde3194", "message": "Merge branch 'master' into 880-QueryModelVisitor", "committedDate": "2020-10-30T00:04:07Z", "type": "commit"}, {"oid": "d09c739af400acdb1e26803c9bf4c139b9a4812c", "url": "https://github.com/NationalSecurityAgency/datawave/commit/d09c739af400acdb1e26803c9bf4c139b9a4812c", "message": "Remove ProductTransformer", "committedDate": "2020-10-30T02:26:01Z", "type": "commit"}, {"oid": "165dae776995b30fcf0f2f473a394a4e6b763b68", "url": "https://github.com/NationalSecurityAgency/datawave/commit/165dae776995b30fcf0f2f473a394a4e6b763b68", "message": "Merge branch 'master' into 880-QueryModelVisitor", "committedDate": "2020-10-30T17:42:33Z", "type": "commit"}]}