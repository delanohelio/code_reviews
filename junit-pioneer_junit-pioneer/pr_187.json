{"pr_number": 187, "pr_title": "Prevent faulty/redundant annotation search", "pr_author": "nipafx", "pr_createdAt": "2020-03-17T20:04:05Z", "pr_url": "https://github.com/junit-pioneer/junit-pioneer/pull/187", "timeline": [{"oid": "e3649aac2cb09acee0335be6cdd5fd73777a0d8d", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/e3649aac2cb09acee0335be6cdd5fd73777a0d8d", "message": "Fix `Utils::findAnnotation` and start phasing out `annotationPresentOnTestMethod`", "committedDate": "2020-03-31T18:46:36Z", "type": "commit"}, {"oid": "62950b6a90ee9296bc048c9ce0c5c0dceada2511", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/62950b6a90ee9296bc048c9ce0c5c0dceada2511", "message": "Format the code", "committedDate": "2020-03-31T18:46:36Z", "type": "commit"}, {"oid": "62950b6a90ee9296bc048c9ce0c5c0dceada2511", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/62950b6a90ee9296bc048c9ce0c5c0dceada2511", "message": "Format the code", "committedDate": "2020-03-31T18:46:36Z", "type": "forcePushed"}, {"oid": "b8a78190067ce7bad410b16b79028c3f8bab0ca1", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b8a78190067ce7bad410b16b79028c3f8bab0ca1", "message": "Properly handle repeatable and stackable annotations", "committedDate": "2020-03-31T22:12:04Z", "type": "commit"}, {"oid": "9d87a27056b14d1d22ef9080bc33f23526d7bb83", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/9d87a27056b14d1d22ef9080bc33f23526d7bb83", "message": "Rename `Utils` to `PioneerUtils`", "committedDate": "2020-03-31T22:13:11Z", "type": "commit"}, {"oid": "b67a0b0bce6b9d3538c62f7606c40401aa754be2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/b67a0b0bce6b9d3538c62f7606c40401aa754be2", "message": "Fix stackable wording", "committedDate": "2020-03-31T22:42:09Z", "type": "commit"}, {"oid": "ff06979c31e7d85b7d13c679f7a474107673848c", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/ff06979c31e7d85b7d13c679f7a474107673848c", "message": "Rename test class", "committedDate": "2020-03-31T22:46:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NjYxNg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401556616", "body": "i am not sure about the naming here,` isAnyAnnotationPresent` would be more representing, right now i would expect that all annotations are present", "bodyText": "i am not sure about the naming here, isAnyAnnotationPresent would be more representing, right now i would expect that all annotations are present", "bodyHTML": "<p dir=\"auto\">i am not sure about the naming here,<code> isAnyAnnotationPresent</code> would be more representing, right now i would expect that all annotations are present</p>", "author": "aepfli", "createdAt": "2020-04-01T11:51:50Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NzE4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401557180", "body": "```suggestion\r\n\tpublic static boolean isAnyRepeatableAnnotationPresent(ExtensionContext context,\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n          \n          \n            \n            \tpublic static boolean isAnyRepeatableAnnotationPresent(ExtensionContext context,", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">\t<span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">repeatableAnnotationsPresent</span>(<span class=\"pl-smi\">ExtensionContext</span> context,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">\t<span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">isAnyRepeatableAnnotationPresent</span>(<span class=\"pl-smi\">ExtensionContext</span> context,</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "aepfli", "createdAt": "2020-04-01T11:52:50Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDA2Nw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401744067", "bodyText": "Same as above, I suggest to rename this to isOneOf[Multiple]RepeatableAnnotationsPresent.", "author": "Bukama", "createdAt": "2020-04-01T16:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1NzE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MTYwNw==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401741607", "body": "Like @aepfli said: The current method name is foolish as it means that **all** of the given annotations must be present to return `true`, but the method does not check if all are present.\r\n\r\nAside the fact that method which return a `boolean` should be named in a way that they can be put into a yes/no question,  I suggest to rename the method to `isOneOf[Multiple]AnnotationsPresent` (not quite sure about the `Multiple`) to be associated to the parameters.\r\n\r\nThe current name and @aepfli's suggestion (`isAnyAnnotationPresent`) appeal that you recieve `true` if any annotation is present and you don't have to even specify which annotations should be searched for. Yes the context can be seen by the parameters, but as we have multiple similar method names a clear distinct method name is even more important in my opinion than if you have a single method. \r\n", "bodyText": "Like @aepfli said: The current method name is foolish as it means that all of the given annotations must be present to return true, but the method does not check if all are present.\nAside the fact that method which return a boolean should be named in a way that they can be put into a yes/no question,  I suggest to rename the method to isOneOf[Multiple]AnnotationsPresent (not quite sure about the Multiple) to be associated to the parameters.\nThe current name and @aepfli's suggestion (isAnyAnnotationPresent) appeal that you recieve true if any annotation is present and you don't have to even specify which annotations should be searched for. Yes the context can be seen by the parameters, but as we have multiple similar method names a clear distinct method name is even more important in my opinion than if you have a single method.", "bodyHTML": "<p dir=\"auto\">Like <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aepfli/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aepfli\">@aepfli</a> said: The current method name is foolish as it means that <strong>all</strong> of the given annotations must be present to return <code>true</code>, but the method does not check if all are present.</p>\n<p dir=\"auto\">Aside the fact that method which return a <code>boolean</code> should be named in a way that they can be put into a yes/no question,  I suggest to rename the method to <code>isOneOf[Multiple]AnnotationsPresent</code> (not quite sure about the <code>Multiple</code>) to be associated to the parameters.</p>\n<p dir=\"auto\">The current name and <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/aepfli/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/aepfli\">@aepfli</a>'s suggestion (<code>isAnyAnnotationPresent</code>) appeal that you recieve <code>true</code> if any annotation is present and you don't have to even specify which annotations should be searched for. Yes the context can be seen by the parameters, but as we have multiple similar method names a clear distinct method name is even more important in my opinion than if you have a single method.</p>", "author": "Bukama", "createdAt": "2020-04-01T16:19:35Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0OTA5MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401749090", "body": "*Mental liveticker*: Is it notable in the javadoc that the closest annotation is used? I don't think so, because we only want to check **if** any annotaiton is is present **regardless where** it is. ", "bodyText": "Mental liveticker: Is it notable in the javadoc that the closest annotation is used? I don't think so, because we only want to check if any annotaiton is is present regardless where it is.", "bodyHTML": "<p dir=\"auto\"><em>Mental liveticker</em>: Is it notable in the javadoc that the closest annotation is used? I don't think so, because we only want to check <strong>if</strong> any annotaiton is is present <strong>regardless where</strong> it is.</p>", "author": "Bukama", "createdAt": "2020-04-01T16:30:33Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1Mzg3NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401753875", "body": "`annotations if they are`", "bodyText": "annotations if they are", "bodyHTML": "<p dir=\"auto\"><code>annotations if they are</code></p>", "author": "Bukama", "createdAt": "2020-04-01T16:37:47Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc1NDE0OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401754149", "body": "`the annotations are present`", "bodyText": "the annotations are present", "bodyHTML": "<p dir=\"auto\"><code>the annotations are present</code></p>", "author": "Bukama", "createdAt": "2020-04-01T16:38:13Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2MDM4NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401760385", "body": "Would like to see a check like\r\n\r\n```\r\nif(repeatable && !annotationType.isRepeatable() {\r\nthrew new IllegalArgumentException(String.format(\"The annotation  is not repeatable!\", annotationType.class.getName()));\r\n}\r\n```\r\n\r\nbut as far as I know (and I couldn't find anything using Google) there's no check like this :/\r\n", "bodyText": "Would like to see a check like\nif(repeatable && !annotationType.isRepeatable() {\nthrew new IllegalArgumentException(String.format(\"The annotation  is not repeatable!\", annotationType.class.getName()));\n}\n\nbut as far as I know (and I couldn't find anything using Google) there's no check like this :/", "bodyHTML": "<p dir=\"auto\">Would like to see a check like</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"if(repeatable &amp;&amp; !annotationType.isRepeatable() {\nthrew new IllegalArgumentException(String.format(&quot;The annotation  is not repeatable!&quot;, annotationType.class.getName()));\n}\"><pre><code>if(repeatable &amp;&amp; !annotationType.isRepeatable() {\nthrew new IllegalArgumentException(String.format(\"The annotation  is not repeatable!\", annotationType.class.getName()));\n}\n</code></pre></div>\n<p dir=\"auto\">but as far as I know (and I couldn't find anything using Google) there's no check like this :/</p>", "author": "Bukama", "createdAt": "2020-04-01T16:48:08Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the instances on the closest one are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findClosestRepeatableAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, false);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllRepeatableAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, true);\n+\t}\n+\n+\tstatic <A extends Annotation> Stream<A> findOnAnything(ExtensionContext context, Class<A> annotationType,\n+\t\t\tboolean repeatable, boolean stackable) {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3OTc4MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r404979781", "bodyText": "Check JUnit Jupiter's AnnotationUtils#findRepeatableAnnotations - they already check whether the annotation is really repeatable.", "author": "nipafx", "createdAt": "2020-04-07T17:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2MDM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2NjExMQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401766111", "body": "`annotations if they are`", "bodyText": "annotations if they are", "bodyHTML": "<p dir=\"auto\"><code>annotations if they are</code></p>", "author": "Bukama", "createdAt": "2020-04-01T16:56:27Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2NjQ0NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401766444", "body": "`annotations are present`", "bodyText": "annotations are present", "bodyHTML": "<p dir=\"auto\"><code>annotations are present</code></p>", "author": "Bukama", "createdAt": "2020-04-01T16:56:56Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MDI4NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401770285", "body": "At least `findClosestRepeatableAnnotations` (plural), **but**: The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like `findClosestInstancesOfRepeatableAnnotation`. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.", "bodyText": "At least findClosestRepeatableAnnotations (plural), but: The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like findClosestInstancesOfRepeatableAnnotation. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.", "bodyHTML": "<p dir=\"auto\">At least <code>findClosestRepeatableAnnotations</code> (plural), <strong>but</strong>: The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like <code>findClosestInstancesOfRepeatableAnnotation</code>. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:02:23Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the instances on the closest one are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findClosestRepeatableAnnotation(ExtensionContext context,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4Mzc4MQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r404983781", "bodyText": "Quoting the JavaDoc of, e.g., AnnotationSupport::findAnnotation:\n\nFind the first annotation of annotationType [...]\n\nIt seems that the word annotation is used to describe the instance of an annotation type. Since that also keeps the name shorter, I'll be going with that interpretation.", "author": "nipafx", "createdAt": "2020-04-07T17:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MjQ5OQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401772499", "body": "The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like `findClosestInstancesOfAnnotation`. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.", "bodyText": "The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like findClosestInstancesOfAnnotation. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.", "bodyHTML": "<p dir=\"auto\">The method only searches for one specific annotation and (maybe) returns multiple instances. So I would prefer a name like <code>findClosestInstancesOfAnnotation</code>. Such a name makes it clear that you recieve multiple instances of the same type, but can not search for multiple, different annotations.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:06:11Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4NDE4MA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r404984180", "bodyText": "See above.", "author": "nipafx", "createdAt": "2020-04-07T17:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MjQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3NTUxMA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401775510", "body": "I prefer javadocs on non-public methods too, especially when they are contain so much logic like this.\r\nI want also suggest to add some inline comments in this method, e.g. on the first return, so that it's clear what happens there, when someone new or anybody else looks as this class in a few days/weeks/...", "bodyText": "I prefer javadocs on non-public methods too, especially when they are contain so much logic like this.\nI want also suggest to add some inline comments in this method, e.g. on the first return, so that it's clear what happens there, when someone new or anybody else looks as this class in a few days/weeks/...", "bodyHTML": "<p dir=\"auto\">I prefer javadocs on non-public methods too, especially when they are contain so much logic like this.<br>\nI want also suggest to add some inline comments in this method, e.g. on the first return, so that it's clear what happens there, when someone new or anybody else looks as this class in a few days/weeks/...</p>", "author": "Bukama", "createdAt": "2020-04-01T17:10:36Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the instances on the closest one are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findClosestRepeatableAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, false);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllRepeatableAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, true);\n+\t}\n+\n+\tstatic <A extends Annotation> Stream<A> findOnAnything(ExtensionContext context, Class<A> annotationType,", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4NDM3NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401784374", "body": "I'm not really happy with the names of the two `boolean` parameter `repeatable` and `stackable`.\r\n\r\nThe `repeatable` at first made me think that the method is repeatable callable, meaning it will call itself recursivly or not. But the parameter is used to determine if the annotation is repeatbale and if all instances have to be returned. So I suggest to rename it to `returnAllInstances` (prefered) or `isAnnotationRepeatable`. \r\n\r\nIt took me quite a long time to be sure what the `stackable` parameter is for. For me `stackable` means I can put multiple things on top and I was (exaggregated) wondering what the difference to `repeatable` should be. In the current context `stackable` means `search on the outer types/containers`. To make this more clearer I would suggest to rename it (everywhere) to somethink like `doSearchOnOuterContainer`.", "bodyText": "I'm not really happy with the names of the two boolean parameter repeatable and stackable.\nThe repeatable at first made me think that the method is repeatable callable, meaning it will call itself recursivly or not. But the parameter is used to determine if the annotation is repeatbale and if all instances have to be returned. So I suggest to rename it to returnAllInstances (prefered) or isAnnotationRepeatable.\nIt took me quite a long time to be sure what the stackable parameter is for. For me stackable means I can put multiple things on top and I was (exaggregated) wondering what the difference to repeatable should be. In the current context stackable means search on the outer types/containers. To make this more clearer I would suggest to rename it (everywhere) to somethink like doSearchOnOuterContainer.", "bodyHTML": "<p dir=\"auto\">I'm not really happy with the names of the two <code>boolean</code> parameter <code>repeatable</code> and <code>stackable</code>.</p>\n<p dir=\"auto\">The <code>repeatable</code> at first made me think that the method is repeatable callable, meaning it will call itself recursivly or not. But the parameter is used to determine if the annotation is repeatbale and if all instances have to be returned. So I suggest to rename it to <code>returnAllInstances</code> (prefered) or <code>isAnnotationRepeatable</code>.</p>\n<p dir=\"auto\">It took me quite a long time to be sure what the <code>stackable</code> parameter is for. For me <code>stackable</code> means I can put multiple things on top and I was (exaggregated) wondering what the difference to <code>repeatable</code> should be. In the current context <code>stackable</code> means <code>search on the outer types/containers</code>. To make this more clearer I would suggest to rename it (everywhere) to somethink like <code>doSearchOnOuterContainer</code>.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:25:03Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the instances on the closest one are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findClosestRepeatableAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, false);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllRepeatableAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, true);\n+\t}\n+\n+\tstatic <A extends Annotation> Stream<A> findOnAnything(ExtensionContext context, Class<A> annotationType,\n+\t\t\tboolean repeatable, boolean stackable) {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc4OTY1OA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401789658", "body": "I suggest to rename this class to `PioneerAnnotationsUtils` and move the two methods at the bottom (`distinctToSet` and `addButThrowIfDuplicate`) to a new class called `PioneerUtils`. I would like to to this, because this class has been grown very large and almost all of it's methods are for finding / dealing with annotations. The number of methods wich do so is large enough to justify an own class.\r\n\r\nWhen doing so classes which are related to this (like the test class) must also be renamed and javadoc updated.", "bodyText": "I suggest to rename this class to PioneerAnnotationsUtils and move the two methods at the bottom (distinctToSet and addButThrowIfDuplicate) to a new class called PioneerUtils. I would like to to this, because this class has been grown very large and almost all of it's methods are for finding / dealing with annotations. The number of methods wich do so is large enough to justify an own class.\nWhen doing so classes which are related to this (like the test class) must also be renamed and javadoc updated.", "bodyHTML": "<p dir=\"auto\">I suggest to rename this class to <code>PioneerAnnotationsUtils</code> and move the two methods at the bottom (<code>distinctToSet</code> and <code>addButThrowIfDuplicate</code>) to a new class called <code>PioneerUtils</code>. I would like to to this, because this class has been grown very large and almost all of it's methods are for finding / dealing with annotations. The number of methods wich do so is large enough to justify an own class.</p>\n<p dir=\"auto\">When doing so classes which are related to this (like the test class) must also be renamed and javadoc updated.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:33:32Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5MDkzMQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401790931", "body": "I'm voting to move the following two methods to a new class (see comment above about class name)", "bodyText": "I'm voting to move the following two methods to a new class (see comment above about class name)", "bodyHTML": "<p dir=\"auto\">I'm voting to move the following two methods to a new class (see comment above about class name)</p>", "author": "Bukama", "createdAt": "2020-04-01T17:35:34Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.\n+\t */\n+\tpublic static boolean annotationsPresent(ExtensionContext context, Class<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.map(annotationType -> findClosestAnnotation(context, annotationType))\n+\t\t\t\t.anyMatch(Optional::isPresent);\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified repeatable\n+\t * {@code annotationTypes} is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing\n+\t * class belonging to the specified {@code context}.\n+\t */\n+\tpublic static boolean repeatableAnnotationsPresent(ExtensionContext context,\n+\t\t\tClass<? extends Annotation>... annotationTypes) {\n+\t\treturn Stream\n+\t\t\t\t.of(annotationTypes)\n+\t\t\t\t.flatMap(annotationType -> findClosestRepeatableAnnotation(context, annotationType))\n+\t\t\t\t.iterator()\n+\t\t\t\t.hasNext();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the closest one is returned.\n+\t */\n+\tpublic static <A extends Annotation> Optional<A> findClosestAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, false).findFirst();\n+\t}\n+\n+\t/**\n+\t * Returns the specified annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, false, true);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * the instances on the closest one are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findClosestRepeatableAnnotation(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, false);\n+\t}\n+\n+\t/**\n+\t * Returns the specified repeatable annotation if it is either <em>present</em>, <em>indirectly present</em>,\n+\t * or <em>meta-present</em> on the test element (method or class) or any enclosing class belonging\n+\t * to the specified {@code context}. If the annotation is present on more than one enclosing type,\n+\t * all instances are returned.\n+\t */\n+\tpublic static <A extends Annotation> Stream<A> findAllRepeatableAnnotations(ExtensionContext context,\n+\t\t\tClass<A> annotationType) {\n+\t\treturn findOnAnything(context, annotationType, true, true);\n+\t}\n+\n+\tstatic <A extends Annotation> Stream<A> findOnAnything(ExtensionContext context, Class<A> annotationType,\n+\t\t\tboolean repeatable, boolean stackable) {\n+\t\tList<A> onMethod = context\n+\t\t\t\t.getTestMethod()\n+\t\t\t\t.map(method -> findOnElement(method, annotationType, repeatable))\n+\t\t\t\t.orElse(Collections.emptyList());\n+\t\tif (!stackable && !onMethod.isEmpty())\n+\t\t\treturn onMethod.stream();\n+\t\tStream<A> onClass = findOnOuterClasses(context.getTestClass(), annotationType, repeatable, stackable);\n+\n+\t\treturn Stream.concat(onMethod.stream(), onClass);\n+\t}\n+\n+\tprivate static <A extends Annotation> List<A> findOnElement(AnnotatedElement element, Class<A> annotationType,\n+\t\t\tboolean repeatable) {\n+\t\tif (repeatable)\n+\t\t\treturn AnnotationSupport.findRepeatableAnnotations(element, annotationType);\n+\t\telse\n+\t\t\treturn AnnotationSupport\n+\t\t\t\t\t.findAnnotation(element, annotationType)\n+\t\t\t\t\t.map(Collections::singletonList)\n+\t\t\t\t\t.orElse(Collections.emptyList());\n+\t}\n+\n+\tprivate static <A extends Annotation> Stream<A> findOnOuterClasses(Optional<Class<?>> type, Class<A> annotationType,\n+\t\t\tboolean repeatable, boolean stackable) {\n+\t\tif (!type.isPresent())\n+\t\t\treturn Stream.empty();\n+\n+\t\tList<A> onThisClass = findOnElement(type.get(), annotationType, repeatable);\n+\t\tif (!stackable && !onThisClass.isEmpty())\n+\t\t\treturn onThisClass.stream();\n+\n+\t\tStream<A> onParentClass = findOnOuterClasses(type.map(Class::getEnclosingClass), annotationType, repeatable,\n+\t\t\tstackable);\n+\t\treturn Stream.concat(onThisClass.stream(), onParentClass);\n+\t}\n+\n+\t/**", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5Njk0NA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401796944", "body": "*Mental liveticker*  Yesterday we discussed if this extension needs the closest or also all annotations fromt he outer containers and we came together that it should deal with all - but I checked [the docs](https://junit-pioneer.org/docs/system-properties/) say it **does not**!\r\n", "bodyText": "Mental liveticker  Yesterday we discussed if this extension needs the closest or also all annotations fromt he outer containers and we came together that it should deal with all - but I checked the docs say it does not!", "bodyHTML": "<p dir=\"auto\"><em>Mental liveticker</em>  Yesterday we discussed if this extension needs the closest or also all annotations fromt he outer containers and we came together that it should deal with all - but I checked <a href=\"https://junit-pioneer.org/docs/system-properties/\" rel=\"nofollow\">the docs</a> say it <strong>does not</strong>!</p>", "author": "Bukama", "createdAt": "2020-04-01T17:45:45Z", "path": "src/main/java/org/junitpioneer/jupiter/SystemPropertyExtension.java", "diffHunk": "@@ -38,36 +34,34 @@\n \n \t@Override\n \tpublic void beforeAll(ExtensionContext context) throws Exception {\n-\t\thandleSystemProperties(context);\n+\t\tclearAndSetSystemProperties(context);\n \t}\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) throws Exception {\n-\t\tboolean present = Utils\n-\t\t\t\t.annotationPresentOnTestMethod(context, ClearSystemProperty.class, ClearSystemProperties.class,\n-\t\t\t\t\tSetSystemProperty.class, SetSystemProperties.class);\n-\t\tif (present) {\n-\t\t\thandleSystemProperties(context);\n-\t\t}\n+\t\tclearAndSetSystemProperties(context);\n \t}\n \n-\tprivate void handleSystemProperties(ExtensionContext context) {\n+\tprivate void clearAndSetSystemProperties(ExtensionContext context) {\n \t\tSet<String> propertiesToClear;\n \t\tMap<String, String> propertiesToSet;\n \t\ttry {\n-\t\t\tpropertiesToClear = findRepeatableAnnotations(context, ClearSystemProperty.class)\n-\t\t\t\t\t.stream()\n+\t\t\tpropertiesToClear = PioneerUtils", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5NzE1NQ==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401797155", "body": "Little, but nice improvement!", "bodyText": "Little, but nice improvement!", "bodyHTML": "<p dir=\"auto\">Little, but nice improvement!</p>", "author": "Bukama", "createdAt": "2020-04-01T17:46:06Z", "path": "src/main/java/org/junitpioneer/jupiter/SystemPropertyExtension.java", "diffHunk": "@@ -38,36 +34,34 @@\n \n \t@Override\n \tpublic void beforeAll(ExtensionContext context) throws Exception {\n-\t\thandleSystemProperties(context);\n+\t\tclearAndSetSystemProperties(context);\n \t}\n \n \t@Override\n \tpublic void beforeEach(ExtensionContext context) throws Exception {\n-\t\tboolean present = Utils\n-\t\t\t\t.annotationPresentOnTestMethod(context, ClearSystemProperty.class, ClearSystemProperties.class,\n-\t\t\t\t\tSetSystemProperty.class, SetSystemProperties.class);\n-\t\tif (present) {\n-\t\t\thandleSystemProperties(context);\n-\t\t}\n+\t\tclearAndSetSystemProperties(context);\n \t}\n \n-\tprivate void handleSystemProperties(ExtensionContext context) {\n+\tprivate void clearAndSetSystemProperties(ExtensionContext context) {\n \t\tSet<String> propertiesToClear;\n \t\tMap<String, String> propertiesToSet;\n \t\ttry {\n-\t\t\tpropertiesToClear = findRepeatableAnnotations(context, ClearSystemProperty.class)\n-\t\t\t\t\t.stream()\n+\t\t\tpropertiesToClear = PioneerUtils\n+\t\t\t\t\t.findClosestRepeatableAnnotation(context, ClearSystemProperty.class)\n \t\t\t\t\t.map(ClearSystemProperty::key)\n-\t\t\t\t\t.collect(Utils.distinctToSet());\n-\t\t\tpropertiesToSet = findRepeatableAnnotations(context, SetSystemProperty.class)\n-\t\t\t\t\t.stream()\n+\t\t\t\t\t.collect(PioneerUtils.distinctToSet());\n+\t\t\tpropertiesToSet = PioneerUtils\n+\t\t\t\t\t.findClosestRepeatableAnnotation(context, SetSystemProperty.class)\n \t\t\t\t\t.collect(toMap(SetSystemProperty::key, SetSystemProperty::value));\n \t\t\tpreventClearAndSetSameSystemProperties(propertiesToClear, propertiesToSet.keySet());\n \t\t}\n \t\tcatch (IllegalStateException ex) {\n \t\t\tthrow new ExtensionConfigurationException(\"Don't clear/set the same property more than once.\", ex);\n \t\t}\n \n+\t\tif (propertiesToClear.isEmpty() && propertiesToSet.isEmpty())", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5ODkzOA==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401798938", "body": "Same suggestion as above: I vote to split the `PioneerUtils` class.", "bodyText": "Same suggestion as above: I vote to split the PioneerUtils class.", "bodyHTML": "<p dir=\"auto\">Same suggestion as above: I vote to split the <code>PioneerUtils</code> class.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:49:00Z", "path": "src/test/java/org/junitpioneer/jupiter/PioneerUtilsTests.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.stream.Collector;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.DisplayName;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.platform.engine.test.event.ExecutionEvent;\n+import org.junit.platform.engine.test.event.ExecutionEventRecorder;\n+import org.junitpioneer.AbstractPioneerTestEngineTests;\n+\n+@DisplayName(\"JUnitPioneer utilities\")\n+class PioneerUtilsTests {", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMzQzNg==", "url": "https://github.com/junit-pioneer/junit-pioneer/pull/187#discussion_r401803436", "body": "Descriptions of parameters and return value are missing in all javadocs inside the class.", "bodyText": "Descriptions of parameters and return value are missing in all javadocs inside the class.", "bodyHTML": "<p dir=\"auto\">Descriptions of parameters and return value are missing in all javadocs inside the class.</p>", "author": "Bukama", "createdAt": "2020-04-01T17:56:24Z", "path": "src/main/java/org/junitpioneer/jupiter/PioneerUtils.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2015-2020 the original author or authors.\n+ *\n+ * All rights reserved. This program and the accompanying materials are\n+ * made available under the terms of the Eclipse Public License v2.0 which\n+ * accompanies this distribution and is available at\n+ *\n+ * http://www.eclipse.org/legal/epl-v20.html\n+ */\n+\n+package org.junitpioneer.jupiter;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collector;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.platform.commons.support.AnnotationSupport;\n+\n+/**\n+ * Pioneer-internal utility class.\n+ */\n+class PioneerUtils {\n+\n+\tprivate PioneerUtils() {\n+\t\t// private constructor to prevent instantiation of utility class\n+\t}\n+\n+\t/**\n+\t * Determines whether an annotation of any of the specified {@code annotationTypes}\n+\t * is either <em>present</em>, <em>indirectly present</em>, or <em>meta-present</em>\n+\t * on the test element (method or class) or any enclosing class belonging to the\n+\t * specified {@code context}.", "originalCommit": "ff06979c31e7d85b7d13c679f7a474107673848c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5af0df40f9de3c0a369190843028cece7f9152b", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/a5af0df40f9de3c0a369190843028cece7f9152b", "message": "Split utilities into two classes", "committedDate": "2020-04-07T17:45:37Z", "type": "commit"}, {"oid": "8f43350872a48b993501d6ab5779465899bd6ea2", "url": "https://github.com/junit-pioneer/junit-pioneer/commit/8f43350872a48b993501d6ab5779465899bd6ea2", "message": "Rename methods, parameters, and add documentation", "committedDate": "2020-04-07T18:38:47Z", "type": "commit"}]}