{"pr_number": 2663, "pr_title": "[F] ENT-2177: Use concrete method to locate ResourceLocator", "pr_author": "abhiskum", "pr_createdAt": "2020-03-24T09:22:27Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2663", "merge_commit": "bff6562d783f81404b711b15314cef775e890b7c", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MDYyNg==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r397160626", "body": "It's not strictly critical to change for this PR, but in the future I would like to see these type of methods return a self-ref so we can do some chaining in the cases where our flow is to just instantiate and then initialize.", "bodyText": "It's not strictly critical to change for this PR, but in the future I would like to see these type of methods return a self-ref so we can do some chaining in the cases where our flow is to just instantiate and then initialize.", "bodyHTML": "<p dir=\"auto\">It's not strictly critical to change for this PR, but in the future I would like to see these type of methods return a self-ref so we can do some chaining in the cases where our flow is to just instantiate and then initialize.</p>", "author": "Ceiu", "createdAt": "2020-03-24T13:42:27Z", "path": "server/src/main/java/org/candlepin/resteasy/MethodLocator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resteasy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Binding;\n+import com.google.inject.Injector;\n+\n+import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n+import org.jboss.resteasy.spi.metadata.ResourceClass;\n+import org.jboss.resteasy.spi.metadata.ResourceLocator;\n+import org.jboss.resteasy.spi.metadata.ResourceMethod;\n+import org.jboss.resteasy.util.GetRestful;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+/**\n+ * Holds a mapping of interface methods to concrete methods.\n+ * This map is populated during servlet initialization and then locked.\n+ */\n+public class MethodLocator {\n+    private static final Logger log = LoggerFactory.getLogger(MethodLocator.class);\n+\n+    private Map<Method, Method> internalMap;\n+    private boolean hasBeenInitialized = false;\n+\n+    private Injector injector;\n+\n+    @Inject\n+    public MethodLocator(Injector injector) {\n+        // Maintain the insertion order for nice output in debug statement\n+        internalMap = new LinkedHashMap<>();\n+        this.injector = injector;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public synchronized void init() {", "originalCommit": "d86ba3da42e443b1f2b7fab5cf6881c13abecc71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3MTg5Mw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r397571893", "bodyText": "Done.", "author": "abhiskum", "createdAt": "2020-03-25T02:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MDYyNg=="}], "type": "inlineReview", "revised_code": {"commit": "a3c0d0184f60555754a06e71fffd94581f606e5d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/MethodLocator.java b/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\nindex 3c825dd18..96baecc2e 100644\n--- a/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\n+++ b/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\n", "chunk": "@@ -56,7 +56,7 @@ public class MethodLocator {\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    public synchronized void init() {\n+    public synchronized MethodLocator init() {\n         if (hasBeenInitialized) {\n             throw new IllegalStateException(\"This map has already been initialized.\");\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "bff6562d783f81404b711b15314cef775e890b7c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/MethodLocator.java b/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\nindex 3c825dd18..96baecc2e 100644\n--- a/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\n+++ b/server/src/main/java/org/candlepin/resteasy/MethodLocator.java\n", "chunk": "@@ -56,7 +56,7 @@ public class MethodLocator {\n     }\n \n     @SuppressWarnings(\"rawtypes\")\n-    public synchronized void init() {\n+    public synchronized MethodLocator init() {\n         if (hasBeenInitialized) {\n             throw new IllegalStateException(\"This map has already been initialized.\");\n         }\n", "next_change": null}]}, "commits_in_main": [{"oid": "bff6562d783f81404b711b15314cef775e890b7c", "message": "Merge commit", "committedDate": null}, {"oid": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-2177: Use concrete method to locate ResourceLocator   - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.   - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.   - Added new class MethodLocator to hold interface method and concrete method mapping   - Updated ResourceLocatorMap class to use MethodLocator   - Update AnnotationLocator class to use MethodLocator instead of internal"}, {"oid": "582e7bafdee1d5891b168f78921b277fd72fde37", "committedDate": "2021-06-14 14:15:28 +0530", "message": "Candlepin project restructuring"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MzI4Nw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r397163287", "body": "This ResourceLocatorMap instantiation is incorrect with the method locator being instantiated as it is below. ", "bodyText": "This ResourceLocatorMap instantiation is incorrect with the method locator being instantiated as it is below.", "bodyHTML": "<p dir=\"auto\">This ResourceLocatorMap instantiation is incorrect with the method locator being instantiated as it is below.</p>", "author": "Ceiu", "createdAt": "2020-03-24T13:46:02Z", "path": "server/src/test/java/org/candlepin/test/DatabaseTestFixture.java", "diffHunk": "@@ -211,8 +213,9 @@ public void init(boolean beginTransaction) throws Exception {\n         locatorMap = this.injector.getInstance(ResourceLocatorMap.class);", "originalCommit": "d86ba3da42e443b1f2b7fab5cf6881c13abecc71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3MTc3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r397571773", "bodyText": "Fixed.", "author": "abhiskum", "createdAt": "2020-03-25T02:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MzI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3MTk4MA==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r397571980", "bodyText": "Fixed.", "author": "abhiskum", "createdAt": "2020-03-25T02:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MzI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODU1MDQwNg==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r398550406", "bodyText": "This is still not going to work as expected. Because we're asking the injector for the ResourceLocator instance, it won't use the MethodLocator instantiated right above it; it'll get a difference instance that's managed by the injector. In this case, we want to create all three locator instances manually or inject all three instances, so that they're all built the same way and share the same instances.", "author": "Ceiu", "createdAt": "2020-03-26T12:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MzI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3MTI3Mw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r399071273", "bodyText": "Done.", "author": "abhiskum", "createdAt": "2020-03-27T07:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a3c0d0184f60555754a06e71fffd94581f606e5d", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex e169b47f7..085c7a399 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -210,11 +210,12 @@ public class DatabaseTestFixture {\n         this.injector = parentInjector.createChildInjector(\n             Modules.override(testingModule).with(getGuiceOverrideModule()));\n \n+        methodLocator = new MethodLocator(injector);\n+        methodLocator.init();\n+\n         locatorMap = this.injector.getInstance(ResourceLocatorMap.class);\n         locatorMap.init();\n \n-        methodLocator = new MethodLocator(injector);\n-        methodLocator.init();\n         annotationLocator = new AnnotationLocator(methodLocator);\n \n         securityInterceptor = this.injector.getInstance(TestingInterceptor.class);\n", "next_change": {"commit": "39a298e0f7bf45a094c45072cfb7ce0686e8f99b", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex 085c7a399..f22295ca3 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -213,7 +213,7 @@ public class DatabaseTestFixture {\n         methodLocator = new MethodLocator(injector);\n         methodLocator.init();\n \n-        locatorMap = this.injector.getInstance(ResourceLocatorMap.class);\n+        locatorMap = new ResourceLocatorMap(injector, methodLocator);\n         locatorMap.init();\n \n         annotationLocator = new AnnotationLocator(methodLocator);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "bff6562d783f81404b711b15314cef775e890b7c", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex e169b47f7..3cabf137f 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -210,11 +209,12 @@ public class DatabaseTestFixture {\n         this.injector = parentInjector.createChildInjector(\n             Modules.override(testingModule).with(getGuiceOverrideModule()));\n \n-        locatorMap = this.injector.getInstance(ResourceLocatorMap.class);\n-        locatorMap.init();\n-\n         methodLocator = new MethodLocator(injector);\n         methodLocator.init();\n+\n+        locatorMap = new ResourceLocatorMap(injector, methodLocator);\n+        locatorMap.init();\n+\n         annotationLocator = new AnnotationLocator(methodLocator);\n \n         securityInterceptor = this.injector.getInstance(TestingInterceptor.class);\n", "next_change": {"commit": "c5969ec0c69fee2a65f716acb594abf124fb3492", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex 3cabf137f..d67af28db 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -209,13 +208,11 @@ public class DatabaseTestFixture {\n         this.injector = parentInjector.createChildInjector(\n             Modules.override(testingModule).with(getGuiceOverrideModule()));\n \n-        methodLocator = new MethodLocator(injector);\n-        methodLocator.init();\n-\n-        locatorMap = new ResourceLocatorMap(injector, methodLocator);\n+        locatorMap = this.injector.getInstance(ResourceLocatorMap.class);\n         locatorMap.init();\n \n-        annotationLocator = new AnnotationLocator(methodLocator);\n+        annotationLocator = this.injector.getInstance(AnnotationLocator.class);\n+        annotationLocator.init();\n \n         securityInterceptor = this.injector.getInstance(TestingInterceptor.class);\n \n", "next_change": {"commit": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex d67af28db..d7723c2e6 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -208,9 +205,6 @@ public class DatabaseTestFixture {\n         this.injector = parentInjector.createChildInjector(\n             Modules.override(testingModule).with(getGuiceOverrideModule()));\n \n-        locatorMap = this.injector.getInstance(ResourceLocatorMap.class);\n-        locatorMap.init();\n-\n         annotationLocator = this.injector.getInstance(AnnotationLocator.class);\n         annotationLocator.init();\n \n", "next_change": {"commit": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex d7723c2e6..c05de1828 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -205,8 +208,13 @@ public class DatabaseTestFixture {\n         this.injector = parentInjector.createChildInjector(\n             Modules.override(testingModule).with(getGuiceOverrideModule()));\n \n-        annotationLocator = this.injector.getInstance(AnnotationLocator.class);\n-        annotationLocator.init();\n+        methodLocator = new MethodLocator(injector);\n+        methodLocator.init();\n+\n+        locatorMap = new ResourceLocatorMap(injector, methodLocator);\n+        locatorMap.init();\n+\n+        annotationLocator = new AnnotationLocator(methodLocator);\n \n         securityInterceptor = this.injector.getInstance(TestingInterceptor.class);\n \n", "next_change": {"commit": "acf678cebda845b78ee58ec6e2de8f313a864338", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex c05de1828..31cd8ab3b 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -219,6 +222,7 @@ public class DatabaseTestFixture {\n         securityInterceptor = this.injector.getInstance(TestingInterceptor.class);\n \n         cpRequestScope = injector.getInstance(CandlepinRequestScope.class);\n+        this.validator = new DTOValidator(Validation.buildDefaultValidatorFactory());\n \n         // Because all candlepin operations are running in the CandlepinRequestScope\n         // we'll force the instance creations to be done inside the scope.\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "bff6562d783f81404b711b15314cef775e890b7c", "message": "Merge commit", "committedDate": null}, {"oid": "c5969ec0c69fee2a65f716acb594abf124fb3492", "committedDate": "2020-02-04 10:55:17 -0500", "message": "Fix the checkstyle to put static imports at the top of each file."}, {"oid": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "committedDate": "2020-02-11 11:35:55 -0500", "message": "Upgraded Resteasy to 4.4.2"}, {"oid": "4487acd448016e3e1370819df93d489970bbbcda", "committedDate": "2021-02-03 11:17:37 -0500", "message": "Updated refresh flow to support provided products on products"}, {"oid": "688031de56444217d819ae0c3538d86995da8e6a", "committedDate": "2021-02-03 11:51:49 -0500", "message": "Updated unit tests to support moving derived products from pool to product"}, {"oid": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-2177: Use concrete method to locate ResourceLocator   - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.   - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.   - Added new class MethodLocator to hold interface method and concrete method mapping   - Updated ResourceLocatorMap class to use MethodLocator   - Update AnnotationLocator class to use MethodLocator instead of internal"}, {"oid": "acf678cebda845b78ee58ec6e2de8f313a864338", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-1886: Port SubscriptionResource to spec-first - Add SubscriptionResource definition - Add missing DTO definitions - Add translators - Add AttributesDeserializer"}, {"oid": "9a3aec69f99e33c054b52bb41cd8fffb02e47f7d", "committedDate": "2021-05-24 10:09:00 +0200", "message": "1935500: Update SCA to cache certs by consumer"}, {"oid": "582e7bafdee1d5891b168f78921b277fd72fde37", "committedDate": "2021-06-14 14:15:28 +0530", "message": "Candlepin project restructuring"}]}, {"oid": "a3c0d0184f60555754a06e71fffd94581f606e5d", "url": "https://github.com/candlepin/candlepin/commit/a3c0d0184f60555754a06e71fffd94581f606e5d", "message": "ENT-2177: Use concrete method to locate ResourceLocator\n  - Added new class MethodLocator to hold interface method and concrete method mapping\n  - Updated ResourceLocatorMap class to use MethodLocator\n  - Update AnnotationLocator class to use MethodLocator instead of internal", "committedDate": "2020-03-25T02:15:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNTEwNw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r398505107", "body": "Why does this method need a new argument but it's not being used in the method?", "bodyText": "Why does this method need a new argument but it's not being used in the method?", "bodyHTML": "<p dir=\"auto\">Why does this method need a new argument but it's not being used in the method?</p>", "author": "nikosmoum", "createdAt": "2020-03-26T11:37:48Z", "path": "server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java", "diffHunk": "@@ -284,7 +290,7 @@ protected void logLocators() {\n         }\n     }\n \n-    protected void registerLocators(ResourceClass resourceClass) {\n+    protected void registerLocators(ResourceClass resourceClass, Class<?> concreteClass) {", "originalCommit": "a3c0d0184f60555754a06e71fffd94581f606e5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA3MTc3OQ==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r399071779", "bodyText": "@nikosmoum Initially I added method mapping in this class and then moved to separate class however forgot to remove this change.", "author": "abhiskum", "createdAt": "2020-03-27T07:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUwNTEwNw=="}], "type": "inlineReview", "revised_code": {"commit": "39a298e0f7bf45a094c45072cfb7ce0686e8f99b", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\nindex a403a2fd2..e8df086a2 100644\n--- a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n+++ b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n", "chunk": "@@ -290,7 +290,7 @@ public class ResourceLocatorMap implements Map<Method, ResourceLocator> {\n         }\n     }\n \n-    protected void registerLocators(ResourceClass resourceClass, Class<?> concreteClass) {\n+    protected void registerLocators(ResourceClass resourceClass) {\n         for (ResourceMethod resourceMethod : resourceClass.getResourceMethods()) {\n             put(resourceMethod.getMethod(), resourceMethod);\n         }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "bff6562d783f81404b711b15314cef775e890b7c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\nindex a403a2fd2..e8df086a2 100644\n--- a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n+++ b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n", "chunk": "@@ -290,7 +290,7 @@ public class ResourceLocatorMap implements Map<Method, ResourceLocator> {\n         }\n     }\n \n-    protected void registerLocators(ResourceClass resourceClass, Class<?> concreteClass) {\n+    protected void registerLocators(ResourceClass resourceClass) {\n         for (ResourceMethod resourceMethod : resourceClass.getResourceMethods()) {\n             put(resourceMethod.getMethod(), resourceMethod);\n         }\n", "next_change": {"commit": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\ndeleted file mode 100644\nindex e8df086a2..000000000\n--- a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n+++ /dev/null\n", "chunk": "@@ -1,306 +0,0 @@\n-/**\n- * Copyright (c) 2009 - 2012 Red Hat, Inc.\n- *\n- * This software is licensed to you under the GNU General Public License,\n- * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n- * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n- * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n- * along with this software; if not, see\n- * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n- *\n- * Red Hat trademarks are not licensed under GPLv2. No permission is\n- * granted to use or replicate Red Hat trademarks that are incorporated\n- * in this software or its documentation.\n- */\n-package org.candlepin.resteasy;\n-\n-import com.google.common.collect.ImmutableMap;\n-import com.google.inject.Binding;\n-import com.google.inject.Injector;\n-\n-import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n-import org.jboss.resteasy.spi.metadata.ResourceClass;\n-import org.jboss.resteasy.spi.metadata.ResourceLocator;\n-import org.jboss.resteasy.spi.metadata.ResourceMethod;\n-import org.jboss.resteasy.util.GetRestful;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Proxy;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.inject.Inject;\n-import javax.ws.rs.Consumes;\n-import javax.ws.rs.CookieParam;\n-import javax.ws.rs.DELETE;\n-import javax.ws.rs.FormParam;\n-import javax.ws.rs.GET;\n-import javax.ws.rs.HEAD;\n-import javax.ws.rs.HeaderParam;\n-import javax.ws.rs.MatrixParam;\n-import javax.ws.rs.PathParam;\n-import javax.ws.rs.Produces;\n-import javax.ws.rs.QueryParam;\n-import javax.ws.rs.core.MediaType;\n-\n-/**\n- * ResourceLocatorMap holds a mapping of Methods to Resteasy ResourceLocators.  This map\n- * is populated during servlet initialization and then locked.  The VerifyAuthorizationFilter\n- * then uses the map to find the correct ResourceLocator for a Method so that we can get\n- * the parameters passed to a Method and run authorization checks on them.\n- */\n-public class ResourceLocatorMap implements Map<Method, ResourceLocator> {\n-    private static final Logger log = LoggerFactory.getLogger(ResourceLocatorMap.class);\n-\n-    private Map<Method, ResourceLocator> internalMap;\n-    private MethodLocator methodLocator;\n-    private boolean hasBeenInitialized = false;\n-\n-    private Injector injector;\n-\n-    @Inject\n-    public ResourceLocatorMap(Injector injector, MethodLocator methodLocator) {\n-        // Maintain the insertion order for nice output in debug statement\n-        internalMap = new LinkedHashMap<>();\n-        this.methodLocator = methodLocator;\n-        this.injector = injector;\n-    }\n-\n-    @Override\n-    public int size() {\n-        return internalMap.size();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        return internalMap.isEmpty();\n-    }\n-\n-    @Override\n-    public boolean containsKey(Object key) {\n-        return internalMap.containsKey(key);\n-    }\n-\n-    @Override\n-    public boolean containsValue(Object value) {\n-        return internalMap.containsKey(value);\n-    }\n-\n-    @Override\n-    public ResourceLocator get(Object key) {\n-        Method concreteMethod = methodLocator.getConcreteMethod((Method) key);\n-        if (concreteMethod != null) {\n-            return internalMap.get(concreteMethod);\n-        }\n-        return internalMap.get(key);\n-    }\n-\n-    @Override\n-    public ResourceLocator put(Method key, ResourceLocator value) {\n-        return internalMap.put(key, value);\n-    }\n-\n-    @Override\n-    public ResourceLocator remove(Object key) {\n-        return internalMap.remove(key);\n-    }\n-\n-    @Override\n-    public void putAll(Map<? extends Method, ? extends ResourceLocator> m) {\n-        internalMap.putAll(m);\n-    }\n-\n-    @Override\n-    public void clear() {\n-        internalMap.clear();\n-    }\n-\n-    @Override\n-    public Set<Method> keySet() {\n-        return internalMap.keySet();\n-    }\n-\n-    @Override\n-    public Collection<ResourceLocator> values() {\n-        return internalMap.values();\n-    }\n-\n-    @Override\n-    public Set<java.util.Map.Entry<Method, ResourceLocator>> entrySet() {\n-        return internalMap.entrySet();\n-    }\n-\n-    @SuppressWarnings(\"rawtypes\")\n-    public void init() {\n-        if (hasBeenInitialized) {\n-            throw new IllegalStateException(\"This map has already been initialized.\");\n-        }\n-\n-        List<Binding<?>> rootResourceBindings = new ArrayList<>();\n-        for (Binding<?> binding : injector.getBindings().values()) {\n-            Type type = binding.getKey().getTypeLiteral().getType();\n-            if (type instanceof Class) {\n-                Class<?> beanClass = (Class) type;\n-                if (GetRestful.isRootResource(beanClass)) {\n-                    rootResourceBindings.add(binding);\n-                }\n-            }\n-        }\n-        for (Binding<?> binding : rootResourceBindings) {\n-            Class<?> clazz = (Class) binding.getKey().getTypeLiteral().getType();\n-            if (Proxy.isProxyClass(clazz)) {\n-                for (Class<?> intf : clazz.getInterfaces()) {\n-                    ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(intf);\n-                    registerLocators(resourceClass);\n-                }\n-            }\n-            else {\n-                ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(clazz);\n-                registerLocators(resourceClass);\n-            }\n-        }\n-\n-        logLocators();\n-        lock();\n-    }\n-\n-    /**\n-     * Log what resources have been detected and warn about missing media types.\n-     *\n-     * Not having a @Produces annotation on a method can have subtle effects on the way Resteasy\n-     * resolves which method to dispatch a request to.\n-     *\n-     * Resource resolution order is detailed in the JAX-RS 2.0 specification in section 3.7.2.\n-     * Consider the following\n-     * {@code\n-     *   @PUT\n-     *   @Path(\"/foo\")\n-     *   public String methodOne() {\n-     *       ...\n-     *   }\n-     *\n-     *   @PUT\n-     *   @Path(\"/{id}\")\n-     *   @Produces(MediaType.APPLICATION_JSON)\n-     *   public String methodTwo(@PathParam(\"id\") String id) {\n-     *       ....\n-     *   }\n-     * }\n-     *\n-     *   With a cursory reading of the specification, it appears that a request to\n-     *\n-     *   PUT /foo\n-     *\n-     *   should result in methodOne being selected since methodOne's Path has more\n-     *   literal characters than methodTwo.  However, methodTwo has a specific media\n-     *   type defined and methodOne does not (thus using the wildcard type as a default),\n-     *   methodTwo is actually the resource selected.\n-     *\n-     *   The same rules apply for @Consumes annotations.\n-     */\n-    protected void logLocators() {\n-        StringBuffer registered = new StringBuffer(\"Registered the following RESTful methods:\\n\");\n-        StringBuffer missingProduces = new StringBuffer();\n-        StringBuffer missingConsumes = new StringBuffer();\n-        for (Method m : keySet()) {\n-            String name = m.getDeclaringClass() + \".\" + m.getName();\n-            registered.append(\"\\t\" + name + \"\\n\");\n-\n-            if (!m.isAnnotationPresent(Produces.class)) {\n-                missingProduces.append(\"\\t\" + name + \"\\n\");\n-            }\n-\n-            if (m.isAnnotationPresent(GET.class) ||\n-                m.isAnnotationPresent(HEAD.class) ||\n-                m.isAnnotationPresent(DELETE.class) ||\n-                m.isAnnotationPresent(Deprecated.class)) {\n-                /* Technically GET, HEAD, and DELETE are allowed to have bodies (and therefore would\n-                 * need a Consumes annotation, but the HTTP 1.1 spec states in section 4.3 that any\n-                 * such body should be ignored.  See http://stackoverflow.com/a/983458/6124862\n-                 *\n-                 * Therefore, we won't print warnings on unannotated GET, HEAD, and DELETE methods.\n-                 *\n-                 * Deprecated methods are not expected to be updated.\n-                 */\n-                continue;\n-            }\n-\n-            if (!m.isAnnotationPresent(Consumes.class)) {\n-                missingConsumes.append(\"\\t\" + name + \"\\n\");\n-            }\n-            else {\n-                /* The purpose of all the ridiculousness below is to find methods that\n-                 * bind objects from the HTTP request body but that are marked as consuming\n-                 * the star slash star wildcard mediatype.  Candlepin only consumes JSON\n-                 * at the moment but even if that changes we still want to be explicit\n-                 * about what we accept.\n-                 */\n-                Consumes consumes = m.getAnnotation(Consumes.class);\n-                List<String> mediaTypes = Arrays.asList(consumes.value());\n-                if (mediaTypes.contains(MediaType.WILDCARD)) {\n-                    Annotation[][] allParamAnnotations = m.getParameterAnnotations();\n-\n-                    boolean bindsBody = false;\n-                    for (Annotation[] paramAnnotations : allParamAnnotations) {\n-                        boolean boundObjectFromBody = true;\n-                        for (Annotation a : paramAnnotations) {\n-                            Class<? extends Annotation> clazz = a.annotationType();\n-                            if (QueryParam.class.isAssignableFrom(clazz) ||\n-                                PathParam.class.isAssignableFrom(clazz) ||\n-                                MatrixParam.class.isAssignableFrom(clazz) ||\n-                                HeaderParam.class.isAssignableFrom(clazz) ||\n-                                FormParam.class.isAssignableFrom(clazz) ||\n-                                CookieParam.class.isAssignableFrom(clazz)\n-                                ) {\n-                                boundObjectFromBody = false;\n-                                continue;\n-                            }\n-                        }\n-                        bindsBody = bindsBody || boundObjectFromBody;\n-                    }\n-\n-                    if (bindsBody) {\n-                        log.warn(\"{} consumes a wildcard media type but binds an object from\" +\n-                            \" the request body.  Define specific media types consumed instead.\", name);\n-                    }\n-                }\n-\n-            }\n-        }\n-\n-        if (log.isDebugEnabled()) {\n-            log.trace(registered.toString());\n-        }\n-\n-        if (missingProduces.length() != 0) {\n-            log.warn(\"The following methods are missing a Produces annotation:\\n{}\", missingProduces);\n-        }\n-\n-        if (missingConsumes.length() != 0) {\n-            log.warn(\"The following methods are missing a Consumes annotation:\\n{}\", missingConsumes);\n-        }\n-    }\n-\n-    protected void registerLocators(ResourceClass resourceClass) {\n-        for (ResourceMethod resourceMethod : resourceClass.getResourceMethods()) {\n-            put(resourceMethod.getMethod(), resourceMethod);\n-        }\n-        for (ResourceLocator resourceMethod : resourceClass.getResourceLocators()) {\n-            put(resourceMethod.getMethod(), resourceMethod);\n-        }\n-    }\n-\n-    public synchronized void lock() {\n-        hasBeenInitialized = true;\n-        internalMap = ImmutableMap.copyOf(internalMap);\n-    }\n-}\n", "next_change": {"commit": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\nnew file mode 100644\nindex 000000000..e8df086a2\n--- /dev/null\n+++ b/server/src/main/java/org/candlepin/resteasy/ResourceLocatorMap.java\n", "chunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) 2009 - 2012 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.resteasy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Binding;\n+import com.google.inject.Injector;\n+\n+import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n+import org.jboss.resteasy.spi.metadata.ResourceClass;\n+import org.jboss.resteasy.spi.metadata.ResourceLocator;\n+import org.jboss.resteasy.spi.metadata.ResourceMethod;\n+import org.jboss.resteasy.util.GetRestful;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.CookieParam;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.FormParam;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.HEAD;\n+import javax.ws.rs.HeaderParam;\n+import javax.ws.rs.MatrixParam;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.MediaType;\n+\n+/**\n+ * ResourceLocatorMap holds a mapping of Methods to Resteasy ResourceLocators.  This map\n+ * is populated during servlet initialization and then locked.  The VerifyAuthorizationFilter\n+ * then uses the map to find the correct ResourceLocator for a Method so that we can get\n+ * the parameters passed to a Method and run authorization checks on them.\n+ */\n+public class ResourceLocatorMap implements Map<Method, ResourceLocator> {\n+    private static final Logger log = LoggerFactory.getLogger(ResourceLocatorMap.class);\n+\n+    private Map<Method, ResourceLocator> internalMap;\n+    private MethodLocator methodLocator;\n+    private boolean hasBeenInitialized = false;\n+\n+    private Injector injector;\n+\n+    @Inject\n+    public ResourceLocatorMap(Injector injector, MethodLocator methodLocator) {\n+        // Maintain the insertion order for nice output in debug statement\n+        internalMap = new LinkedHashMap<>();\n+        this.methodLocator = methodLocator;\n+        this.injector = injector;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return internalMap.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return internalMap.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        return internalMap.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        return internalMap.containsKey(value);\n+    }\n+\n+    @Override\n+    public ResourceLocator get(Object key) {\n+        Method concreteMethod = methodLocator.getConcreteMethod((Method) key);\n+        if (concreteMethod != null) {\n+            return internalMap.get(concreteMethod);\n+        }\n+        return internalMap.get(key);\n+    }\n+\n+    @Override\n+    public ResourceLocator put(Method key, ResourceLocator value) {\n+        return internalMap.put(key, value);\n+    }\n+\n+    @Override\n+    public ResourceLocator remove(Object key) {\n+        return internalMap.remove(key);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends Method, ? extends ResourceLocator> m) {\n+        internalMap.putAll(m);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        internalMap.clear();\n+    }\n+\n+    @Override\n+    public Set<Method> keySet() {\n+        return internalMap.keySet();\n+    }\n+\n+    @Override\n+    public Collection<ResourceLocator> values() {\n+        return internalMap.values();\n+    }\n+\n+    @Override\n+    public Set<java.util.Map.Entry<Method, ResourceLocator>> entrySet() {\n+        return internalMap.entrySet();\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public void init() {\n+        if (hasBeenInitialized) {\n+            throw new IllegalStateException(\"This map has already been initialized.\");\n+        }\n+\n+        List<Binding<?>> rootResourceBindings = new ArrayList<>();\n+        for (Binding<?> binding : injector.getBindings().values()) {\n+            Type type = binding.getKey().getTypeLiteral().getType();\n+            if (type instanceof Class) {\n+                Class<?> beanClass = (Class) type;\n+                if (GetRestful.isRootResource(beanClass)) {\n+                    rootResourceBindings.add(binding);\n+                }\n+            }\n+        }\n+        for (Binding<?> binding : rootResourceBindings) {\n+            Class<?> clazz = (Class) binding.getKey().getTypeLiteral().getType();\n+            if (Proxy.isProxyClass(clazz)) {\n+                for (Class<?> intf : clazz.getInterfaces()) {\n+                    ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(intf);\n+                    registerLocators(resourceClass);\n+                }\n+            }\n+            else {\n+                ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(clazz);\n+                registerLocators(resourceClass);\n+            }\n+        }\n+\n+        logLocators();\n+        lock();\n+    }\n+\n+    /**\n+     * Log what resources have been detected and warn about missing media types.\n+     *\n+     * Not having a @Produces annotation on a method can have subtle effects on the way Resteasy\n+     * resolves which method to dispatch a request to.\n+     *\n+     * Resource resolution order is detailed in the JAX-RS 2.0 specification in section 3.7.2.\n+     * Consider the following\n+     * {@code\n+     *   @PUT\n+     *   @Path(\"/foo\")\n+     *   public String methodOne() {\n+     *       ...\n+     *   }\n+     *\n+     *   @PUT\n+     *   @Path(\"/{id}\")\n+     *   @Produces(MediaType.APPLICATION_JSON)\n+     *   public String methodTwo(@PathParam(\"id\") String id) {\n+     *       ....\n+     *   }\n+     * }\n+     *\n+     *   With a cursory reading of the specification, it appears that a request to\n+     *\n+     *   PUT /foo\n+     *\n+     *   should result in methodOne being selected since methodOne's Path has more\n+     *   literal characters than methodTwo.  However, methodTwo has a specific media\n+     *   type defined and methodOne does not (thus using the wildcard type as a default),\n+     *   methodTwo is actually the resource selected.\n+     *\n+     *   The same rules apply for @Consumes annotations.\n+     */\n+    protected void logLocators() {\n+        StringBuffer registered = new StringBuffer(\"Registered the following RESTful methods:\\n\");\n+        StringBuffer missingProduces = new StringBuffer();\n+        StringBuffer missingConsumes = new StringBuffer();\n+        for (Method m : keySet()) {\n+            String name = m.getDeclaringClass() + \".\" + m.getName();\n+            registered.append(\"\\t\" + name + \"\\n\");\n+\n+            if (!m.isAnnotationPresent(Produces.class)) {\n+                missingProduces.append(\"\\t\" + name + \"\\n\");\n+            }\n+\n+            if (m.isAnnotationPresent(GET.class) ||\n+                m.isAnnotationPresent(HEAD.class) ||\n+                m.isAnnotationPresent(DELETE.class) ||\n+                m.isAnnotationPresent(Deprecated.class)) {\n+                /* Technically GET, HEAD, and DELETE are allowed to have bodies (and therefore would\n+                 * need a Consumes annotation, but the HTTP 1.1 spec states in section 4.3 that any\n+                 * such body should be ignored.  See http://stackoverflow.com/a/983458/6124862\n+                 *\n+                 * Therefore, we won't print warnings on unannotated GET, HEAD, and DELETE methods.\n+                 *\n+                 * Deprecated methods are not expected to be updated.\n+                 */\n+                continue;\n+            }\n+\n+            if (!m.isAnnotationPresent(Consumes.class)) {\n+                missingConsumes.append(\"\\t\" + name + \"\\n\");\n+            }\n+            else {\n+                /* The purpose of all the ridiculousness below is to find methods that\n+                 * bind objects from the HTTP request body but that are marked as consuming\n+                 * the star slash star wildcard mediatype.  Candlepin only consumes JSON\n+                 * at the moment but even if that changes we still want to be explicit\n+                 * about what we accept.\n+                 */\n+                Consumes consumes = m.getAnnotation(Consumes.class);\n+                List<String> mediaTypes = Arrays.asList(consumes.value());\n+                if (mediaTypes.contains(MediaType.WILDCARD)) {\n+                    Annotation[][] allParamAnnotations = m.getParameterAnnotations();\n+\n+                    boolean bindsBody = false;\n+                    for (Annotation[] paramAnnotations : allParamAnnotations) {\n+                        boolean boundObjectFromBody = true;\n+                        for (Annotation a : paramAnnotations) {\n+                            Class<? extends Annotation> clazz = a.annotationType();\n+                            if (QueryParam.class.isAssignableFrom(clazz) ||\n+                                PathParam.class.isAssignableFrom(clazz) ||\n+                                MatrixParam.class.isAssignableFrom(clazz) ||\n+                                HeaderParam.class.isAssignableFrom(clazz) ||\n+                                FormParam.class.isAssignableFrom(clazz) ||\n+                                CookieParam.class.isAssignableFrom(clazz)\n+                                ) {\n+                                boundObjectFromBody = false;\n+                                continue;\n+                            }\n+                        }\n+                        bindsBody = bindsBody || boundObjectFromBody;\n+                    }\n+\n+                    if (bindsBody) {\n+                        log.warn(\"{} consumes a wildcard media type but binds an object from\" +\n+                            \" the request body.  Define specific media types consumed instead.\", name);\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        if (log.isDebugEnabled()) {\n+            log.trace(registered.toString());\n+        }\n+\n+        if (missingProduces.length() != 0) {\n+            log.warn(\"The following methods are missing a Produces annotation:\\n{}\", missingProduces);\n+        }\n+\n+        if (missingConsumes.length() != 0) {\n+            log.warn(\"The following methods are missing a Consumes annotation:\\n{}\", missingConsumes);\n+        }\n+    }\n+\n+    protected void registerLocators(ResourceClass resourceClass) {\n+        for (ResourceMethod resourceMethod : resourceClass.getResourceMethods()) {\n+            put(resourceMethod.getMethod(), resourceMethod);\n+        }\n+        for (ResourceLocator resourceMethod : resourceClass.getResourceLocators()) {\n+            put(resourceMethod.getMethod(), resourceMethod);\n+        }\n+    }\n+\n+    public synchronized void lock() {\n+        hasBeenInitialized = true;\n+        internalMap = ImmutableMap.copyOf(internalMap);\n+    }\n+}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "bff6562d783f81404b711b15314cef775e890b7c", "message": "Merge commit", "committedDate": null}, {"oid": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "committedDate": "2020-02-11 11:35:55 -0500", "message": "Upgraded Resteasy to 4.4.2"}, {"oid": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-2177: Use concrete method to locate ResourceLocator   - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.   - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.   - Added new class MethodLocator to hold interface method and concrete method mapping   - Updated ResourceLocatorMap class to use MethodLocator   - Update AnnotationLocator class to use MethodLocator instead of internal"}, {"oid": "582e7bafdee1d5891b168f78921b277fd72fde37", "committedDate": "2021-06-14 14:15:28 +0530", "message": "Candlepin project restructuring"}]}, {"oid": "39a298e0f7bf45a094c45072cfb7ce0686e8f99b", "url": "https://github.com/candlepin/candlepin/commit/39a298e0f7bf45a094c45072cfb7ce0686e8f99b", "message": "ENT-2177: Use concrete method to locate ResourceLocator\n  - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.\n  - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.\n  - Added new class MethodLocator to hold interface method and concrete method mapping\n  - Updated ResourceLocatorMap class to use MethodLocator\n  - Update AnnotationLocator class to use MethodLocator instead of internal", "committedDate": "2020-03-27T06:58:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1NjE4Mw==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r399356183", "body": "The changes below are good, but mean that these should not be injected (since we create them ourselves during ```init```).", "bodyText": "The changes below are good, but mean that these should not be injected (since we create them ourselves during init).", "bodyHTML": "<p dir=\"auto\">The changes below are good, but mean that these should not be injected (since we create them ourselves during <code>init</code>).</p>", "author": "Ceiu", "createdAt": "2020-03-27T15:40:00Z", "path": "server/src/test/java/org/candlepin/test/DatabaseTestFixture.java", "diffHunk": "@@ -157,6 +158,7 @@\n     @Inject protected PermissionFactory permissionFactory;\n \n     @Inject protected ResourceLocatorMap locatorMap;\n+    @Inject protected MethodLocator methodLocator;", "originalCommit": "39a298e0f7bf45a094c45072cfb7ce0686e8f99b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUyNzAxMA==", "url": "https://github.com/candlepin/candlepin/pull/2663#discussion_r399527010", "bodyText": "Done.", "author": "abhiskum", "createdAt": "2020-03-27T20:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM1NjE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5d7b6beb1e88801d320d7088d8e7e380a3958694", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex f22295ca3..3cabf137f 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -154,14 +154,13 @@ public class DatabaseTestFixture {\n     @Inject protected PoolCurator poolCurator;\n     @Inject protected RoleCurator roleCurator;\n     @Inject protected UserCurator userCurator;\n-\n     @Inject protected PermissionFactory permissionFactory;\n-\n-    @Inject protected ResourceLocatorMap locatorMap;\n-    @Inject protected MethodLocator methodLocator;\n-    @Inject protected AnnotationLocator annotationLocator;\n     @Inject protected ModelTranslator modelTranslator;\n \n+    protected ResourceLocatorMap locatorMap;\n+    protected MethodLocator methodLocator;\n+    protected AnnotationLocator annotationLocator;\n+\n     private static Injector parentInjector;\n     protected Injector injector;\n     private CandlepinRequestScope cpRequestScope;\n", "next_change": null}]}, "revised_code_in_main": {"commit": "bff6562d783f81404b711b15314cef775e890b7c", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex f22295ca3..3cabf137f 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -154,14 +154,13 @@ public class DatabaseTestFixture {\n     @Inject protected PoolCurator poolCurator;\n     @Inject protected RoleCurator roleCurator;\n     @Inject protected UserCurator userCurator;\n-\n     @Inject protected PermissionFactory permissionFactory;\n-\n-    @Inject protected ResourceLocatorMap locatorMap;\n-    @Inject protected MethodLocator methodLocator;\n-    @Inject protected AnnotationLocator annotationLocator;\n     @Inject protected ModelTranslator modelTranslator;\n \n+    protected ResourceLocatorMap locatorMap;\n+    protected MethodLocator methodLocator;\n+    protected AnnotationLocator annotationLocator;\n+\n     private static Injector parentInjector;\n     protected Injector injector;\n     private CandlepinRequestScope cpRequestScope;\n", "next_change": {"commit": "c5969ec0c69fee2a65f716acb594abf124fb3492", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex 3cabf137f..d67af28db 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -154,12 +153,12 @@ public class DatabaseTestFixture {\n     @Inject protected PoolCurator poolCurator;\n     @Inject protected RoleCurator roleCurator;\n     @Inject protected UserCurator userCurator;\n+\n     @Inject protected PermissionFactory permissionFactory;\n-    @Inject protected ModelTranslator modelTranslator;\n \n-    protected ResourceLocatorMap locatorMap;\n-    protected MethodLocator methodLocator;\n-    protected AnnotationLocator annotationLocator;\n+    @Inject protected ResourceLocatorMap locatorMap;\n+    @Inject protected AnnotationLocator annotationLocator;\n+    @Inject protected ModelTranslator modelTranslator;\n \n     private static Injector parentInjector;\n     protected Injector injector;\n", "next_change": {"commit": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex d67af28db..d7723c2e6 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -155,8 +154,6 @@ public class DatabaseTestFixture {\n     @Inject protected UserCurator userCurator;\n \n     @Inject protected PermissionFactory permissionFactory;\n-\n-    @Inject protected ResourceLocatorMap locatorMap;\n     @Inject protected AnnotationLocator annotationLocator;\n     @Inject protected ModelTranslator modelTranslator;\n \n", "next_change": {"commit": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex d7723c2e6..c05de1828 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -152,11 +153,13 @@ public class DatabaseTestFixture {\n     @Inject protected PoolCurator poolCurator;\n     @Inject protected RoleCurator roleCurator;\n     @Inject protected UserCurator userCurator;\n-\n     @Inject protected PermissionFactory permissionFactory;\n-    @Inject protected AnnotationLocator annotationLocator;\n     @Inject protected ModelTranslator modelTranslator;\n \n+    protected ResourceLocatorMap locatorMap;\n+    protected MethodLocator methodLocator;\n+    protected AnnotationLocator annotationLocator;\n+\n     private static Injector parentInjector;\n     protected Injector injector;\n     private CandlepinRequestScope cpRequestScope;\n", "next_change": {"commit": "acf678cebda845b78ee58ec6e2de8f313a864338", "changed_code": [{"header": "diff --git a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\nindex c05de1828..31cd8ab3b 100755\n--- a/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n+++ b/server/src/test/java/org/candlepin/test/DatabaseTestFixture.java\n", "chunk": "@@ -168,6 +170,7 @@ public class DatabaseTestFixture {\n     protected DateSourceForTesting dateSource;\n     protected I18n i18n;\n     protected Provider<I18n> i18nProvider = () -> i18n;\n+    protected DTOValidator validator;\n \n     @BeforeAll\n     public static void initClass() {\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "bff6562d783f81404b711b15314cef775e890b7c", "message": "Merge commit", "committedDate": null}, {"oid": "c5969ec0c69fee2a65f716acb594abf124fb3492", "committedDate": "2020-02-04 10:55:17 -0500", "message": "Fix the checkstyle to put static imports at the top of each file."}, {"oid": "17d65ec61d8f1760fbdedbfeb5f85b4fc2eb3afa", "committedDate": "2020-02-11 11:35:55 -0500", "message": "Upgraded Resteasy to 4.4.2"}, {"oid": "4487acd448016e3e1370819df93d489970bbbcda", "committedDate": "2021-02-03 11:17:37 -0500", "message": "Updated refresh flow to support provided products on products"}, {"oid": "688031de56444217d819ae0c3538d86995da8e6a", "committedDate": "2021-02-03 11:51:49 -0500", "message": "Updated unit tests to support moving derived products from pool to product"}, {"oid": "eab016fb44c9e2f22cf3d422a3b2f0ae3effaec2", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-2177: Use concrete method to locate ResourceLocator   - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.   - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.   - Added new class MethodLocator to hold interface method and concrete method mapping   - Updated ResourceLocatorMap class to use MethodLocator   - Update AnnotationLocator class to use MethodLocator instead of internal"}, {"oid": "acf678cebda845b78ee58ec6e2de8f313a864338", "committedDate": "2021-04-13 15:54:32 +0200", "message": "ENT-1886: Port SubscriptionResource to spec-first - Add SubscriptionResource definition - Add missing DTO definitions - Add translators - Add AttributesDeserializer"}, {"oid": "9a3aec69f99e33c054b52bb41cd8fffb02e47f7d", "committedDate": "2021-05-24 10:09:00 +0200", "message": "1935500: Update SCA to cache certs by consumer"}, {"oid": "582e7bafdee1d5891b168f78921b277fd72fde37", "committedDate": "2021-06-14 14:15:28 +0530", "message": "Candlepin project restructuring"}]}, {"oid": "5d7b6beb1e88801d320d7088d8e7e380a3958694", "url": "https://github.com/candlepin/candlepin/commit/5d7b6beb1e88801d320d7088d8e7e380a3958694", "message": "ENT-2177: Use concrete method to locate ResourceLocator\n  - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.\n  - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.\n  - Added new class MethodLocator to hold interface method and concrete method mapping\n  - Updated ResourceLocatorMap class to use MethodLocator\n  - Update AnnotationLocator class to use MethodLocator instead of internal", "committedDate": "2020-03-27T20:40:11Z", "type": "commit"}, {"oid": "5d7b6beb1e88801d320d7088d8e7e380a3958694", "url": "https://github.com/candlepin/candlepin/commit/5d7b6beb1e88801d320d7088d8e7e380a3958694", "message": "ENT-2177: Use concrete method to locate ResourceLocator\n  - The problem is current code tries to locate the interface method from ResourceLocatorMap class instead of concrete method and finally return \u2018Method XXX not registered as RESTful\u2019 exception.\n  - Easily fix this issue by using the interface method vs concrete method mapping in the ResourceLocatorMap class.\n  - Added new class MethodLocator to hold interface method and concrete method mapping\n  - Updated ResourceLocatorMap class to use MethodLocator\n  - Update AnnotationLocator class to use MethodLocator instead of internal", "committedDate": "2020-03-27T20:40:11Z", "type": "forcePushed"}]}