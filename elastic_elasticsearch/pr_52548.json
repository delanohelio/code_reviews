{"pr_number": 52548, "pr_title": "Consolidate docker availability build logic", "pr_author": "mark-vieira", "pr_createdAt": "2020-02-20T01:04:40Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52548", "timeline": [{"oid": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "url": "https://github.com/elastic/elasticsearch/commit/f32d4158d136cae5dbbd94de600dbed96fce88ad", "message": "Consolidate docker availability build logic\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T00:47:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381882914", "body": "We should stay away from terms like \"blacklist\" and \"whitelist\".\r\n```suggestion\r\n    private boolean isExcludedOs() {\r\n```", "bodyText": "We should stay away from terms like \"blacklist\" and \"whitelist\".\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean isBlacklistedOs() {\n          \n          \n            \n                private boolean isExcludedOs() {", "bodyHTML": "<p dir=\"auto\">We should stay away from terms like \"blacklist\" and \"whitelist\".</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">isBlacklistedOs</span>() {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">boolean</span> <span class=\"x x-first x-last\">isExcludedOs</span>() {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "pugnascotia", "createdAt": "2020-02-20T09:36:37Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE2NjE5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382166195", "bodyText": "Agreed. I've renamed this.", "author": "mark-vieira", "createdAt": "2020-02-20T18:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkxNA=="}], "type": "inlineReview"}, {"oid": "08c44c7b6afb8268cfabfa9e128494ab83bc4cab", "url": "https://github.com/elastic/elasticsearch/commit/08c44c7b6afb8268cfabfa9e128494ab83bc4cab", "message": "Address feedback\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T18:03:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NzU4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381777584", "body": "nit: This shouldn't start with `<p>`, as the first line of a javadoc is the short description.", "bodyText": "nit: This shouldn't start with <p>, as the first line of a javadoc is the short description.", "bodyHTML": "<p dir=\"auto\">nit: This shouldn't start with <code>&lt;p&gt;</code>, as the first line of a javadoc is the short description.</p>", "author": "rjernst", "createdAt": "2020-02-20T05:45:39Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Mjk0Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382192947", "bodyText": "Updated.", "author": "mark-vieira", "createdAt": "2020-02-20T18:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3NzU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODY3MA==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381778670", "body": "I know it is whacky, but `<p>` should basically be used as a paragraph break, without a closing tag, in javadocs. From oracle docs (https://www.oracle.com/technetwork/articles/java/index-137868.html):\r\n\r\n> If you have more than one paragraph in the doc comment, separate the paragraphs with a <p> paragraph tag", "bodyText": "I know it is whacky, but <p> should basically be used as a paragraph break, without a closing tag, in javadocs. From oracle docs (https://www.oracle.com/technetwork/articles/java/index-137868.html):\n\nIf you have more than one paragraph in the doc comment, separate the paragraphs with a  paragraph tag", "bodyHTML": "<p dir=\"auto\">I know it is whacky, but <code>&lt;p&gt;</code> should basically be used as a paragraph break, without a closing tag, in javadocs. From oracle docs (<a href=\"https://www.oracle.com/technetwork/articles/java/index-137868.html\" rel=\"nofollow\">https://www.oracle.com/technetwork/articles/java/index-137868.html</a>):</p>\n<blockquote>\n<p dir=\"auto\">If you have more than one paragraph in the doc comment, separate the paragraphs with a </p><p dir=\"auto\"> paragraph tag</p>\n</blockquote>", "author": "rjernst", "createdAt": "2020-02-20T05:47:48Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5Mjk5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382192995", "bodyText": "Stupid javadocs. Done.", "author": "mark-vieira", "createdAt": "2020-02-20T18:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDMyNw==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381780327", "body": "Why are we setting the property to a boolean string instead of an actual boolean?", "bodyText": "Why are we setting the property to a boolean string instead of an actual boolean?", "bodyHTML": "<p dir=\"auto\">Why are we setting the property to a boolean string instead of an actual boolean?</p>", "author": "rjernst", "createdAt": "2020-02-20T05:51:05Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.gradle.api.Plugin;\n+import org.gradle.api.Project;\n+import org.gradle.api.Task;\n+import org.gradle.api.plugins.ExtraPropertiesExtension;\n+import org.gradle.api.provider.Provider;\n+\n+import java.io.File;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * <p>Plugin providing {@link DockerSupportService} for detecting Docker installations and determining requirements for Docker-based\n+ * Elasticsearch build tasks.</p>\n+ *\n+ * <p>Additionally registers a task graph listener used to assert a compatible Docker installation exists when task requiring Docker are\n+ * scheduled for execution. Tasks may declare a Docker requirement via an extra property. If a compatible Docker installation is not\n+ * available on the build system an exception will be thrown prior to task execution.</p>\n+ *\n+ * <pre>\n+ *     task myDockerTask {\n+ *         ext.requiresDocker = true\n+ *     }\n+ * </pre>\n+ */\n+public class DockerSupportPlugin implements Plugin<Project> {\n+    public static final String DOCKER_SUPPORT_SERVICE_NAME = \"dockerSupportService\";\n+    public static final String DOCKER_ON_LINUX_EXCLUSIONS_FILE = \".ci/dockerOnLinuxExclusions\";\n+    public static final String REQUIRES_DOCKER_ATTRIBUTE = \"requiresDocker\";\n+\n+    @Override\n+    public void apply(Project project) {\n+        if (project != project.getRootProject()) {\n+            throw new IllegalStateException(this.getClass().getName() + \" can only be applied to the root project.\");\n+        }\n+\n+        Provider<DockerSupportService> dockerSupportServiceProvider = project.getGradle()\n+            .getSharedServices()\n+            .registerIfAbsent(\n+                DOCKER_SUPPORT_SERVICE_NAME,\n+                DockerSupportService.class,\n+                spec -> spec.parameters(\n+                    params -> { params.setExclusionsFile(new File(project.getRootDir(), DOCKER_ON_LINUX_EXCLUSIONS_FILE)); }\n+                )\n+            );\n+\n+        // Ensure that if any tasks declare they require docker, we assert an available Docker installation exists\n+        project.getGradle().getTaskGraph().whenReady(graph -> {\n+            List<String> dockerTasks = graph.getAllTasks().stream().filter(task -> {\n+                ExtraPropertiesExtension ext = task.getExtensions().getExtraProperties();\n+                return ext.has(REQUIRES_DOCKER_ATTRIBUTE) && ext.get(REQUIRES_DOCKER_ATTRIBUTE).equals(\"true\");", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzIyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193222", "bodyText": "We were indeed setting to a boolean but were checking for a String. I've fixed this.", "author": "mark-vieira", "createdAt": "2020-02-20T18:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjgyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381782820", "body": "nit: since we are using `assert`s, maybe call use `check` or `ensure` terminology?", "bodyText": "nit: since we are using asserts, maybe call use check or ensure terminology?", "bodyHTML": "<p dir=\"auto\">nit: since we are using <code>assert</code>s, maybe call use <code>check</code> or <code>ensure</code> terminology?</p>", "author": "rjernst", "createdAt": "2020-02-20T05:55:52Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzMwMg==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193302", "bodyText": "Renamed.", "author": "mark-vieira", "createdAt": "2020-02-20T18:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381785841", "body": "removing -> *or* removing?", "bodyText": "removing -> or removing?", "bodyHTML": "<p dir=\"auto\">removing -&gt; <em>or</em> removing?</p>", "author": "rjernst", "createdAt": "2020-02-20T06:02:01Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/docker/DockerSupportService.java", "diffHunk": "@@ -0,0 +1,375 @@\n+package org.elasticsearch.gradle.docker;\n+\n+import org.elasticsearch.gradle.Version;\n+import org.elasticsearch.gradle.info.BuildParams;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+import org.gradle.api.services.BuildService;\n+import org.gradle.api.services.BuildServiceParameters;\n+import org.gradle.process.ExecOperations;\n+import org.gradle.process.ExecResult;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Build service for detecting available Docker installation and checking for compatibility with Elasticsearch Docker image build\n+ * requirements. This includes a minimum version requirement, as well as the ability to run privileged commands.\n+ */\n+public abstract class DockerSupportService implements BuildService<DockerSupportService.Parameters> {\n+\n+    private static Logger LOGGER = Logging.getLogger(DockerSupportService.class);\n+    // Defines the possible locations of the Docker CLI. These will be searched in order.\n+    private static String[] DOCKER_BINARIES = { \"/usr/bin/docker\", \"/usr/local/bin/docker\" };\n+    private static String[] DOCKER_COMPOSE_BINARIES = { \"/usr/local/bin/docker-compose\", \"/usr/bin/docker-compose\" };\n+    private static final Version MINIMUM_DOCKER_VERSION = Version.fromString(\"17.05.0\");\n+\n+    private final ExecOperations execOperations;\n+    private DockerAvailability dockerAvailability;\n+\n+    @Inject\n+    public DockerSupportService(ExecOperations execOperations) {\n+        this.execOperations = execOperations;\n+    }\n+\n+    /**\n+     * Searches for a functional Docker installation, and returns information about the search.\n+     *\n+     * @return the results of the search.\n+     */\n+    public DockerAvailability getDockerAvailability() {\n+        if (this.dockerAvailability == null) {\n+            String dockerPath = null;\n+            Result lastResult = null;\n+            Version version = null;\n+            boolean isVersionHighEnough = false;\n+            boolean isComposeAvailable = false;\n+\n+            // Check if the Docker binary exists\n+            final Optional<String> dockerBinary = getDockerPath();\n+            if (isBlacklistedOs() == false && dockerBinary.isPresent()) {\n+                dockerPath = dockerBinary.get();\n+\n+                // Since we use a multi-stage Docker build, check the Docker version meets minimum requirement\n+                lastResult = runCommand(dockerPath, \"version\", \"--format\", \"{{.Server.Version}}\");\n+\n+                if (lastResult.isSuccess()) {\n+                    version = Version.fromString(lastResult.stdout.trim(), Version.Mode.RELAXED);\n+\n+                    isVersionHighEnough = version.onOrAfter(MINIMUM_DOCKER_VERSION);\n+\n+                    if (isVersionHighEnough) {\n+                        // Check that we can execute a privileged command\n+                        lastResult = runCommand(dockerPath, \"images\");\n+\n+                        // If docker all checks out, see if docker-compose is available and working\n+                        Optional<String> composePath = getDockerComposePath();\n+                        if (lastResult.isSuccess() && composePath.isPresent()) {\n+                            isComposeAvailable = runCommand(composePath.get(), \"version\").isSuccess();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            boolean isAvailable = isVersionHighEnough && lastResult != null && lastResult.isSuccess();\n+\n+            this.dockerAvailability = new DockerAvailability(\n+                isAvailable,\n+                isComposeAvailable,\n+                isVersionHighEnough,\n+                dockerPath,\n+                version,\n+                lastResult\n+            );\n+        }\n+\n+        return this.dockerAvailability;\n+    }\n+\n+    /**\n+     * Given a list of tasks that requires Docker, check whether Docker is available, otherwise throw an exception.\n+     *\n+     * @throws GradleException if Docker is not available. The exception message gives the reason.\n+     */\n+    void assertDockerIsAvailable(List<String> tasks) {\n+        DockerAvailability availability = getDockerAvailability();\n+\n+        // Docker installation is available and compatible\n+        if (availability.isAvailable) {\n+            return;\n+        }\n+\n+        // No Docker binary was located\n+        if (availability.path == null) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"Docker (checked [%s]) is required to run the following task%s: \\n%s\",\n+                String.join(\", \", DOCKER_BINARIES),\n+                tasks.size() > 1 ? \"s\" : \"\",\n+                String.join(\"\\n\", tasks)\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Docker binaries were located, but did not meet the minimum version requirement\n+        if (availability.lastCommand.isSuccess() && availability.isVersionHighEnough == false) {\n+            final String message = String.format(\n+                Locale.ROOT,\n+                \"building Docker images requires minimum Docker version of %s due to use of multi-stage builds yet was [%s]\",\n+                MINIMUM_DOCKER_VERSION,\n+                availability.version\n+            );\n+            throwDockerRequiredException(message);\n+        }\n+\n+        // Some other problem, print the error\n+        final String message = String.format(\n+            Locale.ROOT,\n+            \"a problem occurred while using Docker from [%s]%s yet it is required to run the following task%s: \\n%s\\n\"\n+                + \"the problem is that Docker exited with exit code [%d] with standard error output:\\n%s\",\n+            availability.path,\n+            availability.version == null ? \"\" : \" v\" + availability.version,\n+            tasks.size() > 1 ? \"s\" : \"\",\n+            String.join(\"\\n\", tasks),\n+            availability.lastCommand.exitCode,\n+            availability.lastCommand.stderr.trim()\n+        );\n+        throwDockerRequiredException(message);\n+    }\n+\n+    private boolean isBlacklistedOs() {\n+        // We don't attempt to check the current flavor and version of Linux unless we're\n+        // running in CI, because we don't want to stop people running the Docker tests in\n+        // their own environments if they really want to.\n+        if (BuildParams.isCi() == false) {\n+            return false;\n+        }\n+\n+        // Only some hosts in CI are configured with Docker. We attempt to work out the OS\n+        // and version, so that we know whether to expect to find Docker. We don't attempt\n+        // to probe for whether Docker is available, because that doesn't tell us whether\n+        // Docker is unavailable when it should be.\n+        final Path osRelease = Paths.get(\"/etc/os-release\");\n+\n+        if (Files.exists(osRelease)) {\n+            Map<String, String> values;\n+\n+            try {\n+                final List<String> osReleaseLines = Files.readAllLines(osRelease);\n+                values = parseOsRelease(osReleaseLines);\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read /etc/os-release\", e);\n+            }\n+\n+            final String id = deriveId(values);\n+            final boolean blacklisted = getLinuxExclusionList().contains(id);\n+\n+            if (blacklisted) {\n+                LOGGER.warn(\"Linux OS id [{}] is present in the Docker exclude list. Tasks requiring Docker will be disabled.\", id);\n+            }\n+\n+            return blacklisted;\n+        }\n+\n+        return false;\n+    }\n+\n+    private List<String> getLinuxExclusionList() {\n+        File exclusionsFile = getParameters().getExclusionsFile();\n+\n+        if (exclusionsFile.exists()) {\n+            try {\n+                return Files.readAllLines(exclusionsFile.toPath())\n+                    .stream()\n+                    .map(String::trim)\n+                    .filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false)\n+                    .collect(Collectors.toList());\n+            } catch (IOException e) {\n+                throw new GradleException(\"Failed to read \" + exclusionsFile.getAbsolutePath(), e);\n+            }\n+        } else {\n+            return Collections.emptyList();\n+        }\n+    }\n+\n+    // visible for testing\n+    static String deriveId(Map<String, String> values) {\n+        return values.get(\"ID\") + \"-\" + values.get(\"VERSION_ID\");\n+    }\n+\n+    // visible for testing\n+    static Map<String, String> parseOsRelease(final List<String> osReleaseLines) {\n+        final Map<String, String> values = new HashMap<>();\n+\n+        osReleaseLines.stream().map(String::trim).filter(line -> (line.isEmpty() || line.startsWith(\"#\")) == false).forEach(line -> {\n+            final String[] parts = line.split(\"=\", 2);\n+            final String key = parts[0];\n+            // remove optional leading and trailing quotes and whitespace\n+            final String value = parts[1].replaceAll(\"^['\\\"]?\\\\s*\", \"\").replaceAll(\"\\\\s*['\\\"]?$\", \"\");\n+\n+            values.put(key, value);\n+        });\n+\n+        return values;\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_BINARIES} for the Docker CLI. This method does\n+     * not check whether the Docker installation appears usable, see {@link #getDockerAvailability()}\n+     * instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerPath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    /**\n+     * Searches the entries in {@link #DOCKER_COMPOSE_BINARIES} for the Docker Compose CLI. This method does\n+     * not check whether the installation appears usable, see {@link #getDockerAvailability()} instead.\n+     *\n+     * @return the path to a CLI, if available.\n+     */\n+    private Optional<String> getDockerComposePath() {\n+        // Check if the Docker binary exists\n+        return List.of(DOCKER_COMPOSE_BINARIES).stream().filter(path -> new File(path).exists()).findFirst();\n+    }\n+\n+    private void throwDockerRequiredException(final String message) {\n+        throwDockerRequiredException(message, null);\n+    }\n+\n+    private void throwDockerRequiredException(final String message, Exception e) {\n+        throw new GradleException(\n+            message + \"\\nyou can address this by attending to the reported issue, \" + \"removing the offending tasks from being executed.\",", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MzM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382193387", "bodyText": "I've reworded this message.", "author": "mark-vieira", "createdAt": "2020-02-20T18:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NzU0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r381787541", "body": "Why onlyIf here instead of using the requiresDocker property?", "bodyText": "Why onlyIf here instead of using the requiresDocker property?", "bodyHTML": "<p dir=\"auto\">Why onlyIf here instead of using the requiresDocker property?</p>", "author": "rjernst", "createdAt": "2020-02-20T06:05:10Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/test/DistroTestPlugin.java", "diffHunk": "@@ -324,8 +322,14 @@ public String toString() {\n         });\n     }\n \n-    private static TaskProvider<?> configureDistroTest(Project project, ElasticsearchDistribution distribution) {\n+    private static TaskProvider<?> configureDistroTest(\n+        Project project,\n+        ElasticsearchDistribution distribution,\n+        Provider<DockerSupportService> dockerSupport\n+    ) {\n         return project.getTasks().register(destructiveDistroTestTaskName(distribution), Test.class, t -> {\n+            // Disable Docker distribution tests unless a Docker installation is available\n+            t.onlyIf(t2 -> distribution.getType() != Type.DOCKER || dockerSupport.get().getDockerAvailability().isAvailable);", "originalCommit": "f32d4158d136cae5dbbd94de600dbed96fce88ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NjA5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382186097", "bodyText": "As discussed, using requiresDocker is strict. It fails the build if docker is unavailable. We want to simply skip that task in that scenario.", "author": "mark-vieira", "createdAt": "2020-02-20T18:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4NzU0MQ=="}], "type": "inlineReview"}, {"oid": "4a3cf2d451fa1c485393616db11de37b787afe66", "url": "https://github.com/elastic/elasticsearch/commit/4a3cf2d451fa1c485393616db11de37b787afe66", "message": "Address feedback\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T18:54:06Z", "type": "commit"}, {"oid": "f5fc6b7cf012a84fe8ffa00318eb2198c73e154c", "url": "https://github.com/elastic/elasticsearch/commit/f5fc6b7cf012a84fe8ffa00318eb2198c73e154c", "message": "Fix code style violations\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T19:01:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250465", "body": "bundledJdk *setting*?", "bodyText": "bundledJdk setting?", "bodyHTML": "<p dir=\"auto\">bundledJdk <em>setting</em>?</p>", "author": "rjernst", "createdAt": "2020-02-20T20:51:31Z", "path": "buildSrc/src/main/java/org/elasticsearch/gradle/ElasticsearchDistribution.java", "diffHunk": "@@ -270,6 +276,11 @@ void finalizeValues() {\n                     \"platform not allowed for elasticsearch distribution [\" + name + \"] of type [\" + getType() + \"]\"\n                 );\n             }\n+            if (getType() == Type.DOCKER && bundledJdk.isPresent()) {\n+                throw new IllegalArgumentException(\n+                    \"bundledJdk not allowed for elasticsearch distribution [\" + name + \"] of type [docker]\"", "originalCommit": "4a3cf2d451fa1c485393616db11de37b787afe66", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDgyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52548#discussion_r382250822", "bodyText": "or property or something like that? as it is written it sounds like docker can't use the bundledJdk, when in face it only uses it.", "author": "rjernst", "createdAt": "2020-02-20T20:52:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1MDQ2NQ=="}], "type": "inlineReview"}, {"oid": "5f24188537132bb992e48770c22a4b93163a7b08", "url": "https://github.com/elastic/elasticsearch/commit/5f24188537132bb992e48770c22a4b93163a7b08", "message": "Reword validation error messages\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T20:57:42Z", "type": "commit"}, {"oid": "d1b260d5c21ad50ca6fff1b3fe1383ab43ffb0c0", "url": "https://github.com/elastic/elasticsearch/commit/d1b260d5c21ad50ca6fff1b3fe1383ab43ffb0c0", "message": "Fix unit test\n\nSigned-off-by: Mark Vieira <portugee@gmail.com>", "committedDate": "2020-02-20T21:39:20Z", "type": "commit"}]}