{"pr_number": 51256, "pr_title": "Simplify Snapshot Initialization", "pr_author": "original-brownbear", "pr_createdAt": "2020-01-21T15:38:50Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/51256", "timeline": [{"oid": "233c746a0d9814c0748820fe8bdbe399bbdf8020", "url": "https://github.com/elastic/elasticsearch/commit/233c746a0d9814c0748820fe8bdbe399bbdf8020", "message": "Simplify Snapshot Initialization\n\nWe were loading `RepositoryData` twice during snapshot initialization,\nredundantly checking if a snapshot existed already.\nThe first snapshot existence check is somewhat redundant because a snapshot could be\ncreated between loading `RepositoryData` and updating the cluster state with the `INIT`\nstate snapshot entry.\nAlso, it is much safer to do the subsequent checks for index existence in the repo and\nand the presence of old version snapshots once the `INIT` state entry prevents further\nsnapshots from being created concurrently.\nWhile the current state of things will never lead to corruption on a concurrent snapshot\ncreation, it could result in a situation (though unlikely) where all the snapshot's work\nis done on the data nodes, only to find out that the repository generation was off during\nsnapshot finalization, failing there and leaving a bunch of dead data in the repository\nthat won't be used in a subsequent snapshot (because the shard generation was never referenced\ndue to the failed snapshot finalization).\n\nNote: This is a step on the way to parallel repository operations by making snapshot related CS\nand repo related CS more tightly correlated.", "committedDate": "2020-01-21T15:31:03Z", "type": "commit"}, {"oid": "1ffd8077f85855380d341659b2ff53a373d2def6", "url": "https://github.com/elastic/elasticsearch/commit/1ffd8077f85855380d341659b2ff53a373d2def6", "message": "cs", "committedDate": "2020-01-21T15:40:40Z", "type": "commit"}, {"oid": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "url": "https://github.com/elastic/elasticsearch/commit/7ca5ef3d193a2bb5d45085ed085169d562b604d5", "message": "shorter", "committedDate": "2020-01-21T15:45:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMDAwNw==", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369630007", "body": "I find this a bit more readable:\r\n\r\n```suggestion\r\n                if (snapshots != null && snapshots.entries().isEmpty() == false) {\r\n                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\r\n                }\r\n                // Store newSnapshot here to be processed in clusterStateProcessed\r\n                ...\r\n```", "bodyText": "I find this a bit more readable:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (snapshots == null || snapshots.entries().isEmpty()) {\n          \n          \n            \n                            if (snapshots != null && snapshots.entries().isEmpty() == false) {\n          \n          \n            \n                                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n          \n          \n            \n                            }\n          \n          \n            \n                            // Store newSnapshot here to be processed in clusterStateProcessed\n          \n          \n            \n                            ...", "bodyHTML": "<p dir=\"auto\">I find this a bit more readable:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-k\">if</span> (snapshots <span class=\"pl-k x x-first x-last\">==</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k x x-first x-last\">||</span> snapshots<span class=\"pl-k\">.</span>entries()<span class=\"pl-k\">.</span>isEmpty()) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-k\">if</span> (snapshots <span class=\"pl-k x x-first x-last\">!=</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k x x-first x-last\">&amp;&amp;</span> snapshots<span class=\"pl-k\">.</span>entries()<span class=\"pl-k\">.</span>isEmpty()<span class=\"x x-first\"> </span><span class=\"pl-k x\">==</span><span class=\"x\"> </span><span class=\"pl-c1 x x-last\">false</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ConcurrentSnapshotExecutionException</span>(repositoryName, snapshotName, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span> a snapshot is already running<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Store newSnapshot here to be processed in clusterStateProcessed</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-c1\">...</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "tlrx", "createdAt": "2020-01-22T15:31:13Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {", "originalCommit": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMjkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/51256#discussion_r369632925", "body": "Maybe add a comment on why the list is empty here? Something like \r\n// list of snapshot indices will be resolved later", "bodyText": "Maybe add a comment on why the list is empty here? Something like\n// list of snapshot indices will be resolved later", "bodyHTML": "<p dir=\"auto\">Maybe add a comment on why the list is empty here? Something like<br>\n// list of snapshot indices will be resolved later</p>", "author": "tlrx", "createdAt": "2020-01-22T15:35:59Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -268,90 +268,86 @@ public void createSnapshot(final CreateSnapshotRequest request, final ActionList\n         final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot());\n         validate(repositoryName, snapshotName);\n         final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID()); // new UUID for the snapshot\n-        final StepListener<RepositoryData> repositoryDataListener = new StepListener<>();\n-        repositoriesService.repository(repositoryName).getRepositoryData(repositoryDataListener);\n-        repositoryDataListener.whenComplete(repositoryData -> {\n-            final boolean hasOldFormatSnapshots = hasOldVersionSnapshots(repositoryName, repositoryData, null);\n-            clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n-\n-                private SnapshotsInProgress.Entry newSnapshot = null;\n-\n-                @Override\n-                public ClusterState execute(ClusterState currentState) {\n-                    validate(repositoryName, snapshotName, currentState);\n-                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n-                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n-                    }\n-                    final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n-                    if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n-                            \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n-                    }\n-                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n-                    if (snapshots == null || snapshots.entries().isEmpty()) {\n-                        // Store newSnapshot here to be processed in clusterStateProcessed\n-                        List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n-                            request.indicesOptions(), request.indices()));\n-                        logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n-                        List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices);\n-                        newSnapshot = new SnapshotsInProgress.Entry(\n-                            new Snapshot(repositoryName, snapshotId),\n-                            request.includeGlobalState(), request.partial(),\n-                            State.INIT,\n-                            snapshotIndices,\n-                            threadPool.absoluteTimeInMillis(),\n-                            repositoryData.getGenId(),\n-                            null,\n-                            request.userMetadata(),\n-                            hasOldFormatSnapshots == false &&\n-                                clusterService.state().nodes().getMinNodeVersion().onOrAfter(SHARD_GEN_IN_REPO_DATA_VERSION));\n-                        initializingSnapshots.add(newSnapshot.snapshot());\n-                        snapshots = new SnapshotsInProgress(newSnapshot);\n-                    } else {\n-                        throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, \" a snapshot is already running\");\n-                    }\n-                    return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build();\n+        clusterService.submitStateUpdateTask(\"create_snapshot [\" + snapshotName + ']', new ClusterStateUpdateTask() {\n+\n+            private SnapshotsInProgress.Entry newSnapshot = null;\n+\n+            private List<String> indices;\n+\n+            @Override\n+            public ClusterState execute(ClusterState currentState) {\n+                validate(repositoryName, snapshotName, currentState);\n+                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE);\n+                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a snapshot deletion is in-progress in [\" + deletionsInProgress + \"]\");\n                 }\n+                final RepositoryCleanupInProgress repositoryCleanupInProgress = currentState.custom(RepositoryCleanupInProgress.TYPE);\n+                if (repositoryCleanupInProgress != null && repositoryCleanupInProgress.hasCleanupInProgress()) {\n+                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,\n+                        \"cannot snapshot while a repository cleanup is in-progress in [\" + repositoryCleanupInProgress + \"]\");\n+                }\n+                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE);\n+                if (snapshots == null || snapshots.entries().isEmpty()) {\n+                    // Store newSnapshot here to be processed in clusterStateProcessed\n+                    indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,\n+                        request.indicesOptions(), request.indices()));\n+                    logger.trace(\"[{}][{}] creating snapshot for indices [{}]\", repositoryName, snapshotName, indices);\n+                    newSnapshot = new SnapshotsInProgress.Entry(\n+                        new Snapshot(repositoryName, snapshotId),\n+                        request.includeGlobalState(), request.partial(),\n+                        State.INIT,\n+                        Collections.emptyList(),", "originalCommit": "7ca5ef3d193a2bb5d45085ed085169d562b604d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ae7c2a68c910cf3f79c976229a9396e2068ae373", "url": "https://github.com/elastic/elasticsearch/commit/ae7c2a68c910cf3f79c976229a9396e2068ae373", "message": "Merge remote-tracking branch 'elastic/master' into make-snapshot-delete-order-deterministic", "committedDate": "2020-01-22T16:29:09Z", "type": "commit"}, {"oid": "6da256517662d2c23df67dfac2d04d17ac0af9c2", "url": "https://github.com/elastic/elasticsearch/commit/6da256517662d2c23df67dfac2d04d17ac0af9c2", "message": "CR comments", "committedDate": "2020-01-22T16:33:22Z", "type": "commit"}]}