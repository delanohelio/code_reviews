{"pr_number": 52822, "pr_title": "Implement Cancellable DirectoryReader", "pr_author": "matriv", "pr_createdAt": "2020-02-26T15:01:43Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52822", "merge_commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "timeline": [{"oid": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "url": "https://github.com/elastic/elasticsearch/commit/e2ebfb48fab5d86de9137dfe624967c078cd88bf", "message": "Implement Cancellable DirectoryReader\n\nImplement a Cancellable DirectoryReader that wraps the original\nDirectoryReader so that when a search task is cancelled the\nDirectoryReaders also stop their work fast. This is usuful for\nexpensive operations like wilcard/prefix queries where the\nDirectoryReaders can spend lots of time and consume resources,\nas previously their work wouldn't stop even though the original\nsearch task was cancelled (e.g. because of timeout or dropped client\nconnection).", "committedDate": "2020-02-26T14:55:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDA5Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384554097", "body": "this leniency looks dangerous?", "bodyText": "this leniency looks dangerous?", "bodyHTML": "<p dir=\"auto\">this leniency looks dangerous?</p>", "author": "jpountz", "createdAt": "2020-02-26T15:10:02Z", "path": "server/src/main/java/org/elasticsearch/search/SearchService.java", "diffHunk": "@@ -708,6 +708,8 @@ private DefaultSearchContext createSearchContext(SearchRewriteContext rewriteCon\n                 searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n+        } catch (IOException e) {\n+            return null;", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwNDI4NA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384604284", "bodyText": "Should I simply propagate the exception? or any other suggestion?", "author": "matriv", "createdAt": "2020-02-26T16:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDA5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex d09ae01be57..49b560dcd5b 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -708,8 +708,6 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n-        } catch (IOException e) {\n-            return null;\n         } finally {\n             if (success == false) {\n                 // we handle the case where `IndicesService#indexServiceSafe`or `IndexService#getShard`, or the DefaultSearchContext\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex d09ae01be57..49b560dcd5b 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -708,8 +708,6 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n                 searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n-        } catch (IOException e) {\n-            return null;\n         } finally {\n             if (success == false) {\n                 // we handle the case where `IndicesService#indexServiceSafe`or `IndexService#getShard`, or the DefaultSearchContext\n", "next_change": {"commit": "b2ea32959103b93c03cc487ce475adde792f21e3", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 49b560dcd5b..e8eacdafbaa 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -704,8 +718,17 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             IndexShard indexShard = indexService.getShard(request.shardId().getId());\n             SearchShardTarget shardTarget = new SearchShardTarget(clusterService.localNode().getId(),\n                 indexShard.shardId(), request.getClusterAlias(), OriginalIndices.NONE);\n-            DefaultSearchContext searchContext = new DefaultSearchContext(idGenerator.incrementAndGet(), request, shardTarget,\n-                searcher, clusterService, indexService, indexShard, bigArrays, threadPool::relativeTimeInMillis, timeout, fetchPhase);\n+            // TODO: If no changes are made since the last commit, and the searcher is opened from that commit, then we can use the\n+            //  commit_id as the context_id. And if the local checkpoint and max_seq_no of that commit equal the global checkpoint,\n+            //  then we can use a combination of history_uuid and one of these values as a **weaker** context_id.\n+            //  Reader contexts with the same commit_id can be replaced at any time, as the Lucene doc ids are the same.\n+            //  Reader contexts with the same seq_id, however, can't be replaced between the query and fetch phase because\n+            //  the Lucene doc ids can be different.\n+            final String readerId = UUIDs.base64UUID();\n+            DefaultSearchContext searchContext = new DefaultSearchContext(\n+                new SearchContextId(readerId, idGenerator.incrementAndGet()),\n+                request, shardTarget, searcher, clusterService, indexService, indexShard, bigArrays,\n+                threadPool::relativeTimeInMillis, timeout, fetchPhase);\n             success = true;\n             return searchContext;\n         } finally {\n", "next_change": {"commit": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex e8eacdafbaa..9821f8f212d 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -728,7 +729,7 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             DefaultSearchContext searchContext = new DefaultSearchContext(\n                 new SearchContextId(readerId, idGenerator.incrementAndGet()),\n                 request, shardTarget, searcher, clusterService, indexService, indexShard, bigArrays,\n-                threadPool::relativeTimeInMillis, timeout, fetchPhase);\n+                threadPool::relativeTimeInMillis, timeout, fetchPhase, lowLevelCancellation);\n             success = true;\n             return searchContext;\n         } finally {\n", "next_change": {"commit": "f301f49918452bd89e0c2afbde5d1f0813e76091", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 9821f8f212d..e49e8c746de 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -726,20 +725,25 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             //  Reader contexts with the same seq_id, however, can't be replaced between the query and fetch phase because\n             //  the Lucene doc ids can be different.\n             final String readerId = UUIDs.base64UUID();\n-            DefaultSearchContext searchContext = new DefaultSearchContext(\n+            searchContext = new DefaultSearchContext(\n                 new SearchContextId(readerId, idGenerator.incrementAndGet()),\n                 request, shardTarget, searcher, clusterService, indexService, indexShard, bigArrays,\n                 threadPool::relativeTimeInMillis, timeout, fetchPhase, lowLevelCancellation);\n+            // we clone the query shard context here just for rewriting otherwise we\n+            // might end up with incorrect state since we are using now() or script services\n+            // during rewrite and normalized / evaluate templates etc.\n+            QueryShardContext context = new QueryShardContext(searchContext.getQueryShardContext());\n+            Rewriteable.rewrite(request.getRewriteable(), context, true);\n+            assert searchContext.getQueryShardContext().isCacheable();\n             success = true;\n-            return searchContext;\n         } finally {\n             if (success == false) {\n-                // we handle the case where `IndicesService#indexServiceSafe`or `IndexService#getShard`, or the DefaultSearchContext\n-                // constructor throws an exception since we would otherwise leak a searcher and this can have severe implications\n-                // (unable to obtain shard lock exceptions).\n-                IOUtils.closeWhileHandlingException(rewriteContext.searcher);\n+                // we handle the case where the DefaultSearchContext constructor throws an exception since we would otherwise\n+                // leak a searcher and this can have severe implications (unable to obtain shard lock exceptions).\n+                IOUtils.closeWhileHandlingException(searcher);\n             }\n         }\n+        return searchContext;\n     }\n \n \n", "next_change": {"commit": "879279c9b46b5a9606dfca96075e005624f0785d", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex e49e8c746de..53e06613c44 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -738,83 +809,63 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n             success = true;\n         } finally {\n             if (success == false) {\n-                // we handle the case where the DefaultSearchContext constructor throws an exception since we would otherwise\n-                // leak a searcher and this can have severe implications (unable to obtain shard lock exceptions).\n-                IOUtils.closeWhileHandlingException(searcher);\n+                // we handle the case where `IndicesService#indexServiceSafe`or `IndexService#getShard`, or the DefaultSearchContext\n+                // constructor throws an exception since we would otherwise leak a searcher and this can have severe implications\n+                // (unable to obtain shard lock exceptions).\n+                IOUtils.closeWhileHandlingException(searchContext);\n             }\n         }\n         return searchContext;\n     }\n \n-\n     private void freeAllContextForIndex(Index index) {\n         assert index != null;\n-        for (SearchContext ctx : activeContexts.values()) {\n+        for (ReaderContext ctx : activeReaders.values()) {\n             if (index.equals(ctx.indexShard().shardId().getIndex())) {\n-                freeContext(ctx.id());\n+                freeReaderContext(ctx.id());\n             }\n         }\n     }\n \n-    public boolean freeContext(SearchContextId contextId) {\n-        if (getContext(contextId) != null) {\n-            try (SearchContext context = removeContext(contextId.getId())) {\n-                if (context != null) {\n-                    onFreeContext(context);\n-                    return true;\n-                }\n+    public boolean freeReaderContext(ShardSearchContextId contextId) {\n+        if (getReaderContext(contextId) != null) {\n+            try (ReaderContext context = removeReaderContext(contextId.getId())) {\n+                return context != null;\n             }\n         }\n         return false;\n     }\n \n-    private void onFreeContext(SearchContext context) {\n-        assert context.refCount() > 0 : \" refCount must be > 0: \" + context.refCount();\n-        assert activeContexts.containsKey(context.id().getId()) == false;\n-        context.indexShard().getSearchOperationListener().onFreeContext(context);\n-        if (context.scrollContext() != null) {\n-            context.indexShard().getSearchOperationListener().onFreeScrollContext(context);\n+    public void freeAllScrollContexts() {\n+        for (ReaderContext readerContext : activeReaders.values()) {\n+            if (readerContext.scrollContext() != null) {\n+                freeReaderContext(readerContext.id());\n+            }\n         }\n     }\n \n-    public void freeAllScrollContexts() {\n-        for (SearchContext searchContext : activeContexts.values()) {\n-            if (searchContext.scrollContext() != null) {\n-                freeContext(searchContext.id());\n-            }\n+    private long getKeepAlive(ShardSearchRequest request) {\n+        if (request.scroll() != null && request.scroll().keepAlive() != null) {\n+            return request.scroll().keepAlive().millis();\n+        } else {\n+            return defaultKeepAlive;\n         }\n     }\n \n-    private void contextScrollKeepAlive(SearchContext context, long keepAlive) {\n+    private void checkKeepAliveLimit(long keepAlive) {\n         if (keepAlive > maxKeepAlive) {\n             throw new IllegalArgumentException(\n-                \"Keep alive for scroll (\" + TimeValue.timeValueMillis(keepAlive) + \") is too large. \" +\n+                \"Keep alive for request (\" + TimeValue.timeValueMillis(keepAlive) + \") is too large. \" +\n                     \"It must be less than (\" + TimeValue.timeValueMillis(maxKeepAlive) + \"). \" +\n                     \"This limit can be set by changing the [\" + MAX_KEEPALIVE_SETTING.getKey() + \"] cluster level setting.\");\n         }\n-        context.keepAlive(keepAlive);\n     }\n \n-    private void contextProcessing(SearchContext context) {\n-        // disable timeout while executing a search\n-        context.accessed(-1);\n-    }\n-\n-    private void contextProcessedSuccessfully(SearchContext context) {\n-        context.accessed(threadPool.relativeTimeInMillis());\n-    }\n-\n-    private void cleanContext(SearchContext context) {\n-        try {\n-            context.clearReleasables(Lifetime.PHASE);\n-            context.setTask(null);\n-        } finally {\n-            context.decRef();\n+    private void processFailure(ShardSearchRequest request, ReaderContext context, Exception e) {\n+        if (context.singleSession() || request.scroll() != null) {\n+            // we release the reader on failure if the request is a normal search or a scroll\n+            freeReaderContext(context.id());\n         }\n-    }\n-\n-    private void processFailure(SearchContext context, Exception e) {\n-        freeContext(context.id());\n         try {\n             if (Lucene.isCorruptionException(e)) {\n                 context.indexShard().failShard(\"search execution corruption failure\", e);\n", "next_change": {"commit": "38dc926e10212a5a5a03bcd64c0e7bbf780b1807", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/SearchService.java b/server/src/main/java/org/elasticsearch/search/SearchService.java\nindex 53e06613c44..de303b51446 100644\n--- a/server/src/main/java/org/elasticsearch/search/SearchService.java\n+++ b/server/src/main/java/org/elasticsearch/search/SearchService.java\n", "chunk": "@@ -861,17 +854,38 @@ public class SearchService extends AbstractLifecycleComponent implements IndexEv\n         }\n     }\n \n-    private void processFailure(ShardSearchRequest request, ReaderContext context, Exception e) {\n-        if (context.singleSession() || request.scroll() != null) {\n+    private <T> ActionListener<T> wrapFailureListener(ActionListener<T> listener, ReaderContext context, Releasable releasable) {\n+        return new ActionListener<>() {\n+            @Override\n+            public void onResponse(T resp) {\n+                Releasables.close(releasable);\n+                listener.onResponse(resp);\n+            }\n+\n+            @Override\n+            public void onFailure(Exception exc) {\n+                processFailure(context, exc);\n+                Releasables.close(releasable);\n+                listener.onFailure(exc);\n+            }\n+        };\n+    }\n+\n+    private boolean isScrollContext(ReaderContext context) {\n+        return context instanceof LegacyReaderContext && context.singleSession() == false;\n+    }\n+\n+    private void processFailure(ReaderContext context, Exception exc) {\n+        if (context.singleSession() || isScrollContext(context)) {\n             // we release the reader on failure if the request is a normal search or a scroll\n             freeReaderContext(context.id());\n         }\n         try {\n-            if (Lucene.isCorruptionException(e)) {\n-                context.indexShard().failShard(\"search execution corruption failure\", e);\n+            if (Lucene.isCorruptionException(exc)) {\n+                context.indexShard().failShard(\"search execution corruption failure\", exc);\n             }\n         } catch (Exception inner) {\n-            inner.addSuppressed(e);\n+            inner.addSuppressed(exc);\n             logger.warn(\"failed to process shard failure to (potentially) send back shard failure on corruption\", inner);\n         }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "b2ea32959103b93c03cc487ce475adde792f21e3", "committedDate": "2020-03-09 11:59:30 -0400", "message": "Harden search context id (#53143)"}, {"oid": "a8d89fd0a580d88f127cf93a43a3c2378179bff4", "committedDate": "2020-03-12 11:51:16 -0400", "message": "Fix concurrent requests race over scroll context limit (#53449)"}, {"oid": "4d81edb6257732a73adc3e5bc5157ad01d1a42c4", "committedDate": "2020-03-16 14:51:54 -0400", "message": "Stop using round-tripped PipelineAggregators (#53423)"}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "f301f49918452bd89e0c2afbde5d1f0813e76091", "committedDate": "2020-03-25 00:26:10 +0100", "message": "Avoid I/O operations when rewriting shard search request (#54044)"}, {"oid": "e8c54c73dbee2877637c8dd076d82fb5a94e1b47", "committedDate": "2020-03-25 08:52:20 -0400", "message": "Save a little space in agg tree (#53730)"}, {"oid": "a8f331127a8b0108c2ad2a0e6bfd73aa5b1ff60f", "committedDate": "2020-03-25 16:15:52 +0100", "message": "Fix small typo in SearchService#executeQueryPhase"}, {"oid": "befbe9a433de88aaf0448708d86406ba5cba1ecf", "committedDate": "2020-04-15 22:32:46 +0200", "message": "SearchService#canMatch takes into consideration the alias filter (#55120)"}, {"oid": "b2a15c62fb24977abfab0e6021a4a2998d485390", "committedDate": "2020-04-26 16:43:27 -0400", "message": "Return true for can_match on idle search shards (#55428)"}, {"oid": "fa535d08b50686272d0a6526fb2f8cf25e4d38a8", "committedDate": "2020-05-11 09:53:48 -0700", "message": "Use CollectionUtils.isEmpty where appropriate (#55910)"}, {"oid": "a52c85acbaaee856db65a50ef6a1e2a12cd14da7", "committedDate": "2020-05-12 15:13:51 +0200", "message": "Ensure search contexts are removed on index delete (#56335)"}, {"oid": "c75ed66318d037218a20cd69f45778278902c5d8", "committedDate": "2020-07-20 15:15:47 +0200", "message": "fix handling of alias filter in SearchService#canMatch (#59368)"}, {"oid": "6aee768c7d70f7720124710d73a2bed9894deaa4", "committedDate": "2020-07-22 08:55:52 -0700", "message": "Consolidate validation for 'docvalue_fields'. (#59473)"}, {"oid": "8a89d95372a910255479d0b05cd1f3f46e333c77", "committedDate": "2020-07-27 13:25:55 -0700", "message": "Add search `fields` parameter to support high-level field retrieval. (#60100)"}, {"oid": "9d283287c49577faad891b4263b9501dba1f0505", "committedDate": "2020-07-30 11:57:36 -0700", "message": "Clarify SourceLookup sharing across fetch subphases. (#60179)"}, {"oid": "8c51fc7e2d35d3edb301e35d4bbb23e7030b1654", "committedDate": "2020-08-10 12:38:54 -0600", "message": "System index reads in separate threadpool (#57936)"}, {"oid": "01c6c9bc5c4021e7608c69b748d94484710d7e3f", "committedDate": "2020-08-10 14:52:51 -0700", "message": "Prevent loading 'fields' with stored fields disabled. (#60935)"}, {"oid": "879279c9b46b5a9606dfca96075e005624f0785d", "committedDate": "2020-08-24 20:24:35 -0400", "message": "Introduce point in time APIs in x-pack basic (#61062)"}, {"oid": "38dc926e10212a5a5a03bcd64c0e7bbf780b1807", "committedDate": "2020-09-07 10:47:24 +0200", "message": "Ensure validation of the reader context is executed first (#61831)"}, {"oid": "6a1c3e6059a13d97605892026595ea7f25686d6d", "committedDate": "2020-09-07 13:43:53 +0100", "message": "Remove SearchPhase interface (#62050)"}, {"oid": "aefca5edd76b86d0de06c9c3a2bbba6b0f1ebb58", "committedDate": "2020-09-09 09:14:08 +0200", "message": "Shard Search Scroll failures consistency (#62061)"}, {"oid": "4e974bc91e5af4037ab08345a248e980163c4511", "committedDate": "2020-09-09 14:45:45 -0400", "message": "Release search context when scroll keep_alive is too large (#62179)"}, {"oid": "9a127adb4b1dd8e69ac5b6c08cc7251383562e9c", "committedDate": "2020-09-15 15:57:26 -0400", "message": "Implement fields fetch for runtime fields (#61995)"}, {"oid": "a383aa896582b7dca6c39e4dda1edbcfbe5cb3b9", "committedDate": "2020-09-17 17:30:31 +0100", "message": "Load version metadata even when stored fields are disabled (#62533)"}, {"oid": "64f60521ade808458d458ad02690d6c8a27f048f", "committedDate": "2020-09-21 16:27:22 -0400", "message": "Remove invalid assertion in SearchService (#62675)"}, {"oid": "2d64d4b7fde8e8afd2adf30ca154c4b916eaad3a", "committedDate": "2020-09-22 22:03:18 -0400", "message": "Better UUID for reader context (#62715)"}, {"oid": "cf130f386e5a83e35508f08a1c75352d3b071a08", "committedDate": "2020-10-05 18:02:55 +0200", "message": "Replace some usages of QueryShardContext#getMapperService (#63239)"}, {"oid": "4aaffc6a3deef28e8dedd3d9211951e3db0e2d8e", "committedDate": "2020-10-12 13:11:44 -0400", "message": "Consider query when optimizing date rounding (#63403)"}, {"oid": "498e264df4e8f3c833dd9e3531a1ec5acd305ebd", "committedDate": "2020-10-21 17:51:11 +0200", "message": "Count only mapped fields towards docvalue_fields limit (#63806)"}, {"oid": "2186b75af9f76b866539c16e76ffc8e019ac11d3", "committedDate": "2020-10-28 09:55:52 +0100", "message": "Reduce usages of SearchContext#mapperService (#64250)"}, {"oid": "b48ecdaabac06af945a61bcb9bc343d02c96f084", "committedDate": "2020-11-06 09:53:37 -0800", "message": "Remove some unnecessary methods from SearchContext. (#64672)"}, {"oid": "a08b52f3bd736fd741a38f3a4493a183c2ad8a69", "committedDate": "2020-11-10 12:38:59 -0500", "message": "Add `runtime_mappings` to search request (#64374)"}, {"oid": "c2275540808beb6e4499dafcd1e5474f1b4821a0", "committedDate": "2020-11-30 13:19:44 -0500", "message": "Remove SearchContext from constructing aggregations (#64953)"}, {"oid": "3e45318d87958118be7688f316234b1afb28765b", "committedDate": "2020-12-08 10:22:34 -0500", "message": "Remove BigArrays from SearchContext (#65981)"}, {"oid": "1585078a65676a60aaebdc8ecbaad4a8516b3083", "committedDate": "2020-12-09 15:20:24 -0500", "message": "Clean up some aggregation tests (#66044)"}, {"oid": "32200b1c832b3705ededed59aa11a00465ff080d", "committedDate": "2020-12-15 08:57:37 +0100", "message": "Apply can match phase on coordinator when the min max field data is available at the coordinator. (#65583)"}, {"oid": "c756ce1acfa0e18c3ebed890d214e8904d4bee27", "committedDate": "2020-12-18 12:13:12 +0100", "message": "Sort field tiebreaker for PIT (point in time) readers (#66093)"}, {"oid": "de8b39e52dc8fa4e85ddc091f38bec2123c5820a", "committedDate": "2021-01-04 11:26:42 -0500", "message": "Lower contention on requests with many aggs (#66895)"}, {"oid": "b0747c5a760d2bf9ef0fa403826346bc8ac3c063", "committedDate": "2021-01-07 10:05:59 -0500", "message": "Fix bug with nested and filters agg (#67043)"}, {"oid": "59082c0d3a0e7fb8d809a3ad5f7375fa652ff430", "committedDate": "2021-01-09 09:43:59 -0500", "message": "Retry point in time on other copy when possible (#66713)"}, {"oid": "7a5c3da88908fdf0fba3e1bc4785b17125ebc794", "committedDate": "2021-01-12 21:21:25 -0500", "message": "Fix keep_alive of derived context of point in time (#67398)"}, {"oid": "3052ab8dc27d13b7ffaacaf84610c922c8e22a26", "committedDate": "2021-01-13 13:34:12 -0500", "message": "Drop BigArrays from QueryShardContext (#66945)"}, {"oid": "5852fbedf52c77b0a76c2c731fdd4982fb65cd87", "committedDate": "2021-01-14 09:11:59 -0800", "message": "Rename QueryShardContext -> SearchExecutionContext. (#67490)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "c4e1074e68381dc0b2566beca183f3236055a760", "committedDate": "2021-02-27 21:24:36 +0100", "message": "Close search contexts on reassigned shard (#68539)"}, {"oid": "96e412f771514a4d5c49ff363fe0c7ab403ef2b1", "committedDate": "2021-03-05 14:28:20 +0100", "message": "Cancel searches earlier (#69795)"}, {"oid": "b6a369858d589039505028120fe70b7c4456ac8d", "committedDate": "2021-03-16 08:47:37 +0100", "message": "Cleanup more ActionListener Delegation Spots (#69662)"}, {"oid": "541cb020773df3ee2b96e6627e5295b43b4e5b3b", "committedDate": "2021-04-04 09:47:53 -0400", "message": "Fix search states of CCS requests in mixed cluster (#71265)"}, {"oid": "bd124399c4cc432fe0965f6ec33ab58b919bcfb5", "committedDate": "2021-04-07 14:08:24 -0400", "message": "Ensure search contexts are released after tests (#71427)"}, {"oid": "57e6c78a5271303daf42265edd307955c0916704", "committedDate": "2021-04-13 08:36:51 -0400", "message": "Fix profiled global agg (#71575)"}, {"oid": "f85a9dddb92aaf6cad45941ef2768fb86aeaf76a", "committedDate": "2021-05-19 14:21:18 -0700", "message": "Support field collapsing with search_after (#73023)"}, {"oid": "4b5aebe8b07649a8954063e8099d9265a798a890", "committedDate": "2021-06-02 09:12:54 -0400", "message": "Add setting to disable aggs optimization (#73620)"}, {"oid": "1c295a92d876e243391aa0cbc5cfc173efc4411f", "committedDate": "2021-06-03 12:07:37 -0400", "message": "Add threadpool for critical operations on system indices (#72625)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "aa76ebbfbecf1c6c41921bab63b8d4cb5ca409a9", "committedDate": "2021-06-30 10:21:28 -0400", "message": "Set max allowed size for stored async response (#74455)"}, {"oid": "cdf67e0fd5cf044fc38549032a2cc87280292f58", "committedDate": "2021-07-08 15:33:41 -0700", "message": "Support search slicing with point-in-time (#74457)"}, {"oid": "3f77adcc664e57d79c02f5636565ad9f8d8bb601", "committedDate": "2021-07-27 11:08:09 +0100", "message": "Include reason in cancellation exceptions (#75332)"}, {"oid": "944b3f3b56caf910ab1730afe1114bd154e59ec6", "committedDate": "2021-07-27 19:40:40 +0100", "message": "Fix compiler warnings in :server - part 1 (#75708)"}, {"oid": "85fe2d52670a2777f805b99996adde9bb42e5a26", "committedDate": "2021-08-05 18:57:00 +0200", "message": "Remove Redundant ConcurrentHashMapLong (#76172)"}, {"oid": "ec40e08f90b19a941b25b2028795dfaeb94a2d8b", "committedDate": "2021-10-01 07:22:40 -1000", "message": "Interrupt aggregation reduce phase if the search task is cancelled (#71714)"}, {"oid": "7a7fffcb5a852561a473a022861ce5faec2725ee", "committedDate": "2021-10-04 11:49:16 -0400", "message": "[ML] Text/Log categorization multi-bucket aggregation (#71752)"}, {"oid": "f2ac26f385490eda9c15616498f33e1b0713b48a", "committedDate": "2021-10-14 09:00:52 +0200", "message": "Filter original indices in shard level request (#78508)"}, {"oid": "7ad7d7eccd047c40d0b1b63e63e00ef113450925", "committedDate": "2021-10-14 12:17:04 -0600", "message": "Add fleet search api to wait on refreshes (#73134)"}, {"oid": "13487b1ed6bf1fed605f1e3b9439fb3688a256c1", "committedDate": "2021-10-18 10:13:44 +0200", "message": "Node level can match action (#78765)"}, {"oid": "060976a9f9f9eff089a710f0437169b65b300c25", "committedDate": "2021-10-18 16:45:36 +0200", "message": "Don't always rewrite the Lucene query in search phases (#79358)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "fd185e4661ee61a99eeefe94d781839893c8bba2", "committedDate": "2021-12-07 11:37:47 -0500", "message": "Bring ReduceContext to top level class (#81394)"}, {"oid": "d9589cb3129e110105f3ccc6f3ade7a4724de7b6", "committedDate": "2022-01-24 12:10:09 -1000", "message": "Add support for in index order execution mode to aggregations (#82129)"}, {"oid": "051e1d6c3cc04f325703ca846dc84f58a0ece00e", "committedDate": "2022-01-27 15:22:49 +0100", "message": "Introduce flag for testing CCS compatibility (#81809)"}, {"oid": "6efc28bca03c4ba05172ed93dd9ceae7c38b892b", "committedDate": "2022-02-01 10:50:22 -0500", "message": "Plumb aggregation builder into reduce context (#81740)"}, {"oid": "898d84998b081d47ec6a9c2305f9bf4486d69be3", "committedDate": "2022-03-30 00:21:56 +0200", "message": "Make classes+methods that can be static static in many spots (#85370)"}, {"oid": "b2c9028384253416bd3e17de9e45af5eefe32764", "committedDate": "2022-04-19 21:26:28 -0700", "message": "Move io utils to core package (#85954)"}, {"oid": "f7bb5e02c50e2e981784fbf967c4531116be9dd4", "committedDate": "2022-10-04 08:45:16 -0400", "message": "Support profiling queries in Tracer (#90574)"}, {"oid": "e7bff7d9f9f8721b042cbd9e407475d29b6d2c33", "committedDate": "2022-10-06 13:00:22 -0700", "message": "Remove extra SearchService constructor (#90733)"}, {"oid": "2a44d3f40d7d7cff6c343881f49690a76eafb1a5", "committedDate": "2022-10-11 15:51:17 +0100", "message": "Separate fetch phase doc iteration and hit processing (#90754)"}, {"oid": "33c9636c4c49021cd634c7c5536aca64fe79b105", "committedDate": "2023-02-07 23:29:58 +0100", "message": "Release time series aggegations as tech preview (#93546)"}, {"oid": "86be0f0d6c7eb27f033328144ebc2deb85c53d97", "committedDate": "2023-03-20 14:24:43 -0400", "message": "Limit the resutls objects SearchContext creates (#94405)"}, {"oid": "431a7b2f533fc7a44e8c93151b0c201ffab86f79", "committedDate": "2023-03-30 10:19:39 +0100", "message": "Destringify APM tracer interface (#94864)"}, {"oid": "131da70321c1cef46a1f0659053cb7274eeae433", "committedDate": "2023-03-30 10:46:43 +0100", "message": "ValueFetchers now return a StoredFieldsSpec (#94820)"}, {"oid": "cb048855d77391192c4db6d91dd513fea6d28fda", "committedDate": "2023-04-20 09:22:57 -0400", "message": "Expand the lifecycle of the AggregationContext (#94023)"}, {"oid": "5314e5dd553da74696a74cd061ef4bcec9bf2a48", "committedDate": "2023-04-24 15:07:34 -0700", "message": "Add support for Reciprocal Rank Fusion to the search API (#93396)"}, {"oid": "2fc917265fd0a145ba587cc2b520785a8d45661c", "committedDate": "2023-04-28 15:02:03 +0200", "message": "Remove MultiBucketConsumer from AggregationContext (#95617)"}, {"oid": "61c446dca23b34962b2f3e64c3b9af3d90bcec5d", "committedDate": "2023-05-01 21:31:18 +0200", "message": "Simplify SearchService#ensureAfterSeqNoRefreshed (#95700)"}, {"oid": "73e5c25442706497d2b452c4ef2edadbd648a03d", "committedDate": "2023-05-08 11:22:02 +0200", "message": "fix: change visibility of SearchService#ResultsType to protected (#95671)"}, {"oid": "4192fdc1b654f9f5376a94a40ee456b3e6b25aff", "committedDate": "2023-05-17 00:01:53 +0200", "message": "Allow wait for future checkpoint when timeout is set (#96145)"}, {"oid": "b1a3dc6a172b635a9171614b8be5b468c3f98be4", "committedDate": "2023-05-22 16:32:08 +0200", "message": "Don't use SearchRequest to create an AggregationReduceContext builder (#96249)"}, {"oid": "414eda7b801372a3d1a98c9d25dd2bad4572abad", "committedDate": "2023-06-06 11:42:39 +0200", "message": "Cheaper ActionListener.wrap when error handler is the listener (#96575)"}, {"oid": "a732ecd78ade0f85c586800f9e3ffdf8f6e10f2d", "committedDate": "2023-06-09 15:13:58 +0200", "message": "Skip shards when querying constant keyword fields (#96161)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384556337", "body": "This implementation feels a bit awkward, I'd rather like to fork ExitableDirectoryReader entirely to not inherit from its QueryTimeout abstraction.", "bodyText": "This implementation feels a bit awkward, I'd rather like to fork ExitableDirectoryReader entirely to not inherit from its QueryTimeout abstraction.", "bodyHTML": "<p dir=\"auto\">This implementation feels a bit awkward, I'd rather like to fork ExitableDirectoryReader entirely to not inherit from its QueryTimeout abstraction.</p>", "author": "jpountz", "createdAt": "2020-02-26T15:13:21Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {\n+\n+        private final Cancellable checkCancelled;\n+\n+        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, checkCancelled);\n+                }\n+            });\n+            this.checkCancelled = checkCancelled;\n+        }\n+\n+        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n+            this.checkCancelled.setCancellable(checkCancelled);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a leaf reader with a cancellable task\n+     */\n+    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n+\n+        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n+            super(leafReader, checkCancelled);\n+        }\n+\n+        @Override\n+        public NumericDocValues getNumericDocValues(String field) throws IOException {\n+            return in.getNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n+            return in.getBinaryDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedDocValues getSortedDocValues(String field) throws IOException {\n+            return in.getSortedDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n+            return in.getSortedNumericDocValues(field);\n+        }\n+\n+        @Override\n+        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n+            return in.getSortedSetDocValues(field);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of {@link QueryTimeout} with a Runnable task.\n+     */\n+    private static class Cancellable implements QueryTimeout {\n+\n+        private Supplier<Runnable> cancellable;\n+\n+        public void setCancellable(Supplier<Runnable> cancellable) {\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public boolean shouldExit() {\n+            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n+            if (cancellable.get() == null) {\n+                return false;\n+            }\n+            cancellable.get().run();\n+            return false;\n+        }", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU5ODk2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384598966", "bodyText": "I tried that in the 1st approach but this means we have to copy the whole ExitablePointValues to wrap the point values and therefore the ExitableIntersectVisitor.", "author": "matriv", "createdAt": "2020-02-26T16:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1OTgxNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385159816", "bodyText": "I don't mind copying it.", "author": "jpountz", "createdAt": "2020-02-27T14:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjcxMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756710", "bodyText": "+1 to copy", "author": "jimczi", "createdAt": "2020-02-28T15:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NjMzNw=="}], "type": "inlineReview", "revised_code": {"commit": "ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..89cfae759d8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -425,8 +428,12 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (cancellable.get() == null) {\n                 return false;\n             }\n-            cancellable.get().run();\n-            return false;\n+            try {\n+                cancellable.get().run();\n+                return false;\n+            } catch (Exception e) {\n+                return true;\n+            }\n         }\n \n         @Override\n", "next_change": {"commit": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 89cfae759d8..88637512f8a 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -412,34 +421,41 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Implementation of {@link QueryTimeout} with a Runnable task.\n+     * Implementation of {@link QueryTimeout} with Runnable tasks.\n      */\n-    private static class Cancellable implements QueryTimeout {\n+    private static class DirReaderCancellable implements QueryTimeout {\n+\n+        private Runnable checkCancelled = null;\n+        private Runnable checkTimeout = null;\n+\n+        private void setCheckCancelled(Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+        }\n \n-        private Supplier<Runnable> cancellable;\n+        private void setCheckTimeout(Runnable checkTimeout) {\n+            this.checkTimeout = checkTimeout;\n+        }\n \n-        public void setCancellable(Supplier<Runnable> cancellable) {\n-            this.cancellable = cancellable;\n+        private void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n         }\n \n         @Override\n         public boolean shouldExit() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            if (cancellable.get() == null) {\n-                return false;\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n             }\n-            try {\n-                cancellable.get().run();\n-                return false;\n-            } catch (Exception e) {\n-                return true;\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n             }\n+            // Always return false and rely on checkCancelled or checkTimeout to throw\n+            // the appropriate exception\n+            return false;\n         }\n \n         @Override\n         public boolean isTimeoutEnabled() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            return cancellable.get() != null;\n+            return checkCancelled != null || checkTimeout != null;\n         }\n     }\n }\n", "next_change": {"commit": "331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 88637512f8a..312243a95b0 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -440,22 +443,177 @@ public class ContextIndexSearcher extends IndexSearcher {\n             this.checkTimeout = null;\n         }\n \n-        @Override\n-        public boolean shouldExit() {\n+        void checkCancelled() {\n             if (checkCancelled != null) {\n                 checkCancelled.run();\n             }\n             if (checkTimeout != null) {\n                 checkTimeout.run();\n             }\n-            // Always return false and rely on checkCancelled or checkTimeout to throw\n-            // the appropriate exception\n-            return false;\n         }\n \n-        @Override\n-        public boolean isTimeoutEnabled() {\n+        private boolean isEnabled() {\n             return checkCancelled != null || checkTimeout != null;\n         }\n     }\n+\n+    /**\n+     * Wrapper class for terms that check for query cancellation or timeout.\n+     */\n+    public static class ExitableTerms extends FilterLeafReader.FilterTerms {\n+\n+        private final DirReaderCancellable cancellable;\n+\n+        /** Constructor **/\n+        public ExitableTerms(Terms terms, DirReaderCancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for TermsEnum that is used by ExitableTerms for implementing an\n+     * exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterLeafReader.FilterTermsEnum {\n+\n+        private final DirReaderCancellable cancellable;\n+\n+        /** Constructor **/\n+        private ExitableTermsEnum(TermsEnum termsEnum, DirReaderCancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkCancelled();\n+            return in.next();\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for PointValues that checks for cancellation and timeout.\n+     */\n+    private static class ExitablePointValues extends PointValues {\n+\n+        private final PointValues in;\n+        private final DirReaderCancellable cancellable;\n+\n+        private ExitablePointValues(PointValues in, DirReaderCancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+            this.cancellable.checkCancelled();\n+        }\n+\n+        @Override\n+        public void intersect(IntersectVisitor visitor) throws IOException {\n+            cancellable.checkCancelled();\n+            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n+        }\n+\n+        @Override\n+        public long estimatePointCount(IntersectVisitor visitor) {\n+            cancellable.checkCancelled();\n+            return in.estimatePointCount(visitor);\n+        }\n+\n+        @Override\n+        public byte[] getMinPackedValue() throws IOException {\n+            cancellable.checkCancelled();\n+            return in.getMinPackedValue();\n+        }\n+\n+        @Override\n+        public byte[] getMaxPackedValue() throws IOException {\n+            cancellable.checkCancelled();\n+            return in.getMaxPackedValue();\n+        }\n+\n+        @Override\n+        public int getNumDimensions() throws IOException {\n+            cancellable.checkCancelled();\n+            return in.getNumDimensions();\n+        }\n+\n+        @Override\n+        public int getNumIndexDimensions() throws IOException {\n+            cancellable.checkCancelled();\n+            return in.getNumIndexDimensions();\n+        }\n+\n+        @Override\n+        public int getBytesPerDimension() throws IOException {\n+            cancellable.checkCancelled();\n+            return in.getBytesPerDimension();\n+        }\n+\n+        @Override\n+        public long size() {\n+            cancellable.checkCancelled();\n+            return in.size();\n+        }\n+\n+        @Override\n+        public int getDocCount() {\n+            cancellable.checkCancelled();\n+            return in.getDocCount();\n+        }\n+    }\n+\n+    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n+\n+        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n+\n+        private final PointValues.IntersectVisitor in;\n+        private final DirReaderCancellable cancellable;\n+        private int calls;\n+\n+        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, DirReaderCancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+        }\n+\n+        private void checkAndThrowWithSampling() {\n+            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n+                cancellable.checkCancelled();\n+            }\n+        }\n+\n+        @Override\n+        public void visit(int docID) throws IOException {\n+            checkAndThrowWithSampling();\n+            in.visit(docID);\n+        }\n+\n+        @Override\n+        public void visit(int docID, byte[] packedValue) throws IOException {\n+            checkAndThrowWithSampling();\n+            in.visit(docID, packedValue);\n+        }\n+\n+        @Override\n+        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+            cancellable.checkCancelled();\n+            return in.compare(minPackedValue, maxPackedValue);\n+        }\n+\n+        @Override\n+        public void grow(int count) {\n+            cancellable.checkCancelled();\n+            in.grow(count);\n+        }\n+    }\n }\n", "next_change": {"commit": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 312243a95b0..9f4e5edc5bf 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -606,13 +611,13 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         @Override\n         public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n+            cancellable.checkDirReaderCancelled();\n             return in.compare(minPackedValue, maxPackedValue);\n         }\n \n         @Override\n         public void grow(int count) {\n-            cancellable.checkCancelled();\n+            cancellable.checkDirReaderCancelled();\n             in.grow(count);\n         }\n     }\n", "next_change": {"commit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 9f4e5edc5bf..e7317af8920 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -611,13 +597,13 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         @Override\n         public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n+            cancellable.checkCancelled();\n             return in.compare(minPackedValue, maxPackedValue);\n         }\n \n         @Override\n         public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n+            cancellable.checkCancelled();\n             in.grow(count);\n         }\n     }\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n+            return action;\n         }\n \n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -341,98 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n-     */\n-    private static class CancellableIndexReader extends FilterDirectoryReader {\n-\n-        private final Cancellable checkCancelled;\n-\n-        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, checkCancelled);\n-                }\n-            });\n-            this.checkCancelled = checkCancelled;\n-        }\n-\n-        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n-            this.checkCancelled.setCancellable(checkCancelled);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-    /**\n-     * Wraps a leaf reader with a cancellable task\n-     */\n-    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n-\n-        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n-            super(leafReader, checkCancelled);\n-        }\n-\n-        @Override\n-        public NumericDocValues getNumericDocValues(String field) throws IOException {\n-            return in.getNumericDocValues(field);\n-        }\n-\n-        @Override\n-        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n-            return in.getBinaryDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedDocValues getSortedDocValues(String field) throws IOException {\n-            return in.getSortedDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n-            return in.getSortedNumericDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n-            return in.getSortedSetDocValues(field);\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n+            }\n+            return action;\n         }\n-    }\n-\n-    /**\n-     * Implementation of {@link QueryTimeout} with a Runnable task.\n-     */\n-    private static class Cancellable implements QueryTimeout {\n-\n-        private Supplier<Runnable> cancellable;\n \n-        public void setCancellable(Supplier<Runnable> cancellable) {\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public boolean shouldExit() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            if (cancellable.get() == null) {\n-                return false;\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n-            cancellable.get().run();\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            return cancellable.get() != null;\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzgzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384557839", "body": "use try-with-resources?", "bodyText": "use try-with-resources?", "bodyHTML": "<p dir=\"auto\">use try-with-resources?</p>", "author": "jpountz", "createdAt": "2020-02-26T15:15:24Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -62,13 +61,19 @@ public void testEmpty() throws IOException {\n                 .method(PercentilesMethod.TDIGEST);\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n         fieldType.setName(\"field\");\n-        try (IndexReader reader = new MultiReader()) {\n+\n+        Directory directory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n+        try (IndexReader reader = unmappedIndexWriter.getReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n             PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n             assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n+        } finally {\n+            unmappedIndexWriter.close();\n+            directory.close();", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 047a288250e..001736d49c9 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -62,18 +62,17 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n         fieldType.setName(\"field\");\n \n-        Directory directory = newDirectory();\n-        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n-        try (IndexReader reader = unmappedIndexWriter.getReader()) {\n+\n+\n+        try (Directory directory = newDirectory();\n+             RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n+             IndexReader reader = unmappedIndexWriter.getReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n             PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n             assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n-        } finally {\n-            unmappedIndexWriter.close();\n-            directory.close();\n         }\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 047a288250e..420c9b8cecb 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -61,19 +62,13 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n                 .method(PercentilesMethod.TDIGEST);\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n         fieldType.setName(\"field\");\n-\n-        Directory directory = newDirectory();\n-        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), directory);\n-        try (IndexReader reader = unmappedIndexWriter.getReader()) {\n+        try (IndexReader reader = new MultiReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n             PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n             assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n-        } finally {\n-            unmappedIndexWriter.close();\n-            directory.close();\n         }\n     }\n \n", "next_change": {"commit": "5de0ed9432f4b41b697c9f3bc28953834cd3eae1", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 420c9b8cecb..3d2acaff284 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -53,18 +53,19 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n \n     @Override\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n-        return List.of(CoreValuesSourceType.NUMERIC);\n+        return List.of(CoreValuesSourceType.NUMERIC,\n+            CoreValuesSourceType.DATE,\n+            CoreValuesSourceType.BOOLEAN);\n     }\n \n     public void testEmpty() throws IOException {\n         PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[]{0.5})\n                 .field(\"field\")\n                 .method(PercentilesMethod.TDIGEST);\n-        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE);\n-        fieldType.setName(\"field\");\n+        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n         try (IndexReader reader = new MultiReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n-            PercentileRanks ranks = search(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n+            PercentileRanks ranks = searchAndReduce(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n", "next_change": {"commit": "d71544976608bdb53fa4d29521fb328e1033ee2f", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 3d2acaff284..6b99e20f4a3 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -41,27 +30,22 @@ import java.io.IOException;\n import java.util.Iterator;\n import java.util.List;\n \n-\n public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n \n     @Override\n     protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n-        return new PercentileRanksAggregationBuilder(\"tdigest_ranks\", new double[]{0.1, 0.5, 12})\n-            .field(fieldName)\n+        return new PercentileRanksAggregationBuilder(\"tdigest_ranks\", new double[] { 0.1, 0.5, 12 }).field(fieldName)\n             .percentilesConfig(new PercentilesConfig.TDigest());\n     }\n \n     @Override\n     protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n-        return List.of(CoreValuesSourceType.NUMERIC,\n-            CoreValuesSourceType.DATE,\n-            CoreValuesSourceType.BOOLEAN);\n+        return List.of(CoreValuesSourceType.NUMERIC, CoreValuesSourceType.DATE, CoreValuesSourceType.BOOLEAN);\n     }\n \n     public void testEmpty() throws IOException {\n-        PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[]{0.5})\n-                .field(\"field\")\n-                .method(PercentilesMethod.TDIGEST);\n+        PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[] { 0.5 }).field(\"field\")\n+            .method(PercentilesMethod.TDIGEST);\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n         try (IndexReader reader = new MultiReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n", "next_change": {"commit": "15932d5168030da53a3530c08dc2f86b9ea3fe4a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 6b99e20f4a3..991ef235495 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -49,7 +48,7 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n         try (IndexReader reader = new MultiReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n-            PercentileRanks ranks = searchAndReduce(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n+            PercentileRanks ranks = searchAndReduce(new AggTestConfig(searcher, aggBuilder, fieldType));\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n", "next_change": {"commit": "4a26dda50c947a15d4e4a234a390f4e140573b95", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 991ef235495..c2816c87237 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -48,7 +48,7 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n         try (IndexReader reader = new MultiReader()) {\n             IndexSearcher searcher = new IndexSearcher(reader);\n-            PercentileRanks ranks = searchAndReduce(new AggTestConfig(searcher, aggBuilder, fieldType));\n+            PercentileRanks ranks = searchAndReduce(searcher, new AggTestConfig(aggBuilder, fieldType));\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n", "next_change": null}]}}]}}, {"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 3d2acaff284..6b99e20f4a3 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -69,22 +53,21 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n             Percentile rank = ranks.iterator().next();\n             assertEquals(Double.NaN, rank.getPercent(), 0d);\n             assertEquals(0.5, rank.getValue(), 0d);\n-            assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks)ranks)));\n+            assertFalse(AggregationInspectionHelper.hasValue(((InternalTDigestPercentileRanks) ranks)));\n         }\n     }\n \n     public void testSimple() throws IOException {\n-        try (Directory dir = newDirectory();\n-                RandomIndexWriter w = new RandomIndexWriter(random(), dir)) {\n-            for (double value : new double[] {3, 0.2, 10}) {\n+        try (Directory dir = newDirectory(); RandomIndexWriter w = new RandomIndexWriter(random(), dir)) {\n+            for (double value : new double[] { 3, 0.2, 10 }) {\n                 Document doc = new Document();\n                 doc.add(new SortedNumericDocValuesField(\"field\", NumericUtils.doubleToSortableLong(value)));\n                 w.addDocument(doc);\n             }\n \n-            PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[]{0.1, 0.5, 12})\n-                    .field(\"field\")\n-                    .method(PercentilesMethod.TDIGEST);\n+            PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[] { 0.1, 0.5, 12 })\n+                .field(\"field\")\n+                .method(PercentilesMethod.TDIGEST);\n             MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n             try (IndexReader reader = w.getReader()) {\n                 IndexSearcher searcher = new IndexSearcher(reader);\n", "next_change": {"commit": "15932d5168030da53a3530c08dc2f86b9ea3fe4a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 6b99e20f4a3..991ef235495 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -71,7 +70,7 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n             MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n             try (IndexReader reader = w.getReader()) {\n                 IndexSearcher searcher = new IndexSearcher(reader);\n-                PercentileRanks ranks = searchAndReduce(searcher, new MatchAllDocsQuery(), aggBuilder, fieldType);\n+                PercentileRanks ranks = searchAndReduce(new AggTestConfig(searcher, aggBuilder, fieldType));\n                 Iterator<Percentile> rankIterator = ranks.iterator();\n                 Percentile rank = rankIterator.next();\n                 assertEquals(0.1, rank.getValue(), 0d);\n", "next_change": {"commit": "4a26dda50c947a15d4e4a234a390f4e140573b95", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 991ef235495..c2816c87237 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -70,7 +70,7 @@ public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n             MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE);\n             try (IndexReader reader = w.getReader()) {\n                 IndexSearcher searcher = new IndexSearcher(reader);\n-                PercentileRanks ranks = searchAndReduce(new AggTestConfig(searcher, aggBuilder, fieldType));\n+                PercentileRanks ranks = searchAndReduce(searcher, new AggTestConfig(aggBuilder, fieldType));\n                 Iterator<Percentile> rankIterator = ranks.iterator();\n                 Percentile rank = rankIterator.next();\n                 assertEquals(0.1, rank.getValue(), 0d);\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "a90c1de8745681356a6516f4f22a8c40f71f6b12", "committedDate": "2020-03-26 15:01:07 -0400", "message": "Add ValuesSource Registry and associated logic (#54281)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "5de0ed9432f4b41b697c9f3bc28953834cd3eae1", "committedDate": "2020-08-06 14:08:26 +0200", "message": "Replace AggregatorTestCase#search with AggregatorTestCase#searchAndReduce (#60683)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "d71544976608bdb53fa4d29521fb328e1033ee2f", "committedDate": "2021-08-30 13:42:20 -0400", "message": "Apply spotless to aggregations (#76682)"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "15932d5168030da53a3530c08dc2f86b9ea3fe4a", "committedDate": "2022-09-20 14:58:24 -0400", "message": "Refactor aggregator test case (#90149)"}, {"oid": "4a26dda50c947a15d4e4a234a390f4e140573b95", "committedDate": "2022-10-06 13:33:57 -0400", "message": "Use the AggTestConfig object in testCase (#90699)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTU0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384559546", "body": "CancellableIndexReader shouldn't have any overhead, so it might be simpler to wrap all the time here.", "bodyText": "CancellableIndexReader shouldn't have any overhead, so it might be simpler to wrap all the time here.", "bodyHTML": "<p dir=\"auto\">CancellableIndexReader shouldn't have any overhead, so it might be simpler to wrap all the time here.</p>", "author": "jpountz", "createdAt": "2020-02-26T15:17:49Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -79,8 +89,18 @@\n     private QueryProfiler profiler;\n     private Runnable checkCancelled;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+    }\n+\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                boolean shouldWrap) throws IOException {\n+        super(shouldWrap? new CancellableIndexReader((DirectoryReader) reader, new Cancellable()) : reader);", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwMjUwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384602509", "bodyText": "This boolean was added together with a second constructor because of the AggregatorTestCase and hundreds of tests that derive from that. If we wrap the IndexReader we get:\njava.lang.AssertionError: The top-reader used to create Weight is not the same as the current reader's top-reader (org.apache.lucene.index.CompositeReaderContext@382edaaa\n\nwhich I tried to fix by changing the AggregatorTestCase to receive IndexReader and not IndexSearcher as an argument. and all the tests to use the derived IndexSearcher from the context created. But even with this there were a few more tests failing that didn't manage to fix, so after discussion with @jimczi we decided to make this workaround for the moment and address the issue in a separate PR afterwards.\nI can add a TODO though to not miss it.", "author": "matriv", "createdAt": "2020-02-26T16:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1OTU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..b1d84f27d25 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -94,12 +94,15 @@ public class ContextIndexSearcher extends IndexSearcher {\n         this(reader, similarity, queryCache, queryCachingPolicy, true);\n     }\n \n+    // TODO: Remove the 2nd constructor and the shouldWrap so that we always wrap the IndexReader.\n+    // Some issues must be fixed regarding tests deriving from AggregatorTestCase and more specifically\n+    // the use of searchAndReduce and the ShardSearcher sub-searchers.\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n                                 boolean shouldWrap) throws IOException {\n-        super(shouldWrap? new CancellableIndexReader((DirectoryReader) reader, new Cancellable()) : reader);\n+        super(shouldWrap? new CancellableDirectoryReader((DirectoryReader) reader, new Cancellable()) : reader);\n         if (shouldWrap) {\n-            ((CancellableIndexReader) getIndexReader()).setCheckCancelled(() -> checkCancelled);\n+            ((CancellableDirectoryReader) getIndexReader()).setCheckCancelled(() -> checkCancelled);\n         }\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n", "next_change": {"commit": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex b1d84f27d25..88637512f8a 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -88,22 +87,22 @@ public class ContextIndexSearcher extends IndexSearcher {\n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n     private Runnable checkCancelled;\n+    private Runnable checkTimeout;\n+    private DirReaderCancellable dirReaderCancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+        this(reader, similarity, queryCache, queryCachingPolicy, new DirReaderCancellable());\n     }\n \n-    // TODO: Remove the 2nd constructor and the shouldWrap so that we always wrap the IndexReader.\n+    // TODO: Make the 2nd constructor private so that the dirCancellable is never null and the IndexReader is always wrapped.\n     // Some issues must be fixed regarding tests deriving from AggregatorTestCase and more specifically\n     // the use of searchAndReduce and the ShardSearcher sub-searchers.\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean shouldWrap) throws IOException {\n-        super(shouldWrap? new CancellableDirectoryReader((DirectoryReader) reader, new Cancellable()) : reader);\n-        if (shouldWrap) {\n-            ((CancellableDirectoryReader) getIndexReader()).setCheckCancelled(() -> checkCancelled);\n-        }\n+                                DirReaderCancellable dirReaderCancellable) throws IOException {\n+        super(dirReaderCancellable != null? new CancellableDirectoryReader((DirectoryReader) reader, dirReaderCancellable) : reader);\n+        this.dirReaderCancellable = dirReaderCancellable;\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n", "next_change": {"commit": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 88637512f8a..9f4e5edc5bf 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -100,9 +98,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n     // the use of searchAndReduce and the ShardSearcher sub-searchers.\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                DirReaderCancellable dirReaderCancellable) throws IOException {\n-        super(dirReaderCancellable != null? new CancellableDirectoryReader((DirectoryReader) reader, dirReaderCancellable) : reader);\n-        this.dirReaderCancellable = dirReaderCancellable;\n+                                Holder<Cancellable> cancellable) throws IOException {\n+        super(cancellable!= null? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n+        this.cancellable = cancellable;\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n", "next_change": {"commit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 9f4e5edc5bf..570dbebb6ea 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -90,17 +93,23 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new Holder<>(null));\n+        this(reader, similarity, queryCache, queryCachingPolicy, new Holder<>(new CancellableImpl()));\n     }\n \n     // TODO: Make the 2nd constructor private so that the dirCancellable is never null and the IndexReader is always wrapped.\n-    // Some issues must be fixed regarding tests deriving from AggregatorTestCase and more specifically\n-    // the use of searchAndReduce and the ShardSearcher sub-searchers.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n                                 Holder<Cancellable> cancellable) throws IOException {\n-        super(cancellable!= null? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n-        this.cancellable = cancellable;\n+        super(cancellable != null ? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n+        if (cancellable == null) {\n+            this.cancellable = new Holder<>(new CancellableImpl());\n+        } else {\n+            this.cancellable = cancellable;\n+        }\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -89,27 +90,22 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Holder<Cancellable> cancellable;\n+    private QueryCancellable cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new Holder<>(new CancellableImpl()));\n+        this(reader, similarity, queryCache, queryCachingPolicy, true);\n     }\n \n-    // TODO: Make the 2nd constructor private so that the dirCancellable is never null and the IndexReader is always wrapped.\n+    // TODO: Remove the 2nd constructor so that the IndexReader is always wrapped.\n     // Some issues must be fixed:\n     //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n     //     the ShardSearcher sub-searchers.\n     //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                Holder<Cancellable> cancellable) throws IOException {\n-        super(cancellable != null ? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n-        if (cancellable == null) {\n-            this.cancellable = new Holder<>(new CancellableImpl());\n-        } else {\n-            this.cancellable = cancellable;\n-        }\n+                                boolean shouldWrap) throws IOException {\n+        super(shouldWrap ? new CancellableDirectoryReader((DirectoryReader) reader, new Holder<>(null)) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -90,25 +80,26 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private QueryCancellable cancellable;\n+    private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n     }\n \n-    // TODO: Remove the 2nd constructor so that the IndexReader is always wrapped.\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n     // Some issues must be fixed:\n     //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n     //     the ShardSearcher sub-searchers.\n     //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean shouldWrap) throws IOException {\n-        super(shouldWrap ? new CancellableDirectoryReader((DirectoryReader) reader, new Holder<>(null)) : reader);\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..ecdb43bbcc6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -107,14 +107,18 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n         return this.cancellable.add(action);\n     }\n \n-    public void removeQueryTimeout(Runnable action) {\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n     }\n \n", "next_change": {"commit": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -116,7 +115,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     /**\n      * Remove a {@link Runnable} that checks for query cancellation or timeout\n-     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n      */\n     public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -87,23 +79,26 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n     }\n \n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean shouldWrap) throws IOException {\n-        super(shouldWrap? new CancellableIndexReader((DirectoryReader) reader, new Cancellable()) : reader);\n-        if (shouldWrap) {\n-            ((CancellableIndexReader) getIndexReader()).setCheckCancelled(() -> checkCancelled);\n-        }\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..ed41939b1cb 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -82,23 +82,20 @@ public class ContextIndexSearcher extends IndexSearcher {\n     private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                boolean wrapWithExitableDirectoryReader) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader);\n     }\n \n-    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n-    // Some issues must be fixed:\n-    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n-    //     the ShardSearcher sub-searchers.\n-    //   - tests that use a MultiReader\n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                MutableQueryTimeout cancellable) throws IOException {\n-        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n+    private ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                 MutableQueryTimeout cancellable,\n+                                 boolean wrapWithExitableDirectoryReader) throws IOException {\n+        super(wrapWithExitableDirectoryReader ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n-        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n+        this.cancellable = cancellable;\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ed41939b1cb..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -36,66 +26,97 @@ import org.apache.lucene.search.LeafCollector;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.QueryCache;\n import org.apache.lucene.search.QueryCachingPolicy;\n-import org.apache.lucene.search.ScoreDoc;\n import org.apache.lucene.search.ScoreMode;\n import org.apache.lucene.search.Scorer;\n import org.apache.lucene.search.TermStatistics;\n-import org.apache.lucene.search.TopFieldDocs;\n-import org.apache.lucene.search.TotalHits;\n import org.apache.lucene.search.Weight;\n import org.apache.lucene.search.similarities.Similarity;\n import org.apache.lucene.util.BitSet;\n import org.apache.lucene.util.BitSetIterator;\n import org.apache.lucene.util.Bits;\n-import org.apache.lucene.util.CombinedBitSet;\n import org.apache.lucene.util.SparseFixedBitSet;\n-import org.elasticsearch.common.lucene.search.TopDocsAndMaxScore;\n-import org.elasticsearch.search.DocValueFormat;\n+import org.apache.lucene.util.ThreadInterruptedException;\n+import org.elasticsearch.core.Releasable;\n+import org.elasticsearch.lucene.util.CombinedBitSet;\n import org.elasticsearch.search.dfs.AggregatedDfs;\n import org.elasticsearch.search.profile.Timer;\n import org.elasticsearch.search.profile.query.ProfileWeight;\n import org.elasticsearch.search.profile.query.QueryProfileBreakdown;\n import org.elasticsearch.search.profile.query.QueryProfiler;\n import org.elasticsearch.search.profile.query.QueryTimingType;\n-import org.elasticsearch.search.query.QuerySearchResult;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadPoolExecutor;\n \n /**\n  * Context-aware extension of {@link IndexSearcher}.\n  */\n-public class ContextIndexSearcher extends IndexSearcher {\n+public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n     /**\n      * The interval at which we check for search cancellation when we cannot use\n      * a {@link CancellableBulkScorer}. See {@link #intersectScorerAndBitSet}.\n      */\n-    private static int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n+    private static final int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private MutableQueryTimeout cancellable;\n+    private final MutableQueryTimeout cancellable;\n+\n+    private final QueueSizeBasedExecutor queueSizeBasedExecutor;\n+    private final LeafSlice[] leafSlices;\n+\n+    /** constructor for non-concurrent search */\n+    public ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        boolean wrapWithExitableDirectoryReader\n+    ) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader, null);\n+    }\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean wrapWithExitableDirectoryReader) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader);\n+    /** constructor for concurrent search */\n+    public ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        boolean wrapWithExitableDirectoryReader,\n+        ThreadPoolExecutor executor\n+    ) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader, executor);\n     }\n \n-    private ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                 MutableQueryTimeout cancellable,\n-                                 boolean wrapWithExitableDirectoryReader) throws IOException {\n+    private ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        MutableQueryTimeout cancellable,\n+        boolean wrapWithExitableDirectoryReader,\n+        ThreadPoolExecutor executor\n+    ) throws IOException {\n+        // concurrency is handle in this class so don't pass the executor to the parent class\n         super(wrapWithExitableDirectoryReader ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n         this.cancellable = cancellable;\n+        this.queueSizeBasedExecutor = executor != null ? new QueueSizeBasedExecutor(executor) : null;\n+        this.leafSlices = executor == null ? null : slices(leafContexts);\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MDAyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r384560025", "body": "Let's call it `CancellableDirectoryReader` if it extends DirectoryReader.", "bodyText": "Let's call it CancellableDirectoryReader if it extends DirectoryReader.", "bodyHTML": "<p dir=\"auto\">Let's call it <code>CancellableDirectoryReader</code> if it extends DirectoryReader.</p>", "author": "jpountz", "createdAt": "2020-02-26T15:18:26Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +340,99 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n+     */\n+    private static class CancellableIndexReader extends FilterDirectoryReader {", "originalCommit": "e2ebfb48fab5d86de9137dfe624967c078cd88bf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..b1d84f27d25 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -344,11 +347,11 @@ public class ContextIndexSearcher extends IndexSearcher {\n     /**\n      * Wraps an {@link IndexReader} with a cancellation Runnable task.\n      */\n-    private static class CancellableIndexReader extends FilterDirectoryReader {\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n \n         private final Cancellable checkCancelled;\n \n-        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+        private CancellableDirectoryReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n             super(in, new SubReaderWrapper() {\n                 @Override\n                 public LeafReader wrap(LeafReader reader) {\n", "next_change": {"commit": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex b1d84f27d25..88637512f8a 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -349,20 +365,13 @@ public class ContextIndexSearcher extends IndexSearcher {\n      */\n     private static class CancellableDirectoryReader extends FilterDirectoryReader {\n \n-        private final Cancellable checkCancelled;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n+        private CancellableDirectoryReader(DirectoryReader in, DirReaderCancellable cancellable) throws IOException {\n             super(in, new SubReaderWrapper() {\n                 @Override\n                 public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, checkCancelled);\n+                    return new CancellableLeafReader(reader, cancellable);\n                 }\n             });\n-            this.checkCancelled = checkCancelled;\n-        }\n-\n-        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n-            this.checkCancelled.setCancellable(checkCancelled);\n         }\n \n         @Override\n", "next_change": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 88637512f8a..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -376,7 +412,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         @Override\n         protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n         }\n \n         @Override\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -349,297 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements QueryCancellable {\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n+            return action;\n         }\n \n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n-            }\n-        }\n-\n-        @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n+            return false;\n         }\n \n         @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e949ce9b2ce..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -341,98 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * Wraps an {@link IndexReader} with a cancellation Runnable task.\n-     */\n-    private static class CancellableIndexReader extends FilterDirectoryReader {\n-\n-        private final Cancellable checkCancelled;\n-\n-        private CancellableIndexReader(DirectoryReader in, Cancellable checkCancelled) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, checkCancelled);\n-                }\n-            });\n-            this.checkCancelled = checkCancelled;\n-        }\n-\n-        private void setCheckCancelled(Supplier<Runnable> checkCancelled) {\n-            this.checkCancelled.setCancellable(checkCancelled);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-    /**\n-     * Wraps a leaf reader with a cancellable task\n-     */\n-    private static class CancellableLeafReader extends ExitableDirectoryReader.ExitableFilterAtomicReader {\n-\n-        private CancellableLeafReader(LeafReader leafReader, Cancellable checkCancelled)  {\n-            super(leafReader, checkCancelled);\n-        }\n-\n-        @Override\n-        public NumericDocValues getNumericDocValues(String field) throws IOException {\n-            return in.getNumericDocValues(field);\n-        }\n-\n-        @Override\n-        public BinaryDocValues getBinaryDocValues(String field) throws IOException {\n-            return in.getBinaryDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedDocValues getSortedDocValues(String field) throws IOException {\n-            return in.getSortedDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedNumericDocValues getSortedNumericDocValues(String field) throws IOException {\n-            return in.getSortedNumericDocValues(field);\n-        }\n-\n-        @Override\n-        public SortedSetDocValues getSortedSetDocValues(String field) throws IOException {\n-            return in.getSortedSetDocValues(field);\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n+            }\n+            return action;\n         }\n-    }\n-\n-    /**\n-     * Implementation of {@link QueryTimeout} with a Runnable task.\n-     */\n-    private static class Cancellable implements QueryTimeout {\n-\n-        private Supplier<Runnable> cancellable;\n \n-        public void setCancellable(Supplier<Runnable> cancellable) {\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public boolean shouldExit() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            if (cancellable.get() == null) {\n-                return false;\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n-            cancellable.get().run();\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n-            assert cancellable != null : \"checkCancelled must be set immediately after the construction of CancellableIndexReader\";\n-            return cancellable.get() != null;\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "c8901426c48505594b333392bc7d41008644f11e", "url": "https://github.com/elastic/elasticsearch/commit/c8901426c48505594b333392bc7d41008644f11e", "message": "fix compilation", "committedDate": "2020-02-26T15:49:41Z", "type": "commit"}, {"oid": "e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "url": "https://github.com/elastic/elasticsearch/commit/e38cfa0b5dc885e6540d0433138fa0a8cc796bfe", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-26T16:10:27Z", "type": "commit"}, {"oid": "73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "url": "https://github.com/elastic/elasticsearch/commit/73b0e6d0a4cba0871eb0e941425b0f25d43efa7e", "message": "Address comments", "committedDate": "2020-02-26T16:20:54Z", "type": "commit"}, {"oid": "ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "url": "https://github.com/elastic/elasticsearch/commit/ffdf6d2008be37ffd588df5f5648d0794ae9b5a8", "message": "Fix behaviour by properly handling cancellable.run()", "committedDate": "2020-02-26T16:44:09Z", "type": "commit"}, {"oid": "add7dd448fb6c219ab3788c338ab169b7716d2a4", "url": "https://github.com/elastic/elasticsearch/commit/add7dd448fb6c219ab3788c338ab169b7716d2a4", "message": "split query timeout and cancellation to be able to unset query timeout", "committedDate": "2020-02-27T17:07:22Z", "type": "commit"}, {"oid": "d74edb27f06729b1f299c20b6b5d19284c012578", "url": "https://github.com/elastic/elasticsearch/commit/d74edb27f06729b1f299c20b6b5d19284c012578", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-27T17:07:34Z", "type": "commit"}, {"oid": "331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "url": "https://github.com/elastic/elasticsearch/commit/331411be33e0e2b1bbfad1c6aad03d5af5548b8a", "message": "Custom implementation of ExitableDirReader to overcome casting", "committedDate": "2020-02-27T21:45:40Z", "type": "commit"}, {"oid": "d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "url": "https://github.com/elastic/elasticsearch/commit/d10c51a9ea4ca8d2e2813b0c854f679ad8cc3dc8", "message": "revert changes", "committedDate": "2020-02-27T22:18:03Z", "type": "commit"}, {"oid": "e5fdf477933856da0877b81737c1d77640d01d54", "url": "https://github.com/elastic/elasticsearch/commit/e5fdf477933856da0877b81737c1d77640d01d54", "message": "revert", "committedDate": "2020-02-27T22:20:34Z", "type": "commit"}, {"oid": "248ee5159f39ad7e00dde8490407c6ce858e12d2", "url": "https://github.com/elastic/elasticsearch/commit/248ee5159f39ad7e00dde8490407c6ce858e12d2", "message": "revert unrelated changes", "committedDate": "2020-02-27T22:35:58Z", "type": "commit"}, {"oid": "bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "url": "https://github.com/elastic/elasticsearch/commit/bc8519367323b9a0ce4c2bf98c6df17bd0aee0cb", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-02-27T22:36:10Z", "type": "commit"}, {"oid": "ce2d557d56d860402220bb64cfbca16c100eef25", "url": "https://github.com/elastic/elasticsearch/commit/ce2d557d56d860402220bb64cfbca16c100eef25", "message": "Fix issues after splitting to cancelation and timeout", "committedDate": "2020-02-28T02:08:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385577015", "body": "Why do we need to do this?", "bodyText": "Why do we need to do this?", "bodyHTML": "<p dir=\"auto\">Why do we need to do this?</p>", "author": "jpountz", "createdAt": "2020-02-28T09:00:20Z", "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -310,6 +297,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                 queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n             }\n+            // Search phase has finished, no longer need to check for timeout\n+            searcher.unsetCheckTimeout();", "originalCommit": "ce2d557d56d860402220bb64cfbca16c100eef25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4NjQ4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385686480", "bodyText": "So that we don't experience a timeout during the aggregation phase. (there were integ tests that were failing because of this). I changed the comment to mention it.", "author": "matriv", "createdAt": "2020-02-28T13:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NzIwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757209", "bodyText": "We should do this on the cancellable object directly. The searcher shouldn't be able to unset this way. See my comment on the context searcher.", "author": "jimczi", "createdAt": "2020-02-28T15:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU3NzAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 167a56a19d4..2d1c6bc173b 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -298,6 +298,7 @@ public class QueryPhase implements SearchPhase {\n                 queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n             }\n             // Search phase has finished, no longer need to check for timeout\n+            // otherwise aggregation phase might get cancelled.\n             searcher.unsetCheckTimeout();\n             return shouldRescore;\n         } catch (Exception e) {\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 2d1c6bc173b..83cd38de17f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -299,7 +301,7 @@ public class QueryPhase implements SearchPhase {\n             }\n             // Search phase has finished, no longer need to check for timeout\n             // otherwise aggregation phase might get cancelled.\n-            searcher.unsetCheckTimeout();\n+            cancellable.unsetCheckTimeout();\n             return shouldRescore;\n         } catch (Exception e) {\n             throw new QueryPhaseExecutionException(searchContext.shardTarget(), \"Failed to execute main query\", e);\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 83cd38de17f..5691af384a9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -255,54 +254,58 @@ public class QueryPhase implements SearchPhase {\n                 final long startTime = searchContext.getRelativeTimeInMillis();\n                 final long timeout = searchContext.timeout().millis();\n                 final long maxTime = startTime + timeout;\n-                timeoutRunnable = () -> {\n+                timeoutRunnable = searcher.addQueryCancellation(() -> {\n                     final long time = searchContext.getRelativeTimeInMillis();\n                     if (time > maxTime) {\n                         throw new TimeExceededException();\n                     }\n-                };\n+                });\n             } else {\n                 timeoutRunnable = null;\n             }\n \n-            final Runnable cancellationRunnable;\n             if (searchContext.lowLevelCancellation()) {\n                 SearchShardTask task = searchContext.getTask();\n-                cancellationRunnable = () -> { if (task.isCancelled()) throw new TaskCancelledException(\"cancelled\"); };\n-            } else {\n-                cancellationRunnable = null;\n+                searcher.addQueryCancellation(() -> {\n+                    if (task.isCancelled()) {\n+                        throw new TaskCancelledException(\"cancelled\");\n+                    }\n+                });\n             }\n \n-            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);\n-            searcher.setCancellable(cancellable);\n+            try {\n+                boolean shouldRescore;\n+                // if we are optimizing sort and there are no other collectors\n+                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n+                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n+                } else {\n+                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n+                }\n \n-            boolean shouldRescore;\n-            // if we are optimizing sort and there are no other collectors\n-            if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-            } else {\n-                shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-            }\n+                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n+                if (sortAndFormatsForRewrittenNumericSort != null) {\n+                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n+                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n+                }\n \n-            // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-            if (sortAndFormatsForRewrittenNumericSort != null) {\n-                searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-            }\n+                ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n+                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n+                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n+                    EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n+                    queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n+                    queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                }\n \n-            ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-            assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n-            if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n-                EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n-                queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n-                queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                return shouldRescore;\n+            } finally {\n+                // Search phase has finished, no longer need to check for timeout\n+                // otherwise aggregation phase might get cancelled.\n+                if (timeoutRunnable != null) {\n+                   searcher.removeQueryTimeout(timeoutRunnable);\n+                }\n             }\n-            // Search phase has finished, no longer need to check for timeout\n-            // otherwise aggregation phase might get cancelled.\n-            cancellable.unsetCheckTimeout();\n-            return shouldRescore;\n         } catch (Exception e) {\n             throw new QueryPhaseExecutionException(searchContext.shardTarget(), \"Failed to execute main query\", e);\n         }\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 5691af384a9..4383f0eb545 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -303,7 +303,7 @@ public class QueryPhase implements SearchPhase {\n                 // Search phase has finished, no longer need to check for timeout\n                 // otherwise aggregation phase might get cancelled.\n                 if (timeoutRunnable != null) {\n-                   searcher.removeQueryTimeout(timeoutRunnable);\n+                   searcher.removeQueryCancellation(timeoutRunnable);\n                 }\n             }\n         } catch (Exception e) {\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 167a56a19d4..4383f0eb545 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -254,52 +254,58 @@ public class QueryPhase implements SearchPhase {\n                 final long startTime = searchContext.getRelativeTimeInMillis();\n                 final long timeout = searchContext.timeout().millis();\n                 final long maxTime = startTime + timeout;\n-                timeoutRunnable = () -> {\n+                timeoutRunnable = searcher.addQueryCancellation(() -> {\n                     final long time = searchContext.getRelativeTimeInMillis();\n                     if (time > maxTime) {\n                         throw new TimeExceededException();\n                     }\n-                };\n+                });\n             } else {\n                 timeoutRunnable = null;\n             }\n-            searcher.setCheckTimeout(timeoutRunnable);\n \n-            final Runnable cancellationRunnable;\n             if (searchContext.lowLevelCancellation()) {\n                 SearchShardTask task = searchContext.getTask();\n-                cancellationRunnable = () -> { if (task.isCancelled()) throw new TaskCancelledException(\"cancelled\"); };\n-            } else {\n-                cancellationRunnable = null;\n+                searcher.addQueryCancellation(() -> {\n+                    if (task.isCancelled()) {\n+                        throw new TaskCancelledException(\"cancelled\");\n+                    }\n+                });\n             }\n-            searcher.setCheckCancelled(cancellationRunnable);\n \n-            boolean shouldRescore;\n-            // if we are optimizing sort and there are no other collectors\n-            if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-            } else {\n-                shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-            }\n+            try {\n+                boolean shouldRescore;\n+                // if we are optimizing sort and there are no other collectors\n+                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n+                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n+                } else {\n+                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n+                }\n \n-            // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-            if (sortAndFormatsForRewrittenNumericSort != null) {\n-                searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-            }\n+                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n+                if (sortAndFormatsForRewrittenNumericSort != null) {\n+                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n+                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n+                }\n \n-            ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-            assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n-            if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n-                EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n-                queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n-                queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n+                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n+                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n+                    EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n+                    queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n+                    queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                }\n+\n+                return shouldRescore;\n+            } finally {\n+                // Search phase has finished, no longer need to check for timeout\n+                // otherwise aggregation phase might get cancelled.\n+                if (timeoutRunnable != null) {\n+                   searcher.removeQueryCancellation(timeoutRunnable);\n+                }\n             }\n-            // Search phase has finished, no longer need to check for timeout\n-            searcher.unsetCheckTimeout();\n-            return shouldRescore;\n         } catch (Exception e) {\n             throw new QueryPhaseExecutionException(searchContext.shardTarget(), \"Failed to execute main query\", e);\n         }\n", "next_change": {"commit": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 4383f0eb545..8740f9af1a1 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -264,46 +183,23 @@ public class QueryPhase implements SearchPhase {\n                 timeoutRunnable = null;\n             }\n \n-            if (searchContext.lowLevelCancellation()) {\n-                SearchShardTask task = searchContext.getTask();\n-                searcher.addQueryCancellation(() -> {\n-                    if (task.isCancelled()) {\n-                        throw new TaskCancelledException(\"cancelled\");\n-                    }\n-                });\n-            }\n-\n             try {\n-                boolean shouldRescore;\n-                // if we are optimizing sort and there are no other collectors\n-                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-                } else {\n-                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-                }\n-\n-                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-                if (sortAndFormatsForRewrittenNumericSort != null) {\n-                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-                }\n-\n+                boolean shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n                 ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor\n+                    || (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */)\n+                    : \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n                 if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n                     EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n                     queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                     queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n                 }\n-\n                 return shouldRescore;\n             } finally {\n                 // Search phase has finished, no longer need to check for timeout\n                 // otherwise aggregation phase might get cancelled.\n                 if (timeoutRunnable != null) {\n-                   searcher.removeQueryCancellation(timeoutRunnable);\n+                    searcher.removeQueryCancellation(timeoutRunnable);\n                 }\n             }\n         } catch (Exception e) {\n", "next_change": {"commit": "f50725e197046c9fca5851c152fd650ed29efec2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 8740f9af1a1..dd90cda7abb 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -207,7 +194,7 @@ public class QueryPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(\n+    private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n", "next_change": {"commit": "3bd41b2405378debfada5b469c0c331b8a392b1c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex dd90cda7abb..42f42f82ac9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -194,30 +234,31 @@ public class QueryPhase {\n         }\n     }\n \n+    private static Collector wrapWithProfilerCollectorIfNeeded(\n+        Profilers profilers,\n+        Collector collector,\n+        String profilerName,\n+        Collector... children\n+    ) {\n+        if (profilers == null) {\n+            return collector;\n+        }\n+        return new InternalProfileCollector(collector, profilerName, children);\n+    }\n+\n     private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n+        Collector collector,\n         boolean timeoutSet\n     ) throws IOException {\n-        // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n-        // add the top docs collector, the first collector context in the chain\n-        collectors.addFirst(topDocsFactory);\n-\n-        final Collector queryCollector;\n         if (searchContext.getProfilers() != null) {\n-            InternalProfileCollector profileCollector = QueryCollectorContext.createQueryCollectorWithProfiler(collectors);\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector(profileCollector);\n-            queryCollector = profileCollector;\n-        } else {\n-            queryCollector = QueryCollectorContext.createQueryCollector(collectors);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, queryCollector);\n+            searcher.search(query, collector);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": {"commit": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 42f42f82ac9..f4143c8975f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -234,31 +241,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static Collector wrapWithProfilerCollectorIfNeeded(\n+    private static CollectorManager<Collector, Void> wrapWithProfilerCollectorManagerIfNeeded(\n         Profilers profilers,\n         Collector collector,\n         String profilerName,\n         Collector... children\n     ) {\n         if (profilers == null) {\n-            return collector;\n+            return new SingleThreadCollectorManager(collector);\n         }\n-        return new InternalProfileCollector(collector, profilerName, children);\n+        return new InternalProfileCollectorManager(new InternalProfileCollector(collector, profilerName, children));\n     }\n \n-    private static void searchWithCollector(\n+    private static void searchWithCollectorManager(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        Collector collector,\n+        CollectorManager<Collector, Void> collectorManager,\n         boolean timeoutSet\n     ) throws IOException {\n         if (searchContext.getProfilers() != null) {\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollectorManager((InternalProfileCollectorManager) collectorManager);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, collector);\n+            searcher.search(query, collectorManager);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 4383f0eb545..8740f9af1a1 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -311,8 +207,14 @@ public class QueryPhase implements SearchPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(SearchContext searchContext, ContextIndexSearcher searcher, Query query,\n-            LinkedList<QueryCollectorContext> collectors, boolean hasFilterCollector, boolean timeoutSet) throws IOException {\n+    private static boolean searchWithCollector(\n+        SearchContext searchContext,\n+        ContextIndexSearcher searcher,\n+        Query query,\n+        LinkedList<QueryCollectorContext> collectors,\n+        boolean hasFilterCollector,\n+        boolean timeoutSet\n+    ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n         final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n         // add the top docs collector, the first collector context in the chain\n", "next_change": {"commit": "283f8acd9275d197453e7d9309e62f31abf51f51", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 8740f9af1a1..2e300be8d40 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -212,11 +195,10 @@ public class QueryPhase {\n         ContextIndexSearcher searcher,\n         Query query,\n         LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n         boolean timeoutSet\n     ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n+        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext);\n         // add the top docs collector, the first collector context in the chain\n         collectors.addFirst(topDocsFactory);\n \n", "next_change": {"commit": "3019796e79589a304493ffacc71036eeec271695", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 2e300be8d40..bc5b66a814f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -195,10 +203,11 @@ public class QueryPhase {\n         ContextIndexSearcher searcher,\n         Query query,\n         LinkedList<QueryCollectorContext> collectors,\n+        boolean hasFilterCollector,\n         boolean timeoutSet\n     ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext);\n+        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n         // add the top docs collector, the first collector context in the chain\n         collectors.addFirst(topDocsFactory);\n \n", "next_change": {"commit": "3bd41b2405378debfada5b469c0c331b8a392b1c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex bc5b66a814f..42f42f82ac9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -198,30 +234,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(\n+    private static Collector wrapWithProfilerCollectorIfNeeded(\n+        Profilers profilers,\n+        Collector collector,\n+        String profilerName,\n+        Collector... children\n+    ) {\n+        if (profilers == null) {\n+            return collector;\n+        }\n+        return new InternalProfileCollector(collector, profilerName, children);\n+    }\n+\n+    private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n+        Collector collector,\n         boolean timeoutSet\n     ) throws IOException {\n-        // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n-        // add the top docs collector, the first collector context in the chain\n-        collectors.addFirst(topDocsFactory);\n-\n-        final Collector queryCollector;\n         if (searchContext.getProfilers() != null) {\n-            InternalProfileCollector profileCollector = QueryCollectorContext.createQueryCollectorWithProfiler(collectors);\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector(profileCollector);\n-            queryCollector = profileCollector;\n-        } else {\n-            queryCollector = QueryCollectorContext.createQueryCollector(collectors);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, queryCollector);\n+            searcher.search(query, collector);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": {"commit": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 42f42f82ac9..f4143c8975f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -234,31 +241,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static Collector wrapWithProfilerCollectorIfNeeded(\n+    private static CollectorManager<Collector, Void> wrapWithProfilerCollectorManagerIfNeeded(\n         Profilers profilers,\n         Collector collector,\n         String profilerName,\n         Collector... children\n     ) {\n         if (profilers == null) {\n-            return collector;\n+            return new SingleThreadCollectorManager(collector);\n         }\n-        return new InternalProfileCollector(collector, profilerName, children);\n+        return new InternalProfileCollectorManager(new InternalProfileCollector(collector, profilerName, children));\n     }\n \n-    private static void searchWithCollector(\n+    private static void searchWithCollectorManager(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        Collector collector,\n+        CollectorManager<Collector, Void> collectorManager,\n         boolean timeoutSet\n     ) throws IOException {\n         if (searchContext.getProfilers() != null) {\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollectorManager((InternalProfileCollectorManager) collectorManager);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, collector);\n+            searcher.search(query, collectorManager);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "0d38626d8e6e9e2620a7a446b617a2ac42852461", "committedDate": "2020-03-06 00:19:11 +0100", "message": "Check for query cancellation during rewrite (#53166)"}, {"oid": "2ec1f6b4c4342e90a7d4e8bbf9029b51c03c7d18", "committedDate": "2020-03-19 13:09:50 -0400", "message": "Fix testIndexhasDuplicateData tests (#49786)"}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "bdfb137b340520218b88c1482d4d3fcc9718c9e6", "committedDate": "2020-05-21 14:49:43 -0400", "message": "Don't run sort optimization on size=0 (#57044)"}, {"oid": "b483246868c107ed8e2218c562571d54b97c470c", "committedDate": "2020-05-29 11:26:25 -0400", "message": "Run sort optimization when from+size>0 (#57250)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "879279c9b46b5a9606dfca96075e005624f0785d", "committedDate": "2020-08-24 20:24:35 -0400", "message": "Introduce point in time APIs in x-pack basic (#61062)"}, {"oid": "6a1c3e6059a13d97605892026595ea7f25686d6d", "committedDate": "2020-09-07 13:43:53 +0100", "message": "Remove SearchPhase interface (#62050)"}, {"oid": "2186b75af9f76b866539c16e76ffc8e019ac11d3", "committedDate": "2020-10-28 09:55:52 +0100", "message": "Reduce usages of SearchContext#mapperService (#64250)"}, {"oid": "f1e9aec8dcc7568d496abc4b09d1c8a0e6493087", "committedDate": "2020-11-04 15:49:38 +0100", "message": "Replace more MapperService usages in favour of QueryShardContext (#64584)"}, {"oid": "5852fbedf52c77b0a76c2c731fdd4982fb65cd87", "committedDate": "2021-01-14 09:11:59 -0800", "message": "Rename QueryShardContext -> SearchExecutionContext. (#67490)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "f27da75a6e75ed56b653d2d237b1f5ca5e4dac9d", "committedDate": "2021-02-22 17:52:10 +0100", "message": "Handle _shard_doc field for sort optimization (#69321)"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "3f77adcc664e57d79c02f5636565ad9f8d8bb601", "committedDate": "2021-07-27 11:08:09 +0100", "message": "Include reason in cancellation exceptions (#75332)"}, {"oid": "d9debbfe03b23e782d6afdadddd658b3d83bf710", "committedDate": "2021-09-08 09:20:26 -0400", "message": "Rename profile results for fetch profiling (#77195)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "c2c0165fd2811eb88e10eaa0089fbdbdeaab020c", "committedDate": "2021-09-13 10:00:36 -0400", "message": "Profile the fetch phase (#77064)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "2d9e0e79c8aa15a3f915f7335ca5961f91a6ccd9", "committedDate": "2021-09-21 18:39:58 +0200", "message": "Disable numeric sort optimization conditionally (#78103)"}, {"oid": "5e9c2422d1c7495a3195087b54add8d562f4b9ad", "committedDate": "2021-09-23 20:22:21 -0400", "message": "Disable sort optimization in search_after and scroll requests (#78230)"}, {"oid": "7d82dbf9e3e3e13c1c756f9b0893b6028e638ec4", "committedDate": "2021-09-24 10:46:11 -0400", "message": "Upgrade to Lucene9-snapshot-94c6e261274 (#78286)"}, {"oid": "060976a9f9f9eff089a710f0437169b65b300c25", "committedDate": "2021-10-18 16:45:36 +0200", "message": "Don't always rewrite the Lucene query in search phases (#79358)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "beb248fbbbe7be4fab369de239a6434a834bb53a", "committedDate": "2022-01-06 08:15:42 +0100", "message": "server instanceof pattern matching replacement (#82074)"}, {"oid": "a89d4c34cbd8e5b3b3879df3aec632e7494e3c35", "committedDate": "2022-02-15 11:48:38 -1000", "message": "TSDB: Add time series aggs cancellation (#83492)"}, {"oid": "898d84998b081d47ec6a9c2305f9bf4486d69be3", "committedDate": "2022-03-30 00:21:56 +0200", "message": "Make classes+methods that can be static static in many spots (#85370)"}, {"oid": "283f8acd9275d197453e7d9309e62f31abf51f51", "committedDate": "2023-02-06 11:24:41 +0100", "message": "Remove shortcutTotalHitCount optimization (#89047)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "3019796e79589a304493ffacc71036eeec271695", "committedDate": "2023-03-29 19:48:05 +0200", "message": "Revert \"Remove shortcutTotalHitCount optimization (#89047)\" (#94876)"}, {"oid": "f50725e197046c9fca5851c152fd650ed29efec2", "committedDate": "2023-03-30 15:12:17 +0200", "message": "Remove TopDocsCollectorContext#shouldRescore method (#94895)"}, {"oid": "663d82cf992ffad587c1c4afef8e6c932bf60d2a", "committedDate": "2023-03-30 15:13:00 +0200", "message": "Shortcut total hit count when terminate_after is used (#94889)"}, {"oid": "b275d9155e2fb877944360a77dfedf3509b4649e", "committedDate": "2023-04-21 08:53:54 +0200", "message": "Align constructors for query phase and friends (#95338)"}, {"oid": "3bd41b2405378debfada5b469c0c331b8a392b1c", "committedDate": "2023-04-21 09:04:00 +0200", "message": "Remove QueryCollectorContext abstraction (#95383)"}, {"oid": "8e15a1a7ada1fe3d7caa5d51adcad1d9f6852fff", "committedDate": "2023-04-21 10:00:27 +0200", "message": "Rename TopDocsCollectorContext to TopDocsCollectorFactory (#95435)"}, {"oid": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "committedDate": "2023-04-24 13:31:44 +0200", "message": "Search using CollectorManagers instead of Collectors (#95251)"}, {"oid": "5314e5dd553da74696a74cd061ef4bcec9bf2a48", "committedDate": "2023-04-24 15:07:34 -0700", "message": "Add support for Reciprocal Rank Fusion to the search API (#93396)"}, {"oid": "7fb344238dcad615282b70557b70c67eede482ca", "committedDate": "2023-04-25 13:39:48 +0200", "message": "Switch to Lucene ProfilerCollector (#95526)"}, {"oid": "c07fe6aff32de61f0ca848046482ab7880e41135", "committedDate": "2023-04-25 16:31:02 +0200", "message": "Turn TopDocsCollectorFactory into a collector manager factory (#95535)"}, {"oid": "e208992b66785646dc26cd66969031de35cbf6b5", "committedDate": "2023-05-08 14:50:10 +0200", "message": "Don't generate stacktrace in EarlyTerminationException and TimeExceededException (#95910)"}, {"oid": "815190aa6bd4fd486f56416fcc0c33dd96952191", "committedDate": "2023-05-30 09:50:41 +0200", "message": "Move the registration of the aggregation collector manager to SearchContextAggregations (#96410)"}]}, {"oid": "0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "url": "https://github.com/elastic/elasticsearch/commit/0012e3ac6d9b5578bd434e39e5db1442b5d742cd", "message": "Add unit test", "committedDate": "2020-02-28T13:09:14Z", "type": "commit"}, {"oid": "4c3183f14eefbec43885c33b4b47839c6ed1bf95", "url": "https://github.com/elastic/elasticsearch/commit/4c3183f14eefbec43885c33b4b47839c6ed1bf95", "message": "re-enable MultiReader Tests, fix cancellation tests", "committedDate": "2020-02-28T13:59:30Z", "type": "commit"}, {"oid": "8b38977ffd8682adad31a1063049c42f436b2cce", "url": "https://github.com/elastic/elasticsearch/commit/8b38977ffd8682adad31a1063049c42f436b2cce", "message": "fix checkstyle - enhance comments", "committedDate": "2020-02-28T14:24:26Z", "type": "commit"}, {"oid": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "url": "https://github.com/elastic/elasticsearch/commit/9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "message": "Fix NPE", "committedDate": "2020-02-28T14:53:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MzY0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753641", "body": "The implementation should live on the QueryPhase imo. This way you don't need to expose the `checkDirReaderCancelled` and `checkDirReaderCancelled`  in the searcher.", "bodyText": "The implementation should live on the QueryPhase imo. This way you don't need to expose the checkDirReaderCancelled and checkDirReaderCancelled  in the searcher.", "bodyHTML": "<p dir=\"auto\">The implementation should live on the QueryPhase imo. This way you don't need to expose the <code>checkDirReaderCancelled</code> and <code>checkDirReaderCancelled</code>  in the searcher.</p>", "author": "jimczi", "createdAt": "2020-02-28T15:20:00Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -360,7 +362,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n         void unsetCheckTimeout();\n     }\n \n-    public static class CancellableImpl implements Cancellable {\n+    public static class CancellableImpl implements QueryCancellable {\n \n         private Runnable checkCancelled;\n         private Runnable checkTimeout;\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -354,60 +351,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n      */\n     public interface QueryCancellable {\n \n-        boolean isEnabled();\n         void checkCancelled();\n         default void checkDirReaderCancelled() {\n             checkCancelled();\n         }\n-        void unsetCheckTimeout();\n     }\n \n-    public static class CancellableImpl implements QueryCancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n \n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n \n     /**\n      * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n      */\n     private static class CancellableDirectoryReader extends FilterDirectoryReader {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellable) throws IOException {\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n             super(in, new SubReaderWrapper() {\n                 @Override\n                 public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n                 }\n             });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n         }\n \n         @Override\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,270 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-    }\n-\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n+            return action;\n         }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -347,297 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface Cancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements Cancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n-\n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private final Holder<Cancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n+            return action;\n         }\n \n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, Cancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final Cancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Mzk2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385753969", "body": "These two functions should not be part of the interface, checkCancelled should be enough", "bodyText": "These two functions should not be part of the interface, checkCancelled should be enough", "bodyHTML": "<p dir=\"auto\">These two functions should not be part of the interface, checkCancelled should be enough</p>", "author": "jimczi", "createdAt": "2020-02-28T15:20:38Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyMjI2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386022266", "bodyText": "I don't like that much either, I exposed the checkDirReaderCancelled() so that I we can have tests that differentiate between exit in the searcher and exit from the dirReader: https://github.com/elastic/elasticsearch/pull/52822/files#diff-2abce48f3a52657ce3740afade6d5f8fR132\nBut as discussed I could just unit test the Cancellable reader instead.", "author": "matriv", "createdAt": "2020-02-29T11:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Mzk2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -350,7 +352,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n     /**\n      * iFace which implements the query timeout / cancellation logic\n      */\n-    public interface Cancellable {\n+    public interface QueryCancellable {\n \n         boolean isEnabled();\n         void checkCancelled();\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -354,60 +351,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n      */\n     public interface QueryCancellable {\n \n-        boolean isEnabled();\n         void checkCancelled();\n         default void checkDirReaderCancelled() {\n             checkCancelled();\n         }\n-        void unsetCheckTimeout();\n     }\n \n-    public static class CancellableImpl implements QueryCancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n \n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n \n     /**\n      * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n      */\n     private static class CancellableDirectoryReader extends FilterDirectoryReader {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellable) throws IOException {\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n             super(in, new SubReaderWrapper() {\n                 @Override\n                 public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n                 }\n             });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n         }\n \n         @Override\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,270 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-    }\n-\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n+            return action;\n         }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -347,297 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface Cancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements Cancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n-\n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private final Holder<Cancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n+            return action;\n         }\n \n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, Cancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final Cancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NDE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385754196", "body": "Can you call QueryCancellable ?", "bodyText": "Can you call QueryCancellable ?", "bodyHTML": "<p dir=\"auto\">Can you call QueryCancellable ?</p>", "author": "jimczi", "createdAt": "2020-02-28T15:20:58Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -350,7 +352,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n     /**\n      * iFace which implements the query timeout / cancellation logic\n      */\n-    public interface Cancellable {\n+    public interface QueryCancellable {\n \n         boolean isEnabled();\n         void checkCancelled();\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -354,60 +351,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n      */\n     public interface QueryCancellable {\n \n-        boolean isEnabled();\n         void checkCancelled();\n         default void checkDirReaderCancelled() {\n             checkCancelled();\n         }\n-        void unsetCheckTimeout();\n     }\n \n-    public static class CancellableImpl implements QueryCancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n \n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n \n     /**\n      * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n      */\n     private static class CancellableDirectoryReader extends FilterDirectoryReader {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellable) throws IOException {\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n             super(in, new SubReaderWrapper() {\n                 @Override\n                 public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n                 }\n             });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n         }\n \n         @Override\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,270 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-    }\n-\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n+            return action;\n         }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -347,297 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface Cancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements Cancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n-\n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private final Holder<Cancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n+            return action;\n         }\n \n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, Cancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final Cancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385756200", "body": "why do you need to use a custom `Holder` ? Now that cancellable directory reader is forked, you should be able to set the cancellable lazily ? So instead of passing the `Cancellable` here you'd set it in `ContextIndexSearcher#setCancellable` ?", "bodyText": "why do you need to use a custom Holder ? Now that cancellable directory reader is forked, you should be able to set the cancellable lazily ? So instead of passing the Cancellable here you'd set it in ContextIndexSearcher#setCancellable ?", "bodyHTML": "<p dir=\"auto\">why do you need to use a custom <code>Holder</code> ? Now that cancellable directory reader is forked, you should be able to set the cancellable lazily ? So instead of passing the <code>Cancellable</code> here you'd set it in <code>ContextIndexSearcher#setCancellable</code> ?</p>", "author": "jimczi", "createdAt": "2020-02-28T15:24:34Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,10 +89,27 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private Holder<Cancellable> cancellable;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MjU4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385792582", "bodyText": "The issue is that we need a reference to the cancellable (the holder actually) during construction of the Reader: https://github.com/elastic/elasticsearch/pull/52822/files#diff-913ad694a7d744ee93ae1dac48d67b0eR403\nSo that later on with the setCancellable we can set it to the holder.", "author": "matriv", "createdAt": "2020-02-28T16:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEwMjgzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386102831", "bodyText": "Alreanatively I changed so that the ContextIndexSearcher doesn't know of the holder, but then a cast to CancellableDirectoryReader is required to call the setCancellable.", "author": "matriv", "createdAt": "2020-03-01T12:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1NjIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -89,7 +90,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Holder<Cancellable> cancellable;\n+    private Holder<QueryCancellable> cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -90,27 +90,22 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Holder<QueryCancellable> cancellable;\n+    private QueryCancellable cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new Holder<>(new CancellableImpl()));\n+        this(reader, similarity, queryCache, queryCachingPolicy, true);\n     }\n \n-    // TODO: Make the 2nd constructor private so that the dirCancellable is never null and the IndexReader is always wrapped.\n+    // TODO: Remove the 2nd constructor so that the IndexReader is always wrapped.\n     // Some issues must be fixed:\n     //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n     //     the ShardSearcher sub-searchers.\n     //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                Holder<QueryCancellable> cancellable) throws IOException {\n-        super(cancellable != null ? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n-        if (cancellable == null) {\n-            this.cancellable = new Holder<>(new CancellableImpl());\n-        } else {\n-            this.cancellable = cancellable;\n-        }\n+                                boolean shouldWrap) throws IOException {\n+        super(shouldWrap ? new CancellableDirectoryReader((DirectoryReader) reader, new Holder<>(null)) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -90,25 +80,26 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private QueryCancellable cancellable;\n+    private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, true);\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n     }\n \n-    // TODO: Remove the 2nd constructor so that the IndexReader is always wrapped.\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n     // Some issues must be fixed:\n     //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n     //     the ShardSearcher sub-searchers.\n     //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean shouldWrap) throws IOException {\n-        super(shouldWrap ? new CancellableDirectoryReader((DirectoryReader) reader, new Holder<>(null)) : reader);\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..ecdb43bbcc6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -107,14 +107,18 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n         return this.cancellable.add(action);\n     }\n \n-    public void removeQueryTimeout(Runnable action) {\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n     }\n \n", "next_change": {"commit": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -116,7 +115,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     /**\n      * Remove a {@link Runnable} that checks for query cancellation or timeout\n-     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n      */\n     public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -89,30 +79,26 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Holder<Cancellable> cancellable;\n+    private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new Holder<>(new CancellableImpl()));\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n     }\n \n-    // TODO: Make the 2nd constructor private so that the dirCancellable is never null and the IndexReader is always wrapped.\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n     // Some issues must be fixed:\n     //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n     //     the ShardSearcher sub-searchers.\n     //   - tests that use a MultiReader\n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                Holder<Cancellable> cancellable) throws IOException {\n-        super(cancellable != null ? new CancellableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n-        if (cancellable == null) {\n-            this.cancellable = new Holder<>(new CancellableImpl());\n-        } else {\n-            this.cancellable = cancellable;\n-        }\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..ed41939b1cb 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -82,23 +82,20 @@ public class ContextIndexSearcher extends IndexSearcher {\n     private MutableQueryTimeout cancellable;\n \n     public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                boolean wrapWithExitableDirectoryReader) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader);\n     }\n \n-    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n-    // Some issues must be fixed:\n-    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n-    //     the ShardSearcher sub-searchers.\n-    //   - tests that use a MultiReader\n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                MutableQueryTimeout cancellable) throws IOException {\n-        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n+    private ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                 MutableQueryTimeout cancellable,\n+                                 boolean wrapWithExitableDirectoryReader) throws IOException {\n+        super(wrapWithExitableDirectoryReader ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n-        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n+        this.cancellable = cancellable;\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ed41939b1cb..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -36,66 +26,97 @@ import org.apache.lucene.search.LeafCollector;\n import org.apache.lucene.search.Query;\n import org.apache.lucene.search.QueryCache;\n import org.apache.lucene.search.QueryCachingPolicy;\n-import org.apache.lucene.search.ScoreDoc;\n import org.apache.lucene.search.ScoreMode;\n import org.apache.lucene.search.Scorer;\n import org.apache.lucene.search.TermStatistics;\n-import org.apache.lucene.search.TopFieldDocs;\n-import org.apache.lucene.search.TotalHits;\n import org.apache.lucene.search.Weight;\n import org.apache.lucene.search.similarities.Similarity;\n import org.apache.lucene.util.BitSet;\n import org.apache.lucene.util.BitSetIterator;\n import org.apache.lucene.util.Bits;\n-import org.apache.lucene.util.CombinedBitSet;\n import org.apache.lucene.util.SparseFixedBitSet;\n-import org.elasticsearch.common.lucene.search.TopDocsAndMaxScore;\n-import org.elasticsearch.search.DocValueFormat;\n+import org.apache.lucene.util.ThreadInterruptedException;\n+import org.elasticsearch.core.Releasable;\n+import org.elasticsearch.lucene.util.CombinedBitSet;\n import org.elasticsearch.search.dfs.AggregatedDfs;\n import org.elasticsearch.search.profile.Timer;\n import org.elasticsearch.search.profile.query.ProfileWeight;\n import org.elasticsearch.search.profile.query.QueryProfileBreakdown;\n import org.elasticsearch.search.profile.query.QueryProfiler;\n import org.elasticsearch.search.profile.query.QueryTimingType;\n-import org.elasticsearch.search.query.QuerySearchResult;\n \n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadPoolExecutor;\n \n /**\n  * Context-aware extension of {@link IndexSearcher}.\n  */\n-public class ContextIndexSearcher extends IndexSearcher {\n+public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n     /**\n      * The interval at which we check for search cancellation when we cannot use\n      * a {@link CancellableBulkScorer}. See {@link #intersectScorerAndBitSet}.\n      */\n-    private static int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n+    private static final int CHECK_CANCELLED_SCORER_INTERVAL = 1 << 11;\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private MutableQueryTimeout cancellable;\n+    private final MutableQueryTimeout cancellable;\n+\n+    private final QueueSizeBasedExecutor queueSizeBasedExecutor;\n+    private final LeafSlice[] leafSlices;\n+\n+    /** constructor for non-concurrent search */\n+    public ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        boolean wrapWithExitableDirectoryReader\n+    ) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader, null);\n+    }\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                boolean wrapWithExitableDirectoryReader) throws IOException {\n-        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader);\n+    /** constructor for concurrent search */\n+    public ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        boolean wrapWithExitableDirectoryReader,\n+        ThreadPoolExecutor executor\n+    ) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout(), wrapWithExitableDirectoryReader, executor);\n     }\n \n-    private ContextIndexSearcher(IndexReader reader, Similarity similarity,\n-                                 QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n-                                 MutableQueryTimeout cancellable,\n-                                 boolean wrapWithExitableDirectoryReader) throws IOException {\n+    private ContextIndexSearcher(\n+        IndexReader reader,\n+        Similarity similarity,\n+        QueryCache queryCache,\n+        QueryCachingPolicy queryCachingPolicy,\n+        MutableQueryTimeout cancellable,\n+        boolean wrapWithExitableDirectoryReader,\n+        ThreadPoolExecutor executor\n+    ) throws IOException {\n+        // concurrency is handle in this class so don't pass the executor to the parent class\n         super(wrapWithExitableDirectoryReader ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n         this.cancellable = cancellable;\n+        this.queueSizeBasedExecutor = executor != null ? new QueueSizeBasedExecutor(executor) : null;\n+        this.leafSlices = executor == null ? null : slices(leafContexts);\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Nzg2Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385757862", "body": "Can you revert this change ? It should work without this modification so I'd like to keep this for a different pr since the issue is not related to the exitable directory reader.", "bodyText": "Can you revert this change ? It should work without this modification so I'd like to keep this for a different pr since the issue is not related to the exitable directory reader.", "bodyHTML": "<p dir=\"auto\">Can you revert this change ? It should work without this modification so I'd like to keep this for a different pr since the issue is not related to the exitable directory reader.</p>", "author": "jimczi", "createdAt": "2020-02-28T15:27:11Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java", "diffHunk": "@@ -611,14 +611,8 @@ public void testCacheAggregation() throws IOException {\n         }", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc5MjgzMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385792830", "bodyText": "Sure, will do.", "author": "matriv", "createdAt": "2020-02-28T16:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1Nzg2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 52858cee25b..46f08d786a8 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -611,8 +611,14 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         }\n         indexWriter.close();\n \n+        Directory unmappedDirectory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), unmappedDirectory);\n+        unmappedIndexWriter.close();\n+\n         IndexReader indexReader = DirectoryReader.open(directory);\n-        IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n+        IndexReader unamappedIndexReader = DirectoryReader.open(unmappedDirectory);\n+        MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n+        IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n         fieldType.setName(\"value\");\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 52858cee25b..46f08d786a8 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -611,8 +611,14 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         }\n         indexWriter.close();\n \n+        Directory unmappedDirectory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), unmappedDirectory);\n+        unmappedIndexWriter.close();\n+\n         IndexReader indexReader = DirectoryReader.open(directory);\n-        IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n+        IndexReader unamappedIndexReader = DirectoryReader.open(unmappedDirectory);\n+        MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n+        IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n         fieldType.setName(\"value\");\n", "next_change": {"commit": "3b696828ada5953bb1669b972a353736383edf08", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 46f08d786a8..ece0012e093 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -620,8 +596,7 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n         IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n-        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n-        fieldType.setName(\"value\");\n+        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n         AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\")\n             .field(\"value\");\n \n", "next_change": {"commit": "6ef0e5f5e8b73dcce542ba18d9931350a8219c13", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex ece0012e093..5d95b42f685 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -600,7 +601,8 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\")\n             .field(\"value\");\n \n-        AvgAggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType);\n+        SearchContext context = createSearchContext(indexSearcher, null, fieldType);\n+        AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n         aggregator.postCollection();\n", "next_change": {"commit": "3af540b50dd526ee035c20d691d8ec32e8b5068a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 5d95b42f685..b41d726da54 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -605,7 +603,6 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n-        aggregator.postCollection();\n \n         InternalAvg avg = (InternalAvg) aggregator.buildAggregation(0L);\n \n", "next_change": {"commit": "3e45318d87958118be7688f316234b1afb28765b", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex b41d726da54..b74bb25cc60 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -599,7 +599,7 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\")\n             .field(\"value\");\n \n-        SearchContext context = createSearchContext(indexSearcher, null, fieldType);\n+        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n         AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n", "next_change": {"commit": "0bbc6addd9b5314db9115fa4ac10211e43ba2d66", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex b74bb25cc60..49d3ca9bf71 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -603,6 +595,7 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n+        aggregator.postCollection();\n \n         InternalAvg avg = (InternalAvg) aggregator.buildAggregation(0L);\n \n", "next_change": {"commit": "04bdefd58c6936fd9ab0f8c8a5806aa66c9b597c", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 49d3ca9bf71..4dd7de7e076 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -588,13 +611,12 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n-        AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\")\n-            .field(\"value\");\n+        AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\").field(\"value\");\n \n         AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n         AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n-        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n+        indexSearcher.search(new MatchAllDocsQuery(), aggregator.asCollector());\n         aggregator.postCollection();\n \n         InternalAvg avg = (InternalAvg) aggregator.buildAggregation(0L);\n", "next_change": {"commit": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex 4dd7de7e076..d6883cced34 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -613,21 +601,12 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n         AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\").field(\"value\");\n \n-        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n-        AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n-        aggregator.preCollection();\n-        indexSearcher.search(new MatchAllDocsQuery(), aggregator.asCollector());\n-        aggregator.postCollection();\n-\n-        InternalAvg avg = (InternalAvg) aggregator.buildAggregation(0L);\n+        InternalAvg avg = searchAndReduce(indexSearcher, new AggTestConfig(aggregationBuilder, fieldType));\n \n         assertEquals(5.5, avg.getValue(), 0);\n         assertEquals(\"avg\", avg.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(avg));\n \n-        // Test that an aggregation not using a script does get cached\n-        assertTrue(context.isCacheable());\n-\n         multiReader.close();\n         directory.close();\n         unmappedDirectory.close();\n", "next_change": {"commit": "c05181528a809793a4ad6e29b4f6920f5de249e7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex d6883cced34..c1e2e3ad422 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -607,9 +594,8 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         assertEquals(\"avg\", avg.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(avg));\n \n-        multiReader.close();\n+        indexReader.close();\n         directory.close();\n-        unmappedDirectory.close();\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex b41d726da54..b74bb25cc60 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -611,7 +611,7 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         assertTrue(AggregationInspectionHelper.hasValue(avg));\n \n         // Test that an aggregation not using a script does get cached\n-        assertTrue(context.getQueryShardContext().isCacheable());\n+        assertTrue(context.isCacheable());\n \n         multiReader.close();\n         directory.close();\n", "next_change": {"commit": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex b74bb25cc60..d6883cced34 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -596,23 +599,14 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n-        AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\")\n-            .field(\"value\");\n+        AvgAggregationBuilder aggregationBuilder = new AvgAggregationBuilder(\"avg\").field(\"value\");\n \n-        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n-        AvgAggregator aggregator = createAggregator(aggregationBuilder, context);\n-        aggregator.preCollection();\n-        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n-\n-        InternalAvg avg = (InternalAvg) aggregator.buildAggregation(0L);\n+        InternalAvg avg = searchAndReduce(indexSearcher, new AggTestConfig(aggregationBuilder, fieldType));\n \n         assertEquals(5.5, avg.getValue(), 0);\n         assertEquals(\"avg\", avg.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(avg));\n \n-        // Test that an aggregation not using a script does get cached\n-        assertTrue(context.isCacheable());\n-\n         multiReader.close();\n         directory.close();\n         unmappedDirectory.close();\n", "next_change": {"commit": "c05181528a809793a4ad6e29b4f6920f5de249e7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\nindex d6883cced34..c1e2e3ad422 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/AvgAggregatorTests.java\n", "chunk": "@@ -607,9 +594,8 @@ public class AvgAggregatorTests extends AggregatorTestCase {\n         assertEquals(\"avg\", avg.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(avg));\n \n-        multiReader.close();\n+        indexReader.close();\n         directory.close();\n-        unmappedDirectory.close();\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "f9526f9e1ed2f2ae38781624eb846a00b1a5c9c2", "committedDate": "2020-03-24 08:42:52 +0200", "message": "Add supported-type tests to avg aggregation (#54011)"}, {"oid": "a90c1de8745681356a6516f4f22a8c40f71f6b12", "committedDate": "2020-03-26 15:01:07 -0400", "message": "Add ValuesSource Registry and associated logic (#54281)"}, {"oid": "ceb6e6227fb48cf6986f1124014df4cbc6f82a40", "committedDate": "2020-04-29 16:24:07 +0300", "message": "Modified searchAndReduce() to return empty agg when no docs exist  (#55826)"}, {"oid": "0d7320499d77e57e16b1789b9d1e91e42f4638c9", "committedDate": "2020-05-08 15:39:49 -0400", "message": "Save memory when numeric terms agg is not top (#55873)"}, {"oid": "792087b3161dc9e2f28efa2e92ed50014af610a0", "committedDate": "2020-05-29 12:36:18 -0400", "message": "Fix assertion catching in aggregation supported type test (#56466)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "6ef0e5f5e8b73dcce542ba18d9931350a8219c13", "committedDate": "2020-10-27 09:12:58 -0400", "message": "Limit blast redius of SearchContext in aggs (#64068)"}, {"oid": "3af540b50dd526ee035c20d691d8ec32e8b5068a", "committedDate": "2020-10-28 17:33:27 -0400", "message": "Remove aggregation's postCollect phase (#64016)"}, {"oid": "3e45318d87958118be7688f316234b1afb28765b", "committedDate": "2020-12-08 10:22:34 -0500", "message": "Remove BigArrays from SearchContext (#65981)"}, {"oid": "79d32e544dea8bb5f652b59d9d258e39dcbf73b6", "committedDate": "2020-12-15 10:56:20 -0500", "message": "Clean up some AggregatorTests (#66291)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "0bbc6addd9b5314db9115fa4ac10211e43ba2d66", "committedDate": "2021-02-10 19:12:50 -0500", "message": "Revert \"Remove aggregation's postCollect phase (#68615)"}, {"oid": "07f4f04f19dd1c882ccb9648227a8205f927bea7", "committedDate": "2021-03-09 11:22:35 -0500", "message": "Test: Fix error in assumption around accuracy (#69932)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "d71544976608bdb53fa4d29521fb328e1033ee2f", "committedDate": "2021-08-30 13:42:20 -0400", "message": "Apply spotless to aggregations (#76682)"}, {"oid": "30e15ba8387f2130976ca017553b2ca6f2f5de0e", "committedDate": "2021-11-03 13:13:42 -0500", "message": "Script: Time series compile and cache evict metrics (#79078)"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "d3b1a61f361cbe15d96fa873979a1f219210464b", "committedDate": "2022-07-08 13:48:31 +0200", "message": "Replace usages of deprecated specialized field exists queries (#88312)"}, {"oid": "04bdefd58c6936fd9ab0f8c8a5806aa66c9b597c", "committedDate": "2022-07-18 08:18:13 +0200", "message": "Remove Collector implementation from BucketCollector (#88444)"}, {"oid": "4a26dda50c947a15d4e4a234a390f4e140573b95", "committedDate": "2022-10-06 13:33:57 -0400", "message": "Use the AggTestConfig object in testCase (#90699)"}, {"oid": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "committedDate": "2022-11-17 11:36:12 -0500", "message": "Release agg context in tests part 3 (#91598)"}, {"oid": "9bbea4789973e0faf59e605f0158d15a951f0c29", "committedDate": "2023-05-04 11:12:26 +0200", "message": "use #newIndexSearcher in all AggregatorTestCase implementations (#95796)"}, {"oid": "c05181528a809793a4ad6e29b4f6920f5de249e7", "committedDate": "2023-05-08 07:25:10 +0200", "message": "Use DirectoryReader instead of IndexReader in AggregatorTestCase (#95876)"}, {"oid": "6a3159832d8cb72c3c64a82c131315896f00c232", "committedDate": "2023-05-08 15:28:06 +0200", "message": "Add test coverage for unmapped fields for avg aggregator (#95911)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODE0NQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758145", "body": "Same here, this shouldn't be needed with the extra constructor.", "bodyText": "Same here, this shouldn't be needed with the extra constructor.", "bodyHTML": "<p dir=\"auto\">Same here, this shouldn't be needed with the extra constructor.</p>", "author": "jimczi", "createdAt": "2020-02-28T15:27:37Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java", "diffHunk": "@@ -920,14 +920,8 @@ public void testCacheAggregation() throws IOException {\n         }", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex d43fafc22b2..598d19795db 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -920,8 +920,14 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         }\n         indexWriter.close();\n \n+        Directory unmappedDirectory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), unmappedDirectory);\n+        unmappedIndexWriter.close();\n+\n         IndexReader indexReader = DirectoryReader.open(directory);\n-        IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n+        IndexReader unamappedIndexReader = DirectoryReader.open(unmappedDirectory);\n+        MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n+        IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex d43fafc22b2..598d19795db 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -920,8 +920,14 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         }\n         indexWriter.close();\n \n+        Directory unmappedDirectory = newDirectory();\n+        RandomIndexWriter unmappedIndexWriter = new RandomIndexWriter(random(), unmappedDirectory);\n+        unmappedIndexWriter.close();\n+\n         IndexReader indexReader = DirectoryReader.open(directory);\n-        IndexSearcher indexSearcher = newIndexSearcher(indexReader);\n+        IndexReader unamappedIndexReader = DirectoryReader.open(unmappedDirectory);\n+        MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n+        IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n \n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n", "next_change": {"commit": "3b696828ada5953bb1669b972a353736383edf08", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 598d19795db..d4bc4c4c179 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -930,8 +908,7 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n \n-        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.INTEGER);\n-        fieldType.setName(\"value\");\n+        MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n         MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\")\n             .field(\"value\");\n \n", "next_change": {"commit": "6ef0e5f5e8b73dcce542ba18d9931350a8219c13", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex d4bc4c4c179..4de0ccab0b4 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -912,7 +913,8 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\")\n             .field(\"value\");\n \n-        MaxAggregator aggregator = createAggregator(aggregationBuilder, indexSearcher, fieldType);\n+        SearchContext context = createSearchContext(indexSearcher, null, fieldType);\n+        MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n         aggregator.postCollection();\n", "next_change": {"commit": "3af540b50dd526ee035c20d691d8ec32e8b5068a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 4de0ccab0b4..3b980cbd8bb 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -917,7 +911,6 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n-        aggregator.postCollection();\n \n         InternalMax max = (InternalMax) aggregator.buildAggregation(0L);\n \n", "next_change": {"commit": "3e45318d87958118be7688f316234b1afb28765b", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 3b980cbd8bb..49952e61c2a 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -907,7 +907,7 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\")\n             .field(\"value\");\n \n-        SearchContext context = createSearchContext(indexSearcher, null, fieldType);\n+        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n         MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n", "next_change": {"commit": "0bbc6addd9b5314db9115fa4ac10211e43ba2d66", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 49952e61c2a..7e23012ccc0 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -911,6 +910,7 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n         aggregator.preCollection();\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n+        aggregator.postCollection();\n \n         InternalMax max = (InternalMax) aggregator.buildAggregation(0L);\n \n", "next_change": {"commit": "8cbcaced73164a817686cf58a6e73bac4b6afdc2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 7e23012ccc0..d0e56853eea 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -912,9 +899,9 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n         aggregator.postCollection();\n \n-        InternalMax max = (InternalMax) aggregator.buildAggregation(0L);\n+        Max max = (Max) aggregator.buildAggregation(0L);\n \n-        assertEquals(10.0, max.getValue(), 0);\n+        assertEquals(10.0, max.value(), 0);\n         assertEquals(\"max\", max.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n", "next_change": {"commit": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex d0e56853eea..1be37cf635f 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -893,21 +883,12 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n         MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\").field(\"value\");\n \n-        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n-        MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n-        aggregator.preCollection();\n-        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n-        aggregator.postCollection();\n-\n-        Max max = (Max) aggregator.buildAggregation(0L);\n+        Max max = searchAndReduce(indexSearcher, new AggTestConfig(aggregationBuilder, fieldType));\n \n         assertEquals(10.0, max.value(), 0);\n         assertEquals(\"max\", max.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n-        // Test that an aggregation not using a script does get cached\n-        assertTrue(context.isCacheable());\n-\n         multiReader.close();\n         directory.close();\n         unmappedDirectory.close();\n", "next_change": {"commit": "c05181528a809793a4ad6e29b4f6920f5de249e7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 1be37cf635f..8ac8086b668 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -889,9 +877,8 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         assertEquals(\"max\", max.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n-        multiReader.close();\n+        indexReader.close();\n         directory.close();\n-        unmappedDirectory.close();\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}, {"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 3b980cbd8bb..49952e61c2a 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -919,7 +919,7 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n         // Test that an aggregation not using a script does get cached\n-        assertTrue(context.getQueryShardContext().isCacheable());\n+        assertTrue(context.isCacheable());\n \n         multiReader.close();\n         directory.close();\n", "next_change": {"commit": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 49952e61c2a..1be37cf635f 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -902,25 +880,15 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         MultiReader multiReader = new MultiReader(indexReader, unamappedIndexReader);\n         IndexSearcher indexSearcher = newSearcher(multiReader, true, true);\n \n-\n         MappedFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"value\", NumberFieldMapper.NumberType.INTEGER);\n-        MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\")\n-            .field(\"value\");\n-\n-        AggregationContext context = createAggregationContext(indexSearcher, null, fieldType);\n-        MaxAggregator aggregator = createAggregator(aggregationBuilder, context);\n-        aggregator.preCollection();\n-        indexSearcher.search(new MatchAllDocsQuery(), aggregator);\n+        MaxAggregationBuilder aggregationBuilder = new MaxAggregationBuilder(\"max\").field(\"value\");\n \n-        InternalMax max = (InternalMax) aggregator.buildAggregation(0L);\n+        Max max = searchAndReduce(indexSearcher, new AggTestConfig(aggregationBuilder, fieldType));\n \n-        assertEquals(10.0, max.getValue(), 0);\n+        assertEquals(10.0, max.value(), 0);\n         assertEquals(\"max\", max.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n-        // Test that an aggregation not using a script does get cached\n-        assertTrue(context.isCacheable());\n-\n         multiReader.close();\n         directory.close();\n         unmappedDirectory.close();\n", "next_change": {"commit": "c05181528a809793a4ad6e29b4f6920f5de249e7", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\nindex 1be37cf635f..8ac8086b668 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/MaxAggregatorTests.java\n", "chunk": "@@ -889,9 +877,8 @@ public class MaxAggregatorTests extends AggregatorTestCase {\n         assertEquals(\"max\", max.getName());\n         assertTrue(AggregationInspectionHelper.hasValue(max));\n \n-        multiReader.close();\n+        indexReader.close();\n         directory.close();\n-        unmappedDirectory.close();\n     }\n \n     /**\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "73d2addaa255948ec08fc0bd5a0fef173731a2f7", "committedDate": "2020-03-18 13:19:13 -0700", "message": "supported field type tests for max agg (#53701)"}, {"oid": "a90c1de8745681356a6516f4f22a8c40f71f6b12", "committedDate": "2020-03-26 15:01:07 -0400", "message": "Add ValuesSource Registry and associated logic (#54281)"}, {"oid": "ceb6e6227fb48cf6986f1124014df4cbc6f82a40", "committedDate": "2020-04-29 16:24:07 +0300", "message": "Modified searchAndReduce() to return empty agg when no docs exist  (#55826)"}, {"oid": "0d7320499d77e57e16b1789b9d1e91e42f4638c9", "committedDate": "2020-05-08 15:39:49 -0400", "message": "Save memory when numeric terms agg is not top (#55873)"}, {"oid": "792087b3161dc9e2f28efa2e92ed50014af610a0", "committedDate": "2020-05-29 12:36:18 -0400", "message": "Fix assertion catching in aggregation supported type test (#56466)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "6ef0e5f5e8b73dcce542ba18d9931350a8219c13", "committedDate": "2020-10-27 09:12:58 -0400", "message": "Limit blast redius of SearchContext in aggs (#64068)"}, {"oid": "3af540b50dd526ee035c20d691d8ec32e8b5068a", "committedDate": "2020-10-28 17:33:27 -0400", "message": "Remove aggregation's postCollect phase (#64016)"}, {"oid": "3e45318d87958118be7688f316234b1afb28765b", "committedDate": "2020-12-08 10:22:34 -0500", "message": "Remove BigArrays from SearchContext (#65981)"}, {"oid": "79d32e544dea8bb5f652b59d9d258e39dcbf73b6", "committedDate": "2020-12-15 10:56:20 -0500", "message": "Clean up some AggregatorTests (#66291)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "0bbc6addd9b5314db9115fa4ac10211e43ba2d66", "committedDate": "2021-02-10 19:12:50 -0500", "message": "Revert \"Remove aggregation's postCollect phase (#68615)"}, {"oid": "c4233dfbb7c9b807da6778d1bc18a7318cb7cb3c", "committedDate": "2021-03-15 12:41:15 -0400", "message": "Refactor: Aggs use NOOP leaf collector (#70320)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "d71544976608bdb53fa4d29521fb328e1033ee2f", "committedDate": "2021-08-30 13:42:20 -0400", "message": "Apply spotless to aggregations (#76682)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "30e15ba8387f2130976ca017553b2ca6f2f5de0e", "committedDate": "2021-11-03 13:13:42 -0500", "message": "Script: Time series compile and cache evict metrics (#79078)"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "8cbcaced73164a817686cf58a6e73bac4b6afdc2", "committedDate": "2022-02-28 16:17:39 -0500", "message": "Remove interface for transport client (#83486)"}, {"oid": "d3b1a61f361cbe15d96fa873979a1f219210464b", "committedDate": "2022-07-08 13:48:31 +0200", "message": "Replace usages of deprecated specialized field exists queries (#88312)"}, {"oid": "04bdefd58c6936fd9ab0f8c8a5806aa66c9b597c", "committedDate": "2022-07-18 08:18:13 +0200", "message": "Remove Collector implementation from BucketCollector (#88444)"}, {"oid": "4a26dda50c947a15d4e4a234a390f4e140573b95", "committedDate": "2022-10-06 13:33:57 -0400", "message": "Use the AggTestConfig object in testCase (#90699)"}, {"oid": "2e12d20b39aca69f2c0db5453c193ea86fd998d3", "committedDate": "2022-11-17 11:36:12 -0500", "message": "Release agg context in tests part 3 (#91598)"}, {"oid": "9bbea4789973e0faf59e605f0158d15a951f0c29", "committedDate": "2023-05-04 11:12:26 +0200", "message": "use #newIndexSearcher in all AggregatorTestCase implementations (#95796)"}, {"oid": "c05181528a809793a4ad6e29b4f6920f5de249e7", "committedDate": "2023-05-08 07:25:10 +0200", "message": "Use DirectoryReader instead of IndexReader in AggregatorTestCase (#95876)"}, {"oid": "ace7e39957636c1a5b1008a6214251fbf268b736", "committedDate": "2023-05-08 15:28:30 +0200", "message": "Add test coverage for unmapped fields for max aggregator (#95912)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1ODI2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385758263", "body": "Here too ;)", "bodyText": "Here too ;)", "bodyHTML": "<p dir=\"auto\">Here too ;)</p>", "author": "jimczi", "createdAt": "2020-02-28T15:27:48Z", "path": "server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java", "diffHunk": "@@ -22,7 +22,6 @@\n import org.apache.lucene.document.Document;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 001736d49c9..2541583e945 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -22,6 +22,7 @@ package org.elasticsearch.search.aggregations.metrics;\n import org.apache.lucene.document.Document;\n import org.apache.lucene.document.SortedNumericDocValuesField;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n", "next_change": {"commit": "3936a05c6adb5c38bb33d370d6e05db93dd3d872", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 2541583e945..420c9b8cecb 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -30,20 +30,32 @@ import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.NumericUtils;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.search.aggregations.AggregationBuilder;\n import org.elasticsearch.search.aggregations.AggregatorTestCase;\n-import org.elasticsearch.search.aggregations.metrics.Percentile;\n-import org.elasticsearch.search.aggregations.metrics.PercentileRanks;\n-import org.elasticsearch.search.aggregations.metrics.PercentileRanksAggregationBuilder;\n-import org.elasticsearch.search.aggregations.metrics.PercentilesMethod;\n import org.elasticsearch.search.aggregations.support.AggregationInspectionHelper;\n+import org.elasticsearch.search.aggregations.support.CoreValuesSourceType;\n+import org.elasticsearch.search.aggregations.support.ValuesSourceType;\n import org.hamcrest.Matchers;\n \n import java.io.IOException;\n import java.util.Iterator;\n+import java.util.List;\n \n \n public class TDigestPercentileRanksAggregatorTests extends AggregatorTestCase {\n \n+    @Override\n+    protected AggregationBuilder createAggBuilderForTypeTest(MappedFieldType fieldType, String fieldName) {\n+        return new PercentileRanksAggregationBuilder(\"tdigest_ranks\", new double[]{0.1, 0.5, 12})\n+            .field(fieldName)\n+            .percentilesConfig(new PercentilesConfig.TDigest());\n+    }\n+\n+    @Override\n+    protected List<ValuesSourceType> getSupportedValuesSourceTypes() {\n+        return List.of(CoreValuesSourceType.NUMERIC);\n+    }\n+\n     public void testEmpty() throws IOException {\n         PercentileRanksAggregationBuilder aggBuilder = new PercentileRanksAggregationBuilder(\"my_agg\", new double[]{0.5})\n                 .field(\"field\")\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 001736d49c9..420c9b8cecb 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -22,6 +22,7 @@ package org.elasticsearch.search.aggregations.metrics;\n import org.apache.lucene.document.Document;\n import org.apache.lucene.document.SortedNumericDocValuesField;\n import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n", "next_change": {"commit": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex 420c9b8cecb..f77567d4625 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -23,10 +12,10 @@ import org.apache.lucene.document.Document;\n import org.apache.lucene.document.SortedNumericDocValuesField;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.MultiReader;\n-import org.apache.lucene.index.RandomIndexWriter;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.store.Directory;\n+import org.apache.lucene.tests.index.RandomIndexWriter;\n import org.apache.lucene.util.NumericUtils;\n import org.elasticsearch.index.mapper.MappedFieldType;\n import org.elasticsearch.index.mapper.NumberFieldMapper;\n", "next_change": {"commit": "15932d5168030da53a3530c08dc2f86b9ea3fe4a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\nindex f77567d4625..991ef235495 100644\n--- a/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/aggregations/metrics/TDigestPercentileRanksAggregatorTests.java\n", "chunk": "@@ -13,7 +13,6 @@ import org.apache.lucene.document.SortedNumericDocValuesField;\n import org.apache.lucene.index.IndexReader;\n import org.apache.lucene.index.MultiReader;\n import org.apache.lucene.search.IndexSearcher;\n-import org.apache.lucene.search.MatchAllDocsQuery;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.tests.index.RandomIndexWriter;\n import org.apache.lucene.util.NumericUtils;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "a90c1de8745681356a6516f4f22a8c40f71f6b12", "committedDate": "2020-03-26 15:01:07 -0400", "message": "Add ValuesSource Registry and associated logic (#54281)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "5de0ed9432f4b41b697c9f3bc28953834cd3eae1", "committedDate": "2020-08-06 14:08:26 +0200", "message": "Replace AggregatorTestCase#search with AggregatorTestCase#searchAndReduce (#60683)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "d71544976608bdb53fa4d29521fb328e1033ee2f", "committedDate": "2021-08-30 13:42:20 -0400", "message": "Apply spotless to aggregations (#76682)"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "15932d5168030da53a3530c08dc2f86b9ea3fe4a", "committedDate": "2022-09-20 14:58:24 -0400", "message": "Refactor aggregator test case (#90149)"}, {"oid": "4a26dda50c947a15d4e4a234a390f4e140573b95", "committedDate": "2022-10-06 13:33:57 -0400", "message": "Use the AggTestConfig object in testCase (#90699)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwNzg1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385807859", "body": "can you check that the argument is not null since we seem to assume it's never null in some places?", "bodyText": "can you check that the argument is not null since we seem to assume it's never null in some places?", "bodyHTML": "<p dir=\"auto\">can you check that the argument is not null since we seem to assume it's never null in some places?</p>", "author": "jpountz", "createdAt": "2020-02-28T16:54:41Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -92,10 +121,14 @@ public void setProfiler(QueryProfiler profiler) {\n \n     /**\n      * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * collecting documents and check for query cancellation or timeout\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public void setCancellable(Cancellable cancellable) {\n+        this.cancellable.set(cancellable);", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -123,8 +124,8 @@ public class ContextIndexSearcher extends IndexSearcher {\n      * Set a {@link Runnable} that will be run on a regular basis while\n      * collecting documents and check for query cancellation or timeout\n      */\n-    public void setCancellable(Cancellable cancellable) {\n-        this.cancellable.set(cancellable);\n+    public void setCancellable(QueryCancellable cancellable) {\n+        this.cancellable.set(Objects.requireNonNull(cancellable, \"queryCancellable should not be null\"));\n     }\n \n     public void unsetCheckTimeout() {\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -125,11 +120,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n      * collecting documents and check for query cancellation or timeout\n      */\n     public void setCancellable(QueryCancellable cancellable) {\n-        this.cancellable.set(Objects.requireNonNull(cancellable, \"queryCancellable should not be null\"));\n+        this.cancellable = Objects.requireNonNull(cancellable, \"queryCancellable should not be null\");\n+        ((CancellableDirectoryReader) getIndexReader()).setCancellable(cancellable);\n     }\n \n-    public void unsetCheckTimeout() {\n-        this.cancellable.get().unsetCheckTimeout();\n+    private void checkCancelled() {\n+        if (cancellable != null) {\n+            cancellable.checkCancelled();\n+        }\n     }\n \n     public void setAggregatedDfs(AggregatedDfs aggregatedDfs) {\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -116,18 +107,15 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout\n+     * Add a {@link Runnable} that will be run on a regular basis while\n+     * collecting documents and check for query cancellation or timeout.\n      */\n-    public void setCancellable(QueryCancellable cancellable) {\n-        this.cancellable = Objects.requireNonNull(cancellable, \"queryCancellable should not be null\");\n-        ((CancellableDirectoryReader) getIndexReader()).setCancellable(cancellable);\n+    public Runnable addQueryCancellation(Runnable action) {\n+        return this.cancellable.add(action);\n     }\n \n-    private void checkCancelled() {\n-        if (cancellable != null) {\n-            cancellable.checkCancelled();\n-        }\n+    public void removeQueryTimeout(Runnable action) {\n+        this.cancellable.remove(action);\n     }\n \n     public void setAggregatedDfs(AggregatedDfs aggregatedDfs) {\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..ecdb43bbcc6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -107,14 +107,18 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n         return this.cancellable.add(action);\n     }\n \n-    public void removeQueryTimeout(Runnable action) {\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n     }\n \n", "next_change": {"commit": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -116,7 +115,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     /**\n      * Remove a {@link Runnable} that checks for query cancellation or timeout\n-     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n      */\n     public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -120,15 +106,19 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout\n+     * Add a {@link Runnable} that will be run on a regular basis while accessing documents in the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n-    public void setCancellable(Cancellable cancellable) {\n-        this.cancellable.set(cancellable);\n+    public Runnable addQueryCancellation(Runnable action) {\n+        return this.cancellable.add(action);\n     }\n \n-    public void unsetCheckTimeout() {\n-        this.cancellable.get().unsetCheckTimeout();\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n+        this.cancellable.remove(action);\n     }\n \n     public void setAggregatedDfs(AggregatedDfs aggregatedDfs) {\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -121,6 +119,19 @@ public class ContextIndexSearcher extends IndexSearcher {\n         this.cancellable.remove(action);\n     }\n \n+    @Override\n+    public void close() {\n+        // clear the list of cancellables when closing the owning search context, since the ExitableDirectoryReader might be cached (for\n+        // instance in fielddata cache).\n+        // A cancellable can contain an indirect reference to the search context, which potentially retains a significant amount\n+        // of memory.\n+        this.cancellable.clear();\n+    }\n+\n+    public boolean hasCancellations() {\n+        return this.cancellable.isEnabled();\n+    }\n+\n     public void setAggregatedDfs(AggregatedDfs aggregatedDfs) {\n         this.aggregatedDfs = aggregatedDfs;\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODYwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385808605", "body": "Let's do the `get()` call once for all instead of forcing the bulk scorer to do it every time it wants to check whether the request has been cancelled?\r\n\r\n```suggestion\r\n                        Runnable checkCancelled = cancellable.get();\r\n                        return new CancellableBulkScorer(in, checkCancelled);\r\n```", "bodyText": "Let's do the get() call once for all instead of forcing the bulk scorer to do it every time it wants to check whether the request has been cancelled?\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());\n          \n          \n            \n                                    Runnable checkCancelled = cancellable.get();\n          \n          \n            \n                                    return new CancellableBulkScorer(in, checkCancelled);", "bodyHTML": "<p dir=\"auto\">Let's do the <code>get()</code> call once for all instead of forcing the bulk scorer to do it every time it wants to check whether the request has been cancelled?</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-k x x-first\">return</span><span class=\"x\"> </span><span class=\"pl-k x\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">CancellableBulkScorer</span><span class=\"x\">(in, () </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x x-last\"> </span>cancellable<span class=\"pl-k\">.</span>get(<span class=\"x x-first\">)</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">checkCancelled()</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-smi x x-first\">Runnable</span><span class=\"x\"> checkCancelled </span><span class=\"pl-k x\">=</span><span class=\"x x-last\"> </span>cancellable<span class=\"pl-k\">.</span>get();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">CancellableBulkScorer</span>(in, checkCancelled);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jpountz", "createdAt": "2020-02-28T16:56:12Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +270,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -269,8 +270,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 @Override\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n+                    QueryCancellable checkCancelled = cancellable.get();\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());\n+                        return new CancellableBulkScorer(in, () -> checkCancelled.checkCancelled());\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "ce51935a96c3d59af66205144924f3ff1b32d17e", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..d3bdabeaefa 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -270,9 +268,8 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 @Override\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n-                    QueryCancellable checkCancelled = cancellable.get();\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> checkCancelled.checkCancelled());\n+                        return new CancellableBulkScorer(in, () -> checkCancelled());\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "d562cf1d4a23d023685095dfa18a1448574dd475", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3bdabeaefa..749f981f905 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -269,7 +271,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> checkCancelled());\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -271,7 +258,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n+                        return new CancellableBulkScorer(in, cancellable::shouldExit);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -258,7 +261,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::shouldExit);\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -270,7 +261,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> cancellable.get().checkCancelled());\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..0454d494fea 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -266,33 +245,38 @@ public class ContextIndexSearcher extends IndexSearcher {\n                         return null;\n                     }\n                 }\n+\n+                @Override\n+                public int count(LeafReaderContext context) throws IOException {\n+                    return weight.count(context);\n+                }\n             };\n         } else {\n             return weight;\n         }\n     }\n \n-\n     private static BitSet getSparseBitSetOrNull(Bits liveDocs) {\n         if (liveDocs instanceof SparseFixedBitSet) {\n             return (BitSet) liveDocs;\n         } else if (liveDocs instanceof CombinedBitSet\n-                        // if the underlying role bitset is sparse\n-                        && ((CombinedBitSet) liveDocs).getFirst() instanceof SparseFixedBitSet) {\n-            return (BitSet) liveDocs;\n-        } else {\n-            return null;\n-        }\n+            // if the underlying role bitset is sparse\n+            && ((CombinedBitSet) liveDocs).getFirst() instanceof SparseFixedBitSet) {\n+                return (BitSet) liveDocs;\n+            } else {\n+                return null;\n+            }\n \n     }\n \n-    static void intersectScorerAndBitSet(Scorer scorer, BitSet acceptDocs,\n-                                         LeafCollector collector, Runnable checkCancelled) throws IOException {\n+    static void intersectScorerAndBitSet(Scorer scorer, BitSet acceptDocs, LeafCollector collector, Runnable checkCancelled)\n+        throws IOException {\n         collector.setScorer(scorer);\n         // ConjunctionDISI uses the DocIdSetIterator#cost() to order the iterators, so if roleBits has the lowest cardinality it should\n         // be used first:\n-        DocIdSetIterator iterator = ConjunctionDISI.intersectIterators(Arrays.asList(new BitSetIterator(acceptDocs,\n-            acceptDocs.approximateCardinality()), scorer.iterator()));\n+        DocIdSetIterator iterator = ConjunctionUtils.intersectIterators(\n+            Arrays.asList(new BitSetIterator(acceptDocs, acceptDocs.approximateCardinality()), scorer.iterator())\n+        );\n         int seen = 0;\n         checkCancelled.run();\n         for (int docId = iterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = iterator.nextDoc()) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMDAyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385810022", "body": "let's throw an UnsupportedOperationException? (this is only used when asking a DirectoryReader to take into account some new changes in a directory, which should never happen with this impl)", "bodyText": "let's throw an UnsupportedOperationException? (this is only used when asking a DirectoryReader to take into account some new changes in a directory, which should never happen with this impl)", "bodyHTML": "<p dir=\"auto\">let's throw an UnsupportedOperationException? (this is only used when asking a DirectoryReader to take into account some new changes in a directory, which should never happen with this impl)</p>", "author": "jpountz", "createdAt": "2020-02-28T16:58:48Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -410,7 +412,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         @Override\n         protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n         }\n \n         @Override\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -349,297 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements QueryCancellable {\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n+            return action;\n         }\n \n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n-            }\n-        }\n-\n-        @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n+            return false;\n         }\n \n         @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -347,297 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface Cancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements Cancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n-\n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private final Holder<Cancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n+            return action;\n         }\n \n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, Cancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final Cancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r385811360", "body": "If we want to reduce the overhead to a minimum, we could make `MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK` a power of two minus 1 (e.g. `(1 << 4) - 1`, ie. `15`, and use a mask instead of a remainder: `(calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0`.", "bodyText": "If we want to reduce the overhead to a minimum, we could make MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK a power of two minus 1 (e.g. (1 << 4) - 1, ie. 15, and use a mask instead of a remainder: (calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0.", "bodyHTML": "<p dir=\"auto\">If we want to reduce the overhead to a minimum, we could make <code>MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK</code> a power of two minus 1 (e.g. <code>(1 &lt;&lt; 4) - 1</code>, ie. <code>15</code>, and use a mask instead of a remainder: <code>(calls++ &amp; MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0</code>.</p>", "author": "jpountz", "createdAt": "2020-02-28T17:01:20Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +346,298 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface Cancellable {\n+\n+        boolean isEnabled();\n+        void checkCancelled();\n+        default void checkDirReaderCancelled() {\n+            checkCancelled();\n+        }\n+        void unsetCheckTimeout();\n+    }\n+\n+    public static class CancellableImpl implements Cancellable {\n+\n+        private Runnable checkCancelled;\n+        private Runnable checkTimeout;\n+\n+        private CancellableImpl() {\n+        }\n+\n+        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n+            this.checkCancelled = checkCancelled;\n+            this.checkTimeout = checkTimeout;\n+        }\n+\n+        @Override\n+        public boolean isEnabled() {\n+            return checkCancelled != null || checkTimeout != null;\n+        }\n+\n+        @Override\n+        public void checkCancelled() {\n+            if (checkTimeout != null) {\n+                checkTimeout.run();\n+            }\n+            if (checkCancelled != null) {\n+                checkCancelled.run();\n+            }\n+        }\n+\n+        @Override\n+        public void unsetCheckTimeout() {\n+            this.checkTimeout = null;\n+        }\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellable);\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            return in;\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n+     */\n+    private static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<Cancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    private static class ExitableTerms extends FilterTerms {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, Cancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final Cancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkDirReaderCancelled();\n+            return in.next();\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n+     */\n+    private static class ExitablePointValues extends PointValues {\n+\n+        private final PointValues in;\n+        private final Cancellable cancellable;\n+\n+        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+            this.cancellable.checkDirReaderCancelled();\n+        }\n+\n+        @Override\n+        public void intersect(IntersectVisitor visitor) throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n+        }\n+\n+        @Override\n+        public long estimatePointCount(IntersectVisitor visitor) {\n+            cancellable.checkDirReaderCancelled();\n+            return in.estimatePointCount(visitor);\n+        }\n+\n+        @Override\n+        public byte[] getMinPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMinPackedValue();\n+        }\n+\n+        @Override\n+        public byte[] getMaxPackedValue() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getMaxPackedValue();\n+        }\n+\n+        @Override\n+        public int getNumDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumDimensions();\n+        }\n+\n+        @Override\n+        public int getNumIndexDimensions() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getNumIndexDimensions();\n+        }\n+\n+        @Override\n+        public int getBytesPerDimension() throws IOException {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getBytesPerDimension();\n+        }\n+\n+        @Override\n+        public long size() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.size();\n+        }\n+\n+        @Override\n+        public int getDocCount() {\n+            cancellable.checkDirReaderCancelled();\n+            return in.getDocCount();\n+        }\n+    }\n+\n+    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n+\n+        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n+\n+        private final PointValues.IntersectVisitor in;\n+        private final Cancellable cancellable;\n+        private int calls;\n+\n+        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n+            this.in = in;\n+            this.cancellable = cancellable;\n+        }\n+\n+        private void checkAndThrowWithSampling() {\n+            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {", "originalCommit": "9ebd847614c3c6c4f12ec2df7682c18fed6d67ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAyMTkyNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386021926", "bodyText": "Could you please explain why power of two - 1 is better?", "author": "matriv", "createdAt": "2020-02-29T11:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMwODQ0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386308440", "bodyText": "Masks are typically cheaper than remainders. And a%b is the same as a & (b-1) when a is positive and b is a power of two.", "author": "jpountz", "createdAt": "2020-03-02T10:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MDEwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386370101", "bodyText": "Thank you!", "author": "matriv", "createdAt": "2020-03-02T12:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgxMTM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..c1bf47c7571 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -599,19 +601,19 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n \n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n+        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n \n         private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n+        private final QueryCancellable cancellable;\n         private int calls;\n \n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n+        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n             this.in = in;\n             this.cancellable = cancellable;\n         }\n \n         private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n+            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n                 cancellable.checkDirReaderCancelled();\n             }\n         }\n", "next_change": {"commit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c1bf47c7571..e7317af8920 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -614,7 +579,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         private void checkAndThrowWithSampling() {\n             if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkDirReaderCancelled();\n+                cancellable.checkCancelled();\n             }\n         }\n \n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n+            return action;\n         }\n \n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 570dbebb6ea..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -347,297 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface Cancellable {\n-\n-        boolean isEnabled();\n-        void checkCancelled();\n-        default void checkDirReaderCancelled() {\n-            checkCancelled();\n-        }\n-        void unsetCheckTimeout();\n-    }\n-\n-    public static class CancellableImpl implements Cancellable {\n-\n-        private Runnable checkCancelled;\n-        private Runnable checkTimeout;\n-\n-        private CancellableImpl() {\n-        }\n-\n-        public CancellableImpl(Runnable checkTimeout, Runnable checkCancelled) {\n-            this.checkCancelled = checkCancelled;\n-            this.checkTimeout = checkTimeout;\n-        }\n-\n-        @Override\n-        public boolean isEnabled() {\n-            return checkCancelled != null || checkTimeout != null;\n-        }\n-\n-        @Override\n-        public void checkCancelled() {\n-            if (checkTimeout != null) {\n-                checkTimeout.run();\n-            }\n-            if (checkCancelled != null) {\n-                checkCancelled.run();\n-            }\n-        }\n-\n-        @Override\n-        public void unsetCheckTimeout() {\n-            this.checkTimeout = null;\n-        }\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<Cancellable> cancellable) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellable);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            return in;\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link Cancellable}.\n-     */\n-    private static class CancellableLeafReader extends FilterLeafReader {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private final Holder<Cancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<Cancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get().isEnabled()) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get().isEnabled() && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n+            return action;\n         }\n \n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link Cancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    private static class ExitableTerms extends FilterTerms {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, Cancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final Cancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, Cancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkDirReaderCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    private static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final Cancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkDirReaderCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkDirReaderCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = 10;\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final Cancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, Cancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if (calls++ % MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK == 0) {\n-                cancellable.checkDirReaderCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkDirReaderCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkDirReaderCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "url": "https://github.com/elastic/elasticsearch/commit/0bf64f0efbde5c080fab3c51667a81fe113cbcd2", "message": "address comments", "committedDate": "2020-02-29T11:42:57Z", "type": "commit"}, {"oid": "3936a05c6adb5c38bb33d370d6e05db93dd3d872", "url": "https://github.com/elastic/elasticsearch/commit/3936a05c6adb5c38bb33d370d6e05db93dd3d872", "message": "fix revert", "committedDate": "2020-02-29T16:00:24Z", "type": "commit"}, {"oid": "9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "url": "https://github.com/elastic/elasticsearch/commit/9bf0fe3d64f140fc2e534257a6eae073ea1b5c95", "message": "fix revert", "committedDate": "2020-02-29T16:01:31Z", "type": "commit"}, {"oid": "ce51935a96c3d59af66205144924f3ff1b32d17e", "url": "https://github.com/elastic/elasticsearch/commit/ce51935a96c3d59af66205144924f3ff1b32d17e", "message": "move impl to QueryPhase", "committedDate": "2020-02-29T17:26:42Z", "type": "commit"}, {"oid": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "url": "https://github.com/elastic/elasticsearch/commit/9695114f3028f98ae59dc5ff7481aab3251bce9f", "message": "unit test wrapping and exit", "committedDate": "2020-03-01T12:10:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958322", "body": "Let's use a method ref instead in order to avoid creating an anonymous class\r\n```suggestion\r\n                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\r\n```", "bodyText": "Let's use a method ref instead in order to avoid creating an anonymous class\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    return new CancellableBulkScorer(in, () -> checkCancelled());\n          \n          \n            \n                                    return new CancellableBulkScorer(in, cancellable::checkCancelled);", "bodyHTML": "<p dir=\"auto\">Let's use a method ref instead in order to avoid creating an anonymous class</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">CancellableBulkScorer</span>(in, <span class=\"x x-first\">() </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x x-last\"> </span>checkCancelled<span class=\"x x-first x-last\">()</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">CancellableBulkScorer</span>(in, <span class=\"x x-first\">cancellable</span><span class=\"pl-k x x-last\">::</span>checkCancelled);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jpountz", "createdAt": "2020-03-03T11:28:04Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -244,7 +269,7 @@ public Scorer scorer(LeafReaderContext context) throws IOException {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, checkCancelled);\n+                        return new CancellableBulkScorer(in, () -> checkCancelled());", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d562cf1d4a23d023685095dfa18a1448574dd475", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..749f981f905 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -269,7 +271,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> checkCancelled());\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -271,7 +258,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n+                        return new CancellableBulkScorer(in, cancellable::shouldExit);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -258,7 +261,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::shouldExit);\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -269,7 +261,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n                 public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n                     BulkScorer in = weight.bulkScorer(context);\n                     if (in != null) {\n-                        return new CancellableBulkScorer(in, () -> checkCancelled());\n+                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n                     } else {\n                         return null;\n                     }\n", "next_change": {"commit": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..0454d494fea 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -266,33 +245,38 @@ public class ContextIndexSearcher extends IndexSearcher {\n                         return null;\n                     }\n                 }\n+\n+                @Override\n+                public int count(LeafReaderContext context) throws IOException {\n+                    return weight.count(context);\n+                }\n             };\n         } else {\n             return weight;\n         }\n     }\n \n-\n     private static BitSet getSparseBitSetOrNull(Bits liveDocs) {\n         if (liveDocs instanceof SparseFixedBitSet) {\n             return (BitSet) liveDocs;\n         } else if (liveDocs instanceof CombinedBitSet\n-                        // if the underlying role bitset is sparse\n-                        && ((CombinedBitSet) liveDocs).getFirst() instanceof SparseFixedBitSet) {\n-            return (BitSet) liveDocs;\n-        } else {\n-            return null;\n-        }\n+            // if the underlying role bitset is sparse\n+            && ((CombinedBitSet) liveDocs).getFirst() instanceof SparseFixedBitSet) {\n+                return (BitSet) liveDocs;\n+            } else {\n+                return null;\n+            }\n \n     }\n \n-    static void intersectScorerAndBitSet(Scorer scorer, BitSet acceptDocs,\n-                                         LeafCollector collector, Runnable checkCancelled) throws IOException {\n+    static void intersectScorerAndBitSet(Scorer scorer, BitSet acceptDocs, LeafCollector collector, Runnable checkCancelled)\n+        throws IOException {\n         collector.setScorer(scorer);\n         // ConjunctionDISI uses the DocIdSetIterator#cost() to order the iterators, so if roleBits has the lowest cardinality it should\n         // be used first:\n-        DocIdSetIterator iterator = ConjunctionDISI.intersectIterators(Arrays.asList(new BitSetIterator(acceptDocs,\n-            acceptDocs.approximateCardinality()), scorer.iterator()));\n+        DocIdSetIterator iterator = ConjunctionUtils.intersectIterators(\n+            Arrays.asList(new BitSetIterator(acceptDocs, acceptDocs.approximateCardinality()), scorer.iterator())\n+        );\n         int seen = 0;\n         checkCancelled.run();\n         for (int docId = iterator.nextDoc(); docId < DocIdSetIterator.NO_MORE_DOCS; docId = iterator.nextDoc()) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1ODU4OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386958588", "body": "can you avoid doing a null check every time we check whether the request should be cancelled, like the code did before?", "bodyText": "can you avoid doing a null check every time we check whether the request should be cancelled, like the code did before?", "bodyHTML": "<p dir=\"auto\">can you avoid doing a null check every time we check whether the request should be cancelled, like the code did before?</p>", "author": "jpountz", "createdAt": "2020-03-03T11:28:40Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -207,8 +233,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector, () -> checkCancelled());", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d562cf1d4a23d023685095dfa18a1448574dd475", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..749f981f905 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -233,7 +234,8 @@ public class ContextIndexSearcher extends IndexSearcher {\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector, () -> checkCancelled());\n+                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n+                            this.cancellable == null ? () -> {} : this::checkCancelled);\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..c5543b36a61 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -235,7 +235,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable == null ? () -> {} : this::checkCancelled);\n+                            this.cancellable == null ? () -> {} : cancellable::checkCancelled);\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c5543b36a61..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -235,7 +222,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable == null ? () -> {} : cancellable::checkCancelled);\n+                            this.cancellable.isTimeoutEnabled() ? cancellable::shouldExit : () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -222,7 +225,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable.isTimeoutEnabled() ? cancellable::shouldExit : () -> {});\n+                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -233,7 +224,8 @@ public class ContextIndexSearcher extends IndexSearcher {\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector, () -> checkCancelled());\n+                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n+                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..1e15db5a45a 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -224,8 +202,12 @@ public class ContextIndexSearcher extends IndexSearcher {\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n+                    intersectScorerAndBitSet(\n+                        scorer,\n+                        liveDocsBitSet,\n+                        leafCollector,\n+                        this.cancellable.isEnabled() ? cancellable::checkCancelled : () -> {}\n+                    );\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 1e15db5a45a..2d2ca8bf4d6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -216,39 +323,6 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n         }\n     }\n \n-    private Weight wrapWeight(Weight weight) {\n-        if (cancellable.isEnabled()) {\n-            return new Weight(weight.getQuery()) {\n-                @Override\n-                public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public boolean isCacheable(LeafReaderContext ctx) {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public Scorer scorer(LeafReaderContext context) throws IOException {\n-                    return weight.scorer(context);\n-                }\n-\n-                @Override\n-                public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n-                    BulkScorer in = weight.bulkScorer(context);\n-                    if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n-                    } else {\n-                        return null;\n-                    }\n-                }\n-            };\n-        } else {\n-            return weight;\n-        }\n-    }\n-\n     private static BitSet getSparseBitSetOrNull(Bits liveDocs) {\n         if (liveDocs instanceof SparseFixedBitSet) {\n             return (BitSet) liveDocs;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386959490", "body": "this constructor seems to always be called with a `Holder` around a `null`, so let's remove it from the ctor arguments and just set `cancellableHolder = new Holder<>(null);`?", "bodyText": "this constructor seems to always be called with a Holder around a null, so let's remove it from the ctor arguments and just set cancellableHolder = new Holder<>(null);?", "bodyHTML": "<p dir=\"auto\">this constructor seems to always be called with a <code>Holder</code> around a <code>null</code>, so let's remove it from the ctor arguments and just set <code>cancellableHolder = new Holder&lt;&gt;(null);</code>?</p>", "author": "jpountz", "createdAt": "2020-03-03T11:30:32Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk3OTE4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386979181", "bodyText": "The issue is that we need to pass it in the ctor because we need to use it in the constructor: https://github.com/elastic/elasticsearch/pull/52822/files/9695114f3028f98ae59dc5ff7481aab3251bce9f#diff-913ad694a7d744ee93ae1dac48d67b0eR368\nso that it's passed down the object tree properly.", "author": "matriv", "createdAt": "2020-03-03T12:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk5MDQ3NA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386990474", "bodyText": "Ah, I see. Nevermind then.", "author": "jpountz", "createdAt": "2020-03-03T12:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyNzA0OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387327048", "bodyText": "I also wonder if we can replace the Holder with a mutable QueryTimeout implementation:\nSomething like:\n   private static class MutableQueryTimeout implements QueryTimeout {\n        private final Set<Runnable> runnables = new HashSet<>();\n\n        Object add(Runnable action) {\n            if (runnables.add(action) == false) {\n                throw new IllegalArgumentException(\"already added\");\n            }\n            return action;\n        }\n\n        boolean remove(Runnable action) {\n            return runnables.remove(action);\n        }\n\n        @Override\n        public boolean shouldExit() {\n            for (Runnable timeout : runnables) {\n                timeout.run();\n            }\n            return false;\n        }\n\n        @Override\n        public boolean isTimeoutEnabled() {\n            return runnables.size() > 0;\n        }\n    }\n\nThis way you can expose a simple QueryTimeout in the wrapped reader and keep the logic simple there ?\nThe ContextIndexSearcher could then expose the addQueryTimeout, removeQueryTimeout directly for the QueryPhase modification.", "author": "jimczi", "createdAt": "2020-03-03T22:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk1OTQ5MA=="}], "type": "inlineReview", "revised_code": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n+            return action;\n         }\n \n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+            return action;\n         }\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MDY4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386960687", "body": "can you add a comment about why we're not wrapping CompletionTerms? I also wonder that this `instanceof` logic might be fragile as terms may be wrapped e.g. if document-level security is used?", "bodyText": "can you add a comment about why we're not wrapping CompletionTerms? I also wonder that this instanceof logic might be fragile as terms may be wrapped e.g. if document-level security is used?", "bodyHTML": "<p dir=\"auto\">can you add a comment about why we're not wrapping CompletionTerms? I also wonder that this <code>instanceof</code> logic might be fragile as terms may be wrapped e.g. if document-level security is used?</p>", "author": "jpountz", "createdAt": "2020-03-03T11:32:44Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk5MDkwNA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386990904", "bodyText": "Added a comment.\n\nWhat other wrapping classes could we encouter?\nShould we have another ExitableTerms class that extends CompletionTerms and also wrap those with cancellation?", "author": "matriv", "createdAt": "2020-03-03T12:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MDY4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d562cf1d4a23d023685095dfa18a1448574dd475", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..749f981f905 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -413,6 +415,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (terms == null) {\n                 return null;\n             }\n+            // If we have a suggest CompletionQuery then the CompletionWeight#bulkScorer() will check that\n+            // the terms are instanceof CompletionTerms (not generic FilterTerms) and will throw an exception\n+            // if that's not the case.\n             return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n                     new ExitableTerms(terms, cancellable.get()) : terms;\n         }\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -348,277 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Supplier<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Supplier<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            // If we have a suggest CompletionQuery then the CompletionWeight#bulkScorer() will check that\n-            // the terms are instanceof CompletionTerms (not generic FilterTerms) and will throw an exception\n-            // if that's not the case.\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> implements Supplier<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        @Override\n-        public T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private int calls;\n-        private final QueryCancellable cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            checkAndThrowWithSampling();\n-            return in.next();\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n+            return action;\n         }\n \n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+            return action;\n         }\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MTM4MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r386961380", "body": "Can we do it on a regular interval (like in ExitableIntersectVisitor) instead of for every term, I worry that this might add noticeable overhead.", "bodyText": "Can we do it on a regular interval (like in ExitableIntersectVisitor) instead of for every term, I worry that this might add noticeable overhead.", "bodyHTML": "<p dir=\"auto\">Can we do it on a regular interval (like in ExitableIntersectVisitor) instead of for every term, I worry that this might add noticeable overhead.</p>", "author": "jpountz", "createdAt": "2020-03-03T11:33:56Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +345,266 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {\n+\n+        private final Holder<QueryCancellable> cancellableHolder;\n+\n+        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n+            super(in, new SubReaderWrapper() {\n+                @Override\n+                public LeafReader wrap(LeafReader reader) {\n+                    return new CancellableLeafReader(reader, cancellableHolder);\n+                }\n+            });\n+            this.cancellableHolder = cancellableHolder;\n+        }\n+\n+        private void setCancellable(QueryCancellable cancellable) {\n+            this.cancellableHolder.set(cancellable);\n+        }\n+\n+        @Override\n+        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n+            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableLeafReader extends FilterLeafReader {\n+\n+        private final Holder<QueryCancellable> cancellable;\n+\n+        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n+            super(leafReader);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public PointValues getPointValues(String field) throws IOException {\n+            final PointValues pointValues = in.getPointValues(field);\n+            if (pointValues == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+        }\n+\n+        @Override\n+        public Terms terms(String field) throws IOException {\n+            Terms terms = in.terms(field);\n+            if (terms == null) {\n+                return null;\n+            }\n+            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n+                    new ExitableTerms(terms, cancellable.get()) : terms;\n+        }\n+\n+        @Override\n+        public CacheHelper getCoreCacheHelper() {\n+            return in.getCoreCacheHelper();\n+        }\n+\n+        @Override\n+        public CacheHelper getReaderCacheHelper() {\n+            return in.getReaderCacheHelper();\n+        }\n+    }\n+\n+    /**\n+     * Helper class to be used as an immutable reference so that the underlying\n+     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n+     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n+     */\n+    private static class Holder<T> {\n+\n+        private T in;\n+\n+        private Holder(T in) {\n+            this.in = in;\n+        }\n+\n+        private void set(T in) {\n+            this.in = in;\n+        }\n+\n+        private T get() {\n+            return in;\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n+     */\n+    static class ExitableTerms extends FilterTerms {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n+            super(terms);\n+            this.cancellable = cancellable;\n+        }\n+\n+        @Override\n+        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n+            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n+        }\n+\n+        @Override\n+        public TermsEnum iterator() throws IOException {\n+            return new ExitableTermsEnum(in.iterator(), cancellable);\n+        }\n+    }\n+\n+    /**\n+     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n+     * implementing an exitable enumeration of terms.\n+     */\n+    private static class ExitableTermsEnum extends FilterTermsEnum {\n+\n+        private final QueryCancellable cancellable;\n+\n+        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n+            super(termsEnum);\n+            this.cancellable = cancellable;\n+            this.cancellable.checkCancelled();\n+        }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            // Before every iteration, check if the iteration should exit\n+            this.cancellable.checkCancelled();", "originalCommit": "9695114f3028f98ae59dc5ff7481aab3251bce9f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d562cf1d4a23d023685095dfa18a1448574dd475", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..749f981f905 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -489,10 +498,15 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n         @Override\n         public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n+            checkAndThrowWithSampling();\n             return in.next();\n         }\n+\n+        private void checkAndThrowWithSampling() {\n+            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n+                cancellable.checkCancelled();\n+            }\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..c5543b36a61 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -496,17 +496,17 @@ public class ContextIndexSearcher extends IndexSearcher {\n             this.cancellable.checkCancelled();\n         }\n \n-        @Override\n-        public BytesRef next() throws IOException {\n-            checkAndThrowWithSampling();\n-            return in.next();\n-        }\n-\n         private void checkAndThrowWithSampling() {\n             if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n                 cancellable.checkCancelled();\n             }\n         }\n+\n+        @Override\n+        public BytesRef next() throws IOException {\n+            checkAndThrowWithSampling();\n+            return in.next();\n+        }\n     }\n \n     /**\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c5543b36a61..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -348,277 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Supplier<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Supplier<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            // If we have a suggest CompletionQuery then the CompletionWeight#bulkScorer() will check that\n-            // the terms are instanceof CompletionTerms (not generic FilterTerms) and will throw an exception\n-            // if that's not the case.\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> implements Supplier<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        @Override\n-        public T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private int calls;\n-        private final QueryCancellable cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n+            return action;\n         }\n \n-        @Override\n-        public BytesRef next() throws IOException {\n-            checkAndThrowWithSampling();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex e7317af8920..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -346,265 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Holder<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Holder<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n+            return action;\n         }\n \n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        private T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public BytesRef next() throws IOException {\n-            // Before every iteration, check if the iteration should exit\n-            this.cancellable.checkCancelled();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "d562cf1d4a23d023685095dfa18a1448574dd475", "url": "https://github.com/elastic/elasticsearch/commit/d562cf1d4a23d023685095dfa18a1448574dd475", "message": "address comments", "committedDate": "2020-03-03T12:32:42Z", "type": "commit"}, {"oid": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "url": "https://github.com/elastic/elasticsearch/commit/6243ceddaf39089ce8fef6c14da6d22608099f3f", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-03T12:52:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3MjE0OQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387172149", "body": "```suggestion\r\n                            this.cancellable == null ? () -> {} : cancellable::checkCancelled);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        this.cancellable == null ? () -> {} : this::checkCancelled);\n          \n          \n            \n                                        this.cancellable == null ? () -> {} : cancellable::checkCancelled);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>cancellable <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">?</span> () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {} <span class=\"pl-k\">:</span> <span class=\"pl-c1 x x-first x-last\">this</span><span class=\"pl-k\">::</span>checkCancelled);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>cancellable <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span> <span class=\"pl-k\">?</span> () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {} <span class=\"pl-k\">:</span> <span class=\"x x-first x-last\">cancellable</span><span class=\"pl-k\">::</span>checkCancelled);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "jpountz", "createdAt": "2020-03-03T17:17:44Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -208,7 +235,7 @@ private void searchLeaf(LeafReaderContext ctx, Weight weight, Collector collecto\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                        checkCancelled == null ? () -> { } : checkCancelled);\n+                            this.cancellable == null ? () -> {} : this::checkCancelled);", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..c5543b36a61 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -235,7 +235,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable == null ? () -> {} : this::checkCancelled);\n+                            this.cancellable == null ? () -> {} : cancellable::checkCancelled);\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c5543b36a61..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -235,7 +222,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable == null ? () -> {} : cancellable::checkCancelled);\n+                            this.cancellable.isTimeoutEnabled() ? cancellable::shouldExit : () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -222,7 +225,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable.isTimeoutEnabled() ? cancellable::shouldExit : () -> {});\n+                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 749f981f905..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -235,7 +225,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n             if (scorer != null) {\n                 try {\n                     intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable == null ? () -> {} : this::checkCancelled);\n+                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..1e15db5a45a 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -224,8 +202,12 @@ public class ContextIndexSearcher extends IndexSearcher {\n             Scorer scorer = weight.scorer(ctx);\n             if (scorer != null) {\n                 try {\n-                    intersectScorerAndBitSet(scorer, liveDocsBitSet, leafCollector,\n-                            this.cancellable.isEnabled() ? cancellable::checkCancelled: () -> {});\n+                    intersectScorerAndBitSet(\n+                        scorer,\n+                        liveDocsBitSet,\n+                        leafCollector,\n+                        this.cancellable.isEnabled() ? cancellable::checkCancelled : () -> {}\n+                    );\n                 } catch (CollectionTerminatedException e) {\n                     // collection was terminated prematurely\n                     // continue with the following leaf\n", "next_change": {"commit": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 1e15db5a45a..2d2ca8bf4d6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -216,39 +323,6 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n         }\n     }\n \n-    private Weight wrapWeight(Weight weight) {\n-        if (cancellable.isEnabled()) {\n-            return new Weight(weight.getQuery()) {\n-                @Override\n-                public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public boolean isCacheable(LeafReaderContext ctx) {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                @Override\n-                public Scorer scorer(LeafReaderContext context) throws IOException {\n-                    return weight.scorer(context);\n-                }\n-\n-                @Override\n-                public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n-                    BulkScorer in = weight.bulkScorer(context);\n-                    if (in != null) {\n-                        return new CancellableBulkScorer(in, cancellable::checkCancelled);\n-                    } else {\n-                        return null;\n-                    }\n-                }\n-            };\n-        } else {\n-            return weight;\n-        }\n-    }\n-\n     private static BitSet getSparseBitSetOrNull(Bits liveDocs) {\n         if (liveDocs instanceof SparseFixedBitSet) {\n             return (BitSet) liveDocs;\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NzAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387177013", "body": "I tend to prefer fully-qualified calls to `TestUtil#nextInt` instead of adding a static import, given that this method name is quite generic.", "bodyText": "I tend to prefer fully-qualified calls to TestUtil#nextInt instead of adding a static import, given that this method name is quite generic.", "bodyHTML": "<p dir=\"auto\">I tend to prefer fully-qualified calls to <code>TestUtil#nextInt</code> instead of adding a static import, given that this method name is quite generic.</p>", "author": "jpountz", "createdAt": "2020-03-03T17:26:14Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -53,17 +57,19 @@ public static void setup() throws IOException {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20));\n+        int numDocs = nextInt(random(), 2, 20);\n+        indexRandomDocuments(w, numDocs, 0);\n         w.flush();\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20));\n+        indexRandomDocuments(w, nextInt(random(), 1, 20), numDocs);", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3f65da227ae..106f1e12a77 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -57,10 +62,10 @@ public class SearchCancellationTests extends ESTestCase {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        int numDocs = nextInt(random(), 2, 20);\n+        int numDocs = TestUtil.nextInt(random(), 2, 20);\n         indexRandomDocuments(w, numDocs, 0);\n         w.flush();\n-        indexRandomDocuments(w, nextInt(random(), 1, 20), numDocs);\n+        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20), numDocs);\n         reader = w.getReader();\n         w.close();\n     }\n", "next_change": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 106f1e12a77..2ef269890a8 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -62,18 +62,17 @@ public class SearchCancellationTests extends ESTestCase {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        int numDocs = TestUtil.nextInt(random(), 2, 20);\n-        indexRandomDocuments(w, numDocs, 0);\n+        indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20));\n         w.flush();\n-        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20), numDocs);\n+        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20));\n         reader = w.getReader();\n         w.close();\n     }\n \n-    private static void indexRandomDocuments(RandomIndexWriter w, int numDocs, int repeatChar) throws IOException {\n+    private static void indexRandomDocuments(RandomIndexWriter w, int numDocs) throws IOException {\n         for (int i = 1; i <= numDocs; ++i) {\n             Document doc = new Document();\n-            doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i + repeatChar), Field.Store.NO));\n+            doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i), Field.Store.NO));\n             doc.add(new IntPoint(POINT_FIELD_NAME, i, i + 1));\n             w.addDocument(doc);\n         }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3f65da227ae..3aafdcc5752 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -57,18 +62,17 @@ public class SearchCancellationTests extends ESTestCase {\n         // we need at least 2 segments - so no merges should be allowed\n         w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE);\n         w.setDoRandomForceMerge(false);\n-        int numDocs = nextInt(random(), 2, 20);\n-        indexRandomDocuments(w, numDocs, 0);\n+        indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20));\n         w.flush();\n-        indexRandomDocuments(w, nextInt(random(), 1, 20), numDocs);\n+        indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20));\n         reader = w.getReader();\n         w.close();\n     }\n \n-    private static void indexRandomDocuments(RandomIndexWriter w, int numDocs, int repeatChar) throws IOException {\n+    private static void indexRandomDocuments(RandomIndexWriter w, int numDocs) throws IOException {\n         for (int i = 1; i <= numDocs; ++i) {\n             Document doc = new Document();\n-            doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i + repeatChar), Field.Store.NO));\n+            doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i), Field.Store.NO));\n             doc.add(new IntPoint(POINT_FIELD_NAME, i, i + 1));\n             w.addDocument(doc);\n         }\n", "next_change": {"commit": "2a17e5302d92a9c15d4686cdd101d076867dbb4d", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3aafdcc5752..2fabddbb5d2 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -74,6 +67,7 @@ public class SearchCancellationTests extends ESTestCase {\n             Document doc = new Document();\n             doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i), Field.Store.NO));\n             doc.add(new IntPoint(POINT_FIELD_NAME, i, i + 1));\n+            doc.add(new KnnVectorField(KNN_FIELD_NAME, new float[] { 1.0f, 0.5f, 42.0f }));\n             w.addDocument(doc);\n         }\n     }\n", "next_change": {"commit": "200e061e3296aee830fb5e2c16b741a79a4034d5", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 2fabddbb5d2..19f6400badc 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -67,7 +67,7 @@ public class SearchCancellationTests extends ESTestCase {\n             Document doc = new Document();\n             doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i), Field.Store.NO));\n             doc.add(new IntPoint(POINT_FIELD_NAME, i, i + 1));\n-            doc.add(new KnnVectorField(KNN_FIELD_NAME, new float[] { 1.0f, 0.5f, 42.0f }));\n+            doc.add(new KnnFloatVectorField(KNN_FIELD_NAME, new float[] { 1.0f, 0.5f, 42.0f }));\n             w.addDocument(doc);\n         }\n     }\n", "next_change": {"commit": "32c17d79c55c109636659aa162ac7d38e863897c", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 19f6400badc..f8acccf69af 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -67,7 +67,7 @@ public class SearchCancellationTests extends ESTestCase {\n             Document doc = new Document();\n             doc.add(new StringField(STRING_FIELD_NAME, \"a\".repeat(i), Field.Store.NO));\n             doc.add(new IntPoint(POINT_FIELD_NAME, i, i + 1));\n-            doc.add(new KnnFloatVectorField(KNN_FIELD_NAME, new float[] { 1.0f, 0.5f, 42.0f }));\n+            doc.add(new XKnnFloatVectorField(KNN_FIELD_NAME, new float[] { 1.0f, 0.5f, 42.0f }));\n             w.addDocument(doc);\n         }\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "b2c9028384253416bd3e17de9e45af5eefe32764", "committedDate": "2022-04-19 21:26:28 -0700", "message": "Move io utils to core package (#85954)"}, {"oid": "2a17e5302d92a9c15d4686cdd101d076867dbb4d", "committedDate": "2022-10-04 09:13:09 -0400", "message": "Make `knn` search requests fully cancellable (#90612)"}, {"oid": "c24a2cab7e6c9bf8d6bd226ab5d06b0bc27d607a", "committedDate": "2022-10-12 13:52:20 -0400", "message": "Fix performance regression caused by cancellation check in vector scripts (#90804)"}, {"oid": "200e061e3296aee830fb5e2c16b741a79a4034d5", "committedDate": "2023-01-31 19:48:25 +0100", "message": "Upgrade to Lucene 9.5.0 (#93385)"}, {"oid": "32c17d79c55c109636659aa162ac7d38e863897c", "committedDate": "2023-04-17 09:05:49 -0400", "message": "Increase max number of vector dims to 2048 (#95257)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387178313", "body": "let's also test that it can interrupt iteration over the terms/points?", "bodyText": "let's also test that it can interrupt iteration over the terms/points?", "bodyHTML": "<p dir=\"auto\">let's also test that it can interrupt iteration over the terms/points?</p>", "author": "jpountz", "createdAt": "2020-03-03T17:28:33Z", "path": "server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java", "diffHunk": "@@ -92,4 +98,22 @@ public void testCancellableCollector() throws IOException {\n             () -> searcher.search(new MatchAllDocsQuery(), collector));\n     }\n \n+    public void testCancellableDirectoryReader() throws IOException {\n+        AtomicBoolean cancelled = new AtomicBoolean();\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        searcher.setCancellable(() -> {\n+            if (cancelled.get()) {\n+                throw new TaskCancelledException(\"cancelled\");\n+            }\n+        });\n+        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n+        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+    }", "originalCommit": "6243ceddaf39089ce8fef6c14da6d22608099f3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcyMTA2Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387721067", "bodyText": "Can you also test the removal of the runnable ?", "author": "jimczi", "createdAt": "2020-03-04T14:58:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3ODMxMw=="}], "type": "inlineReview", "revised_code": {"commit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3f65da227ae..106f1e12a77 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -107,13 +112,40 @@ public class SearchCancellationTests extends ESTestCase {\n                 throw new TaskCancelledException(\"cancelled\");\n             }\n         });\n-        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n-        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(\"a.*\").toAutomaton());\n \n-        cancelled.set(true);\n         expectThrows(TaskCancelledException.class,\n                 () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n         expectThrows(TaskCancelledException.class,\n-                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).intersect(automaton, null));\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME));\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME));\n+\n+        cancelled.set(false); // Avoid exception during construction of the wrapper objects\n+        Terms terms = searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME);\n+        TermsEnum termsIterator = terms.iterator();\n+        TermsEnum termsIntersect = terms.intersect(automaton, null);\n+        PointValues pointValues = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class, termsIterator::next);\n+        expectThrows(TaskCancelledException.class, termsIntersect::next);\n+        expectThrows(TaskCancelledException.class, pointValues::getDocCount);\n+        expectThrows(TaskCancelledException.class, pointValues::getNumDimensions);\n+        expectThrows(TaskCancelledException.class, () -> pointValues.intersect(new PointValues.IntersectVisitor() {\n+            @Override\n+            public void visit(int docID) {\n+            }\n+\n+            @Override\n+            public void visit(int docID, byte[] packedValue) {\n+            }\n+\n+            @Override\n+            public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+                return null;\n+            }\n+        }));\n     }\n }\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 106f1e12a77..3aafdcc5752 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -127,25 +140,42 @@ public class SearchCancellationTests extends ESTestCase {\n         Terms terms = searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME);\n         TermsEnum termsIterator = terms.iterator();\n         TermsEnum termsIntersect = terms.intersect(automaton, null);\n-        PointValues pointValues = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n+        PointValues pointValues1 = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n         cancelled.set(true);\n         expectThrows(TaskCancelledException.class, termsIterator::next);\n         expectThrows(TaskCancelledException.class, termsIntersect::next);\n-        expectThrows(TaskCancelledException.class, pointValues::getDocCount);\n-        expectThrows(TaskCancelledException.class, pointValues::getNumDimensions);\n-        expectThrows(TaskCancelledException.class, () -> pointValues.intersect(new PointValues.IntersectVisitor() {\n-            @Override\n-            public void visit(int docID) {\n-            }\n-\n-            @Override\n-            public void visit(int docID, byte[] packedValue) {\n-            }\n-\n-            @Override\n-            public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-                return null;\n-            }\n-        }));\n+        expectThrows(TaskCancelledException.class, pointValues1::getDocCount);\n+        expectThrows(TaskCancelledException.class, pointValues1::getNumIndexDimensions);\n+        expectThrows(TaskCancelledException.class, () -> pointValues1.intersect(new PointValuesIntersectVisitor()));\n+\n+        cancelled.set(false); // Avoid exception during construction of the wrapper objects\n+        // Re-initialize objects so that we reset the `calls` counter used to avoid cancellation check\n+        // on every iteration and assure that cancellation would normally happen if we hadn't removed the\n+        // cancellation runnable.\n+        termsIterator = terms.iterator();\n+        termsIntersect = terms.intersect(automaton, null);\n+        PointValues pointValues2 = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n+        cancelled.set(true);\n+        searcher.removeQueryCancellation(cancellation);\n+        termsIterator.next();\n+        termsIntersect.next();\n+        pointValues2.getDocCount();\n+        pointValues2.getNumIndexDimensions();\n+        pointValues2.intersect(new PointValuesIntersectVisitor());\n+    }\n+\n+    private static class PointValuesIntersectVisitor implements PointValues.IntersectVisitor {\n+        @Override\n+        public void visit(int docID) {\n+        }\n+\n+        @Override\n+        public void visit(int docID, byte[] packedValue) {\n+        }\n+\n+        @Override\n+        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+            return PointValues.Relation.CELL_CROSSES_QUERY;\n+        }\n     }\n }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3f65da227ae..3aafdcc5752 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -81,39 +85,97 @@ public class SearchCancellationTests extends ESTestCase {\n         reader = null;\n     }\n \n+    public void testAddingCancellationActions() throws IOException {\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        NullPointerException npe = expectThrows(NullPointerException.class, () -> searcher.addQueryCancellation(null));\n+        assertEquals(\"cancellation runnable should not be null\", npe.getMessage());\n+\n+        Runnable r = () -> {};\n+        searcher.addQueryCancellation(r);\n+        IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> searcher.addQueryCancellation(r));\n+        assertEquals(\"Cancellation runnable already added\", iae.getMessage());\n+    }\n+\n     public void testCancellableCollector() throws IOException {\n-        TotalHitCountCollector collector = new TotalHitCountCollector();\n-        AtomicBoolean cancelled = new AtomicBoolean();\n+        TotalHitCountCollector collector1 = new TotalHitCountCollector();\n+        Runnable cancellation = () -> { throw new TaskCancelledException(\"cancelled\"); };\n         ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n             IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n-        searcher.setCancellable(() -> {\n-            if (cancelled.get()) {\n-                throw new TaskCancelledException(\"cancelled\");\n-            }\n-        });\n-        searcher.search(new MatchAllDocsQuery(), collector);\n-        assertThat(collector.getTotalHits(), equalTo(reader.numDocs()));\n-        cancelled.set(true);\n+\n+        searcher.search(new MatchAllDocsQuery(), collector1);\n+        assertThat(collector1.getTotalHits(), equalTo(reader.numDocs()));\n+\n+        searcher.addQueryCancellation(cancellation);\n         expectThrows(TaskCancelledException.class,\n-            () -> searcher.search(new MatchAllDocsQuery(), collector));\n+            () -> searcher.search(new MatchAllDocsQuery(), collector1));\n+\n+        searcher.removeQueryCancellation(cancellation);\n+        TotalHitCountCollector collector2 = new TotalHitCountCollector();\n+        searcher.search(new MatchAllDocsQuery(), collector2);\n+        assertThat(collector2.getTotalHits(), equalTo(reader.numDocs()));\n     }\n \n     public void testCancellableDirectoryReader() throws IOException {\n-        AtomicBoolean cancelled = new AtomicBoolean();\n-        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n-                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n-        searcher.setCancellable(() -> {\n+        AtomicBoolean cancelled = new AtomicBoolean(true);\n+        Runnable cancellation = () -> {\n             if (cancelled.get()) {\n                 throw new TaskCancelledException(\"cancelled\");\n-            }\n-        });\n-        searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator();\n-        searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount();\n+        }};\n+        ContextIndexSearcher searcher = new ContextIndexSearcher(reader,\n+                IndexSearcher.getDefaultSimilarity(), IndexSearcher.getDefaultQueryCache(), IndexSearcher.getDefaultQueryCachingPolicy());\n+        searcher.addQueryCancellation(cancellation);\n+        CompiledAutomaton automaton = new CompiledAutomaton(new RegExp(\"a.*\").toAutomaton());\n \n-        cancelled.set(true);\n         expectThrows(TaskCancelledException.class,\n                 () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).iterator());\n         expectThrows(TaskCancelledException.class,\n-                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME).getDocCount());\n+                () -> searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME).intersect(automaton, null));\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME));\n+        expectThrows(TaskCancelledException.class,\n+                () -> searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME));\n+\n+        cancelled.set(false); // Avoid exception during construction of the wrapper objects\n+        Terms terms = searcher.getIndexReader().leaves().get(0).reader().terms(STRING_FIELD_NAME);\n+        TermsEnum termsIterator = terms.iterator();\n+        TermsEnum termsIntersect = terms.intersect(automaton, null);\n+        PointValues pointValues1 = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n+        cancelled.set(true);\n+        expectThrows(TaskCancelledException.class, termsIterator::next);\n+        expectThrows(TaskCancelledException.class, termsIntersect::next);\n+        expectThrows(TaskCancelledException.class, pointValues1::getDocCount);\n+        expectThrows(TaskCancelledException.class, pointValues1::getNumIndexDimensions);\n+        expectThrows(TaskCancelledException.class, () -> pointValues1.intersect(new PointValuesIntersectVisitor()));\n+\n+        cancelled.set(false); // Avoid exception during construction of the wrapper objects\n+        // Re-initialize objects so that we reset the `calls` counter used to avoid cancellation check\n+        // on every iteration and assure that cancellation would normally happen if we hadn't removed the\n+        // cancellation runnable.\n+        termsIterator = terms.iterator();\n+        termsIntersect = terms.intersect(automaton, null);\n+        PointValues pointValues2 = searcher.getIndexReader().leaves().get(0).reader().getPointValues(POINT_FIELD_NAME);\n+        cancelled.set(true);\n+        searcher.removeQueryCancellation(cancellation);\n+        termsIterator.next();\n+        termsIntersect.next();\n+        pointValues2.getDocCount();\n+        pointValues2.getNumIndexDimensions();\n+        pointValues2.intersect(new PointValuesIntersectVisitor());\n+    }\n+\n+    private static class PointValuesIntersectVisitor implements PointValues.IntersectVisitor {\n+        @Override\n+        public void visit(int docID) {\n+        }\n+\n+        @Override\n+        public void visit(int docID, byte[] packedValue) {\n+        }\n+\n+        @Override\n+        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+            return PointValues.Relation.CELL_CROSSES_QUERY;\n+        }\n     }\n }\n", "next_change": {"commit": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "changed_code": [{"header": "diff --git a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\nindex 3aafdcc5752..861b71aad5e 100644\n--- a/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n+++ b/server/src/test/java/org/elasticsearch/search/SearchCancellationTests.java\n", "chunk": "@@ -166,12 +178,10 @@ public class SearchCancellationTests extends ESTestCase {\n \n     private static class PointValuesIntersectVisitor implements PointValues.IntersectVisitor {\n         @Override\n-        public void visit(int docID) {\n-        }\n+        public void visit(int docID) {}\n \n         @Override\n-        public void visit(int docID, byte[] packedValue) {\n-        }\n+        public void visit(int docID, byte[] packedValue) {}\n \n         @Override\n         public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "b2c9028384253416bd3e17de9e45af5eefe32764", "committedDate": "2022-04-19 21:26:28 -0700", "message": "Move io utils to core package (#85954)"}, {"oid": "2a17e5302d92a9c15d4686cdd101d076867dbb4d", "committedDate": "2022-10-04 09:13:09 -0400", "message": "Make `knn` search requests fully cancellable (#90612)"}, {"oid": "c24a2cab7e6c9bf8d6bd226ab5d06b0bc27d607a", "committedDate": "2022-10-12 13:52:20 -0400", "message": "Fix performance regression caused by cancellation check in vector scripts (#90804)"}, {"oid": "200e061e3296aee830fb5e2c16b741a79a4034d5", "committedDate": "2023-01-31 19:48:25 +0100", "message": "Upgrade to Lucene 9.5.0 (#93385)"}, {"oid": "32c17d79c55c109636659aa162ac7d38e863897c", "committedDate": "2023-04-17 09:05:49 -0400", "message": "Increase max number of vector dims to 2048 (#95257)"}]}, {"oid": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "url": "https://github.com/elastic/elasticsearch/commit/19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "message": "improve tests", "committedDate": "2020-03-03T19:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387323729", "body": "nit: This class deserves its own file. Is there a specific reason to rename from `ExitableDirectoryReader` ?", "bodyText": "nit: This class deserves its own file. Is there a specific reason to rename from ExitableDirectoryReader ?", "bodyHTML": "<p dir=\"auto\">nit: This class deserves its own file. Is there a specific reason to rename from <code>ExitableDirectoryReader</code> ?</p>", "author": "jimczi", "createdAt": "2020-03-03T22:07:40Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +347,278 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    /**\n+     * iFace which implements the query timeout / cancellation logic\n+     */\n+    public interface QueryCancellable {\n+\n+        void checkCancelled();\n+    }\n+\n+    /**\n+     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n+     */\n+    static class CancellableDirectoryReader extends FilterDirectoryReader {", "originalCommit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzNzczNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387337736", "bodyText": "Initially I didn't want to mix it up with Lucene's ExitableDirectoryReader, but I can rename. Only this class or also include the underlying wrapper classes?", "author": "matriv", "createdAt": "2020-03-03T22:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzODU2MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387338560", "bodyText": "Also if we move it to its own file then it needs to know of the MutableQueryTimeout.", "author": "matriv", "createdAt": "2020-03-03T22:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2Njk1OA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387366958", "bodyText": "Only this class or also include the underlying wrapper classes?\n\nAll of it, yes.\n\nAlso if we move it to its own file then it needs to know of the MutableQueryTimeout.\n\nWhy that ? The idea is to have a simple interface in the reader and to use the mutable impl only for the searcher. You can create one in the ctr like this:\n public ContextIndexSearcher(IndexReader reader,\n                                Similarity similarity,\n                                QueryCache queryCache,\n                                QueryCachingPolicy queryCachingPolicy) throws IOException {\n        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n    }\n\n    private ContextIndexSearcher(IndexReader reader,\n                                Similarity similarity,\n                                QueryCache queryCache,\n                                QueryCachingPolicy queryCachingPolicy,\n                                MutableQueryTimeout timeout) throws IOException {\n        super(ExitableDirectoryReader.wrap((DirectoryReader) reader, timeout));\n        this.queryTimeout = timeout;\n        setSimilarity(similarity);\n        setQueryCache(queryCache);\n        setQueryCachingPolicy(queryCachingPolicy);\n    }\n\n?", "author": "jimczi", "createdAt": "2020-03-04T00:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMzcyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c5543b36a61..139c48c543d 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -348,277 +335,33 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Supplier<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Supplier<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            // If we have a suggest CompletionQuery then the CompletionWeight#bulkScorer() will check that\n-            // the terms are instanceof CompletionTerms (not generic FilterTerms) and will throw an exception\n-            // if that's not the case.\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> implements Supplier<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        @Override\n-        public T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private int calls;\n-        private final QueryCancellable cancellable;\n+    private static class MutableQueryTimeout implements QueryTimeout {\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n+            return action;\n         }\n \n-        @Override\n-        public BytesRef next() throws IOException {\n-            checkAndThrowWithSampling();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n-        }\n-\n-        @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public boolean shouldExit() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n+            return false;\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isTimeoutEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -352,15 +355,14 @@ public class ContextIndexSearcher extends IndexSearcher {\n         }\n \n         @Override\n-        public boolean shouldExit() {\n+        public void checkCancelled() {\n             for (Runnable timeout : runnables) {\n                 timeout.run();\n             }\n-            return false;\n         }\n \n         @Override\n-        public boolean isTimeoutEnabled() {\n+        public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n     }\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex c5543b36a61..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -348,277 +338,32 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    /**\n-     * iFace which implements the query timeout / cancellation logic\n-     */\n-    public interface QueryCancellable {\n-\n-        void checkCancelled();\n-    }\n-\n-    /**\n-     * Wraps an {@link IndexReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableDirectoryReader extends FilterDirectoryReader {\n-\n-        private final Holder<QueryCancellable> cancellableHolder;\n-\n-        private CancellableDirectoryReader(DirectoryReader in, Holder<QueryCancellable> cancellableHolder) throws IOException {\n-            super(in, new SubReaderWrapper() {\n-                @Override\n-                public LeafReader wrap(LeafReader reader) {\n-                    return new CancellableLeafReader(reader, cancellableHolder);\n-                }\n-            });\n-            this.cancellableHolder = cancellableHolder;\n-        }\n-\n-        private void setCancellable(QueryCancellable cancellable) {\n-            this.cancellableHolder.set(cancellable);\n-        }\n-\n-        @Override\n-        protected DirectoryReader doWrapDirectoryReader(DirectoryReader in) {\n-            throw new UnsupportedOperationException(\"doWrapDirectoryReader() should never be invoked\");\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Wraps a {@link FilterLeafReader} with a {@link QueryCancellable}.\n-     */\n-    static class CancellableLeafReader extends FilterLeafReader {\n-\n-        private final Supplier<QueryCancellable> cancellable;\n-\n-        private CancellableLeafReader(LeafReader leafReader, Supplier<QueryCancellable> cancellable)  {\n-            super(leafReader);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public PointValues getPointValues(String field) throws IOException {\n-            final PointValues pointValues = in.getPointValues(field);\n-            if (pointValues == null) {\n-                return null;\n-            }\n-            return (cancellable.get() != null) ? new ExitablePointValues(pointValues, cancellable.get()) : pointValues;\n-        }\n-\n-        @Override\n-        public Terms terms(String field) throws IOException {\n-            Terms terms = in.terms(field);\n-            if (terms == null) {\n-                return null;\n-            }\n-            // If we have a suggest CompletionQuery then the CompletionWeight#bulkScorer() will check that\n-            // the terms are instanceof CompletionTerms (not generic FilterTerms) and will throw an exception\n-            // if that's not the case.\n-            return (cancellable.get() != null && terms instanceof CompletionTerms == false) ?\n-                    new ExitableTerms(terms, cancellable.get()) : terms;\n-        }\n-\n-        @Override\n-        public CacheHelper getCoreCacheHelper() {\n-            return in.getCoreCacheHelper();\n-        }\n-\n-        @Override\n-        public CacheHelper getReaderCacheHelper() {\n-            return in.getReaderCacheHelper();\n-        }\n-    }\n-\n-    /**\n-     * Helper class to be used as an immutable reference so that the underlying\n-     * {@link QueryCancellable} passed trough the hierarchy to the {@link Terms} and {@link PointValues}\n-     * during construction can be set later with {@link ContextIndexSearcher#setCancellable}\n-     */\n-    private static class Holder<T> implements Supplier<T> {\n-\n-        private T in;\n-\n-        private Holder(T in) {\n-            this.in = in;\n-        }\n-\n-        private void set(T in) {\n-            this.in = in;\n-        }\n-\n-        @Override\n-        public T get() {\n-            return in;\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTerms} that check for query cancellation or timeout.\n-     */\n-    static class ExitableTerms extends FilterTerms {\n-\n-        private final QueryCancellable cancellable;\n-\n-        private ExitableTerms(Terms terms, QueryCancellable cancellable) {\n-            super(terms);\n-            this.cancellable = cancellable;\n-        }\n-\n-        @Override\n-        public TermsEnum intersect(CompiledAutomaton compiled, BytesRef startTerm) throws IOException {\n-            return new ExitableTermsEnum(in.intersect(compiled, startTerm), cancellable);\n-        }\n-\n-        @Override\n-        public TermsEnum iterator() throws IOException {\n-            return new ExitableTermsEnum(in.iterator(), cancellable);\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link FilterTermsEnum} that is used by {@link ExitableTerms} for\n-     * implementing an exitable enumeration of terms.\n-     */\n-    private static class ExitableTermsEnum extends FilterTermsEnum {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n-        private int calls;\n-        private final QueryCancellable cancellable;\n+        private final Set<Runnable> runnables = new HashSet<>();\n \n-        private ExitableTermsEnum(TermsEnum termsEnum, QueryCancellable cancellable) {\n-            super(termsEnum);\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        private Runnable add(Runnable action) {\n+            Objects.requireNonNull(action, \"cancellation runnable should not be null\");\n+            if (runnables.add(action) == false) {\n+                throw new IllegalArgumentException(\"Cancellation runnable already added\");\n             }\n+            return action;\n         }\n \n-        @Override\n-        public BytesRef next() throws IOException {\n-            checkAndThrowWithSampling();\n-            return in.next();\n-        }\n-    }\n-\n-    /**\n-     * Wrapper class for {@link PointValues} that checks for query cancellation or timeout.\n-     */\n-    static class ExitablePointValues extends PointValues {\n-\n-        private final PointValues in;\n-        private final QueryCancellable cancellable;\n-\n-        private ExitablePointValues(PointValues in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-            this.cancellable.checkCancelled();\n-        }\n-\n-        @Override\n-        public void intersect(IntersectVisitor visitor) throws IOException {\n-            cancellable.checkCancelled();\n-            in.intersect(new ExitableIntersectVisitor(visitor, cancellable));\n-        }\n-\n-        @Override\n-        public long estimatePointCount(IntersectVisitor visitor) {\n-            cancellable.checkCancelled();\n-            return in.estimatePointCount(visitor);\n+        private void remove(Runnable action) {\n+            runnables.remove(action);\n         }\n \n         @Override\n-        public byte[] getMinPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMinPackedValue();\n-        }\n-\n-        @Override\n-        public byte[] getMaxPackedValue() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getMaxPackedValue();\n-        }\n-\n-        @Override\n-        public int getNumDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumDimensions();\n-        }\n-\n-        @Override\n-        public int getNumIndexDimensions() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getNumIndexDimensions();\n-        }\n-\n-        @Override\n-        public int getBytesPerDimension() throws IOException {\n-            cancellable.checkCancelled();\n-            return in.getBytesPerDimension();\n-        }\n-\n-        @Override\n-        public long size() {\n-            cancellable.checkCancelled();\n-            return in.size();\n-        }\n-\n-        @Override\n-        public int getDocCount() {\n-            cancellable.checkCancelled();\n-            return in.getDocCount();\n-        }\n-    }\n-\n-    private static class ExitableIntersectVisitor implements PointValues.IntersectVisitor {\n-\n-        private static final int MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK = (1 << 4) - 1; // 15\n-\n-        private final PointValues.IntersectVisitor in;\n-        private final QueryCancellable cancellable;\n-        private int calls;\n-\n-        private ExitableIntersectVisitor(PointValues.IntersectVisitor in, QueryCancellable cancellable) {\n-            this.in = in;\n-            this.cancellable = cancellable;\n-        }\n-\n-        private void checkAndThrowWithSampling() {\n-            if ((calls++ & MAX_CALLS_BEFORE_QUERY_TIMEOUT_CHECK) == 0) {\n-                cancellable.checkCancelled();\n+        public void checkCancelled() {\n+            for (Runnable timeout : runnables) {\n+                timeout.run();\n             }\n         }\n \n         @Override\n-        public void visit(int docID) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID);\n-        }\n-\n-        @Override\n-        public void visit(int docID, byte[] packedValue) throws IOException {\n-            checkAndThrowWithSampling();\n-            in.visit(docID, packedValue);\n-        }\n-\n-        @Override\n-        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n-            cancellable.checkCancelled();\n-            return in.compare(minPackedValue, maxPackedValue);\n-        }\n-\n-        @Override\n-        public void grow(int count) {\n-            cancellable.checkCancelled();\n-            in.grow(count);\n+        public boolean isEnabled() {\n+            return runnables.isEmpty() == false;\n         }\n     }\n }\n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -365,5 +376,9 @@ public class ContextIndexSearcher extends IndexSearcher {\n         public boolean isEnabled() {\n             return runnables.isEmpty() == false;\n         }\n+\n+        public void clear() {\n+            runnables.clear();\n+        }\n     }\n }\n", "next_change": {"commit": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 3e453c3cdef..00bfaa61fe8 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -381,4 +458,52 @@ public class ContextIndexSearcher extends IndexSearcher implements Releasable {\n             runnables.clear();\n         }\n     }\n+\n+    private static class QueueSizeBasedExecutor {\n+        private static final double LIMITING_FACTOR = 1.5;\n+\n+        private final ThreadPoolExecutor threadPoolExecutor;\n+\n+        QueueSizeBasedExecutor(ThreadPoolExecutor threadPoolExecutor) {\n+            this.threadPoolExecutor = threadPoolExecutor;\n+        }\n+\n+        public void invokeAll(Collection<? extends Runnable> tasks) {\n+            int i = 0;\n+\n+            for (Runnable task : tasks) {\n+                boolean shouldExecuteOnCallerThread = false;\n+\n+                // Execute last task on caller thread\n+                if (i == tasks.size() - 1) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                if (threadPoolExecutor.getQueue().size() >= (threadPoolExecutor.getMaximumPoolSize() * LIMITING_FACTOR)) {\n+                    shouldExecuteOnCallerThread = true;\n+                }\n+\n+                processTask(task, shouldExecuteOnCallerThread);\n+\n+                ++i;\n+            }\n+        }\n+\n+        protected void processTask(final Runnable task, final boolean shouldExecuteOnCallerThread) {\n+            if (task == null) {\n+                throw new IllegalArgumentException(\"Input is null\");\n+            }\n+\n+            if (shouldExecuteOnCallerThread == false) {\n+                try {\n+                    threadPoolExecutor.execute(task);\n+\n+                    return;\n+                } catch (@SuppressWarnings(\"unused\") RejectedExecutionException e) {\n+                    // Execute on caller thread\n+                }\n+            }\n+            task.run();\n+        }\n+    }\n }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyOTM4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387329382", "body": "See my comment below, I think this could be simplified into:\r\n`````\r\n            boolean timeoutSet = scrollContext == null && searchContext.timeout() != null &&\r\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\r\n            final Runnable timeoutRunnable;\r\n            if (timeoutSet) {\r\n                final long startTime = searchContext.getRelativeTimeInMillis();\r\n                final long timeout = searchContext.timeout().millis();\r\n                final long maxTime = startTime + timeout;\r\n                timeoutRunnable = searcher.addQueryTimeout(() -> {\r\n                    final long time = searchContext.getRelativeTimeInMillis();\r\n                    if (time > maxTime) {\r\n                        throw new TimeExceededException();\r\n                    }\r\n                });\r\n            } else {\r\n                timeoutRunnable = null;\r\n            }\r\n\r\n            if (searchContext.lowLevelCancellation()) {\r\n                SearchShardTask task = searchContext.getTask();\r\n                searcher.addQueryTimeout(() -> {\r\n                    if (task.isCancelled()) {\r\n                        throw new TaskCancelledException(\"cancelled\");\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                ...\r\n            } finally {\r\n              if (timeoutRunnable != null) {\r\n                 searcher.removeQueryTimeout(timeoutRunnable);\r\n              }\r\n           }\r\n`````\r\n", "bodyText": "See my comment below, I think this could be simplified into:\n            boolean timeoutSet = scrollContext == null && searchContext.timeout() != null &&\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\n            final Runnable timeoutRunnable;\n            if (timeoutSet) {\n                final long startTime = searchContext.getRelativeTimeInMillis();\n                final long timeout = searchContext.timeout().millis();\n                final long maxTime = startTime + timeout;\n                timeoutRunnable = searcher.addQueryTimeout(() -> {\n                    final long time = searchContext.getRelativeTimeInMillis();\n                    if (time > maxTime) {\n                        throw new TimeExceededException();\n                    }\n                });\n            } else {\n                timeoutRunnable = null;\n            }\n\n            if (searchContext.lowLevelCancellation()) {\n                SearchShardTask task = searchContext.getTask();\n                searcher.addQueryTimeout(() -> {\n                    if (task.isCancelled()) {\n                        throw new TaskCancelledException(\"cancelled\");\n                    }\n                });\n            }\n            try {\n                ...\n            } finally {\n              if (timeoutRunnable != null) {\n                 searcher.removeQueryTimeout(timeoutRunnable);\n              }\n           }", "bodyHTML": "<p dir=\"auto\">See my comment below, I think this could be simplified into:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"            boolean timeoutSet = scrollContext == null &amp;&amp; searchContext.timeout() != null &amp;&amp;\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\n            final Runnable timeoutRunnable;\n            if (timeoutSet) {\n                final long startTime = searchContext.getRelativeTimeInMillis();\n                final long timeout = searchContext.timeout().millis();\n                final long maxTime = startTime + timeout;\n                timeoutRunnable = searcher.addQueryTimeout(() -&gt; {\n                    final long time = searchContext.getRelativeTimeInMillis();\n                    if (time &gt; maxTime) {\n                        throw new TimeExceededException();\n                    }\n                });\n            } else {\n                timeoutRunnable = null;\n            }\n\n            if (searchContext.lowLevelCancellation()) {\n                SearchShardTask task = searchContext.getTask();\n                searcher.addQueryTimeout(() -&gt; {\n                    if (task.isCancelled()) {\n                        throw new TaskCancelledException(&quot;cancelled&quot;);\n                    }\n                });\n            }\n            try {\n                ...\n            } finally {\n              if (timeoutRunnable != null) {\n                 searcher.removeQueryTimeout(timeoutRunnable);\n              }\n           }\"><pre><code>            boolean timeoutSet = scrollContext == null &amp;&amp; searchContext.timeout() != null &amp;&amp;\n                searchContext.timeout().equals(SearchService.NO_TIMEOUT) == false;\n            final Runnable timeoutRunnable;\n            if (timeoutSet) {\n                final long startTime = searchContext.getRelativeTimeInMillis();\n                final long timeout = searchContext.timeout().millis();\n                final long maxTime = startTime + timeout;\n                timeoutRunnable = searcher.addQueryTimeout(() -&gt; {\n                    final long time = searchContext.getRelativeTimeInMillis();\n                    if (time &gt; maxTime) {\n                        throw new TimeExceededException();\n                    }\n                });\n            } else {\n                timeoutRunnable = null;\n            }\n\n            if (searchContext.lowLevelCancellation()) {\n                SearchShardTask task = searchContext.getTask();\n                searcher.addQueryTimeout(() -&gt; {\n                    if (task.isCancelled()) {\n                        throw new TaskCancelledException(\"cancelled\");\n                    }\n                });\n            }\n            try {\n                ...\n            } finally {\n              if (timeoutRunnable != null) {\n                 searcher.removeQueryTimeout(timeoutRunnable);\n              }\n           }\n</code></pre></div>", "author": "jimczi", "createdAt": "2020-03-03T22:19:46Z", "path": "server/src/main/java/org/elasticsearch/search/query/QueryPhase.java", "diffHunk": "@@ -272,20 +273,8 @@ static boolean executeInternal(SearchContext searchContext) throws QueryPhaseExe\n                 cancellationRunnable = null;\n             }\n \n-            final Runnable checkCancelled;\n-            if (timeoutRunnable != null && cancellationRunnable != null) {\n-                checkCancelled = () -> {\n-                    timeoutRunnable.run();\n-                    cancellationRunnable.run();\n-                };\n-            } else if (timeoutRunnable != null) {\n-                checkCancelled = timeoutRunnable;\n-            } else if (cancellationRunnable != null) {\n-                checkCancelled = cancellationRunnable;\n-            } else {\n-                checkCancelled = null;\n-            }\n-            searcher.setCheckCancelled(checkCancelled);\n+            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);", "originalCommit": "19bdbdf07825ecdb51d3a8e90e30a84ae5f224a4", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 83cd38de17f..5691af384a9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -255,54 +254,58 @@ public class QueryPhase implements SearchPhase {\n                 final long startTime = searchContext.getRelativeTimeInMillis();\n                 final long timeout = searchContext.timeout().millis();\n                 final long maxTime = startTime + timeout;\n-                timeoutRunnable = () -> {\n+                timeoutRunnable = searcher.addQueryCancellation(() -> {\n                     final long time = searchContext.getRelativeTimeInMillis();\n                     if (time > maxTime) {\n                         throw new TimeExceededException();\n                     }\n-                };\n+                });\n             } else {\n                 timeoutRunnable = null;\n             }\n \n-            final Runnable cancellationRunnable;\n             if (searchContext.lowLevelCancellation()) {\n                 SearchShardTask task = searchContext.getTask();\n-                cancellationRunnable = () -> { if (task.isCancelled()) throw new TaskCancelledException(\"cancelled\"); };\n-            } else {\n-                cancellationRunnable = null;\n+                searcher.addQueryCancellation(() -> {\n+                    if (task.isCancelled()) {\n+                        throw new TaskCancelledException(\"cancelled\");\n+                    }\n+                });\n             }\n \n-            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);\n-            searcher.setCancellable(cancellable);\n+            try {\n+                boolean shouldRescore;\n+                // if we are optimizing sort and there are no other collectors\n+                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n+                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n+                } else {\n+                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n+                }\n \n-            boolean shouldRescore;\n-            // if we are optimizing sort and there are no other collectors\n-            if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-            } else {\n-                shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-            }\n+                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n+                if (sortAndFormatsForRewrittenNumericSort != null) {\n+                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n+                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n+                }\n \n-            // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-            if (sortAndFormatsForRewrittenNumericSort != null) {\n-                searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-            }\n+                ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n+                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n+                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n+                    EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n+                    queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n+                    queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                }\n \n-            ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-            assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n-            if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n-                EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n-                queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n-                queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                return shouldRescore;\n+            } finally {\n+                // Search phase has finished, no longer need to check for timeout\n+                // otherwise aggregation phase might get cancelled.\n+                if (timeoutRunnable != null) {\n+                   searcher.removeQueryTimeout(timeoutRunnable);\n+                }\n             }\n-            // Search phase has finished, no longer need to check for timeout\n-            // otherwise aggregation phase might get cancelled.\n-            cancellable.unsetCheckTimeout();\n-            return shouldRescore;\n         } catch (Exception e) {\n             throw new QueryPhaseExecutionException(searchContext.shardTarget(), \"Failed to execute main query\", e);\n         }\n", "next_change": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 5691af384a9..4383f0eb545 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -303,7 +303,7 @@ public class QueryPhase implements SearchPhase {\n                 // Search phase has finished, no longer need to check for timeout\n                 // otherwise aggregation phase might get cancelled.\n                 if (timeoutRunnable != null) {\n-                   searcher.removeQueryTimeout(timeoutRunnable);\n+                   searcher.removeQueryCancellation(timeoutRunnable);\n                 }\n             }\n         } catch (Exception e) {\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 83cd38de17f..4383f0eb545 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -255,54 +254,58 @@ public class QueryPhase implements SearchPhase {\n                 final long startTime = searchContext.getRelativeTimeInMillis();\n                 final long timeout = searchContext.timeout().millis();\n                 final long maxTime = startTime + timeout;\n-                timeoutRunnable = () -> {\n+                timeoutRunnable = searcher.addQueryCancellation(() -> {\n                     final long time = searchContext.getRelativeTimeInMillis();\n                     if (time > maxTime) {\n                         throw new TimeExceededException();\n                     }\n-                };\n+                });\n             } else {\n                 timeoutRunnable = null;\n             }\n \n-            final Runnable cancellationRunnable;\n             if (searchContext.lowLevelCancellation()) {\n                 SearchShardTask task = searchContext.getTask();\n-                cancellationRunnable = () -> { if (task.isCancelled()) throw new TaskCancelledException(\"cancelled\"); };\n-            } else {\n-                cancellationRunnable = null;\n+                searcher.addQueryCancellation(() -> {\n+                    if (task.isCancelled()) {\n+                        throw new TaskCancelledException(\"cancelled\");\n+                    }\n+                });\n             }\n \n-            QueryCancellableImpl cancellable = new QueryCancellableImpl(timeoutRunnable, cancellationRunnable);\n-            searcher.setCancellable(cancellable);\n+            try {\n+                boolean shouldRescore;\n+                // if we are optimizing sort and there are no other collectors\n+                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n+                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n+                } else {\n+                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n+                }\n \n-            boolean shouldRescore;\n-            // if we are optimizing sort and there are no other collectors\n-            if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-            } else {\n-                shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-            }\n+                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n+                if (sortAndFormatsForRewrittenNumericSort != null) {\n+                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n+                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n+                }\n \n-            // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-            if (sortAndFormatsForRewrittenNumericSort != null) {\n-                searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-            }\n+                ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n+                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n+                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n+                    EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n+                    queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n+                    queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                }\n \n-            ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-            assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n-            if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n-                EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n-                queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n-                queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n+                return shouldRescore;\n+            } finally {\n+                // Search phase has finished, no longer need to check for timeout\n+                // otherwise aggregation phase might get cancelled.\n+                if (timeoutRunnable != null) {\n+                   searcher.removeQueryCancellation(timeoutRunnable);\n+                }\n             }\n-            // Search phase has finished, no longer need to check for timeout\n-            // otherwise aggregation phase might get cancelled.\n-            cancellable.unsetCheckTimeout();\n-            return shouldRescore;\n         } catch (Exception e) {\n             throw new QueryPhaseExecutionException(searchContext.shardTarget(), \"Failed to execute main query\", e);\n         }\n", "next_change": {"commit": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 4383f0eb545..8740f9af1a1 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -264,46 +183,23 @@ public class QueryPhase implements SearchPhase {\n                 timeoutRunnable = null;\n             }\n \n-            if (searchContext.lowLevelCancellation()) {\n-                SearchShardTask task = searchContext.getTask();\n-                searcher.addQueryCancellation(() -> {\n-                    if (task.isCancelled()) {\n-                        throw new TaskCancelledException(\"cancelled\");\n-                    }\n-                });\n-            }\n-\n             try {\n-                boolean shouldRescore;\n-                // if we are optimizing sort and there are no other collectors\n-                if (sortAndFormatsForRewrittenNumericSort != null && collectors.size() == 0 && searchContext.getProfilers() == null) {\n-                    shouldRescore = searchWithCollectorManager(searchContext, searcher, query, leafSorter, timeoutSet);\n-                } else {\n-                    shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n-                }\n-\n-                // if we rewrote numeric long or date sort, restore fieldDocs based on the original sort\n-                if (sortAndFormatsForRewrittenNumericSort != null) {\n-                    searchContext.sort(sortAndFormatsForRewrittenNumericSort); // restore SortAndFormats\n-                    restoreTopFieldDocs(queryResult, sortAndFormatsForRewrittenNumericSort);\n-                }\n-\n+                boolean shouldRescore = searchWithCollector(searchContext, searcher, query, collectors, hasFilterCollector, timeoutSet);\n                 ExecutorService executor = searchContext.indexShard().getThreadPool().executor(ThreadPool.Names.SEARCH);\n-                assert executor instanceof EWMATrackingEsThreadPoolExecutor ||\n-                    (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */) :\n-                    \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n+                assert executor instanceof EWMATrackingEsThreadPoolExecutor\n+                    || (executor instanceof EsThreadPoolExecutor == false /* in case thread pool is mocked out in tests */)\n+                    : \"SEARCH threadpool should have an executor that exposes EWMA metrics, but is of type \" + executor.getClass();\n                 if (executor instanceof EWMATrackingEsThreadPoolExecutor) {\n                     EWMATrackingEsThreadPoolExecutor rExecutor = (EWMATrackingEsThreadPoolExecutor) executor;\n                     queryResult.nodeQueueSize(rExecutor.getCurrentQueueSize());\n                     queryResult.serviceTimeEWMA((long) rExecutor.getTaskExecutionEWMA());\n                 }\n-\n                 return shouldRescore;\n             } finally {\n                 // Search phase has finished, no longer need to check for timeout\n                 // otherwise aggregation phase might get cancelled.\n                 if (timeoutRunnable != null) {\n-                   searcher.removeQueryCancellation(timeoutRunnable);\n+                    searcher.removeQueryCancellation(timeoutRunnable);\n                 }\n             }\n         } catch (Exception e) {\n", "next_change": {"commit": "f50725e197046c9fca5851c152fd650ed29efec2", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 8740f9af1a1..dd90cda7abb 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -207,7 +194,7 @@ public class QueryPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(\n+    private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n", "next_change": {"commit": "3bd41b2405378debfada5b469c0c331b8a392b1c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex dd90cda7abb..42f42f82ac9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -194,30 +234,31 @@ public class QueryPhase {\n         }\n     }\n \n+    private static Collector wrapWithProfilerCollectorIfNeeded(\n+        Profilers profilers,\n+        Collector collector,\n+        String profilerName,\n+        Collector... children\n+    ) {\n+        if (profilers == null) {\n+            return collector;\n+        }\n+        return new InternalProfileCollector(collector, profilerName, children);\n+    }\n+\n     private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n+        Collector collector,\n         boolean timeoutSet\n     ) throws IOException {\n-        // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n-        // add the top docs collector, the first collector context in the chain\n-        collectors.addFirst(topDocsFactory);\n-\n-        final Collector queryCollector;\n         if (searchContext.getProfilers() != null) {\n-            InternalProfileCollector profileCollector = QueryCollectorContext.createQueryCollectorWithProfiler(collectors);\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector(profileCollector);\n-            queryCollector = profileCollector;\n-        } else {\n-            queryCollector = QueryCollectorContext.createQueryCollector(collectors);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, queryCollector);\n+            searcher.search(query, collector);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": {"commit": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 42f42f82ac9..f4143c8975f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -234,31 +241,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static Collector wrapWithProfilerCollectorIfNeeded(\n+    private static CollectorManager<Collector, Void> wrapWithProfilerCollectorManagerIfNeeded(\n         Profilers profilers,\n         Collector collector,\n         String profilerName,\n         Collector... children\n     ) {\n         if (profilers == null) {\n-            return collector;\n+            return new SingleThreadCollectorManager(collector);\n         }\n-        return new InternalProfileCollector(collector, profilerName, children);\n+        return new InternalProfileCollectorManager(new InternalProfileCollector(collector, profilerName, children));\n     }\n \n-    private static void searchWithCollector(\n+    private static void searchWithCollectorManager(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        Collector collector,\n+        CollectorManager<Collector, Void> collectorManager,\n         boolean timeoutSet\n     ) throws IOException {\n         if (searchContext.getProfilers() != null) {\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollectorManager((InternalProfileCollectorManager) collectorManager);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, collector);\n+            searcher.search(query, collectorManager);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": null}]}}]}}]}}, {"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 4383f0eb545..8740f9af1a1 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -311,8 +207,14 @@ public class QueryPhase implements SearchPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(SearchContext searchContext, ContextIndexSearcher searcher, Query query,\n-            LinkedList<QueryCollectorContext> collectors, boolean hasFilterCollector, boolean timeoutSet) throws IOException {\n+    private static boolean searchWithCollector(\n+        SearchContext searchContext,\n+        ContextIndexSearcher searcher,\n+        Query query,\n+        LinkedList<QueryCollectorContext> collectors,\n+        boolean hasFilterCollector,\n+        boolean timeoutSet\n+    ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n         final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n         // add the top docs collector, the first collector context in the chain\n", "next_change": {"commit": "283f8acd9275d197453e7d9309e62f31abf51f51", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 8740f9af1a1..2e300be8d40 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -212,11 +195,10 @@ public class QueryPhase {\n         ContextIndexSearcher searcher,\n         Query query,\n         LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n         boolean timeoutSet\n     ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n+        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext);\n         // add the top docs collector, the first collector context in the chain\n         collectors.addFirst(topDocsFactory);\n \n", "next_change": {"commit": "3019796e79589a304493ffacc71036eeec271695", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 2e300be8d40..bc5b66a814f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -195,10 +203,11 @@ public class QueryPhase {\n         ContextIndexSearcher searcher,\n         Query query,\n         LinkedList<QueryCollectorContext> collectors,\n+        boolean hasFilterCollector,\n         boolean timeoutSet\n     ) throws IOException {\n         // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext);\n+        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n         // add the top docs collector, the first collector context in the chain\n         collectors.addFirst(topDocsFactory);\n \n", "next_change": {"commit": "3bd41b2405378debfada5b469c0c331b8a392b1c", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex bc5b66a814f..42f42f82ac9 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -198,30 +234,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static boolean searchWithCollector(\n+    private static Collector wrapWithProfilerCollectorIfNeeded(\n+        Profilers profilers,\n+        Collector collector,\n+        String profilerName,\n+        Collector... children\n+    ) {\n+        if (profilers == null) {\n+            return collector;\n+        }\n+        return new InternalProfileCollector(collector, profilerName, children);\n+    }\n+\n+    private static void searchWithCollector(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        LinkedList<QueryCollectorContext> collectors,\n-        boolean hasFilterCollector,\n+        Collector collector,\n         boolean timeoutSet\n     ) throws IOException {\n-        // create the top docs collector last when the other collectors are known\n-        final TopDocsCollectorContext topDocsFactory = createTopDocsCollectorContext(searchContext, hasFilterCollector);\n-        // add the top docs collector, the first collector context in the chain\n-        collectors.addFirst(topDocsFactory);\n-\n-        final Collector queryCollector;\n         if (searchContext.getProfilers() != null) {\n-            InternalProfileCollector profileCollector = QueryCollectorContext.createQueryCollectorWithProfiler(collectors);\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector(profileCollector);\n-            queryCollector = profileCollector;\n-        } else {\n-            queryCollector = QueryCollectorContext.createQueryCollector(collectors);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, queryCollector);\n+            searcher.search(query, collector);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": {"commit": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\nindex 42f42f82ac9..f4143c8975f 100644\n--- a/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n+++ b/server/src/main/java/org/elasticsearch/search/query/QueryPhase.java\n", "chunk": "@@ -234,31 +241,31 @@ public class QueryPhase {\n         }\n     }\n \n-    private static Collector wrapWithProfilerCollectorIfNeeded(\n+    private static CollectorManager<Collector, Void> wrapWithProfilerCollectorManagerIfNeeded(\n         Profilers profilers,\n         Collector collector,\n         String profilerName,\n         Collector... children\n     ) {\n         if (profilers == null) {\n-            return collector;\n+            return new SingleThreadCollectorManager(collector);\n         }\n-        return new InternalProfileCollector(collector, profilerName, children);\n+        return new InternalProfileCollectorManager(new InternalProfileCollector(collector, profilerName, children));\n     }\n \n-    private static void searchWithCollector(\n+    private static void searchWithCollectorManager(\n         SearchContext searchContext,\n         ContextIndexSearcher searcher,\n         Query query,\n-        Collector collector,\n+        CollectorManager<Collector, Void> collectorManager,\n         boolean timeoutSet\n     ) throws IOException {\n         if (searchContext.getProfilers() != null) {\n-            searchContext.getProfilers().getCurrentQueryProfiler().setCollector((InternalProfileCollector) collector);\n+            searchContext.getProfilers().getCurrentQueryProfiler().setCollectorManager((InternalProfileCollectorManager) collectorManager);\n         }\n         QuerySearchResult queryResult = searchContext.queryResult();\n         try {\n-            searcher.search(query, collector);\n+            searcher.search(query, collectorManager);\n         } catch (EarlyTerminatingCollector.EarlyTerminationException e) {\n             queryResult.terminatedEarly(true);\n         } catch (TimeExceededException e) {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "0d38626d8e6e9e2620a7a446b617a2ac42852461", "committedDate": "2020-03-06 00:19:11 +0100", "message": "Check for query cancellation during rewrite (#53166)"}, {"oid": "2ec1f6b4c4342e90a7d4e8bbf9029b51c03c7d18", "committedDate": "2020-03-19 13:09:50 -0400", "message": "Fix testIndexhasDuplicateData tests (#49786)"}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "bdfb137b340520218b88c1482d4d3fcc9718c9e6", "committedDate": "2020-05-21 14:49:43 -0400", "message": "Don't run sort optimization on size=0 (#57044)"}, {"oid": "b483246868c107ed8e2218c562571d54b97c470c", "committedDate": "2020-05-29 11:26:25 -0400", "message": "Run sort optimization when from+size>0 (#57250)"}, {"oid": "3b696828ada5953bb1669b972a353736383edf08", "committedDate": "2020-06-15 17:47:15 +0100", "message": "MappedFieldType should not extend FieldType (#57666)"}, {"oid": "879279c9b46b5a9606dfca96075e005624f0785d", "committedDate": "2020-08-24 20:24:35 -0400", "message": "Introduce point in time APIs in x-pack basic (#61062)"}, {"oid": "6a1c3e6059a13d97605892026595ea7f25686d6d", "committedDate": "2020-09-07 13:43:53 +0100", "message": "Remove SearchPhase interface (#62050)"}, {"oid": "2186b75af9f76b866539c16e76ffc8e019ac11d3", "committedDate": "2020-10-28 09:55:52 +0100", "message": "Reduce usages of SearchContext#mapperService (#64250)"}, {"oid": "f1e9aec8dcc7568d496abc4b09d1c8a0e6493087", "committedDate": "2020-11-04 15:49:38 +0100", "message": "Replace more MapperService usages in favour of QueryShardContext (#64584)"}, {"oid": "5852fbedf52c77b0a76c2c731fdd4982fb65cd87", "committedDate": "2021-01-14 09:11:59 -0800", "message": "Rename QueryShardContext -> SearchExecutionContext. (#67490)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "f27da75a6e75ed56b653d2d237b1f5ca5e4dac9d", "committedDate": "2021-02-22 17:52:10 +0100", "message": "Handle _shard_doc field for sort optimization (#69321)"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "3f77adcc664e57d79c02f5636565ad9f8d8bb601", "committedDate": "2021-07-27 11:08:09 +0100", "message": "Include reason in cancellation exceptions (#75332)"}, {"oid": "d9debbfe03b23e782d6afdadddd658b3d83bf710", "committedDate": "2021-09-08 09:20:26 -0400", "message": "Rename profile results for fetch profiling (#77195)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "c2c0165fd2811eb88e10eaa0089fbdbdeaab020c", "committedDate": "2021-09-13 10:00:36 -0400", "message": "Profile the fetch phase (#77064)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "2d9e0e79c8aa15a3f915f7335ca5961f91a6ccd9", "committedDate": "2021-09-21 18:39:58 +0200", "message": "Disable numeric sort optimization conditionally (#78103)"}, {"oid": "5e9c2422d1c7495a3195087b54add8d562f4b9ad", "committedDate": "2021-09-23 20:22:21 -0400", "message": "Disable sort optimization in search_after and scroll requests (#78230)"}, {"oid": "7d82dbf9e3e3e13c1c756f9b0893b6028e638ec4", "committedDate": "2021-09-24 10:46:11 -0400", "message": "Upgrade to Lucene9-snapshot-94c6e261274 (#78286)"}, {"oid": "060976a9f9f9eff089a710f0437169b65b300c25", "committedDate": "2021-10-18 16:45:36 +0200", "message": "Don't always rewrite the Lucene query in search phases (#79358)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "beb248fbbbe7be4fab369de239a6434a834bb53a", "committedDate": "2022-01-06 08:15:42 +0100", "message": "server instanceof pattern matching replacement (#82074)"}, {"oid": "a89d4c34cbd8e5b3b3879df3aec632e7494e3c35", "committedDate": "2022-02-15 11:48:38 -1000", "message": "TSDB: Add time series aggs cancellation (#83492)"}, {"oid": "898d84998b081d47ec6a9c2305f9bf4486d69be3", "committedDate": "2022-03-30 00:21:56 +0200", "message": "Make classes+methods that can be static static in many spots (#85370)"}, {"oid": "283f8acd9275d197453e7d9309e62f31abf51f51", "committedDate": "2023-02-06 11:24:41 +0100", "message": "Remove shortcutTotalHitCount optimization (#89047)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "3019796e79589a304493ffacc71036eeec271695", "committedDate": "2023-03-29 19:48:05 +0200", "message": "Revert \"Remove shortcutTotalHitCount optimization (#89047)\" (#94876)"}, {"oid": "f50725e197046c9fca5851c152fd650ed29efec2", "committedDate": "2023-03-30 15:12:17 +0200", "message": "Remove TopDocsCollectorContext#shouldRescore method (#94895)"}, {"oid": "663d82cf992ffad587c1c4afef8e6c932bf60d2a", "committedDate": "2023-03-30 15:13:00 +0200", "message": "Shortcut total hit count when terminate_after is used (#94889)"}, {"oid": "b275d9155e2fb877944360a77dfedf3509b4649e", "committedDate": "2023-04-21 08:53:54 +0200", "message": "Align constructors for query phase and friends (#95338)"}, {"oid": "3bd41b2405378debfada5b469c0c331b8a392b1c", "committedDate": "2023-04-21 09:04:00 +0200", "message": "Remove QueryCollectorContext abstraction (#95383)"}, {"oid": "8e15a1a7ada1fe3d7caa5d51adcad1d9f6852fff", "committedDate": "2023-04-21 10:00:27 +0200", "message": "Rename TopDocsCollectorContext to TopDocsCollectorFactory (#95435)"}, {"oid": "49a74847cdb477fee297b9d365d95f05ce1fcaaa", "committedDate": "2023-04-24 13:31:44 +0200", "message": "Search using CollectorManagers instead of Collectors (#95251)"}, {"oid": "5314e5dd553da74696a74cd061ef4bcec9bf2a48", "committedDate": "2023-04-24 15:07:34 -0700", "message": "Add support for Reciprocal Rank Fusion to the search API (#93396)"}, {"oid": "7fb344238dcad615282b70557b70c67eede482ca", "committedDate": "2023-04-25 13:39:48 +0200", "message": "Switch to Lucene ProfilerCollector (#95526)"}, {"oid": "c07fe6aff32de61f0ca848046482ab7880e41135", "committedDate": "2023-04-25 16:31:02 +0200", "message": "Turn TopDocsCollectorFactory into a collector manager factory (#95535)"}, {"oid": "e208992b66785646dc26cd66969031de35cbf6b5", "committedDate": "2023-05-08 14:50:10 +0200", "message": "Don't generate stacktrace in EarlyTerminationException and TimeExceededException (#95910)"}, {"oid": "815190aa6bd4fd486f56416fcc0c33dd96952191", "committedDate": "2023-05-30 09:50:41 +0200", "message": "Move the registration of the aggregation collector manager to SearchContextAggregations (#96410)"}]}, {"oid": "b446dfd16c6de533f1ccc2a552407e6df03f3376", "url": "https://github.com/elastic/elasticsearch/commit/b446dfd16c6de533f1ccc2a552407e6df03f3376", "message": "extract wrapper classes to another file, use more elegant approach for cancellable", "committedDate": "2020-03-04T11:36:21Z", "type": "commit"}, {"oid": "183da1740e1380abba936dd676eba04694717bb5", "url": "https://github.com/elastic/elasticsearch/commit/183da1740e1380abba936dd676eba04694717bb5", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-04T13:07:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387719706", "body": "nit: the naming of the add is inconsistent with the remove. I wonder how to expose the name here, `[add/remove]CheckExitReader` ? \r\nIn any case the javadocs should be adapted to mention the fact that these checks run when we access the reader so not only when collecting document. This makes me think that we may want to wrap the task cancellation check before we rewrite the Lucene query for instance. I am fine if we do this in a follow up since it should be fairly easy to add. ", "bodyText": "nit: the naming of the add is inconsistent with the remove. I wonder how to expose the name here, [add/remove]CheckExitReader ?\nIn any case the javadocs should be adapted to mention the fact that these checks run when we access the reader so not only when collecting document. This makes me think that we may want to wrap the task cancellation check before we rewrite the Lucene query for instance. I am fine if we do this in a follow up since it should be fairly easy to add.", "bodyHTML": "<p dir=\"auto\">nit: the naming of the add is inconsistent with the remove. I wonder how to expose the name here, <code>[add/remove]CheckExitReader</code> ?<br>\nIn any case the javadocs should be adapted to mention the fact that these checks run when we access the reader so not only when collecting document. This makes me think that we may want to wrap the task cancellation check before we rewrite the Lucene query for instance. I am fine if we do this in a follow up since it should be fairly easy to add.</p>", "author": "jimczi", "createdAt": "2020-03-04T14:57:05Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +80,42 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while\n+     * collecting documents and check for query cancellation or timeout.\n      */\n-    public void setCheckCancelled(Runnable checkCancelled) {\n-        this.checkCancelled = checkCancelled;\n+    public Runnable addQueryCancellation(Runnable action) {", "originalCommit": "183da1740e1380abba936dd676eba04694717bb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzczODcxOQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387738719", "bodyText": "I prefer the addQueryCancellation since the cancellation is used not only for the reader.\nWill rename the removal method and fix the javadoc though.", "author": "matriv", "createdAt": "2020-03-04T15:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNTkxOA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388205918", "bodyText": "ok fine with me", "author": "jimczi", "createdAt": "2020-03-05T10:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzcxOTcwNg=="}], "type": "inlineReview", "revised_code": {"commit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..ecdb43bbcc6 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -107,14 +107,18 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n         return this.cancellable.add(action);\n     }\n \n-    public void removeQueryTimeout(Runnable action) {\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n     }\n \n", "next_change": {"commit": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -116,7 +115,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n \n     /**\n      * Remove a {@link Runnable} that checks for query cancellation or timeout\n-     * which is called while fetching documents from the DirectoryReader but also while collecting them.\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n      */\n     public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 139c48c543d..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -107,14 +106,18 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents and check for query cancellation or timeout.\n+     * Add a {@link Runnable} that will be run on a regular basis while accessing documents in the\n+     * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n         return this.cancellable.add(action);\n     }\n \n-    public void removeQueryTimeout(Runnable action) {\n+    /**\n+     * Remove a {@link Runnable} that checks for query cancellation or timeout\n+     * which is called while accessing documents in the DirectoryReader but also while collecting them.\n+     */\n+    public void removeQueryCancellation(Runnable action) {\n         this.cancellable.remove(action);\n     }\n \n", "next_change": {"commit": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex d3c4f5641dc..3e453c3cdef 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -121,6 +119,19 @@ public class ContextIndexSearcher extends IndexSearcher {\n         this.cancellable.remove(action);\n     }\n \n+    @Override\n+    public void close() {\n+        // clear the list of cancellables when closing the owning search context, since the ExitableDirectoryReader might be cached (for\n+        // instance in fielddata cache).\n+        // A cancellable can contain an indirect reference to the search context, which potentially retains a significant amount\n+        // of memory.\n+        this.cancellable.clear();\n+    }\n+\n+    public boolean hasCancellations() {\n+        return this.cancellable.isEnabled();\n+    }\n+\n     public void setAggregatedDfs(AggregatedDfs aggregatedDfs) {\n         this.aggregatedDfs = aggregatedDfs;\n     }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "url": "https://github.com/elastic/elasticsearch/commit/a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "message": "rename method, add more tests", "committedDate": "2020-03-04T15:37:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTg5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387801891", "body": "Please don't implement QueryTimeout, I think this introduces more issues than it helps, since its contract is that `shouldExit` should return true once the timeout is hit, while we instead use runnables that throw exceptions.", "bodyText": "Please don't implement QueryTimeout, I think this introduces more issues than it helps, since its contract is that shouldExit should return true once the timeout is hit, while we instead use runnables that throw exceptions.", "bodyHTML": "<p dir=\"auto\">Please don't implement QueryTimeout, I think this introduces more issues than it helps, since its contract is that <code>shouldExit</code> should return true once the timeout is hit, while we instead use runnables that throw exceptions.</p>", "author": "jpountz", "createdAt": "2020-03-04T16:57:25Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -320,4 +338,34 @@ public DirectoryReader getDirectoryReader() {\n         assert reader instanceof DirectoryReader : \"expected an instance of DirectoryReader, got \" + reader.getClass();\n         return (DirectoryReader) reader;\n     }\n+\n+    private static class MutableQueryTimeout implements QueryTimeout {", "originalCommit": "a912fa348d07c8cc9b2d90a376f7b1f2aeb52280", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMDAwMw==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387810003", "bodyText": "Replaced with our own iface.", "author": "matriv", "createdAt": "2020-03-04T17:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..839e6844fb7 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -339,7 +338,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    private static class MutableQueryTimeout implements QueryTimeout {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n         private final Set<Runnable> runnables = new HashSet<>();\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex ecdb43bbcc6..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -339,7 +338,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n         return (DirectoryReader) reader;\n     }\n \n-    private static class MutableQueryTimeout implements QueryTimeout {\n+    private static class MutableQueryTimeout implements ExitableDirectoryReader.QueryCancellation {\n \n         private final Set<Runnable> runnables = new HashSet<>();\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "url": "https://github.com/elastic/elasticsearch/commit/23c3adc7129b3ca912e5c19a4828dd01c26364bb", "message": "replace QueryTimeout with our own iface", "committedDate": "2020-03-04T17:10:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMTE0MA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387811140", "body": "Can you document the contract?", "bodyText": "Can you document the contract?", "bodyHTML": "<p dir=\"auto\">Can you document the contract?</p>", "author": "jpountz", "createdAt": "2020-03-04T17:13:24Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.search.internal;\n+\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.FilterDirectoryReader;\n+import org.apache.lucene.index.FilterLeafReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.index.Terms;\n+import org.apache.lucene.index.TermsEnum;\n+import org.apache.lucene.search.suggest.document.CompletionTerms;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.lucene.util.automaton.CompiledAutomaton;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Wraps an {@link IndexReader} with a {@link QueryCancellation}\n+ * which checks for cancelled or timed-out query.\n+ */\n+class ExitableDirectoryReader extends FilterDirectoryReader {\n+\n+    interface QueryCancellation {\n+\n+        boolean isEnabled();\n+\n+        void checkCancelled();", "originalCommit": "23c3adc7129b3ca912e5c19a4828dd01c26364bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxNTEyMA==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r387815120", "bodyText": "Sure!", "author": "matriv", "createdAt": "2020-03-04T17:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgxMTE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java b/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\nindex d79c16bb720..b66532bbd09 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\n", "chunk": "@@ -39,10 +39,22 @@ import java.io.IOException;\n  */\n class ExitableDirectoryReader extends FilterDirectoryReader {\n \n+    /**\n+     * Used to check if query cancellation is actually enabled\n+     * and if so use it to check if the query is cancelled or timed-out.\n+     */\n     interface QueryCancellation {\n \n+        /**\n+         * Used to prevent unnecessary checks for cancellation\n+         * @return true if query cancellation is enabled\n+         */\n         boolean isEnabled();\n \n+        /**\n+         * Call to check if the query is cancelled or timed-out.\n+         * If so a {@link RuntimeException} is thrown\n+         */\n         void checkCancelled();\n     }\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java b/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\nindex d79c16bb720..b66532bbd09 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ExitableDirectoryReader.java\n", "chunk": "@@ -39,10 +39,22 @@ import java.io.IOException;\n  */\n class ExitableDirectoryReader extends FilterDirectoryReader {\n \n+    /**\n+     * Used to check if query cancellation is actually enabled\n+     * and if so use it to check if the query is cancelled or timed-out.\n+     */\n     interface QueryCancellation {\n \n+        /**\n+         * Used to prevent unnecessary checks for cancellation\n+         * @return true if query cancellation is enabled\n+         */\n         boolean isEnabled();\n \n+        /**\n+         * Call to check if the query is cancelled or timed-out.\n+         * If so a {@link RuntimeException} is thrown\n+         */\n         void checkCancelled();\n     }\n \n", "next_change": null}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "6b5fc35e4458e60a7ca5822584ec6a60562f2c01", "committedDate": "2020-03-18 14:52:03 +0100", "message": "Increase step between checks for cancellation (#53712)"}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6784c4d1b55d443511c517a8b992e657fa2b678f", "committedDate": "2020-09-17 18:46:40 +0200", "message": "Faster sequential access for stored fields (#62509)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "26c3dd6857d047054b2108f85bc2b040a9c81fe4", "committedDate": "2022-02-22 09:53:20 +0100", "message": "Upgrade to lucene-9.1.0-snapshot-1336263051c (#83667)"}, {"oid": "8f08c7b55bd7b9e950062abc843e33b480ef6a47", "committedDate": "2022-08-04 11:48:36 -0400", "message": "Override bulk visit methods of exitable point visitor (#82120)"}, {"oid": "2a17e5302d92a9c15d4686cdd101d076867dbb4d", "committedDate": "2022-10-04 09:13:09 -0400", "message": "Make `knn` search requests fully cancellable (#90612)"}, {"oid": "c24a2cab7e6c9bf8d6bd226ab5d06b0bc27d607a", "committedDate": "2022-10-12 13:52:20 -0400", "message": "Fix performance regression caused by cancellation check in vector scripts (#90804)"}, {"oid": "766e426a925bc4bf3edca42d2872113abf2c922e", "committedDate": "2023-01-11 23:34:15 +0100", "message": "Avoid doing I/O when fetching min and max for keyword fields (#92026)"}, {"oid": "edd7749164aa6873a0eb7565abcc612d29c601f0", "committedDate": "2023-01-19 14:07:33 +0100", "message": "Upgrade to lucene-9.5.0-snapshot-d19c3e2e0ed (#92957)"}, {"oid": "200e061e3296aee830fb5e2c16b741a79a4034d5", "committedDate": "2023-01-31 19:48:25 +0100", "message": "Upgrade to Lucene 9.5.0 (#93385)"}]}, {"oid": "087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "url": "https://github.com/elastic/elasticsearch/commit/087f2ad9a9d9cedaaae0ef718ec123858a08dd95", "message": "document iface", "committedDate": "2020-03-04T17:19:38Z", "type": "commit"}, {"oid": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "url": "https://github.com/elastic/elasticsearch/commit/df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "message": "Merge remote-tracking branch 'upstream/master' into impl-cancellable", "committedDate": "2020-03-04T17:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzg5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/52822#discussion_r388207896", "body": "nit: s/while accessing/while fetching document/ this is confusing since we don't check the cancellation when visiting the stored fields ?", "bodyText": "nit: s/while accessing/while fetching document/ this is confusing since we don't check the cancellation when visiting the stored fields ?", "bodyHTML": "<p dir=\"auto\">nit: s/while accessing/while fetching document/ this is confusing since we don't check the cancellation when visiting the stored fields ?</p>", "author": "jimczi", "createdAt": "2020-03-05T10:34:50Z", "path": "server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java", "diffHunk": "@@ -77,25 +79,46 @@\n \n     private AggregatedDfs aggregatedDfs;\n     private QueryProfiler profiler;\n-    private Runnable checkCancelled;\n+    private MutableQueryTimeout cancellable;\n \n-    public ContextIndexSearcher(IndexReader reader, Similarity similarity, QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) {\n-        super(reader);\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy) throws IOException {\n+        this(reader, similarity, queryCache, queryCachingPolicy, new MutableQueryTimeout());\n+    }\n+\n+    // TODO: Make the 2nd constructor private so that the IndexReader is always wrapped.\n+    // Some issues must be fixed:\n+    //   - regarding tests deriving from AggregatorTestCase and more specifically the use of searchAndReduce and\n+    //     the ShardSearcher sub-searchers.\n+    //   - tests that use a MultiReader\n+    public ContextIndexSearcher(IndexReader reader, Similarity similarity,\n+                                QueryCache queryCache, QueryCachingPolicy queryCachingPolicy,\n+                                MutableQueryTimeout cancellable) throws IOException {\n+        super(cancellable != null ? new ExitableDirectoryReader((DirectoryReader) reader, cancellable) : reader);\n         setSimilarity(similarity);\n         setQueryCache(queryCache);\n         setQueryCachingPolicy(queryCachingPolicy);\n+        this.cancellable = cancellable != null ? cancellable : new MutableQueryTimeout();\n     }\n \n     public void setProfiler(QueryProfiler profiler) {\n         this.profiler = profiler;\n     }\n \n     /**\n-     * Set a {@link Runnable} that will be run on a regular basis while\n-     * collecting documents.\n+     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the", "originalCommit": "df0da4c8c45aa49ebeceb276ec871c6f4d03d4de", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 839e6844fb7..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -106,7 +106,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * Add a {@link Runnable} that will be run on a regular basis while accessing documents in the\n      * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "67acaf61f33bc5f54e26541514d07e375c202e03", "changed_code": [{"header": "diff --git a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\nindex 839e6844fb7..d3c4f5641dc 100644\n--- a/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n+++ b/server/src/main/java/org/elasticsearch/search/internal/ContextIndexSearcher.java\n", "chunk": "@@ -106,7 +106,7 @@ public class ContextIndexSearcher extends IndexSearcher {\n     }\n \n     /**\n-     * Add a {@link Runnable} that will be run on a regular basis while fetching document from the\n+     * Add a {@link Runnable} that will be run on a regular basis while accessing documents in the\n      * DirectoryReader but also while collecting them and check for query cancellation or timeout.\n      */\n     public Runnable addQueryCancellation(Runnable action) {\n", "next_change": null}]}, "commits_in_main": [{"oid": "67acaf61f33bc5f54e26541514d07e375c202e03", "message": "Merge commit", "committedDate": null}, {"oid": "cdc377e8e74d3ca6c231c36dc5e80621aab47c69", "committedDate": "2020-03-23 19:49:32 +0100", "message": "Reduce performance impact of ExitableDirectoryReader (#53978)"}, {"oid": "6b51d85cbde8e0ddea020dcccb1e798dcb4ef27a", "committedDate": "2020-09-02 13:41:57 +0200", "message": "Search memory leak (#61788)"}, {"oid": "a92a647b9f17d1bddf5c707490a19482c273eda3", "committedDate": "2021-02-02 16:10:53 -0800", "message": "Update sources with new SSPL+Elastic-2.0 license headers"}, {"oid": "051bbb2238bc1282f60701940b4eeb78f1a388de", "committedDate": "2021-05-06 09:47:47 +0200", "message": "Fix early termination of search request with sort optimization (#72683)"}, {"oid": "68817d7ca29c264b3ea3f766737d81e2ebb4028c", "committedDate": "2021-06-08 09:53:28 -0700", "message": "Rename o.e.common in libs/core to o.e.core (#73909)"}, {"oid": "1b56e8b3249cb3e060d171b236e758d7ee165b07", "committedDate": "2021-09-13 06:56:27 -0400", "message": "Add sort optimization with after from Lucene (#64292)"}, {"oid": "524d1ea757938cc4a05eb596dc0e93f888933d50", "committedDate": "2021-09-21 10:48:26 +0100", "message": "Upgrade to lucene-9.0.0-snapshot-32a0a16aff0 (#73324)"}, {"oid": "5964ffe7df684196ccc1a3dc64dfa4c1fea4ab1a", "committedDate": "2021-09-22 16:18:58 -0400", "message": "Initial move commit, CombinedBitSet (#78189)"}, {"oid": "12ad399c488f0cc60e19b5e1b29c6d569cb4351a", "committedDate": "2021-10-27 08:19:51 -0700", "message": "Reformat Elasticsearch source"}, {"oid": "bd69f90fffe6c5126cd5bcf02b23db00505d3832", "committedDate": "2022-07-06 16:16:03 -0400", "message": "Upgrade to Lucene-9.3.0-snapshot-2d05f5c623e (#88284)"}, {"oid": "4732fc2343bce7a1390e2b48e61f82cfc2e4d65f", "committedDate": "2022-07-13 16:57:12 -0400", "message": "Implement count for wrapped Weight in ContextIndexSearcher (#88396)"}, {"oid": "acf134850595ca37730da48d74e9391951952986", "committedDate": "2023-03-27 17:10:24 +0200", "message": "Simplify aggs collector methods in SearchContext (#94565)"}, {"oid": "c4158d78dbc712552d896c77324f8a91e3e69d4c", "committedDate": "2023-05-08 17:28:18 +0200", "message": "ContextIndexSearcher#search should return only when all threads are finished (#95909)"}, {"oid": "42d0efcbbb7a17502f8d9d583599eb07a9b5ef34", "committedDate": "2023-05-09 20:05:01 +0200", "message": "Remove wrap weight in ContextIndexSearcher (#95849)"}]}, {"oid": "eb158e54a363eda92f3e7830e6158f5e8da555eb", "url": "https://github.com/elastic/elasticsearch/commit/eb158e54a363eda92f3e7830e6158f5e8da555eb", "message": "fix comment", "committedDate": "2020-03-05T10:40:42Z", "type": "commit"}]}