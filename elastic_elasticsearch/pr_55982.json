{"pr_number": 55982, "pr_title": "Handle merging dotted object names when merging V2 template mappings", "pr_author": "dakrone", "pr_createdAt": "2020-04-29T21:21:53Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55982", "timeline": [{"oid": "f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "url": "https://github.com/elastic/elasticsearch/commit/f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "message": "Handle merging dotted object names when merging V2 template mappings\n\nWhen merging component template, index template, and request mappings, we now treat any declaration\nof a top-level field the same as replacing all sub-objects. For example, assuming two component\ntemplates with mappings and template B taking precedence:\n\n```\nA: {foo: {...}}\nB: {foo.bar: {...}}\nResult: {foo.bar: {...}}\n\nA: {foo.bar: {...}}\nB: {foo: {...}}\nResult: {foo: {...}}\n\nA: {foo.bar: {...}}\nB: {foo.baz: {...}}\nResult: {foo.baz: {...}}\n```\n\nRelates to #53101", "committedDate": "2020-04-29T20:48:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg1ODA0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55982#discussion_r417858043", "body": "If I understand this correctly it can be simplified:\r\n```java\r\nstatic Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {\r\n    Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\r\n    Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\r\n    Map<String, Object> results = new HashMap<>(first);\r\n    Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\r\n    results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\r\n    results.putAll(second);\r\n    return results;\r\n}\r\n\r\nprivate static String prefix(String s) {\r\n    return s.split(\"\\\\.\", 2)[0];\r\n}\r\n```", "bodyText": "If I understand this correctly it can be simplified:\nstatic Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {\n    Objects.requireNonNull(first, \"merging requires two non-null maps but the first map was null\");\n    Objects.requireNonNull(second, \"merging requires two non-null maps but the second map was null\");\n    Map<String, Object> results = new HashMap<>(first);\n    Set<String> prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n    results.keySet().removeIf(k -> prefixes.contains(prefix(k)));\n    results.putAll(second);\n    return results;\n}\n\nprivate static String prefix(String s) {\n    return s.split(\"\\\\.\", 2)[0];\n}", "bodyHTML": "<p dir=\"auto\">If I understand this correctly it can be simplified:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"static Map&lt;String, Object&gt; mergeIgnoringDots(Map&lt;String, Object&gt; first, Map&lt;String, Object&gt; second) {\n    Objects.requireNonNull(first, &quot;merging requires two non-null maps but the first map was null&quot;);\n    Objects.requireNonNull(second, &quot;merging requires two non-null maps but the second map was null&quot;);\n    Map&lt;String, Object&gt; results = new HashMap&lt;&gt;(first);\n    Set&lt;String&gt; prefixes = second.keySet().stream().map(MetadataCreateIndexService::prefix).collect(Collectors.toSet());\n    results.keySet().removeIf(k -&gt; prefixes.contains(prefix(k)));\n    results.putAll(second);\n    return results;\n}\n\nprivate static String prefix(String s) {\n    return s.split(&quot;\\\\.&quot;, 2)[0];\n}\"><pre><span class=\"pl-k\">static</span> <span class=\"pl-k\">Map&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">Object</span>&gt;</span> mergeIgnoringDots(<span class=\"pl-k\">Map&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">Object</span>&gt;</span> first, <span class=\"pl-k\">Map&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">Object</span>&gt;</span> second) {\n    <span class=\"pl-smi\">Objects</span><span class=\"pl-k\">.</span>requireNonNull(first, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>merging requires two non-null maps but the first map was null<span class=\"pl-pds\">\"</span></span>);\n    <span class=\"pl-smi\">Objects</span><span class=\"pl-k\">.</span>requireNonNull(second, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>merging requires two non-null maps but the second map was null<span class=\"pl-pds\">\"</span></span>);\n    <span class=\"pl-k\">Map&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">Object</span>&gt;</span> results <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-k\">HashMap&lt;&gt;</span>(first);\n    <span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">String</span>&gt;</span> prefixes <span class=\"pl-k\">=</span> second<span class=\"pl-k\">.</span>keySet()<span class=\"pl-k\">.</span>stream()<span class=\"pl-k\">.</span>map(<span class=\"pl-smi\">MetadataCreateIndexService</span><span class=\"pl-k\">::</span>prefix)<span class=\"pl-k\">.</span>collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span>toSet());\n    results<span class=\"pl-k\">.</span>keySet()<span class=\"pl-k\">.</span>removeIf(k <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> prefixes<span class=\"pl-k\">.</span>contains(prefix(k)));\n    results<span class=\"pl-k\">.</span>putAll(second);\n    <span class=\"pl-k\">return</span> results;\n}\n\n<span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">String</span> prefix(<span class=\"pl-smi\">String</span> s) {\n    <span class=\"pl-k\">return</span> s<span class=\"pl-k\">.</span>split(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span><span class=\"pl-cce\">\\\\</span>.<span class=\"pl-pds\">\"</span></span>, <span class=\"pl-c1\">2</span>)[<span class=\"pl-c1\">0</span>];\n}</pre></div>", "author": "probakowski", "createdAt": "2020-04-30T08:54:38Z", "path": "server/src/main/java/org/elasticsearch/cluster/metadata/MetadataCreateIndexService.java", "diffHunk": "@@ -596,6 +597,52 @@ private ClusterState applyCreateIndexRequestWithExistingMetadata(final ClusterSt\n         return Collections.singletonMap(MapperService.SINGLE_MAPPING_NAME, finalMappings);\n     }\n \n+    /**\n+     * Add the objects in the second map to the first, where the keys in the {@code second} map have\n+     * higher predecence and overwrite the keys in the {@code first} map. In the event of a key with\n+     * a dot in it (ie, \"foo.bar\"), the keys are treated as only the prefix counting towards\n+     * equality. If the {@code second} map has a key such as \"foo\", all keys starting from \"foo.\" in\n+     * the {@code first} map are discarded.\n+     */\n+    static Map<String, Object> mergeIgnoringDots(Map<String, Object> first, Map<String, Object> second) {", "originalCommit": "f5a0851e3346ce6c4b2f3a35b08bfbe7ad311a83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1MzcxMw==", "url": "https://github.com/elastic/elasticsearch/pull/55982#discussion_r418053713", "bodyText": "Sounds good, that works and passes the tests, updated the function.", "author": "dakrone", "createdAt": "2020-04-30T14:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzg1ODA0Mw=="}], "type": "inlineReview"}, {"oid": "6a08f44a277323999aca45db01b9052916f5f432", "url": "https://github.com/elastic/elasticsearch/commit/6a08f44a277323999aca45db01b9052916f5f432", "message": "Use simplified function", "committedDate": "2020-04-30T14:29:29Z", "type": "commit"}]}