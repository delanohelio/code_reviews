{"pr_number": 52436, "pr_title": "Do not lock when generating time based uuid", "pr_author": "tbrooks8", "pr_createdAt": "2020-02-17T19:20:13Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/52436", "timeline": [{"oid": "3bd07cfe9368a68043f369e93d7862bf14b0ef85", "url": "https://github.com/elastic/elasticsearch/commit/3bd07cfe9368a68043f369e93d7862bf14b0ef85", "message": "Do not lock when generating time based uuid\n\nCurrently we lock when generating time based uuids. The lock is\nimplemented to prevent concurrent writes to the last timestamp. The uuid\ngeneration is an area of contention when indexing. This commit modifies\nthe code to use atomic compare and set operations to update the last\ntimestamp.", "committedDate": "2020-02-17T18:17:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380362972", "body": "I think we can fold the loop into a convenience method on `AtomicLong`:\r\n\r\n```diff\r\ndiff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\r\nindex c30a8d0aaa2..aa14d608aa7 100644\r\n--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\r\n+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\r\n@@ -21,6 +21,7 @@ package org.elasticsearch.common;\r\n \r\n import java.util.Base64;\r\n import java.util.concurrent.atomic.AtomicInteger;\r\n+import java.util.concurrent.atomic.AtomicLong;\r\n \r\n /**\r\n  * These are essentially flake ids but we use 6 (not 8) bytes for timestamp, and use 3 (not 2) bytes for sequence number. We also reorder\r\n@@ -37,7 +38,7 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\r\n     private final AtomicInteger sequenceNumber = new AtomicInteger(SecureRandomHolder.INSTANCE.nextInt());\r\n \r\n     // Used to ensure clock moves forward:\r\n-    private long lastTimestamp;\r\n+    private AtomicLong lastTimestamp = new AtomicLong();\r\n \r\n     private static final byte[] SECURE_MUNGED_ADDRESS = MacAddressProvider.getSecureMungedAddress();\r\n \r\n@@ -58,21 +59,22 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\r\n     @Override\r\n     public String getBase64UUID()  {\r\n         final int sequenceId = sequenceNumber.incrementAndGet() & 0xffffff;\r\n-        long timestamp = currentTimeMillis();\r\n \r\n-        synchronized (this) {\r\n-            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\r\n-            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\r\n-            // collision:\r\n-            timestamp = Math.max(lastTimestamp, timestamp);\r\n+        final long timestamp = lastTimestamp.updateAndGet(\r\n+            last -> {\r\n+                // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\r\n+                // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\r\n+                // collision:\r\n+                long nonBackwardsCurrentTimestamp = Math.max(last, currentTimeMillis());\r\n \r\n-            if (sequenceId == 0) {\r\n-                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\r\n-                timestamp++;\r\n-            }\r\n+                if (sequenceId == 0) {\r\n+                    // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\r\n+                    nonBackwardsCurrentTimestamp++;\r\n+                }\r\n \r\n-            lastTimestamp = timestamp;\r\n-        }\r\n+                return nonBackwardsCurrentTimestamp;\r\n+            }\r\n+         );\r\n \r\n         final byte[] uuidBytes = new byte[15];\r\n         int i = 0;\r\n```", "bodyText": "I think we can fold the loop into a convenience method on AtomicLong:\ndiff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\nindex c30a8d0aaa2..aa14d608aa7 100644\n--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n@@ -21,6 +21,7 @@ package org.elasticsearch.common;\n \n import java.util.Base64;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * These are essentially flake ids but we use 6 (not 8) bytes for timestamp, and use 3 (not 2) bytes for sequence number. We also reorder\n@@ -37,7 +38,7 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     private final AtomicInteger sequenceNumber = new AtomicInteger(SecureRandomHolder.INSTANCE.nextInt());\n \n     // Used to ensure clock moves forward:\n-    private long lastTimestamp;\n+    private AtomicLong lastTimestamp = new AtomicLong();\n \n     private static final byte[] SECURE_MUNGED_ADDRESS = MacAddressProvider.getSecureMungedAddress();\n \n@@ -58,21 +59,22 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     @Override\n     public String getBase64UUID()  {\n         final int sequenceId = sequenceNumber.incrementAndGet() & 0xffffff;\n-        long timestamp = currentTimeMillis();\n \n-        synchronized (this) {\n-            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\n-            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n-            // collision:\n-            timestamp = Math.max(lastTimestamp, timestamp);\n+        final long timestamp = lastTimestamp.updateAndGet(\n+            last -> {\n+                // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are\n+                // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n+                // collision:\n+                long nonBackwardsCurrentTimestamp = Math.max(last, currentTimeMillis());\n \n-            if (sequenceId == 0) {\n-                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n-                timestamp++;\n-            }\n+                if (sequenceId == 0) {\n+                    // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n+                    nonBackwardsCurrentTimestamp++;\n+                }\n \n-            lastTimestamp = timestamp;\n-        }\n+                return nonBackwardsCurrentTimestamp;\n+            }\n+         );\n \n         final byte[] uuidBytes = new byte[15];\n         int i = 0;", "bodyHTML": "<p dir=\"auto\">I think we can fold the loop into a convenience method on <code>AtomicLong</code>:</p>\n<div class=\"highlight highlight-source-diff position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"diff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\nindex c30a8d0aaa2..aa14d608aa7 100644\n--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java\n@@ -21,6 +21,7 @@ package org.elasticsearch.common;\n \n import java.util.Base64;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n /**\n  * These are essentially flake ids but we use 6 (not 8) bytes for timestamp, and use 3 (not 2) bytes for sequence number. We also reorder\n@@ -37,7 +38,7 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     private final AtomicInteger sequenceNumber = new AtomicInteger(SecureRandomHolder.INSTANCE.nextInt());\n \n     // Used to ensure clock moves forward:\n-    private long lastTimestamp;\n+    private AtomicLong lastTimestamp = new AtomicLong();\n \n     private static final byte[] SECURE_MUNGED_ADDRESS = MacAddressProvider.getSecureMungedAddress();\n \n@@ -58,21 +59,22 @@ class TimeBasedUUIDGenerator implements UUIDGenerator {\n     @Override\n     public String getBase64UUID()  {\n         final int sequenceId = sequenceNumber.incrementAndGet() &amp; 0xffffff;\n-        long timestamp = currentTimeMillis();\n \n-        synchronized (this) {\n-            // Don't let timestamp go backwards, at least &quot;on our watch&quot; (while this JVM is running).  We are still vulnerable if we are\n-            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n-            // collision:\n-            timestamp = Math.max(lastTimestamp, timestamp);\n+        final long timestamp = lastTimestamp.updateAndGet(\n+            last -&gt; {\n+                // Don't let timestamp go backwards, at least &quot;on our watch&quot; (while this JVM is running).  We are still vulnerable if we are\n+                // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of\n+                // collision:\n+                long nonBackwardsCurrentTimestamp = Math.max(last, currentTimeMillis());\n \n-            if (sequenceId == 0) {\n-                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n-                timestamp++;\n-            }\n+                if (sequenceId == 0) {\n+                    // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:\n+                    nonBackwardsCurrentTimestamp++;\n+                }\n \n-            lastTimestamp = timestamp;\n-        }\n+                return nonBackwardsCurrentTimestamp;\n+            }\n+         );\n \n         final byte[] uuidBytes = new byte[15];\n         int i = 0;\"><pre><span class=\"pl-c1\">diff --git a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java</span>\nindex c30a8d0aaa2..aa14d608aa7 100644\n<span class=\"pl-md\">--- a/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java</span>\n<span class=\"pl-mi1\">+++ b/server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java</span>\n<span class=\"pl-mdr\">@@ -21,6 +21,7 @@</span> package org.elasticsearch.common;\n \n import java.util.Base64;\n import java.util.concurrent.atomic.AtomicInteger;\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>import java.util.concurrent.atomic.AtomicLong;</span>\n \n /**\n  * These are essentially flake ids but we use 6 (not 8) bytes for timestamp, and use 3 (not 2) bytes for sequence number. We also reorder\n<span class=\"pl-mdr\">@@ -37,7 +38,7 @@</span> class TimeBasedUUIDGenerator implements UUIDGenerator {\n     private final AtomicInteger sequenceNumber = new AtomicInteger(SecureRandomHolder.INSTANCE.nextInt());\n \n     // Used to ensure clock moves forward:\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>    private long lastTimestamp;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>    private AtomicLong lastTimestamp = new AtomicLong();</span>\n \n     private static final byte[] SECURE_MUNGED_ADDRESS = MacAddressProvider.getSecureMungedAddress();\n \n<span class=\"pl-mdr\">@@ -58,21 +59,22 @@</span> class TimeBasedUUIDGenerator implements UUIDGenerator {\n     @Override\n     public String getBase64UUID()  {\n         final int sequenceId = sequenceNumber.incrementAndGet() &amp; 0xffffff;\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>        long timestamp = currentTimeMillis();</span>\n \n<span class=\"pl-md\"><span class=\"pl-md\">-</span>        synchronized (this) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            // collision:</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            timestamp = Math.max(lastTimestamp, timestamp);</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>        final long timestamp = lastTimestamp.updateAndGet(</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>            last -&gt; {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // Don't let timestamp go backwards, at least \"on our watch\" (while this JVM is running).  We are still vulnerable if we are</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // collision:</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                long nonBackwardsCurrentTimestamp = Math.max(last, currentTimeMillis());</span>\n \n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            if (sequenceId == 0) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                timestamp++;</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            }</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                if (sequenceId == 0) {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                    // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                    nonBackwardsCurrentTimestamp++;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                }</span>\n \n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            lastTimestamp = timestamp;</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>        }</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                return nonBackwardsCurrentTimestamp;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>            }</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>         );</span>\n \n         final byte[] uuidBytes = new byte[15];\n         int i = 0;</pre></div>", "author": "jasontedor", "createdAt": "2020-02-17T20:55:53Z", "path": "server/src/main/java/org/elasticsearch/common/TimeBasedUUIDGenerator.java", "diffHunk": "@@ -71,7 +74,9 @@ public String getBase64UUID()  {\n                 timestamp++;\n             }\n \n-            lastTimestamp = timestamp;\n+            if (this.lastTimestamp.compareAndSet(lastTimestamp, timestamp)) {", "originalCommit": "3bd07cfe9368a68043f369e93d7862bf14b0ef85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3NDczMA==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380374730", "bodyText": "In your proposal we might call currentTimeMillis() multiple times, but I don't think we have to? It could be computed only once like in master or Tim's proposal?", "author": "jpountz", "createdAt": "2020-02-17T21:41:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwNzM4Nw==", "url": "https://github.com/elastic/elasticsearch/pull/52436#discussion_r380607387", "bodyText": "I missed that, thanks. It can lifted out of the updateAndGet update function as @tbrooks8 did in bf13356.", "author": "jasontedor", "createdAt": "2020-02-18T11:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2Mjk3Mg=="}], "type": "inlineReview"}, {"oid": "bf13356b18bcb22e0da0db8a861afae00cd5847b", "url": "https://github.com/elastic/elasticsearch/commit/bf13356b18bcb22e0da0db8a861afae00cd5847b", "message": "Use update and get", "committedDate": "2020-02-18T01:36:06Z", "type": "commit"}]}