{"pr_number": 54020, "pr_title": "EQL: Add wildcard function", "pr_author": "rw-access", "pr_createdAt": "2020-03-23T20:23:35Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/54020", "timeline": [{"oid": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "url": "https://github.com/elastic/elasticsearch/commit/c0c7995ed5a01269bcd28fe68efd28e015494fb0", "message": "EQL: Add wildcard function", "committedDate": "2020-03-23T20:18:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396771793", "body": "`java.*` packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.", "bodyText": "java.* packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.", "bodyHTML": "<p dir=\"auto\"><code>java.*</code> packages should be imported - the only reason when a class should be fully qualified if there's a class name clash.</p>", "author": "costin", "createdAt": "2020-03-23T21:37:02Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTE4MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809180", "bodyText": "thanks. I think this was an oversight on my part using IntelliJ's 'automatically import class' functionality. cleaned this up with the array initialization", "author": "rw-access", "createdAt": "2020-03-23T23:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772168", "body": "Easier to do `Arrays.asList(args..)` directly in the constructor", "bodyText": "Easier to do Arrays.asList(args..) directly in the constructor", "bodyHTML": "<p dir=\"auto\">Easier to do <code>Arrays.asList(args..)</code> directly in the constructor</p>", "author": "costin", "createdAt": "2020-03-23T21:37:52Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwODk5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396808991", "bodyText": "I tried to find a way to get src, then all of patterns and couldn't find a good way.\nArrays.asList(src, patterns) didn't seem to work. I'm definitely open to learning a better way", "author": "rw-access", "createdAt": "2020-03-23T23:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396772806", "body": "```suggestion\r\n        super(source, Arrays.asList(field, patterns));\r\n```\r\n\r\nlike the rest of the subclasses.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(source, getArguments(field, patterns));\n          \n          \n            \n                    super(source, Arrays.asList(field, patterns));\n          \n      \n    \n    \n  \n\nlike the rest of the subclasses.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">super</span>(source, <span class=\"x x-first x-last\">getArguments</span>(field, patterns));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">super</span>(source, <span class=\"pl-smi x x-first\">Arrays</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">asList</span>(field, patterns));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">like the rest of the subclasses.</p>", "author": "costin", "createdAt": "2020-03-23T21:39:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgwOTM2Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396809366", "bodyText": "doesn't seem to work if the first value is a T, and the next is a List<T>", "author": "rw-access", "createdAt": "2020-03-23T23:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0MDcxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r399240712", "bodyText": "CollectionUtils.combine(patterns, field) or if you want to preserve the order:\nCollectionUtils.combine(singletonList(field), patterns)", "author": "costin", "createdAt": "2020-03-27T12:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc3MjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MjgxMg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396782812", "body": "```suggestion\r\n        return Expressions.foldable(arguments());\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean foldable = field.foldable();\n          \n          \n            \n                    for (Expression p : patterns) {\n          \n          \n            \n                        foldable = foldable && p.foldable();\n          \n          \n            \n                    }\n          \n          \n            \n                    return foldable;\n          \n          \n            \n                    return Expressions.foldable(arguments());", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">boolean</span> foldable <span class=\"pl-k\">=</span> field<span class=\"pl-k\">.</span>foldable();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">Expression</span> p <span class=\"pl-k\">:</span> patterns) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            foldable <span class=\"pl-k\">=</span> foldable <span class=\"pl-k\">&amp;&amp;</span> p<span class=\"pl-k\">.</span>foldable();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">return</span> foldable;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Expressions</span><span class=\"pl-k\">.</span>foldable(arguments());</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "costin", "createdAt": "2020-03-23T22:00:57Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        boolean foldable = field.foldable();\n+        for (Expression p : patterns) {\n+            foldable = foldable && p.foldable();\n+        }\n+        return foldable;", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396783925", "body": "```suggestion\r\n    return asLike().makePipe();\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Expression asLikes = asLikes();\n          \n          \n            \n                    if (asLikes instanceof Like) {\n          \n          \n            \n                        return ((Like) asLikes).makePipe();\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return ((Or) asLikes).makePipe();\n          \n          \n            \n                    }\n          \n          \n            \n                return asLike().makePipe();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"92\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-smi\">Expression</span> asLikes <span class=\"pl-k\">=</span> asLikes();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"93\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">if</span> (asLikes <span class=\"pl-k\">instanceof</span> <span class=\"pl-smi\">Like</span>) {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"94\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> ((<span class=\"pl-smi\">Like</span>) asLikes)<span class=\"pl-k\">.</span>makePipe();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"95\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        } <span class=\"pl-k\">else</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"96\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            <span class=\"pl-k\">return</span> ((<span class=\"pl-smi\">Or</span>) asLikes)<span class=\"pl-k\">.</span>makePipe();</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"97\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        }</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"92\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-k\">return</span> asLike()<span class=\"pl-k\">.</span>makePipe();</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "costin", "createdAt": "2020-03-23T22:03:24Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjUxMw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792513", "bodyText": "This doesn't seem to be needed and in fact the implementation should be throw new EqlIllegalArgumentException(\"should not call this method\")", "author": "costin", "createdAt": "2020-03-23T22:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMjkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396812901", "bodyText": "awesome. that was my hope.\nI still need to keep fold() though for the optimizer, right?", "author": "rw-access", "createdAt": "2020-03-23T23:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4MzkyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784265", "body": "Since it's always a Like or an Or, return a `ScalarFunction` instead. Also the method should be private.", "bodyText": "Since it's always a Like or an Or, return a ScalarFunction instead. Also the method should be private.", "bodyHTML": "<p dir=\"auto\">Since it's always a Like or an Or, return a <code>ScalarFunction</code> instead. Also the method should be private.</p>", "author": "costin", "createdAt": "2020-03-23T22:04:09Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxOTUxNg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396819516", "bodyText": "Currently accessing via the Optimizer, which is why it was left public:\nhttps://github.com/elastic/elasticsearch/pull/54020/files#diff-cb6f05d0222f3291ea3df5d33525d6f6R71", "author": "rw-access", "createdAt": "2020-03-23T23:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4NDM5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396784395", "body": "Extra new line.", "bodyText": "Extra new line.", "bodyHTML": "<p dir=\"auto\">Extra new line.</p>", "author": "costin", "createdAt": "2020-03-23T22:04:29Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc4ODc4Mg==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396788782", "body": "Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:\r\n\r\nconstructor\r\nnodeInfo/replaceChildren\r\ntype resolution\r\ngetters\r\ndatatype/nullable\r\nfoldable/fold\r\nscripting & co\r\nequals/hash\r\n", "bodyText": "Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:\nconstructor\nnodeInfo/replaceChildren\ntype resolution\ngetters\ndatatype/nullable\nfoldable/fold\nscripting & co\nequals/hash", "bodyHTML": "<p dir=\"auto\">Please implement the methods in the order of the super class (which is not alphabetical) which roughly is:</p>\n<p dir=\"auto\">constructor<br>\nnodeInfo/replaceChildren<br>\ntype resolution<br>\ngetters<br>\ndatatype/nullable<br>\nfoldable/fold<br>\nscripting &amp; co<br>\nequals/hash</p>", "author": "costin", "createdAt": "2020-03-23T22:14:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MjI1MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396792250", "body": "Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly", "bodyText": "Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly", "bodyHTML": "<p dir=\"auto\">Since the optimizer is replacing this function, this method will never be called but rather Like and Or directly</p>", "author": "costin", "createdAt": "2020-03-23T22:22:23Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.utils.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    private static List<Expression> getArguments(Expression src, List<Expression> patterns) {\n+        List<Expression> arguments = new java.util.ArrayList<>(Collections.singletonList(src));\n+        arguments.addAll(patterns);\n+        return arguments;\n+    }\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, getArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    public Expression asLikes() {\n+        Expression result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).makePipe();\n+        } else {\n+            return ((Or) asLikes).makePipe();\n+        }\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        Expression asLikes = asLikes();\n+        if (asLikes instanceof Like) {\n+            return ((Like) asLikes).asScript();\n+        } else {\n+            return ((Or) asLikes).asScript();\n+        }\n+    }", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5MzEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396793100", "body": "Make the class `abstract` or better yet final + private constructor to prevent instantiation/inheritance.", "bodyText": "Make the class abstract or better yet final + private constructor to prevent instantiation/inheritance.", "bodyHTML": "<p dir=\"auto\">Make the class <code>abstract</code> or better yet final + private constructor to prevent instantiation/inheritance.</p>", "author": "costin", "createdAt": "2020-03-23T22:24:18Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/utils/StringUtils.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.utils;\n+\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.LikePattern;\n+\n+public class StringUtils {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795034", "body": "How many arguments does wildcard expect?", "bodyText": "How many arguments does wildcard expect?", "bodyHTML": "<p dir=\"auto\">How many arguments does wildcard expect?</p>", "author": "costin", "createdAt": "2020-03-23T22:28:46Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/function/FunctionRegistry.java", "diffHunk": "@@ -421,4 +421,26 @@ public static FunctionDefinition def(Class<? extends Function> function, Functio\n     protected interface CastFunctionBuilder<T> {\n         T build(Source source, Expression expression, DataType dataType);\n     }\n+\n+    @SuppressWarnings(\"overloads\")  // These are ambiguous if you aren't using ctor references but we always do\n+    public static <T extends Function> FunctionDefinition def(Class<T> function,", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzI1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813255", "bodyText": "at least two, but it's unbounded in the maximum number\nhttps://eql.readthedocs.io/en/latest/query-guide/functions.html#wildcard", "author": "rw-access", "createdAt": "2020-03-23T23:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396795064", "body": "Why?", "bodyText": "Why?", "bodyHTML": "<p dir=\"auto\">Why?</p>", "author": "costin", "createdAt": "2020-03-23T22:28:51Z", "path": "x-pack/plugin/ql/src/main/java/org/elasticsearch/xpack/ql/expression/predicate/logical/BinaryLogic.java", "diffHunk": "@@ -34,7 +34,7 @@ protected TypeResolution resolveInputType(Expression e, Expressions.ParamOrdinal\n     }\n \n     @Override\n-    protected Pipe makePipe() {\n+    public Pipe makePipe() {", "originalCommit": "c0c7995ed5a01269bcd28fe68efd28e015494fb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgxMzY3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r396813675", "bodyText": "I'll set this back. I was using it within Wildcard.make_pipe, but since that is unreachable, I'll set this back.", "author": "rw-access", "createdAt": "2020-03-23T23:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc5NTA2NA=="}], "type": "inlineReview"}, {"oid": "dea1f7baa1fe1cac55fc65e5246af907cb446894", "url": "https://github.com/elastic/elasticsearch/commit/dea1f7baa1fe1cac55fc65e5246af907cb446894", "message": "EQL: Cleanup Wildcard.getArguments", "committedDate": "2020-03-23T22:59:54Z", "type": "commit"}, {"oid": "d87361de121acfc972776d8c173531a40fe7a8a7", "url": "https://github.com/elastic/elasticsearch/commit/d87361de121acfc972776d8c173531a40fe7a8a7", "message": "EQL: Cleanup Wildcard and rearrange methods", "committedDate": "2020-03-23T23:20:48Z", "type": "commit"}, {"oid": "3826eac1904ef22a57b15fa0243fd5fcb497af3e", "url": "https://github.com/elastic/elasticsearch/commit/3826eac1904ef22a57b15fa0243fd5fcb497af3e", "message": "EQL: Wildcard newline lint", "committedDate": "2020-03-23T23:23:43Z", "type": "commit"}, {"oid": "f93d2975112e81d513b6ed835eded45485220846", "url": "https://github.com/elastic/elasticsearch/commit/f93d2975112e81d513b6ed835eded45485220846", "message": "EQL: Make StringUtils function final", "committedDate": "2020-03-23T23:37:51Z", "type": "commit"}, {"oid": "78f4fbdb1c342c729a684e9758994e14c18d367c", "url": "https://github.com/elastic/elasticsearch/commit/78f4fbdb1c342c729a684e9758994e14c18d367c", "message": "EQL: Make Wildcard.asLikes return ScalarFunction", "committedDate": "2020-03-23T23:43:45Z", "type": "commit"}, {"oid": "c93b67c11694dcd2f10cdf5854e00a17192a1b74", "url": "https://github.com/elastic/elasticsearch/commit/c93b67c11694dcd2f10cdf5854e00a17192a1b74", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function", "committedDate": "2020-03-24T15:02:59Z", "type": "commit"}, {"oid": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "url": "https://github.com/elastic/elasticsearch/commit/169245d5d956f6ef65a598cecae15a4b5352a4a3", "message": "QL: Restore BinaryLogic.java", "committedDate": "2020-03-24T15:04:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397237007", "body": "Isn't `wildcard` a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has `substring` in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.", "bodyText": "Isn't wildcard a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has substring in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.", "bodyHTML": "<p dir=\"auto\">Isn't <code>wildcard</code> a \"string function\"? If so, it should belong to the FunctionDefinition array that, also, has <code>substring</code> in it. In SQL we were grouping these functions by their type: string, grouping, math, conditional, date etc.</p>", "author": "astefan", "createdAt": "2020-03-24T15:21:11Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/EqlFunctionRegistry.java", "diffHunk": "@@ -17,14 +18,17 @@\n     public EqlFunctionRegistry() {\n         super(functions());\n     }\n-    \n+\n     private static FunctionDefinition[][] functions() {\n         return new FunctionDefinition[][] {\n         // Scalar functions\n         // String\n             new FunctionDefinition[] {\n                 def(Substring.class, Substring::new, \"substring\"),\n             },\n+            new FunctionDefinition[] {\n+                def(Wildcard.class, Wildcard::new, \"wildcard\"),", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNjk2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397426963", "bodyText": "oh right, good catch", "author": "rw-access", "createdAt": "2020-03-24T20:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzNzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzIzODU4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397238581", "body": "`childrenResolved() == false`", "bodyText": "childrenResolved() == false", "bodyHTML": "<p dir=\"auto\"><code>childrenResolved() == false</code></p>", "author": "astefan", "createdAt": "2020-03-24T15:23:16Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397243661", "body": "Shouldn't the field be, also, foldable? (ie `return Expressions.foldable(children());`)", "bodyText": "Shouldn't the field be, also, foldable? (ie return Expressions.foldable(children());)", "bodyHTML": "<p dir=\"auto\">Shouldn't the field be, also, foldable? (ie <code>return Expressions.foldable(children());</code>)</p>", "author": "astefan", "createdAt": "2020-03-24T15:29:36Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Njc5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397296796", "bodyText": "Since wildcard is converted to a bunch of LIKEs, I'm wondering if foldable() shouldn't fall back to the result of the wildcard -> LIKEs transformation foldable() functionality. Basically the Or.foldable().", "author": "astefan", "createdAt": "2020-03-24T16:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyNzM0Ng==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397427346", "bodyText": "arguments() = field + patterns()\narguments() comes from the super and is identical to children()\nI'll swap to children() since that's more obvious", "author": "rw-access", "createdAt": "2020-03-24T20:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI5Mjg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397292890", "body": "I don't think `isStringAndExact` is correct here... \"exact\" refers to a field being of type `keyword` or having a sub-field of type `keyword` basically. `isString` should be enough imo.\r\nAlso, shouldn't the `p.foldable() == false` (comparison against variables basically) check be before this one?", "bodyText": "I don't think isStringAndExact is correct here... \"exact\" refers to a field being of type keyword or having a sub-field of type keyword basically. isString should be enough imo.\nAlso, shouldn't the p.foldable() == false (comparison against variables basically) check be before this one?", "bodyHTML": "<p dir=\"auto\">I don't think <code>isStringAndExact</code> is correct here... \"exact\" refers to a field being of type <code>keyword</code> or having a sub-field of type <code>keyword</code> basically. <code>isString</code> should be enough imo.<br>\nAlso, shouldn't the <code>p.foldable() == false</code> (comparison against variables basically) check be before this one?</p>", "author": "astefan", "createdAt": "2020-03-24T16:31:28Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397303377", "body": "Maybe move this method to `org.elasticsearch.xpack.ql.util.CollectionUtils` and make it more generic?", "bodyText": "Maybe move this method to org.elasticsearch.xpack.ql.util.CollectionUtils and make it more generic?", "bodyHTML": "<p dir=\"auto\">Maybe move this method to <code>org.elasticsearch.xpack.ql.util.CollectionUtils</code> and make it more generic?</p>", "author": "astefan", "createdAt": "2020-03-24T16:45:23Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/expression/function/scalar/string/Wildcard.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.eql.expression.function.scalar.string;\n+\n+import org.elasticsearch.xpack.eql.EqlIllegalArgumentException;\n+import org.elasticsearch.xpack.eql.util.StringUtils;\n+import org.elasticsearch.xpack.ql.expression.Expression;\n+import org.elasticsearch.xpack.ql.expression.Expressions;\n+import org.elasticsearch.xpack.ql.expression.Expressions.ParamOrdinal;\n+import org.elasticsearch.xpack.ql.expression.function.scalar.ScalarFunction;\n+import org.elasticsearch.xpack.ql.expression.gen.pipeline.Pipe;\n+import org.elasticsearch.xpack.ql.expression.gen.script.ScriptTemplate;\n+import org.elasticsearch.xpack.ql.expression.predicate.logical.Or;\n+import org.elasticsearch.xpack.ql.expression.predicate.regex.Like;\n+import org.elasticsearch.xpack.ql.tree.NodeInfo;\n+import org.elasticsearch.xpack.ql.tree.Source;\n+import org.elasticsearch.xpack.ql.type.DataType;\n+import org.elasticsearch.xpack.ql.type.DataTypes;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.logging.LoggerMessageFormat.format;\n+import static org.elasticsearch.xpack.ql.expression.TypeResolutions.isStringAndExact;\n+\n+/**\n+ * EQL wildcard function. Matches the form:\n+ *     wildcard(field, \"*wildcard*pattern*\", \"*wildcard*pattern*\")\n+ */\n+public class Wildcard extends ScalarFunction {\n+\n+    private final Expression field;\n+    private final List<Expression> patterns;\n+\n+    public Wildcard(Source source, Expression field, List<Expression> patterns) {\n+        super(source, toArguments(field, patterns));\n+        this.field = field;\n+        this.patterns = patterns;\n+    }\n+\n+    @Override\n+    protected NodeInfo<? extends Expression> info() {\n+        return NodeInfo.create(this, Wildcard::new, field, patterns);\n+    }\n+\n+    @Override\n+    public Expression replaceChildren(List<Expression> newChildren) {\n+        if (newChildren.size() < 2) {\n+            throw new IllegalArgumentException(\"expected at least [2] children but received [\" + newChildren.size() + \"]\");\n+        }\n+\n+        return new Wildcard(source(), newChildren.get(0), newChildren.subList(1, newChildren.size()));\n+    }\n+\n+    @Override\n+    public DataType dataType() {\n+        return DataTypes.BOOLEAN;\n+    }\n+\n+    @Override\n+    protected TypeResolution resolveType() {\n+        if (!childrenResolved()) {\n+            return new TypeResolution(\"Unresolved children\");\n+        }\n+\n+        TypeResolution lastResolution = isStringAndExact(field, sourceText(), ParamOrdinal.FIRST);\n+        if (lastResolution.unresolved()) {\n+            return lastResolution;\n+        }\n+\n+        for (Expression p: patterns) {\n+            lastResolution = isStringAndExact(p, sourceText(), ParamOrdinal.DEFAULT);\n+            if (lastResolution.unresolved()) {\n+                break;\n+            }\n+\n+            if (p.foldable() == false) {\n+                return new TypeResolution(format(null, \"wildcard against variables are not (currently) supported; offender [{}] in [{}]\",\n+                    Expressions.name(p),\n+                    sourceText()));\n+            }\n+        }\n+\n+        return lastResolution;\n+    }\n+\n+    @Override\n+    public boolean foldable() {\n+        return Expressions.foldable(arguments());\n+    }\n+\n+    @Override\n+    public Object fold() {\n+        return asLikes().fold();\n+    }\n+\n+    @Override\n+    protected Pipe makePipe() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.makePipe() should not be called directly\");\n+    }\n+\n+    @Override\n+    public ScriptTemplate asScript() {\n+        throw new EqlIllegalArgumentException(\"Wildcard.asScript() should not be called directly\");\n+    }\n+\n+    public ScalarFunction asLikes() {\n+        ScalarFunction result = null;\n+\n+        for (Expression pattern: patterns) {\n+            String wcString = pattern.fold().toString();\n+            Like like = new Like(source(), field, StringUtils.toLikePattern(wcString));\n+            result = result == null ? like : new Or(source(), result, like);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static List<Expression> toArguments(Expression src, List<Expression> patterns) {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0MzIzMw==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397843233", "bodyText": "saw this kind fo construct used in few places\nCollectionUtils.combine(singletonList(src), patterns))", "author": "aleksmaus", "createdAt": "2020-03-25T13:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwMzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNDcwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397304705", "body": "`return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e;` as a shorter (hopefully more elegant) variant?", "bodyText": "return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e; as a shorter (hopefully more elegant) variant?", "bodyHTML": "<p dir=\"auto\"><code>return e instanceof Wildcard ? ((Wildcard) e).asLikes() : e;</code> as a shorter (hopefully more elegant) variant?</p>", "author": "astefan", "createdAt": "2020-03-24T16:46:58Z", "path": "x-pack/plugin/eql/src/main/java/org/elasticsearch/xpack/eql/optimizer/Optimizer.java", "diffHunk": "@@ -60,6 +62,20 @@ public LogicalPlan optimize(LogicalPlan verified) {\n     }\n \n \n+    private static class ReplaceWildcardFunction extends OptimizerRule<Filter> {\n+\n+        @Override\n+        protected LogicalPlan rule(Filter filter) {\n+            return filter.transformExpressionsUp(e -> {\n+                if (e instanceof Wildcard) {\n+                    e = ((Wildcard) e).asLikes();\n+                }\n+\n+                return e;", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzkxMQ==", "url": "https://github.com/elastic/elasticsearch/pull/54020#discussion_r397317911", "body": "I think there are other error messages to check with `wildcard`: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?", "bodyText": "I think there are other error messages to check with wildcard: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?", "bodyHTML": "<p dir=\"auto\">I think there are other error messages to check with <code>wildcard</code>: the fact that the field needs to be string and exact and, also, that the \"patterns\" should be all strings, no?</p>", "author": "astefan", "createdAt": "2020-03-24T17:04:51Z", "path": "x-pack/plugin/eql/src/test/java/org/elasticsearch/xpack/eql/planner/QueryFolderFailTests.java", "diffHunk": "@@ -22,4 +24,19 @@ public void testPropertyEquationInClauseFilterUnsupported() {\n         String msg = e.getMessage();\n         assertEquals(\"Line 1:52: Comparisons against variables are not (currently) supported; offender [parent_process_name] in [==]\", msg);\n     }\n+\n+    public void testWildcardNotEnoughArguments() {", "originalCommit": "169245d5d956f6ef65a598cecae15a4b5352a4a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c7e1475a2962cb62776fe4897f6222dba390cc2", "url": "https://github.com/elastic/elasticsearch/commit/5c7e1475a2962cb62776fe4897f6222dba390cc2", "message": "Merge branch 'master' into eql/wildcard-function", "committedDate": "2020-03-24T20:13:15Z", "type": "commit"}, {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "message": "EQL: Add Wildcard PR feedback", "committedDate": "2020-03-24T20:27:15Z", "type": "commit"}, {"oid": "e12a60c5f36e263062a7ed6679e75b122f93c721", "url": "https://github.com/elastic/elasticsearch/commit/e12a60c5f36e263062a7ed6679e75b122f93c721", "message": "EQL: Add Wildcard PR feedback", "committedDate": "2020-03-24T20:27:15Z", "type": "forcePushed"}, {"oid": "502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "url": "https://github.com/elastic/elasticsearch/commit/502ca88d0430d8c252e0c7c2b63d1d259f9dd4e0", "message": "EQL: Add Wildcard verification tests", "committedDate": "2020-03-24T21:03:44Z", "type": "commit"}, {"oid": "90dc8e035aed864c4dbd247b94301412f1ae4fb1", "url": "https://github.com/elastic/elasticsearch/commit/90dc8e035aed864c4dbd247b94301412f1ae4fb1", "message": "EQL: Switch wildcard to isFoldable test", "committedDate": "2020-03-24T21:25:10Z", "type": "commit"}, {"oid": "d482c472d05af7220ce1896e323deb30769b05f8", "url": "https://github.com/elastic/elasticsearch/commit/d482c472d05af7220ce1896e323deb30769b05f8", "message": "EQL: Change wildcard test to numeric field", "committedDate": "2020-03-24T21:52:53Z", "type": "commit"}, {"oid": "285582f53796dbbafda6c55e5fde528c6bffa740", "url": "https://github.com/elastic/elasticsearch/commit/285582f53796dbbafda6c55e5fde528c6bffa740", "message": "EQL: Remove Wildcard.get_arguments", "committedDate": "2020-03-25T14:53:06Z", "type": "commit"}, {"oid": "167c13a954a21809fce72c602d1c9aee0efa1790", "url": "https://github.com/elastic/elasticsearch/commit/167c13a954a21809fce72c602d1c9aee0efa1790", "message": "Merge remote-tracking branch 'origin/master' into eql/wildcard-function", "committedDate": "2020-03-30T20:21:20Z", "type": "commit"}, {"oid": "d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "url": "https://github.com/elastic/elasticsearch/commit/d3b1dd1747ddc7c5d663dde21e1bc0a0d99f95a7", "message": "Merge branch 'master' into eql/wildcard-function", "committedDate": "2020-04-02T14:36:38Z", "type": "commit"}]}