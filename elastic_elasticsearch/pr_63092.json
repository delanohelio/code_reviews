{"pr_number": 63092, "pr_title": "[ML] adding for_export flag for ml plugin GET resource APIs", "pr_author": "benwtrent", "pr_createdAt": "2020-09-30T17:29:20Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/63092", "timeline": [{"oid": "baf04b72176018f812a2ec3a2e37f170532a6c58", "url": "https://github.com/elastic/elasticsearch/commit/baf04b72176018f812a2ec3a2e37f170532a6c58", "message": "[ML] adding for_export flag for APIs", "committedDate": "2020-09-30T17:28:05Z", "type": "commit"}, {"oid": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "url": "https://github.com/elastic/elasticsearch/commit/fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "message": "fixing test", "committedDate": "2020-09-30T18:11:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497990034", "body": "BTW, is there any reason for `ALLOW_NO_MATCH` to be `ParseField` rather than `String`?", "bodyText": "BTW, is there any reason for ALLOW_NO_MATCH to be ParseField rather than String?", "bodyHTML": "<p dir=\"auto\">BTW, is there any reason for <code>ALLOW_NO_MATCH</code> to be <code>ParseField</code> rather than <code>String</code>?</p>", "author": "przemekwitek", "createdAt": "2020-10-01T05:23:05Z", "path": "client/rest-high-level/src/main/java/org/elasticsearch/client/ml/GetDataFrameAnalyticsRequest.java", "diffHunk": "@@ -33,10 +33,12 @@\n public class GetDataFrameAnalyticsRequest implements Validatable {\n \n     public static final ParseField ALLOW_NO_MATCH = new ParseField(\"allow_no_match\");", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MTgwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498181805", "bodyText": "probably not, but just didn't touch the existing field :)", "author": "benwtrent", "createdAt": "2020-10-01T11:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MjMyMg==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497992322", "body": "```suggestion\r\n        } else { // Don't include random defaults or unnecessary defaults in export\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else { // Don't include random defaults or unnecessary defauls in export\n          \n          \n            \n                    } else { // Don't include random defaults or unnecessary defaults in export", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        } <span class=\"pl-k\">else</span> { <span class=\"pl-c\"><span class=\"pl-c\">//</span> Don't include random defaults or unnecessary <span class=\"x x-first x-last\">defauls</span> in export</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        } <span class=\"pl-k\">else</span> { <span class=\"pl-c\"><span class=\"pl-c\">//</span> Don't include random defaults or unnecessary <span class=\"x x-first x-last\">defaults</span> in export</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "przemekwitek", "createdAt": "2020-10-01T05:31:46Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r497993914", "body": "So this `else` block is not for making the retrieved config \"puttable\" but it does something more (clears defaults).\r\nI'm wondering what happens when we ever change the code for generating the default. Then the config is indexed with default `D1`, then in the subsequent version we change the default to be `D2` and then we retrieve the config for export and the default is not cleared (as it was the default in the past but no longer is). Is that a good behavior?", "bodyText": "So this else block is not for making the retrieved config \"puttable\" but it does something more (clears defaults).\nI'm wondering what happens when we ever change the code for generating the default. Then the config is indexed with default D1, then in the subsequent version we change the default to be D2 and then we retrieve the config for export and the default is not cleared (as it was the default in the past but no longer is). Is that a good behavior?", "bodyHTML": "<p dir=\"auto\">So this <code>else</code> block is not for making the retrieved config \"puttable\" but it does something more (clears defaults).<br>\nI'm wondering what happens when we ever change the code for generating the default. Then the config is indexed with default <code>D1</code>, then in the subsequent version we change the default to be <code>D2</code> and then we retrieve the config for export and the default is not cleared (as it was the default in the past but no longer is). Is that a good behavior?</p>", "author": "przemekwitek", "createdAt": "2020-10-01T05:37:30Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4Mjk0Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498182943", "bodyText": "@przemekwitek a related question.\nWhat if the user didn't set their own chunking_config but when they cloned the datafeed, they DID change the aggregation information (maybe the date_histogram bucket size). Then when they try to PUT, the chunking config is now illegal.\nShould we allow this behavior?", "author": "benwtrent", "createdAt": "2020-10-01T11:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzEyNg==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498217126", "bodyText": "Tough question. I guess it's better to stick to the promise that we are able to PUT the config obtained via GET with for_export...", "author": "przemekwitek", "createdAt": "2020-10-01T12:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk5MzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNDY0MA==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498034640", "body": "We should have a single method that calculates the default query delay between this one and `Builder.setDefaultQueryDelay`", "bodyText": "We should have a single method that calculates the default query delay between this one and Builder.setDefaultQueryDelay", "bodyHTML": "<p dir=\"auto\">We should have a single method that calculates the default query delay between this one and <code>Builder.setDefaultQueryDelay</code></p>", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:23:20Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498036877", "body": "Is there a benefit to not always return the query? The query is integral to the behaviour of the datafeed. Even in the improbable scenario where we change the default query in a future release, it'd be a weird surprise to get a datafeed `for_export` from a previous version cluster and put it in a newer version to find out different docs are picked because the default query changed.", "bodyText": "Is there a benefit to not always return the query? The query is integral to the behaviour of the datafeed. Even in the improbable scenario where we change the default query in a future release, it'd be a weird surprise to get a datafeed for_export from a previous version cluster and put it in a newer version to find out different docs are picked because the default query changed.", "bodyHTML": "<p dir=\"auto\">Is there a benefit to not always return the query? The query is integral to the behaviour of the datafeed. Even in the improbable scenario where we change the default query in a future release, it'd be a weird surprise to get a datafeed <code>for_export</code> from a previous version cluster and put it in a newer version to find out different docs are picked because the default query changed.</p>", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:27:31Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -451,17 +453,47 @@ public void writeTo(StreamOutput out) throws IOException {\n     @Override\n     public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n         builder.startObject();\n-        builder.field(ID.getPreferredName(), id);\n-        builder.field(Job.ID.getPreferredName(), jobId);\n-        if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+        if (params.paramAsBoolean(FOR_EXPORT, false) == false) {\n+            builder.field(ID.getPreferredName(), id);\n+            // We don't include the job_id in export as we assume the PUT will be referring to a new job as well\n+            builder.field(Job.ID.getPreferredName(), jobId);\n+            if (params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(CONFIG_TYPE.getPreferredName(), TYPE);\n+            }\n+            if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n+                builder.field(HEADERS.getPreferredName(), headers);\n+            }\n+            builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            builder.field(QUERY.getPreferredName(), queryProvider.getQuery());\n+            if (chunkingConfig != null) {\n+                builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n+            }\n+            builder.startObject(INDICES_OPTIONS.getPreferredName());\n+            indicesOptions.toXContent(builder, params);\n+            builder.endObject();\n+        } else { // Don't include random defaults or unnecessary defauls in export\n+            if (queryDelay.equals(defaultRandomQueryDelay()) == false) {\n+                builder.field(QUERY_DELAY.getPreferredName(), queryDelay.getStringRep());\n+            }\n+            // This is always \"match_all\"\n+            if (queryProvider.equals(QueryProvider.defaultQuery()) == false) {", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MzkxNw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498183917", "bodyText": "put it in a newer version to find out different docs are picked because the default query changed.\n\nIf we change the default query to EXCLUDE docs, I think that is a huge thing and should probably never be done.\nI can happily include the query here, but it did seem unnecessary to me.", "author": "benwtrent", "createdAt": "2020-10-01T11:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwMTA4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498301085", "bodyText": "Agreed that changing the default query sounds hard to justify :-)\nBut I do think we should include the query. We return it in get, so we might as well also return it for_export.", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T14:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzODc1Mw==", "url": "https://github.com/elastic/elasticsearch/pull/63092#discussion_r498038753", "body": "Same here, let's avoid duplication on the default calculation. We can reuse this in the `Builder.setDefaultChunkingConfig`.", "bodyText": "Same here, let's avoid duplication on the default calculation. We can reuse this in the Builder.setDefaultChunkingConfig.", "bodyHTML": "<p dir=\"auto\">Same here, let's avoid duplication on the default calculation. We can reuse this in the <code>Builder.setDefaultChunkingConfig</code>.</p>", "author": "dimitris-athanasiou", "createdAt": "2020-10-01T07:31:00Z", "path": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/ml/datafeed/DatafeedConfig.java", "diffHunk": "@@ -473,26 +505,36 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n             builder.endObject();\n         }\n         builder.field(SCROLL_SIZE.getPreferredName(), scrollSize);\n-        if (chunkingConfig != null) {\n-            builder.field(CHUNKING_CONFIG.getPreferredName(), chunkingConfig);\n-        }\n-        if (headers.isEmpty() == false && params.paramAsBoolean(ToXContentParams.FOR_INTERNAL_STORAGE, false)) {\n-            builder.field(HEADERS.getPreferredName(), headers);\n-        }\n         if (delayedDataCheckConfig != null) {\n             builder.field(DELAYED_DATA_CHECK_CONFIG.getPreferredName(), delayedDataCheckConfig);\n         }\n         if (maxEmptySearches != null) {\n             builder.field(MAX_EMPTY_SEARCHES.getPreferredName(), maxEmptySearches);\n         }\n-        builder.startObject(INDICES_OPTIONS.getPreferredName());\n-        indicesOptions.toXContent(builder, params);\n-        builder.endObject();\n-\n         builder.endObject();\n         return builder;\n     }\n \n+    private TimeValue defaultRandomQueryDelay() {\n+        Random random = new Random(jobId.hashCode());\n+        long delayMillis = random.longs(Builder.MIN_DEFAULT_QUERY_DELAY.millis(), Builder.MAX_DEFAULT_QUERY_DELAY.millis())\n+            .findFirst().getAsLong();\n+        return TimeValue.timeValueMillis(delayMillis);\n+    }\n+\n+    private ChunkingConfig defaultChunkingConfig() {\n+        if (aggProvider == null || aggProvider.getParsedAggs() == null) {", "originalCommit": "fd78a818c3b30ef8e6ea1aebbb5af524ee67f5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa4ed0bcf916fb3598b6e24aab33bb14f2f488a9", "url": "https://github.com/elastic/elasticsearch/commit/fa4ed0bcf916fb3598b6e24aab33bb14f2f488a9", "message": "addressing pr comments", "committedDate": "2020-10-01T12:32:36Z", "type": "commit"}, {"oid": "90d7c0ac5ae9536cc5aa33f3025683886d72d5b5", "url": "https://github.com/elastic/elasticsearch/commit/90d7c0ac5ae9536cc5aa33f3025683886d72d5b5", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-add-for-export-flag", "committedDate": "2020-10-01T12:50:48Z", "type": "commit"}, {"oid": "03edfd4fec42419d1c495cba55e3bce7d29e9cc9", "url": "https://github.com/elastic/elasticsearch/commit/03edfd4fec42419d1c495cba55e3bce7d29e9cc9", "message": "fixing style", "committedDate": "2020-10-01T12:59:49Z", "type": "commit"}, {"oid": "2a639213f77b08f2eda92b6c3fed8b101f509940", "url": "https://github.com/elastic/elasticsearch/commit/2a639213f77b08f2eda92b6c3fed8b101f509940", "message": "Merge remote-tracking branch 'upstream/master' into feature/ml-add-for-export-flag", "committedDate": "2020-10-02T11:14:34Z", "type": "commit"}]}