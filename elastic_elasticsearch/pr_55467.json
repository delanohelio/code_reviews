{"pr_number": 55467, "pr_title": "Rely on the computeIfAbsent logic to prevent duplicated compilation of scripts", "pr_author": "mjmbischoff", "pr_createdAt": "2020-04-20T14:59:36Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55467", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r420314607", "body": "The call to `checkCompilationLimit()` is no longer locked on the `ScriptCache`, we'll have to make this call safe.", "bodyText": "The call to checkCompilationLimit() is no longer locked on the ScriptCache, we'll have to make this call safe.", "bodyHTML": "<p dir=\"auto\">The call to <code>checkCompilationLimit()</code> is no longer locked on the <code>ScriptCache</code>, we'll have to make this call safe.</p>", "author": "stu-elastic", "createdAt": "2020-05-05T18:20:36Z", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();", "originalCommit": "ae24c668a68496080b9990b978503590b79d9aca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NTQzOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r422195439", "bodyText": "Yeah noticed that too that's why I added commit b55e8e3", "author": "mjmbischoff", "createdAt": "2020-05-08T15:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDYwNw=="}], "type": "inlineReview"}, {"oid": "0dd254137c228138d9b3af4ffdd2f5acc7217d92", "url": "https://github.com/elastic/elasticsearch/commit/0dd254137c228138d9b3af4ffdd2f5acc7217d92", "message": "Instead of serializing compilation using a plain lock / mutex combined with a double check, rely on the computeIfAbsent logic to prevent duplicated compilation of scripts.", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "65a09c3d8a954dddeb109cc7ca588e5833deb01f", "url": "https://github.com/elastic/elasticsearch/commit/65a09c3d8a954dddeb109cc7ca588e5833deb01f", "message": "Updating checkCompilationLimit to be thread-safe", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "message": "Fixing checkstyle violations.", "committedDate": "2020-05-08T16:02:14Z", "type": "commit"}, {"oid": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "url": "https://github.com/elastic/elasticsearch/commit/e999353b7adf00745d2218b90c5e2031cc7b2a43", "message": "Fixing checkstyle violations.", "committedDate": "2020-05-08T16:02:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r439065901", "body": "Let's clean this up a bit by moving the `try/catch` from inside the lambda out to this level and avoid checking for `RuntimeException`.\r\n```diff\r\ngit diff\r\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\r\nindex 148f06716a5..5d59a91b207 100644\r\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\r\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\r\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\r\n \r\n import org.apache.logging.log4j.LogManager;\r\n import org.apache.logging.log4j.Logger;\r\n-import org.elasticsearch.ElasticsearchException;\r\n import org.elasticsearch.common.breaker.CircuitBreaker;\r\n import org.elasticsearch.common.breaker.CircuitBreakingException;\r\n import org.elasticsearch.common.cache.Cache;\r\n@@ -98,41 +97,41 @@ public class ScriptCache {\r\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\r\n         try {\r\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\r\n-                try {\r\n-                    // Either an un-cached inline script or indexed script\r\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\r\n-                    // but give the script engine the chance to be better, give it separate name + source code\r\n-                    // for the inline case, then its anonymous: null.\r\n-                    if (logger.isTraceEnabled()) {\r\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\r\n-                            lang, options);\r\n-                    }\r\n-                    // Check whether too many compilations have happened\r\n-                    checkCompilationLimit();\r\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\r\n-                    // Since the cache key is the script content itself we don't need to\r\n-                    // invalidate/check the cache if an indexed script changes.\r\n-                    scriptMetrics.onCompilation();\r\n-                    return compiledScript;\r\n-                } catch (ScriptException good) {\r\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\r\n-                    throw good; // its already good\r\n-                } catch (Exception exception) {\r\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\r\n-                            exception);\r\n+                // Either an un-cached inline script or indexed script\r\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\r\n+                // but give the script engine the chance to be better, give it separate name + source code\r\n+                // for the inline case, then its anonymous: null.\r\n+                if (logger.isTraceEnabled()) {\r\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\r\n+                        lang, options);\r\n                 }\r\n+                // Check whether too many compilations have happened\r\n+                checkCompilationLimit();\r\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\r\n+                // Since the cache key is the script content itself we don't need to\r\n+                // invalidate/check the cache if an indexed script changes.\r\n+                scriptMetrics.onCompilation();\r\n+                return compiledScript;\r\n             }));\r\n         } catch (ExecutionException executionException) {\r\n             Throwable cause = executionException.getCause();\r\n-            if(cause instanceof RuntimeException) {\r\n-                throw (RuntimeException) cause;\r\n+            if (cause instanceof ScriptException) {\r\n+                throw (ScriptException) cause;\r\n+            } else if (cause instanceof Exception) {\r\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\r\n             } else {\r\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\r\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\r\n+                rethrow(cause);\r\n+                throw new AssertionError(cause);\r\n             }\r\n         }\r\n     }\r\n \r\n+    /** Hack to rethrow unknown Exceptions from compile: */\r\n+    @SuppressWarnings(\"unchecked\")\r\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\r\n+        throw (T) t;\r\n+    }\r\n+\r\n     public ScriptStats stats() {\r\n         return scriptMetrics.stats();\r\n     }\r\n```", "bodyText": "Let's clean this up a bit by moving the try/catch from inside the lambda out to this level and avoid checking for RuntimeException.\ngit diff\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5..5d59a91b207 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n@@ -98,41 +97,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -> {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n-                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T extends Throwable> void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }", "bodyHTML": "<p dir=\"auto\">Let's clean this up a bit by moving the <code>try/catch</code> from inside the lambda out to this level and avoid checking for <code>RuntimeException</code>.</p>\n<div class=\"highlight highlight-source-diff position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"git diff\ndiff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\nindex 148f06716a5..5d59a91b207 100644\n--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java\n@@ -21,7 +21,6 @@ package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n@@ -98,41 +97,41 @@ public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -&gt; {\n-                try {\n-                    // Either an un-cached inline script or indexed script\n-                    // If the script type is inline the name will be the same as the code for identification in exceptions\n-                    // but give the script engine the chance to be better, give it separate name + source code\n-                    // for the inline case, then its anonymous: null.\n-                    if (logger.isTraceEnabled()) {\n-                        logger.trace(&quot;context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]&quot;, context.name, type,\n-                            lang, options);\n-                    }\n-                    // Check whether too many compilations have happened\n-                    checkCompilationLimit();\n-                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n-                    // Since the cache key is the script content itself we don't need to\n-                    // invalidate/check the cache if an indexed script changes.\n-                    scriptMetrics.onCompilation();\n-                    return compiledScript;\n-                } catch (ScriptException good) {\n-                    // TODO: remove this try-catch completely, when all script engines have good exceptions!\n-                    throw good; // its already good\n-                } catch (Exception exception) {\n-                    throw new GeneralScriptException(&quot;Failed to compile &quot; + type + &quot; script [&quot; + id + &quot;] using lang [&quot; + lang + &quot;]&quot;,\n-                            exception);\n+                // Either an un-cached inline script or indexed script\n+                // If the script type is inline the name will be the same as the code for identification in exceptions\n+                // but give the script engine the chance to be better, give it separate name + source code\n+                // for the inline case, then its anonymous: null.\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(&quot;context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]&quot;, context.name, type,\n+                        lang, options);\n                 }\n+                // Check whether too many compilations have happened\n+                checkCompilationLimit();\n+                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                // Since the cache key is the script content itself we don't need to\n+                // invalidate/check the cache if an indexed script changes.\n+                scriptMetrics.onCompilation();\n+                return compiledScript;\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n-            if(cause instanceof RuntimeException) {\n-                throw (RuntimeException) cause;\n+            if (cause instanceof ScriptException) {\n+                throw (ScriptException) cause;\n+            } else if (cause instanceof Exception) {\n+                throw new GeneralScriptException(&quot;Failed to compile &quot; + type + &quot; script [&quot; + id + &quot;] using lang [&quot; + lang + &quot;]&quot;, cause);\n             } else {\n-                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -&gt; throwing generic exception.\n-                throw new ElasticsearchException(&quot;Failed to compile &quot; + type + &quot; script [&quot; + id + &quot;] using lang [&quot; + lang + &quot;]&quot;, cause);\n+                rethrow(cause);\n+                throw new AssertionError(cause);\n             }\n         }\n     }\n \n+    /** Hack to rethrow unknown Exceptions from compile: */\n+    @SuppressWarnings(&quot;unchecked&quot;)\n+    static &lt;T extends Throwable&gt; void rethrow(Throwable t) throws T {\n+        throw (T) t;\n+    }\n+\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }\"><pre>git diff\n<span class=\"pl-c1\">diff --git a/server/src/main/java/org/elasticsearch/script/ScriptCache.java b/server/src/main/java/org/elasticsearch/script/ScriptCache.java</span>\nindex 148f06716a5..5d59a91b207 100644\n<span class=\"pl-md\">--- a/server/src/main/java/org/elasticsearch/script/ScriptCache.java</span>\n<span class=\"pl-mi1\">+++ b/server/src/main/java/org/elasticsearch/script/ScriptCache.java</span>\n<span class=\"pl-mdr\">@@ -21,7 +21,6 @@</span> package org.elasticsearch.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>import org.elasticsearch.ElasticsearchException;</span>\n import org.elasticsearch.common.breaker.CircuitBreaker;\n import org.elasticsearch.common.breaker.CircuitBreakingException;\n import org.elasticsearch.common.cache.Cache;\n<span class=\"pl-mdr\">@@ -98,41 +97,41 @@</span> public class ScriptCache {\n         // Relying on computeIfAbsent to avoid multiple threads from compiling the same script\n         try {\n             return context.factoryClazz.cast(cache.computeIfAbsent(cacheKey, key -&gt; {\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                try {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // Either an un-cached inline script or indexed script</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // If the script type is inline the name will be the same as the code for identification in exceptions</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // but give the script engine the chance to be better, give it separate name + source code</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // for the inline case, then its anonymous: null.</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    if (logger.isTraceEnabled()) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                        logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                            lang, options);</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    }</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // Check whether too many compilations have happened</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    checkCompilationLimit();</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // Since the cache key is the script content itself we don't need to</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // invalidate/check the cache if an indexed script changes.</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    scriptMetrics.onCompilation();</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    return compiledScript;</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                } catch (ScriptException good) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    // TODO: remove this try-catch completely, when all script engines have good exceptions!</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    throw good; // its already good</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                } catch (Exception exception) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                    throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                            exception);</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // Either an un-cached inline script or indexed script</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // If the script type is inline the name will be the same as the code for identification in exceptions</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // but give the script engine the chance to be better, give it separate name + source code</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // for the inline case, then its anonymous: null.</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                if (logger.isTraceEnabled()) {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                    logger.trace(\"context [{}]: compiling script, type: [{}], lang: [{}], options: [{}]\", context.name, type,</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                        lang, options);</span>\n                 }\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // Check whether too many compilations have happened</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                checkCompilationLimit();</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // Since the cache key is the script content itself we don't need to</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                // invalidate/check the cache if an indexed script changes.</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                scriptMetrics.onCompilation();</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                return compiledScript;</span>\n             }));\n         } catch (ExecutionException executionException) {\n             Throwable cause = executionException.getCause();\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>            if(cause instanceof RuntimeException) {</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                throw (RuntimeException) cause;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>            if (cause instanceof ScriptException) {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                throw (ScriptException) cause;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>            } else if (cause instanceof Exception) {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);</span>\n             } else {\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -&gt; throwing generic exception.</span>\n<span class=\"pl-md\"><span class=\"pl-md\">-</span>                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                rethrow(cause);</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>                throw new AssertionError(cause);</span>\n             }\n         }\n     }\n \n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>    /** Hack to rethrow unknown Exceptions from compile: */</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>    @SuppressWarnings(\"unchecked\")</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>    static &lt;T extends Throwable&gt; void rethrow(Throwable t) throws T {</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>        throw (T) t;</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span>    }</span>\n<span class=\"pl-mi1\"><span class=\"pl-mi1\">+</span></span>\n     public ScriptStats stats() {\n         return scriptMetrics.stats();\n     }</pre></div>", "author": "stu-elastic", "createdAt": "2020-06-11T20:55:33Z", "path": "server/src/main/java/org/elasticsearch/script/ScriptCache.java", "diffHunk": "@@ -121,24 +109,28 @@\n                     }\n                     // Check whether too many compilations have happened\n                     checkCompilationLimit();\n-                    compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    Object compiledScript = scriptEngine.compile(id, idOrCode, context, options);\n+                    // Since the cache key is the script content itself we don't need to\n+                    // invalidate/check the cache if an indexed script changes.\n+                    scriptMetrics.onCompilation();\n+                    return compiledScript;\n                 } catch (ScriptException good) {\n                     // TODO: remove this try-catch completely, when all script engines have good exceptions!\n                     throw good; // its already good\n                 } catch (Exception exception) {\n                     throw new GeneralScriptException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\",\n                             exception);\n                 }\n-\n-                // Since the cache key is the script content itself we don't need to\n-                // invalidate/check the cache if an indexed script changes.\n-                scriptMetrics.onCompilation();\n-                cache.put(cacheKey, compiledScript);\n+            }));\n+        } catch (ExecutionException executionException) {\n+            Throwable cause = executionException.getCause();\n+            if(cause instanceof RuntimeException) {\n+                throw (RuntimeException) cause;\n+            } else {\n+                // No non-RuntimeExceptions are thrown from the loader, this should not happen. -> throwing generic exception.\n+                throw new ElasticsearchException(\"Failed to compile \" + type + \" script [\" + id + \"] using lang [\" + lang + \"]\", cause);", "originalCommit": "e999353b7adf00745d2218b90c5e2031cc7b2a43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxNzM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440017375", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.", "author": "mjmbischoff", "createdAt": "2020-06-15T08:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIzMDc2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55467#discussion_r440230763", "bodyText": "Yeah I went for the smallest delta, this looks cleaner.\n\nTotally reasonable, just made sense to go a bit further for this one.", "author": "stu-elastic", "createdAt": "2020-06-15T14:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2NTkwMQ=="}], "type": "inlineReview"}, {"oid": "6b253d00005ddc5ef14e5b5b76174431b4c7db11", "url": "https://github.com/elastic/elasticsearch/commit/6b253d00005ddc5ef14e5b5b76174431b4c7db11", "message": "Processing review comments", "committedDate": "2020-06-15T08:38:00Z", "type": "commit"}, {"oid": "bc3f1d83369749be20780b8e0b07343151c7769f", "url": "https://github.com/elastic/elasticsearch/commit/bc3f1d83369749be20780b8e0b07343151c7769f", "message": "Merge remote-tracking branch 'origin/master' into script-compilation", "committedDate": "2020-06-15T09:16:19Z", "type": "commit"}, {"oid": "52925938e6fd9624011c26ac4e57f32240ac1403", "url": "https://github.com/elastic/elasticsearch/commit/52925938e6fd9624011c26ac4e57f32240ac1403", "message": "Fixing unused import triggering checkstyle.", "committedDate": "2020-06-15T10:00:34Z", "type": "commit"}]}