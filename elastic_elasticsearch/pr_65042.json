{"pr_number": 65042, "pr_title": "Fix Two Snapshot Clone State Machine Bugs", "pr_author": "original-brownbear", "pr_createdAt": "2020-11-15T19:14:57Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/65042", "timeline": [{"oid": "6f0214b62db03b4c3189016e068cf73b59b8c626", "url": "https://github.com/elastic/elasticsearch/commit/6f0214b62db03b4c3189016e068cf73b59b8c626", "message": "Fix Two Snapshot Clone State Machine Bugs\n\nThere are two separate but closely related bug fixes in this PR:\n1. When two snapshot clones would initialize concurrently we could get into a state\nwhere one is in front of the other in the queue snapshots array but its shard states\nare in fact queued behind the other snapshot or clone. Tightly linked to this,\nsnapshot cloning would not account for snapshot deletes when queueing shard snapshots\nwhich could lead to races where both delete and clone are running concurrently for a shard.\n2. As a result of fixing the first issue and writing a test for it, it also became obvious\nthat a finished delete was not properly accounted for when it comes to starting snapshot\nclones that could now queue behind a delete.", "committedDate": "2020-11-15T19:12:21Z", "type": "commit"}, {"oid": "3d57e5da3cf8466ff06584b89649cb19d88d16c9", "url": "https://github.com/elastic/elasticsearch/commit/3d57e5da3cf8466ff06584b89649cb19d88d16c9", "message": "drier", "committedDate": "2020-11-15T19:14:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODkwMA==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525078900", "body": "This is the only place where the clone is re-queued right? I was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?", "bodyText": "This is the only place where the clone is re-queued right? I was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?", "bodyHTML": "<p dir=\"auto\">This is the only place where the clone is re-queued right? I was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?</p>", "author": "fcofdez", "createdAt": "2020-11-17T11:21:34Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(\n+                                SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress.EMPTY).getEntries().stream()\n+                                .noneMatch(e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                        final InFlightShardSnapshotStates inFlightShardStates;\n+                        if (readyToExecute) {\n+                            inFlightShardStates = InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        } else {\n+                            // no need to compute these, we'll mark all shards as queued anyway because we wait for the delete\n+                            inFlightShardStates = null;\n+                        }\n+                        boolean queuedShards = false;\n                         for (Tuple<IndexId, Integer> count : counts) {\n                             for (int shardId = 0; shardId < count.v2(); shardId++) {\n                                 final RepositoryShardId repoShardId = new RepositoryShardId(count.v1(), shardId);\n                                 final String indexName = repoShardId.indexName();\n-                                if (inFlightShardStates.isActive(indexName, shardId)) {\n+                                if (readyToExecute == false || inFlightShardStates.isActive(indexName, shardId)) {\n                                     clonesBuilder.put(repoShardId, ShardSnapshotStatus.UNASSIGNED_QUEUED);\n+                                    queuedShards = true;\n                                 } else {\n                                     clonesBuilder.put(repoShardId, new ShardSnapshotStatus(localNodeId,\n                                         inFlightShardStates.generationForShard(repoShardId.index(), shardId, shardGenerations)));\n                                 }\n                             }\n                         }\n                         updatedEntry = cloneEntry.withClones(clonesBuilder.build());\n-                        updatedEntries.set(i, updatedEntry);\n+                        if (queuedShards) {\n+                            // We queued up some shards based on the in-flight operations found in all snapshots for the current\n+                            // repository, so in order to make sure we don't set a shard to QUEUED before (as in before it in the\n+                            // `updatedEntries` list) one that is actively executing we just put it to the back of the list as if we had\n+                            // just created the entry\n+                            // TODO: If we could eventually drop the snapshot clone init phase we don't need this any longer\n+                            updatedEntries.remove(i);\n+                            updatedEntries.add(updatedEntry);", "originalCommit": "3d57e5da3cf8466ff06584b89649cb19d88d16c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE1MDU5NQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525150595", "bodyText": "This is the only place where the clone is re-queued right\n\nRight, we're only doing this here.\n\nI was wondering if this could lead to starvation in some really bad scenarios, but I think that's not possible?\n\nI think we're good here even in theory. We do all the shard count fetching on the SNAPSHOT pool and any operation that would keep adding more and more operations to the list so quickly that we never get our turn would have to do some work on the SNAPSHOT pool eventually so we're safe on that front :)", "author": "original-brownbear", "createdAt": "2020-11-17T13:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3ODkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525079735", "body": "Is this related to this pr? ", "bodyText": "Is this related to this pr?", "bodyHTML": "<p dir=\"auto\">Is this related to this pr?</p>", "author": "fcofdez", "createdAt": "2020-11-17T11:22:54Z", "path": "server/src/main/java/org/elasticsearch/cluster/SnapshotsInProgress.java", "diffHunk": "@@ -471,6 +472,25 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n                 }\n             }\n             builder.endArray();\n+            if (isClone()) {", "originalCommit": "3d57e5da3cf8466ff06584b89649cb19d88d16c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0OTMxMg==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525149312", "bodyText": "Sort of, it's of necessary to make assertion failure messages useful, that's where I noticed this was missing.", "author": "original-brownbear", "createdAt": "2020-11-17T13:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIzODYwMg==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525238602", "bodyText": "That looks strange that Entry implements ToXContent just for rendering assertion error messages? I guess it's fine but I find it strange (and it should implement ToXContentObject)", "author": "tlrx", "createdAt": "2020-11-17T15:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA3OTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MTczMg==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525081732", "body": "Maybe we could assert here that the shard snapshots are queued?", "bodyText": "Maybe we could assert here that the shard snapshots are queued?", "bodyHTML": "<p dir=\"auto\">Maybe we could assert here that the shard snapshots are queued?</p>", "author": "fcofdez", "createdAt": "2020-11-17T11:26:28Z", "path": "server/src/internalClusterTest/java/org/elasticsearch/snapshots/CloneSnapshotIT.java", "diffHunk": "@@ -571,6 +575,40 @@ public void testStartCloneWithSuccessfulShardSnapshotPendingFinalization() throw\n         assertEquals(getSnapshot(repoName, cloneName).state(), SnapshotState.SUCCESS);\n     }\n \n+    public void testStartCloneDuringRunningDelete() throws Exception {\n+        final String masterName = internalCluster().startMasterOnlyNode(LARGE_SNAPSHOT_POOL_SETTINGS);\n+        internalCluster().startDataOnlyNode();\n+        final String repoName = \"test-repo\";\n+        createRepository(repoName, \"mock\");\n+\n+        final String indexName = \"test-idx\";\n+        createIndexWithContent(indexName);\n+\n+        final String sourceSnapshot = \"source-snapshot\";\n+        createFullSnapshot(repoName, sourceSnapshot);\n+\n+        final List<String> snapshotNames = createNSnapshots(repoName, randomIntBetween(1, 5));\n+        blockMasterOnWriteIndexFile(repoName);\n+        final ActionFuture<AcknowledgedResponse> deleteFuture = startDeleteSnapshot(repoName, randomFrom(snapshotNames));\n+        waitForBlock(masterName, repoName);\n+        awaitNDeletionsInProgress(1);\n+\n+        final ActionFuture<AcknowledgedResponse> cloneFuture = startClone(repoName, sourceSnapshot, \"target-snapshot\", indexName);\n+        logger.info(\"--> waiting for snapshot clone to be fully initialized\");\n+        awaitClusterState(state -> {\n+            for (SnapshotsInProgress.Entry entry : state.custom(SnapshotsInProgress.TYPE, SnapshotsInProgress.EMPTY).entries()) {\n+                if (entry.clones().isEmpty() == false) {\n+                    assertEquals(sourceSnapshot, entry.source().getName());", "originalCommit": "3d57e5da3cf8466ff06584b89649cb19d88d16c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0ODM2OQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525148369", "bodyText": "++ I added that now. Technically this is ensured by assertions we have on the cluster state in SnapshotsService but practically this makes the test a lot clearer in its intent :)", "author": "original-brownbear", "createdAt": "2020-11-17T13:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA4MTczMg=="}], "type": "inlineReview"}, {"oid": "1cca1970528597f0381ec4bdb04199661e0bd44e", "url": "https://github.com/elastic/elasticsearch/commit/1cca1970528597f0381ec4bdb04199661e0bd44e", "message": "Merge remote-tracking branch 'elastic/master' into fix-clone-bug", "committedDate": "2020-11-17T12:57:45Z", "type": "commit"}, {"oid": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "url": "https://github.com/elastic/elasticsearch/commit/f7b19344a1b1c239f6bbd5db749e43189e0efea8", "message": "add assertion", "committedDate": "2020-11-17T13:02:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0NTgxMA==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525245810", "body": "`readyToExecute` kind of lack of meaning, maybe `startedSnapshotDeletion` (+ `anyMatch`)?", "bodyText": "readyToExecute kind of lack of meaning, maybe startedSnapshotDeletion (+ anyMatch)?", "bodyHTML": "<p dir=\"auto\"><code>readyToExecute</code> kind of lack of meaning, maybe <code>startedSnapshotDeletion</code> (+ <code>anyMatch</code>)?</p>", "author": "tlrx", "createdAt": "2020-11-17T15:26:43Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -476,25 +476,50 @@ public ClusterState execute(ClusterState currentState) {\n                 final String repoName = cloneEntry.repository();\n                 final ShardGenerations shardGenerations = repoData.shardGenerations();\n                 for (int i = 0; i < updatedEntries.size(); i++) {\n-                    if (cloneEntry.snapshot().equals(updatedEntries.get(i).snapshot())) {\n+                    final SnapshotsInProgress.Entry entry = updatedEntries.get(i);\n+                    if (cloneEntry.repository().equals(entry.repository()) == false) {\n+                        // different repo => just continue without modification\n+                        continue;\n+                    }\n+                    if (cloneEntry.snapshot().getSnapshotId().equals(entry.snapshot().getSnapshotId())) {\n                         final ImmutableOpenMap.Builder<RepositoryShardId, ShardSnapshotStatus> clonesBuilder =\n                                 ImmutableOpenMap.builder();\n-                        final InFlightShardSnapshotStates inFlightShardStates =\n-                            InFlightShardSnapshotStates.forRepo(repoName, snapshotsInProgress.entries());\n+                        final boolean readyToExecute = currentState.custom(", "originalCommit": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NjEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525276131", "bodyText": "++ this is 100% the better name, I'll leave it as is for a sec though so it's less confusing to review when drying things up (we use the same mechanics and var name in the normal snapshot shard assignments path ... and it's equally weird there in hindsight :))", "author": "original-brownbear", "createdAt": "2020-11-17T15:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0NTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI0OTQ4MQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525249481", "body": ":+1:", "bodyText": "\ud83d\udc4d", "bodyHTML": "<p dir=\"auto\"><g-emoji class=\"g-emoji\" alias=\"+1\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png\">\ud83d\udc4d</g-emoji></p>", "author": "tlrx", "createdAt": "2020-11-17T15:29:05Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -797,11 +822,15 @@ private static boolean assertNoDanglingSnapshots(ClusterState state) {\n         final Set<String> reposSeen = new HashSet<>();\n         for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n             if (reposSeen.add(entry.repository())) {\n-                for (ObjectCursor<ShardSnapshotStatus> value : entry.shards().values()) {\n+                for (ObjectCursor<ShardSnapshotStatus> value : (entry.isClone() ? entry.clones() : entry.shards()).values()) {\n                     if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)) {\n                         assert reposWithRunningDelete.contains(entry.repository())\n                                 : \"Found shard snapshot waiting to be assigned in [\" + entry +\n                                 \"] but it is not blocked by any running delete\";\n+                    } else if (value.value.isActive()) {\n+                        assert reposWithRunningDelete.contains(entry.repository()) == false\n+                                : \"Found shard snapshot actively executing in [\" + entry +\n+                                \"] when it should be blocked by a running delete\";", "originalCommit": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1NTYxNw==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525255617", "body": "```suggestion\r\n                            // Collect waiting shards from that entry that we can assign now that we are done with the deletion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n          \n          \n            \n                                        // Collect waiting shards from that entry that we can assign now that we are done with the deletion", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                            <span class=\"pl-c\"><span class=\"pl-c\">//</span> Collect waiting shards <span class=\"x x-first x-last\">that in</span> entry that we can assign now that we are done with the deletion</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                            <span class=\"pl-c\"><span class=\"pl-c\">//</span> Collect waiting shards <span class=\"x x-first x-last\">from that</span> entry that we can assign now that we are done with the deletion</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "tlrx", "createdAt": "2020-11-17T15:33:07Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1929,50 +1961,89 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n \n             // Keep track of shardIds that we started snapshots for as a result of removing this delete so we don't assign\n             // them to multiple snapshots by accident\n-            final Set<ShardId> reassignedShardIds = new HashSet<>();\n+            final Map<String, Set<Integer>> reassignedShardIds = new HashMap<>();\n \n             boolean changed = false;\n \n+            final String localNodeId = currentState.nodes().getLocalNodeId();\n             final String repoName = deleteEntry.repository();\n             // Computing the new assignments can be quite costly, only do it once below if actually needed\n             ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;\n+            InFlightShardSnapshotStates inFlightShardStates = null;\n             for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n                 if (entry.repository().equals(repoName)) {\n                     if (entry.state().completed() == false) {\n-                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n-                        final List<ShardId> canBeUpdated = new ArrayList<>();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> value : entry.shards()) {\n-                            if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n-                                    && reassignedShardIds.contains(value.key) == false) {\n-                                canBeUpdated.add(value.key);\n+                        // TODO: dry up redundant computation and code between clone and non-clone case, in particular reuse\n+                        //  `inFlightShardStates` across both clone and standard snapshot code\n+                        if (entry.isClone()) {\n+                            // Collect waiting shards that in entry that we can assign now that we are done with the deletion", "originalCommit": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1ODAxMw==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525258013", "body": "Maybe evaluate `canBeUpdated.isEmpty()` first and then only compute `readyToExecute` if needed?", "bodyText": "Maybe evaluate canBeUpdated.isEmpty() first and then only compute readyToExecute if needed?", "bodyHTML": "<p dir=\"auto\">Maybe evaluate <code>canBeUpdated.isEmpty()</code> first and then only compute <code>readyToExecute</code> if needed?</p>", "author": "tlrx", "createdAt": "2020-11-17T15:35:50Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1929,50 +1961,89 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n \n             // Keep track of shardIds that we started snapshots for as a result of removing this delete so we don't assign\n             // them to multiple snapshots by accident\n-            final Set<ShardId> reassignedShardIds = new HashSet<>();\n+            final Map<String, Set<Integer>> reassignedShardIds = new HashMap<>();\n \n             boolean changed = false;\n \n+            final String localNodeId = currentState.nodes().getLocalNodeId();\n             final String repoName = deleteEntry.repository();\n             // Computing the new assignments can be quite costly, only do it once below if actually needed\n             ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardAssignments = null;\n+            InFlightShardSnapshotStates inFlightShardStates = null;\n             for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {\n                 if (entry.repository().equals(repoName)) {\n                     if (entry.state().completed() == false) {\n-                        // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n-                        final List<ShardId> canBeUpdated = new ArrayList<>();\n-                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> value : entry.shards()) {\n-                            if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n-                                    && reassignedShardIds.contains(value.key) == false) {\n-                                canBeUpdated.add(value.key);\n+                        // TODO: dry up redundant computation and code between clone and non-clone case, in particular reuse\n+                        //  `inFlightShardStates` across both clone and standard snapshot code\n+                        if (entry.isClone()) {\n+                            // Collect waiting shards that in entry that we can assign now that we are done with the deletion\n+                            final List<RepositoryShardId> canBeUpdated = new ArrayList<>();\n+                            for (ObjectObjectCursor<RepositoryShardId, ShardSnapshotStatus> value : entry.clones()) {\n+                                if (value.value.equals(ShardSnapshotStatus.UNASSIGNED_QUEUED)\n+                                        && alreadyReassigned(value.key.indexName(), value.key.shardId(), reassignedShardIds) == false) {\n+                                    canBeUpdated.add(value.key);\n+                                }\n+                            }\n+                            // TODO: the below logic is very similar to that in #startCloning and both could be dried up against each other\n+                            //       also the code for standard snapshots could make use of this breakout as well\n+                            final boolean readyToExecute = updatedDeletions.getEntries().stream().noneMatch(\n+                                    e -> e.repository().equals(repoName) && e.state() == SnapshotDeletionsInProgress.State.STARTED);\n+                            if (readyToExecute == false || canBeUpdated.isEmpty()) {", "originalCommit": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3NDIxNQ==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525274215", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-11-17T15:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1ODAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1OTE5Ng==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525259196", "body": "Maybe add some message in case it occurs in tests?", "bodyText": "Maybe add some message in case it occurs in tests?", "bodyHTML": "<p dir=\"auto\">Maybe add some message in case it occurs in tests?</p>", "author": "tlrx", "createdAt": "2020-11-17T15:37:12Z", "path": "server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java", "diffHunk": "@@ -1987,6 +2058,15 @@ private SnapshotsInProgress updatedSnapshotsInProgress(ClusterState currentState\n             }\n             return changed ? SnapshotsInProgress.of(snapshotEntries) : null;\n         }\n+\n+        private void markShardReassigned(String indexName, int shardId, Map<String, Set<Integer>> reassignments) {\n+            final boolean added = reassignments.computeIfAbsent(indexName, k -> new HashSet<>()).add(shardId);\n+            assert added;", "originalCommit": "f7b19344a1b1c239f6bbd5db749e43189e0efea8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI3OTI1Nw==", "url": "https://github.com/elastic/elasticsearch/pull/65042#discussion_r525279257", "bodyText": "++", "author": "original-brownbear", "createdAt": "2020-11-17T16:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTI1OTE5Ng=="}], "type": "inlineReview"}, {"oid": "2f03a53c0ca5be2fc7a7fa953c4500b3d026ae1e", "url": "https://github.com/elastic/elasticsearch/commit/2f03a53c0ca5be2fc7a7fa953c4500b3d026ae1e", "message": "Update server/src/main/java/org/elasticsearch/snapshots/SnapshotsService.java\n\nCo-authored-by: Tanguy Leroux <tlrx.dev@gmail.com>", "committedDate": "2020-11-17T15:53:49Z", "type": "commit"}, {"oid": "f524930d2f53d368fb1509c47924d2b93b88dfc2", "url": "https://github.com/elastic/elasticsearch/commit/f524930d2f53d368fb1509c47924d2b93b88dfc2", "message": "Merge remote-tracking branch 'elastic/master' into fix-clone-bug", "committedDate": "2020-11-17T15:54:46Z", "type": "commit"}, {"oid": "9b1ade6ecf0dfa95eb1500ab6911252e7c43c0a0", "url": "https://github.com/elastic/elasticsearch/commit/9b1ade6ecf0dfa95eb1500ab6911252e7c43c0a0", "message": "CR: comments", "committedDate": "2020-11-17T16:00:51Z", "type": "commit"}]}