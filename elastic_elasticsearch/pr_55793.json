{"pr_number": 55793, "pr_title": "Use workers to warm cache parts", "pr_author": "tlrx", "pr_createdAt": "2020-04-27T09:46:05Z", "pr_url": "https://github.com/elastic/elasticsearch/pull/55793", "timeline": [{"oid": "9743806ad5a396d88079be890ef43b84b2815ca0", "url": "https://github.com/elastic/elasticsearch/commit/9743806ad5a396d88079be890ef43b84b2815ca0", "message": "Use workers to warm cache parts", "committedDate": "2020-04-27T08:30:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDM3NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415674375", "body": "Why wrap this in a SizeBlockingQueue?", "bodyText": "Why wrap this in a SizeBlockingQueue?", "bodyHTML": "<p dir=\"auto\">Why wrap this in a SizeBlockingQueue?</p>", "author": "ywelsch", "createdAt": "2020-04-27T09:55:05Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -361,68 +367,95 @@ private void prewarmCache() {\n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n             logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n \n+            final BlockingQueue<CheckedRunnable<Exception>> queue = new SizeBlockingQueue<>(new LinkedBlockingQueue<>(), Integer.MAX_VALUE);", "originalCommit": "9743806ad5a396d88079be890ef43b84b2815ca0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NTc4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415685785", "bodyText": "Mostly to prevent the queue to have more than Integer.MAX_VALUE elements, which could maybe happen for a large number of files with very low chunk size?", "author": "tlrx", "createdAt": "2020-04-27T10:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NDM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NTg4OA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415675888", "body": "should this not always be true? Why should this queue ever overflow?", "bodyText": "should this not always be true? Why should this queue ever overflow?", "bodyHTML": "<p dir=\"auto\">should this not always be true? Why should this queue ever overflow?</p>", "author": "ywelsch", "createdAt": "2020-04-27T09:57:18Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -361,68 +367,95 @@ private void prewarmCache() {\n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n             logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n \n+            final BlockingQueue<CheckedRunnable<Exception>> queue = new SizeBlockingQueue<>(new LinkedBlockingQueue<>(), Integer.MAX_VALUE);\n             for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n                 final String fileName = cacheFile.physicalName();\n                 try {\n                     final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n                     assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n \n                     final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                final int bytesRead = cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-                                assert bytesRead == cacheFile.partBytes(part);\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n+                    if (queue.remainingCapacity() >= numberOfParts) {", "originalCommit": "9743806ad5a396d88079be890ef43b84b2815ca0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyNjc0NA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415826744", "bodyText": "Do we just silently ignore if we have more than Integer.MAX_VALUE items? Should we log a big fat warning at that point instead?", "author": "ywelsch", "createdAt": "2020-04-27T13:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NTg4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzMjk1NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r417932955", "bodyText": "++ the fact that org.elasticsearch.index.snapshots.blobstore.BlobStoreIndexShardSnapshot.FileInfo#numberOfParts is a long is weird to begin with here. But practically speaking there's no way we could ever exceed the queue size here (before we get here, writing/reading the necessary metadata would have OOMed already). I'd just remove this check and assume that if the queue ever throws IllegalStateException there's some other bug at play.", "author": "original-brownbear", "createdAt": "2020-04-30T11:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3NTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3Nzc1MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415677751", "body": "do we need to drain the queue and close input here?", "bodyText": "do we need to drain the queue and close input here?", "bodyHTML": "<p dir=\"auto\">do we need to drain the queue and close input here?</p>", "author": "ywelsch", "createdAt": "2020-04-27T10:00:00Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -361,68 +367,95 @@ private void prewarmCache() {\n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n             logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n \n+            final BlockingQueue<CheckedRunnable<Exception>> queue = new SizeBlockingQueue<>(new LinkedBlockingQueue<>(), Integer.MAX_VALUE);\n             for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n                 final String fileName = cacheFile.physicalName();\n                 try {\n                     final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n                     assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n \n                     final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                final int bytesRead = cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-                                assert bytesRead == cacheFile.partBytes(part);\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n+                    if (queue.remainingCapacity() >= numberOfParts) {\n+                        final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n+                        for (long p = 0; p < numberOfParts; p++) {\n+                            final int part = Math.toIntExact(p);\n+                            queue.add(() -> {\n+                                try {\n+                                    ensureOpen();\n+\n+                                    logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n+                                    final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n+\n+                                    final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n+                                    final int bytesRead = cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n+                                    assert bytesRead == cacheFile.partBytes(part);\n+\n+                                    logger.trace(\n+                                        () -> new ParameterizedMessage(\n+                                            \"part [{}/{}] of [{}] warmed in [{}] ms\",\n+                                            part,\n+                                            numberOfParts,\n+                                            fileName,\n+                                            TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n+                                        )\n+                                    );\n+                                } catch (Exception e) {\n+                                    logger.trace(\n+                                        () -> new ParameterizedMessage(\n+                                            \"failed to warm cache for [{}] part [{}/{}]\",\n+                                            fileName,\n+                                            part,\n+                                            numberOfParts\n+                                        ),\n+                                        e\n+                                    );\n+                                    if (e instanceof AlreadyClosedException\n+                                        || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n+                                        return; // don't rethrow in case of cache eviction or directory closing\n+                                    }\n+                                    throw e;\n+                                } finally {\n+                                    if (countDown.countDown()) {\n+                                        IOUtils.closeWhileHandlingException(input);\n+                                    }\n                                 }\n-                            }\n-                        });\n+                            });\n+                        }\n                     }\n                 } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n+                    logger.trace(() -> new ParameterizedMessage(\"unable to schedule cache prewarming for [{}]\", fileName), e);", "originalCommit": "9743806ad5a396d88079be890ef43b84b2815ca0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4NjUzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415686535", "bodyText": "Right - I checked again and the only situation I see is the directory being close so it makes sense to drain the queue. I'll address that.", "author": "tlrx", "createdAt": "2020-04-27T10:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3Nzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3OTQwNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415679405", "body": "If scheduling fails here, how do we guarantee that IndexInput is closed?", "bodyText": "If scheduling fails here, how do we guarantee that IndexInput is closed?", "bodyHTML": "<p dir=\"auto\">If scheduling fails here, how do we guarantee that IndexInput is closed?</p>", "author": "ywelsch", "createdAt": "2020-04-27T10:02:24Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -361,68 +367,95 @@ private void prewarmCache() {\n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n             logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n \n+            final BlockingQueue<CheckedRunnable<Exception>> queue = new SizeBlockingQueue<>(new LinkedBlockingQueue<>(), Integer.MAX_VALUE);\n             for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n                 final String fileName = cacheFile.physicalName();\n                 try {\n                     final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n                     assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n \n                     final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                final int bytesRead = cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-                                assert bytesRead == cacheFile.partBytes(part);\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n+                    if (queue.remainingCapacity() >= numberOfParts) {\n+                        final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n+                        for (long p = 0; p < numberOfParts; p++) {\n+                            final int part = Math.toIntExact(p);\n+                            queue.add(() -> {\n+                                try {\n+                                    ensureOpen();\n+\n+                                    logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n+                                    final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n+\n+                                    final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n+                                    final int bytesRead = cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n+                                    assert bytesRead == cacheFile.partBytes(part);\n+\n+                                    logger.trace(\n+                                        () -> new ParameterizedMessage(\n+                                            \"part [{}/{}] of [{}] warmed in [{}] ms\",\n+                                            part,\n+                                            numberOfParts,\n+                                            fileName,\n+                                            TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n+                                        )\n+                                    );\n+                                } catch (Exception e) {\n+                                    logger.trace(\n+                                        () -> new ParameterizedMessage(\n+                                            \"failed to warm cache for [{}] part [{}/{}]\",\n+                                            fileName,\n+                                            part,\n+                                            numberOfParts\n+                                        ),\n+                                        e\n+                                    );\n+                                    if (e instanceof AlreadyClosedException\n+                                        || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n+                                        return; // don't rethrow in case of cache eviction or directory closing\n+                                    }\n+                                    throw e;\n+                                } finally {\n+                                    if (countDown.countDown()) {\n+                                        IOUtils.closeWhileHandlingException(input);\n+                                    }\n                                 }\n-                            }\n-                        });\n+                            });\n+                        }\n                     }\n                 } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n+                    logger.trace(() -> new ParameterizedMessage(\"unable to schedule cache prewarming for [{}]\", fileName), e);\n                 }\n             }\n+\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                executeNextWarmer(executor, queue);\n+            }\n         }\n     }\n \n+    private void executeNextWarmer(final Executor executor, final BlockingQueue<CheckedRunnable<Exception>> queue) {\n+        executor.execute(new AbstractRunnable() {", "originalCommit": "9743806ad5a396d88079be890ef43b84b2815ca0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4ODEzNQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415688135", "bodyText": "Arghl right... you saw nothing. I'll address that.", "author": "tlrx", "createdAt": "2020-04-27T10:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3OTQwNQ=="}], "type": "inlineReview"}, {"oid": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "url": "https://github.com/elastic/elasticsearch/commit/01ca9f711d4c3297890a601f93b7aadc2701e2d3", "message": "apply feedback", "committedDate": "2020-04-27T13:09:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxOTg0MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415819841", "body": "Call `warmer.onFailure` here?", "bodyText": "Call warmer.onFailure here?", "bodyHTML": "<p dir=\"auto\">Call <code>warmer.onFailure</code> here?</p>", "author": "ywelsch", "createdAt": "2020-04-27T13:38:26Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -393,33 +403,64 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(new IOException(\"Shard cache prewarming cancelled\"));\n                             }\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();\n+                        }\n+                    }\n+                } finally {\n+                    if (enqueued == false) {\n+                        IOUtils.closeWhileHandlingException(input);\n+                    }\n+                }\n+            }\n \n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                executeNextWarmer(executor, queue);\n+            }\n+        }\n+    }\n \n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n+    private void executeNextWarmer(final Executor executor, final BlockingQueue<ActionRunnable<Void>> queue) {\n+        try {\n+            final ActionRunnable<?> warmer = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (warmer != null) {\n+                executor.execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        warmer.run();\n+                        executeNextWarmer(executor, queue);\n                     }\n-                } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n-                }\n+\n+                    @Override\n+                    public void onRejection(Exception e) {\n+                        warmer.onRejection(e);\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(\"failed to schedule next file part to prewarm in cache\", e);", "originalCommit": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzNjUwOA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415836508", "bodyText": "I don't think we need to delegate here: warmer.run() already calls warmer.onFailure if something went wrong when executing warmer.doRun() and the only case that we want to delegate to is the case of rejection.", "author": "tlrx", "createdAt": "2020-04-27T13:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxOTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMTgwNA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415821804", "body": "This never rethrows the exception?", "bodyText": "This never rethrows the exception?", "bodyHTML": "<p dir=\"auto\">This never rethrows the exception?</p>", "author": "ywelsch", "createdAt": "2020-04-27T13:40:52Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -393,33 +403,64 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    }\n+                } catch (Exception e) {", "originalCommit": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg0NjQwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415846409", "bodyText": "If I understand correctly rethrowing here would fail the shard which I think it's something we should try to avoid in case of prewarming. Maybe we should rethrow only non-AlreadyClosedException, so that we don't fail the shard if the node is closing.", "author": "tlrx", "createdAt": "2020-04-27T14:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2NTU2Mw==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415865563", "bodyText": "Something like 92bcbcb", "author": "tlrx", "createdAt": "2020-04-27T14:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMTk4NQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415821985", "body": "This just swallows the exception?", "bodyText": "This just swallows the exception?", "bodyHTML": "<p dir=\"auto\">This just swallows the exception?</p>", "author": "ywelsch", "createdAt": "2020-04-27T13:41:06Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -393,33 +403,64 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(new IOException(\"Shard cache prewarming cancelled\"));\n                             }\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();", "originalCommit": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg0OTY4Ng==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415849686", "bodyText": "I don't think we need to do more than logging here so I pushed b6b90c4", "author": "tlrx", "createdAt": "2020-04-27T14:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMjEwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415822100", "body": "This just swallows the exception?", "bodyText": "This just swallows the exception?", "bodyHTML": "<p dir=\"auto\">This just swallows the exception?</p>", "author": "ywelsch", "createdAt": "2020-04-27T13:41:15Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -393,33 +403,64 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(new IOException(\"Shard cache prewarming cancelled\"));\n                             }\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();\n+                        }\n+                    }\n+                } finally {\n+                    if (enqueued == false) {\n+                        IOUtils.closeWhileHandlingException(input);\n+                    }\n+                }\n+            }\n \n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                executeNextWarmer(executor, queue);\n+            }\n+        }\n+    }\n \n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n+    private void executeNextWarmer(final Executor executor, final BlockingQueue<ActionRunnable<Void>> queue) {\n+        try {\n+            final ActionRunnable<?> warmer = queue.poll(0L, TimeUnit.MILLISECONDS);\n+            if (warmer != null) {\n+                executor.execute(new AbstractRunnable() {\n+                    @Override\n+                    protected void doRun() {\n+                        warmer.run();\n+                        executeNextWarmer(executor, queue);\n                     }\n-                } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n-                }\n+\n+                    @Override\n+                    public void onRejection(Exception e) {\n+                        warmer.onRejection(e);\n+                    }\n+\n+                    @Override\n+                    public void onFailure(Exception e) {\n+                        logger.warn(\"failed to schedule next file part to prewarm in cache\", e);\n+                    }\n+                });\n             }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();", "originalCommit": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg0OTYyMw==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415849623", "bodyText": "I don't think we need to do more than logging here so I pushed b6b90c4", "author": "tlrx", "createdAt": "2020-04-27T14:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyMjEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMDQ4NA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415830484", "body": "why not pass the original exception here?", "bodyText": "why not pass the original exception here?", "bodyHTML": "<p dir=\"auto\">why not pass the original exception here?</p>", "author": "ywelsch", "createdAt": "2020-04-27T13:51:42Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -393,33 +403,64 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(new IOException(\"Shard cache prewarming cancelled\"));", "originalCommit": "01ca9f711d4c3297890a601f93b7aadc2701e2d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg1MTMyMA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r415851320", "bodyText": "Right - I pushed e0f8874", "author": "tlrx", "createdAt": "2020-04-27T14:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMDQ4NA=="}], "type": "inlineReview"}, {"oid": "b6b90c4e6c630972a8888dbadbc8222cf2ecc9bc", "url": "https://github.com/elastic/elasticsearch/commit/b6b90c4e6c630972a8888dbadbc8222cf2ecc9bc", "message": "log warn interrupts", "committedDate": "2020-04-27T14:14:39Z", "type": "commit"}, {"oid": "e0f8874eb43086609aa52ba6e06414b33d34ecfb", "url": "https://github.com/elastic/elasticsearch/commit/e0f8874eb43086609aa52ba6e06414b33d34ecfb", "message": "pass original exception", "committedDate": "2020-04-27T14:16:58Z", "type": "commit"}, {"oid": "717c98f05fa34271fc071fc899165bd114cb1674", "url": "https://github.com/elastic/elasticsearch/commit/717c98f05fa34271fc071fc899165bd114cb1674", "message": "log a warning when too many files to warm", "committedDate": "2020-04-27T14:21:08Z", "type": "commit"}, {"oid": "92bcbcb85f3a1ca4a2ad7081dd0c012712f06df0", "url": "https://github.com/elastic/elasticsearch/commit/92bcbcb85f3a1ca4a2ad7081dd0c012712f06df0", "message": "rethrow non closed exceptions", "committedDate": "2020-04-27T14:33:41Z", "type": "commit"}, {"oid": "a42716d5c52cb2d2797ba2cd29cc5b2420809272", "url": "https://github.com/elastic/elasticsearch/commit/a42716d5c52cb2d2797ba2cd29cc5b2420809272", "message": "make spotless happy", "committedDate": "2020-04-28T09:36:13Z", "type": "commit"}, {"oid": "d22c34ace60a052294000abc1d9d400f404d66a8", "url": "https://github.com/elastic/elasticsearch/commit/d22c34ace60a052294000abc1d9d400f404d66a8", "message": "Merge branch 'master' into use-worker-to-warm-cache", "committedDate": "2020-04-28T09:49:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkzOTEzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r417939131", "body": "Do we actually need this? If my understanding is correct, we are only ever opening any resources on the worker threads (which haven't yet started here), so why do we need to fail the runnables here here?", "bodyText": "Do we actually need this? If my understanding is correct, we are only ever opening any resources on the worker threads (which haven't yet started here), so why do we need to fail the runnables here here?", "bodyHTML": "<p dir=\"auto\">Do we actually need this? If my understanding is correct, we are only ever opening any resources on the worker threads (which haven't yet started here), so why do we need to fail the runnables here here?</p>", "author": "original-brownbear", "createdAt": "2020-04-30T11:23:36Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -392,33 +404,73 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    } else {\n+                        logger.warn(\"{} too many files ({}) to warm in cache, skipping file [{}]\", shardId, queue.size(), fileName);\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(e);", "originalCommit": "d22c34ace60a052294000abc1d9d400f404d66a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk0NDU1NA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r417944554", "body": "Why do our own queuing here? Can't we just push all the tasks in `queue` onto the `executor` and let it poll tasks from its internal queue when we're using the full pool anyway?", "bodyText": "Why do our own queuing here? Can't we just push all the tasks in queue onto the executor and let it poll tasks from its internal queue when we're using the full pool anyway?", "bodyHTML": "<p dir=\"auto\">Why do our own queuing here? Can't we just push all the tasks in <code>queue</code> onto the <code>executor</code> and let it poll tasks from its internal queue when we're using the full pool anyway?</p>", "author": "original-brownbear", "createdAt": "2020-04-30T11:34:34Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -392,33 +404,73 @@ protected void doRun() throws Exception {\n                                         TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n                                     )\n                                 );\n+                            }));\n+                        }\n+                        enqueued = true;\n+                    } else {\n+                        logger.warn(\"{} too many files ({}) to warm in cache, skipping file [{}]\", shardId, queue.size(), fileName);\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\n+                        () -> new ParameterizedMessage(\"unable to open file [{}], cancelling prewarming for shard [{}]\", fileName, shardId),\n+                        e\n+                    );\n+                    if (queue.size() > 0) {\n+                        try {\n+                            ActionRunnable<Void> warmer;\n+                            while ((warmer = queue.poll(0L, TimeUnit.MILLISECONDS)) != null) {\n+                                warmer.onFailure(e);\n                             }\n+                        } catch (InterruptedException ie) {\n+                            Thread.currentThread().interrupt();\n+                            logger.warn(() -> new ParameterizedMessage(\"{} shard cache warming has been interrupted\", shardId), ie);\n+                        }\n+                    }\n+                    if (e instanceof AlreadyClosedException || (e.getCause() != null && e.getCause() instanceof AlreadyClosedException)) {\n+                        break;\n+                    } else {\n+                        throw new ElasticsearchException(\"Exception when warming cache for shard \" + shardId, e);\n+                    }\n+                } finally {\n+                    if (enqueued == false) {\n+                        IOUtils.closeWhileHandlingException(input);\n+                    }\n+                }\n+            }\n \n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {", "originalCommit": "d22c34ace60a052294000abc1d9d400f404d66a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66197fce8b8bec02e88731aef1976d369b5d5ae6", "url": "https://github.com/elastic/elasticsearch/commit/66197fce8b8bec02e88731aef1976d369b5d5ae6", "message": "remove size blocking queue", "committedDate": "2020-05-04T08:48:14Z", "type": "commit"}, {"oid": "0d9d5b6ac8894771b0b6a1de023960c9bd03d3b8", "url": "https://github.com/elastic/elasticsearch/commit/0d9d5b6ac8894771b0b6a1de023960c9bd03d3b8", "message": "apply armin feedback", "committedDate": "2020-05-04T10:52:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1OTc4NA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419359784", "body": "NIT: \r\n\r\nI guess technically we could \r\n\r\n```java\r\nfinal BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\r\nif (file == null) {\r\n    return;\r\n}\r\n```\r\n\r\nbefore branching off to the executor at the beginning of this method. That way we save at least one pointless task on the scheduler for each shard (and an indent level in the abstract runnable :)).", "bodyText": "NIT:\nI guess technically we could\nfinal BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\nif (file == null) {\n    return;\n}\nbefore branching off to the executor at the beginning of this method. That way we save at least one pointless task on the scheduler for each shard (and an indent level in the abstract runnable :)).", "bodyHTML": "<p dir=\"auto\">NIT:</p>\n<p dir=\"auto\">I guess technically we could</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\nif (file == null) {\n    return;\n}\"><pre><span class=\"pl-k\">final</span> <span class=\"pl-smi\">BlobStoreIndexShardSnapshot</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">FileInfo</span> file <span class=\"pl-k\">=</span> queue<span class=\"pl-k\">.</span>poll(<span class=\"pl-c1\">0L</span>, <span class=\"pl-smi\">TimeUnit</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>MILLISECONDS</span>);\n<span class=\"pl-k\">if</span> (file <span class=\"pl-k\">==</span> <span class=\"pl-c1\">null</span>) {\n    <span class=\"pl-k\">return</span>;\n}</pre></div>\n<p dir=\"auto\">before branching off to the executor at the beginning of this method. That way we save at least one pointless task on the scheduler for each shard (and an indent level in the abstract runnable :)).</p>", "author": "original-brownbear", "createdAt": "2020-05-04T11:05:51Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -352,74 +357,71 @@ public String toString() {\n \n     private void prewarmCache() {\n         if (prewarmCache) {\n-            final List<BlobStoreIndexShardSnapshot.FileInfo> cacheFiles = snapshot().indexFiles()\n+            final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue = snapshot().indexFiles()\n                 .stream()\n                 .filter(file -> file.metadata().hashEqualsContents() == false)\n                 .filter(file -> isExcludedFromCache(file.physicalName()) == false)\n-                .collect(Collectors.toList());\n+                .collect(Collectors.toCollection(LinkedBlockingQueue::new));\n \n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n-            logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n+            logger.debug(\"{} warming shard cache for [{}] files\", shardId, queue.size());\n \n-            for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n-                final String fileName = cacheFile.physicalName();\n-                try {\n-                    final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                prewarmNextFile(executor, queue);\n+            }\n+        }\n+    }\n+\n+    private void prewarmNextFile(final Executor executor, final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue) {\n+        executor.execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() throws Exception {\n+                final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);", "originalCommit": "0d9d5b6ac8894771b0b6a1de023960c9bd03d3b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2ODE0OA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419368148", "bodyText": "Sure, I pushed dc6d484", "author": "tlrx", "createdAt": "2020-05-04T11:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1OTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQxNDYwOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419414609", "bodyText": "Sorry I should've added another line here to the snippet, I was thinking about this:\nfinal BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\nif (file == null) {\n    return;\n}\nexecutor.execute(new AbstractRunnable() {\ni.e. doing the polling from the queue on the calling thread. This way:\n\nWe don't have to create as many tasks as we have threads to begin with. (e.g. if we're only warming 5 files, we're still creating 32 threads on the pool of which 27 will just not do anything and just poll a null)\nWe don't waste another task at the end of each file as well. Currently if 32 threads had work at some point, each of them will add one needless task that only polls a null at the end of the warming of a shard.\n\nHope that makes sense? :)", "author": "original-brownbear", "createdAt": "2020-05-04T12:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1OTc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0NjA5MQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419446091", "bodyText": "My bad, I've been too quick reading your comment. I pushed 1bffb66", "author": "tlrx", "createdAt": "2020-05-04T13:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1OTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2MTg5MA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419361890", "body": "I'm wondering if we should just special case `numberOfParts == 1` here? It's the by far most common case and we could simply run it straight on the current thread instead of creating another task. Currently, we're creating twice as many tasks on the pool as necessary with this change.\r\nNo need for a lot of code here even, could just keep it short and use the direct executor service if `numberOfParts == 1` and be happy with it?", "bodyText": "I'm wondering if we should just special case numberOfParts == 1 here? It's the by far most common case and we could simply run it straight on the current thread instead of creating another task. Currently, we're creating twice as many tasks on the pool as necessary with this change.\nNo need for a lot of code here even, could just keep it short and use the direct executor service if numberOfParts == 1 and be happy with it?", "bodyHTML": "<p dir=\"auto\">I'm wondering if we should just special case <code>numberOfParts == 1</code> here? It's the by far most common case and we could simply run it straight on the current thread instead of creating another task. Currently, we're creating twice as many tasks on the pool as necessary with this change.<br>\nNo need for a lot of code here even, could just keep it short and use the direct executor service if <code>numberOfParts == 1</code> and be happy with it?</p>", "author": "original-brownbear", "createdAt": "2020-05-04T11:10:49Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -352,74 +357,71 @@ public String toString() {\n \n     private void prewarmCache() {\n         if (prewarmCache) {\n-            final List<BlobStoreIndexShardSnapshot.FileInfo> cacheFiles = snapshot().indexFiles()\n+            final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue = snapshot().indexFiles()\n                 .stream()\n                 .filter(file -> file.metadata().hashEqualsContents() == false)\n                 .filter(file -> isExcludedFromCache(file.physicalName()) == false)\n-                .collect(Collectors.toList());\n+                .collect(Collectors.toCollection(LinkedBlockingQueue::new));\n \n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n-            logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n+            logger.debug(\"{} warming shard cache for [{}] files\", shardId, queue.size());\n \n-            for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n-                final String fileName = cacheFile.physicalName();\n-                try {\n-                    final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                prewarmNextFile(executor, queue);\n+            }\n+        }\n+    }\n+\n+    private void prewarmNextFile(final Executor executor, final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue) {\n+        executor.execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() throws Exception {\n+                final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                if (file != null) {\n+                    final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n                     assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n \n-                    final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n+                    final int numberOfParts = Math.toIntExact(file.numberOfParts());", "originalCommit": "0d9d5b6ac8894771b0b6a1de023960c9bd03d3b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2ODI1OA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419368258", "bodyText": "Makes perfect sense, I pushed 47b2f0e", "author": "tlrx", "createdAt": "2020-05-04T11:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2MTg5MA=="}], "type": "inlineReview"}, {"oid": "dc6d484930a61310a64020fb44dbe912c65d72fc", "url": "https://github.com/elastic/elasticsearch/commit/dc6d484930a61310a64020fb44dbe912c65d72fc", "message": "branch early", "committedDate": "2020-05-04T11:13:05Z", "type": "commit"}, {"oid": "47b2f0e5e175111adc1937d0884b2246579f3727", "url": "https://github.com/elastic/elasticsearch/commit/47b2f0e5e175111adc1937d0884b2246579f3727", "message": "case 1", "committedDate": "2020-05-04T11:24:13Z", "type": "commit"}, {"oid": "fffc4cf388fbe10dc184b5a823bedf76144bd371", "url": "https://github.com/elastic/elasticsearch/commit/fffc4cf388fbe10dc184b5a823bedf76144bd371", "message": "Merge branch 'master' into use-worker-to-warm-cache", "committedDate": "2020-05-04T12:10:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQzMjQzMQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419432431", "body": "Not sure it's a big deal but I guess we could always use the current thread for one part:\r\n\r\n```suggestion\r\n                     final Executor warmExecutor = (p < numberOfParts - 1) ? executor : EsExecutors.newDirectExecutorService();\r\n                    warmExecutor.execute(ActionRunnable.run(listener, () -> {\r\n```", "bodyText": "Not sure it's a big deal but I guess we could always use the current thread for one part:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                warmExecutor.execute(ActionRunnable.run(listener, () -> {\n          \n          \n            \n                                 final Executor warmExecutor = (p < numberOfParts - 1) ? executor : EsExecutors.newDirectExecutorService();\n          \n          \n            \n                                warmExecutor.execute(ActionRunnable.run(listener, () -> {", "bodyHTML": "<p dir=\"auto\">Not sure it's a big deal but I guess we could always use the current thread for one part:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    warmExecutor<span class=\"pl-k x x-first\">.</span><span class=\"x\">execute(</span><span class=\"pl-smi x\">ActionRunnable</span><span class=\"pl-k x\">.</span><span class=\"x\">run(listener, () </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x x-last\"> {</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    <span class=\"x x-first\"> </span><span class=\"pl-k x\">final</span><span class=\"x\"> </span><span class=\"pl-smi x\">Executor</span><span class=\"x x-last\"> </span>warmExecutor<span class=\"x x-first\"> </span><span class=\"pl-k x\">=</span><span class=\"x\"> (p </span><span class=\"pl-k x\">&lt;</span><span class=\"x\"> numberOfParts </span><span class=\"pl-k x\">-</span><span class=\"x\"> </span><span class=\"pl-c1 x\">1</span><span class=\"x\">) </span><span class=\"pl-k x\">?</span><span class=\"x\"> executor </span><span class=\"pl-k x\">:</span><span class=\"x\"> </span><span class=\"pl-smi x\">EsExecutors</span><span class=\"pl-k x\">.</span><span class=\"x x-last\">newDirectExecutorService();</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    warmExecutor<span class=\"pl-k\">.</span>execute(<span class=\"pl-smi\">ActionRunnable</span><span class=\"pl-k\">.</span>run(listener, () <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "DaveCTurner", "createdAt": "2020-05-04T13:24:36Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -352,76 +358,78 @@ public String toString() {\n \n     private void prewarmCache() {\n         if (prewarmCache) {\n-            final List<BlobStoreIndexShardSnapshot.FileInfo> cacheFiles = snapshot().indexFiles()\n+            final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue = snapshot().indexFiles()\n                 .stream()\n                 .filter(file -> file.metadata().hashEqualsContents() == false)\n                 .filter(file -> isExcludedFromCache(file.physicalName()) == false)\n-                .collect(Collectors.toList());\n+                .collect(Collectors.toCollection(LinkedBlockingQueue::new));\n \n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n-            logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n-\n-            for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n-                final String fileName = cacheFile.physicalName();\n-                try {\n-                    final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n-                    assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n-\n-                    final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n-                    }\n-                } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n-                }\n+            logger.debug(\"{} warming shard cache for [{}] files\", shardId, queue.size());\n+\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                prewarmNextFile(executor, queue);\n             }\n         }\n     }\n \n+    private void prewarmNextFile(final Executor executor, final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue) {\n+        executor.execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() throws Exception {\n+                final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                if (file == null) {\n+                    return;\n+                }\n+\n+                final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n+                assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n+\n+                final int numberOfParts = Math.toIntExact(file.numberOfParts());\n+                final GroupedActionListener<Void> listener = new GroupedActionListener<>(\n+                    ActionListener.runAfter(\n+                        ActionListener.wrap(() -> IOUtils.closeWhileHandlingException(input)),\n+                        () -> prewarmNextFile(executor, queue)\n+                    ),\n+                    numberOfParts\n+                );\n+\n+                // if the file to prewarm is composed of a single part then it is prewarmed using the current thread\n+                final Executor warmExecutor = (numberOfParts > 1) ? executor : EsExecutors.newDirectExecutorService();\n+\n+                for (int p = 0; p < numberOfParts; p++) {\n+                    final int part = p;\n+                    warmExecutor.execute(ActionRunnable.run(listener, () -> {", "originalCommit": "fffc4cf388fbe10dc184b5a823bedf76144bd371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQzNzQwNg==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419437406", "body": "I think this means we use `IOUtils.closeWhileHandlingException` even when not handling an exception, which sounds wrong to me.", "bodyText": "I think this means we use IOUtils.closeWhileHandlingException even when not handling an exception, which sounds wrong to me.", "bodyHTML": "<p dir=\"auto\">I think this means we use <code>IOUtils.closeWhileHandlingException</code> even when not handling an exception, which sounds wrong to me.</p>", "author": "DaveCTurner", "createdAt": "2020-05-04T13:31:22Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -352,76 +358,78 @@ public String toString() {\n \n     private void prewarmCache() {\n         if (prewarmCache) {\n-            final List<BlobStoreIndexShardSnapshot.FileInfo> cacheFiles = snapshot().indexFiles()\n+            final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue = snapshot().indexFiles()\n                 .stream()\n                 .filter(file -> file.metadata().hashEqualsContents() == false)\n                 .filter(file -> isExcludedFromCache(file.physicalName()) == false)\n-                .collect(Collectors.toList());\n+                .collect(Collectors.toCollection(LinkedBlockingQueue::new));\n \n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n-            logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n-\n-            for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n-                final String fileName = cacheFile.physicalName();\n-                try {\n-                    final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n-                    assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n-\n-                    final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n-                    }\n-                } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n-                }\n+            logger.debug(\"{} warming shard cache for [{}] files\", shardId, queue.size());\n+\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                prewarmNextFile(executor, queue);\n             }\n         }\n     }\n \n+    private void prewarmNextFile(final Executor executor, final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue) {\n+        executor.execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() throws Exception {\n+                final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                if (file == null) {\n+                    return;\n+                }\n+\n+                final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n+                assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n+\n+                final int numberOfParts = Math.toIntExact(file.numberOfParts());\n+                final GroupedActionListener<Void> listener = new GroupedActionListener<>(\n+                    ActionListener.runAfter(\n+                        ActionListener.wrap(() -> IOUtils.closeWhileHandlingException(input)),", "originalCommit": "fffc4cf388fbe10dc184b5a823bedf76144bd371", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxMjY1OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419512659", "bodyText": "Good point, I changed that.", "author": "tlrx", "createdAt": "2020-05-04T15:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQzNzQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0Mjc4OQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419442789", "body": "IIUC this means we wait for all parts of this file to be warmed before starting on the next file, which sounds like it might under-utilise the available threads. Could we use something cleverer than a `Queue<FileInfo>` to track the progress of the work in terms of parts that keeps all the threads busy until the very end?", "bodyText": "IIUC this means we wait for all parts of this file to be warmed before starting on the next file, which sounds like it might under-utilise the available threads. Could we use something cleverer than a Queue<FileInfo> to track the progress of the work in terms of parts that keeps all the threads busy until the very end?", "bodyHTML": "<p dir=\"auto\">IIUC this means we wait for all parts of this file to be warmed before starting on the next file, which sounds like it might under-utilise the available threads. Could we use something cleverer than a <code>Queue&lt;FileInfo&gt;</code> to track the progress of the work in terms of parts that keeps all the threads busy until the very end?</p>", "author": "DaveCTurner", "createdAt": "2020-05-04T13:39:08Z", "path": "x-pack/plugin/searchable-snapshots/src/main/java/org/elasticsearch/index/store/SearchableSnapshotDirectory.java", "diffHunk": "@@ -352,76 +358,78 @@ public String toString() {\n \n     private void prewarmCache() {\n         if (prewarmCache) {\n-            final List<BlobStoreIndexShardSnapshot.FileInfo> cacheFiles = snapshot().indexFiles()\n+            final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue = snapshot().indexFiles()\n                 .stream()\n                 .filter(file -> file.metadata().hashEqualsContents() == false)\n                 .filter(file -> isExcludedFromCache(file.physicalName()) == false)\n-                .collect(Collectors.toList());\n+                .collect(Collectors.toCollection(LinkedBlockingQueue::new));\n \n             final Executor executor = threadPool.executor(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME);\n-            logger.debug(\"{} warming shard cache for [{}] files\", shardId, cacheFiles.size());\n-\n-            for (BlobStoreIndexShardSnapshot.FileInfo cacheFile : cacheFiles) {\n-                final String fileName = cacheFile.physicalName();\n-                try {\n-                    final IndexInput input = openInput(fileName, CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n-                    assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n-\n-                    final long numberOfParts = cacheFile.numberOfParts();\n-                    final CountDown countDown = new CountDown(Math.toIntExact(numberOfParts));\n-                    for (long p = 0; p < numberOfParts; p++) {\n-                        final int part = Math.toIntExact(p);\n-                        // TODO use multiple workers to warm each part instead of filling the thread pool\n-                        executor.execute(new AbstractRunnable() {\n-                            @Override\n-                            protected void doRun() throws Exception {\n-                                ensureOpen();\n-\n-                                logger.trace(\"warming cache for [{}] part [{}/{}]\", fileName, part, numberOfParts);\n-                                final long startTimeInNanos = statsCurrentTimeNanosSupplier.getAsLong();\n-\n-                                final CachedBlobContainerIndexInput cachedIndexInput = (CachedBlobContainerIndexInput) input.clone();\n-                                cachedIndexInput.prefetchPart(part); // TODO does not include any rate limitation\n-\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"part [{}/{}] of [{}] warmed in [{}] ms\",\n-                                        part,\n-                                        numberOfParts,\n-                                        fileName,\n-                                        TimeValue.timeValueNanos(statsCurrentTimeNanosSupplier.getAsLong() - startTimeInNanos).millis()\n-                                    )\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onFailure(Exception e) {\n-                                logger.trace(\n-                                    () -> new ParameterizedMessage(\n-                                        \"failed to warm cache for [{}] part [{}/{}]\",\n-                                        fileName,\n-                                        part,\n-                                        numberOfParts\n-                                    ),\n-                                    e\n-                                );\n-                            }\n-\n-                            @Override\n-                            public void onAfter() {\n-                                if (countDown.countDown()) {\n-                                    IOUtils.closeWhileHandlingException(input);\n-                                }\n-                            }\n-                        });\n-                    }\n-                } catch (IOException e) {\n-                    logger.trace(() -> new ParameterizedMessage(\"failed to warm cache for [{}]\", fileName), e);\n-                }\n+            logger.debug(\"{} warming shard cache for [{}] files\", shardId, queue.size());\n+\n+            // Start as many workers as fit into the searchable snapshot pool at once at the most\n+            final int workers = Math.min(threadPool.info(SEARCHABLE_SNAPSHOTS_THREAD_POOL_NAME).getMax(), queue.size());\n+            for (int i = 0; i < workers; ++i) {\n+                prewarmNextFile(executor, queue);\n             }\n         }\n     }\n \n+    private void prewarmNextFile(final Executor executor, final BlockingQueue<BlobStoreIndexShardSnapshot.FileInfo> queue) {\n+        executor.execute(new AbstractRunnable() {\n+            @Override\n+            protected void doRun() throws Exception {\n+                final BlobStoreIndexShardSnapshot.FileInfo file = queue.poll(0L, TimeUnit.MILLISECONDS);\n+                if (file == null) {\n+                    return;\n+                }\n+\n+                final IndexInput input = openInput(file.physicalName(), CachedBlobContainerIndexInput.CACHE_WARMING_CONTEXT);\n+                assert input instanceof CachedBlobContainerIndexInput : \"expected cached index input but got \" + input.getClass();\n+\n+                final int numberOfParts = Math.toIntExact(file.numberOfParts());\n+                final GroupedActionListener<Void> listener = new GroupedActionListener<>(\n+                    ActionListener.runAfter(\n+                        ActionListener.wrap(() -> IOUtils.closeWhileHandlingException(input)),\n+                        () -> prewarmNextFile(executor, queue)", "originalCommit": "fffc4cf388fbe10dc184b5a823bedf76144bd371", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUxNDczOQ==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419514739", "bodyText": "I agree this is not optimal. The alternative I see is to enqueue file parts instead of file and then have workers polling each part to warm. I pushed 1aea980, it's a bit less readable IMO but still more than what I did in previous iterations. Let me know what you think.", "author": "tlrx", "createdAt": "2020-05-04T15:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0Mjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTUzMzUwMA==", "url": "https://github.com/elastic/elasticsearch/pull/55793#discussion_r419533500", "bodyText": "Yes I like that solution, thanks for the extra iteration. I don't think it's made a material difference to readability but I do think it's clearer now that the tasks are the warming of the individual parts rather than the files; also I just noticed that previously we would bound the worker pool size by the number of files rather than the number of parts, which may have resulted in less concurrency than we wanted -- this is now addressed.", "author": "DaveCTurner", "createdAt": "2020-05-04T15:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTQ0Mjc4OQ=="}], "type": "inlineReview"}, {"oid": "1bffb66766ad3dc53548c6c759c854ce4ffcee17", "url": "https://github.com/elastic/elasticsearch/commit/1bffb66766ad3dc53548c6c759c854ce4ffcee17", "message": "yuuup", "committedDate": "2020-05-04T13:42:14Z", "type": "commit"}, {"oid": "8a1045ee44fe3db2ab3fcc7e548da79a811ea907", "url": "https://github.com/elastic/elasticsearch/commit/8a1045ee44fe3db2ab3fcc7e548da79a811ea907", "message": "use direct exec also for last part", "committedDate": "2020-05-04T13:58:09Z", "type": "commit"}, {"oid": "e89213eef5621d776539bfa7391a4ddb8027a887", "url": "https://github.com/elastic/elasticsearch/commit/e89213eef5621d776539bfa7391a4ddb8027a887", "message": "wrap differently", "committedDate": "2020-05-04T14:02:49Z", "type": "commit"}, {"oid": "1aea98042c48781b63edd56be0e4b17ceeca07f8", "url": "https://github.com/elastic/elasticsearch/commit/1aea98042c48781b63edd56be0e4b17ceeca07f8", "message": "David's feedback", "committedDate": "2020-05-04T15:11:44Z", "type": "commit"}]}