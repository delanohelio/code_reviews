{"pr_number": 3697, "pr_title": "SPI and engine changes for aggregation pushdown", "pr_author": "Parth-Brahmbhatt", "pr_createdAt": "2020-05-11T17:03:02Z", "pr_url": "https://github.com/trinodb/trino/pull/3697", "timeline": [{"oid": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "url": "https://github.com/trinodb/trino/commit/5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "message": "SPI changes to support nonpartial and complete aggregate pushdown to connectors.\nThe commit also includes the top level optimizer rule", "committedDate": "2020-05-18T21:37:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428459360", "body": "Place the first argument on the next line", "bodyText": "Place the first argument on the next line", "bodyHTML": "<p dir=\"auto\">Place the first argument on the next line</p>", "author": "martint", "createdAt": "2020-05-21T05:54:55Z", "path": "presto-main/src/main/java/io/prestosql/metadata/Metadata.java", "diffHunk": "@@ -352,6 +354,12 @@\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n+    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDI2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130262", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ1OTM2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/Metadata.java b/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\nindex 583680937e..2241a084ef 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/Metadata.java\n", "chunk": "@@ -354,11 +355,12 @@ public interface Metadata\n \n     Optional<TableHandle> applySample(Session session, TableHandle table, SampleType sampleType, double sampleRatio);\n \n-    Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,\n+    Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n+            Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy);\n+            List<List<ColumnHandle>> groupingSets);\n \n     default void validateScan(Session session, TableHandle table) {}\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428461299", "body": "Rename to `AggregationApplicationResult` for consistency with `ProjectionApplicationResult`", "bodyText": "Rename to AggregationApplicationResult for consistency with ProjectionApplicationResult", "bodyHTML": "<p dir=\"auto\">Rename to <code>AggregationApplicationResult</code> for consistency with <code>ProjectionApplicationResult</code></p>", "author": "martint", "createdAt": "2020-05-21T06:01:32Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDIxMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130212", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nsimilarity index 58%\nrename from presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\nrename to presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nindex f1ace05a19..943361e42b 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\n", "chunk": "@@ -15,23 +15,31 @@ package io.prestosql.spi.connector;\n \n import io.prestosql.spi.expression.ConnectorExpression;\n \n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n-public class AggregationPushdownResult<T>\n+public class AggregationApplicationResult<T>\n {\n     private final T handle;\n     private final List<ConnectorExpression> projections;\n     private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingColumnMapping;\n \n-    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingColumnMapping)\n     {\n         this.handle = requireNonNull(handle, \"handle is null\");\n-        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n-        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n+        requireNonNull(groupingColumnMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingColumnMapping = Map.copyOf(groupingColumnMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n     }\n \n     public T getHandle()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463081", "body": "Format as:\r\n\r\n```suggestion\r\n                .map(result -> {\r\n```", "bodyText": "Format as:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(\n          \n          \n            \n                                    result -> {\n          \n          \n            \n                            .map(result -> {", "bodyHTML": "<p dir=\"auto\">Format as:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .map(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        result <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .map(result <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T06:07:51Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE4OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130188", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzA4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\nindex 9ee303fae8..f12a45082b 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n", "chunk": "@@ -1119,16 +1127,16 @@ public final class MetadataManager\n         }\n \n         ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n-        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n-                .map(\n-                        result -> {\n-                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupingSets)\n+                .map(result -> {\n+                    verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n \n-                            return new AggregationPushdownResult<>(\n-                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n-                                    result.getProjections(),\n-                                    result.getAssignments());\n-                        });\n+                    return new AggregationApplicationResult<>(\n+                            new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                            result.getProjections(),\n+                            result.getAssignments(),\n+                            result.getGroupingColumnMapping());\n+                });\n     }\n \n     private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428463560", "body": "Format as:\r\n\r\n```suggestion\r\n                .findAny()\r\n                .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\r\n```", "bodyText": "Format as:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n          \n          \n            \n                            .findAny()\n          \n          \n            \n                            .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "bodyHTML": "<p dir=\"auto\">Format as:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .findAny()<span class=\"pl-k x x-first\">.</span><span class=\"x\">ifPresent(variableName </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> { </span><span class=\"pl-k x\">throw</span><span class=\"x\"> </span><span class=\"pl-k x\">new</span><span class=\"x\"> </span><span class=\"pl-smi x\">IllegalStateException</span><span class=\"x\">(</span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x\">Unbound variable: </span><span class=\"pl-pds x\">\"</span></span><span class=\"x\"> </span><span class=\"pl-k x\">+</span><span class=\"x x-last\"> variableName); });</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .findAny()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .ifPresent(variableName <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> { <span class=\"pl-k\">throw</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">IllegalStateException</span>(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>Unbound variable: <span class=\"pl-pds\">\"</span></span> <span class=\"pl-k\">+</span> variableName); });</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T06:09:39Z", "path": "presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java", "diffHunk": "@@ -1100,6 +1103,56 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n                         Optional.empty()));\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(\n+            Session session,\n+            TableHandle table,\n+            List<AggregateFunction> aggregations,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)\n+    {\n+        CatalogName catalogName = table.getCatalogName();\n+        ConnectorMetadata metadata = getMetadata(session, catalogName);\n+\n+        if (metadata.usesLegacyTableLayouts()) {\n+            return Optional.empty();\n+        }\n+\n+        ConnectorSession connectorSession = session.toConnectorSession(catalogName);\n+        return metadata.applyAggregation(connectorSession, table.getConnectorHandle(), aggregations, assignments, groupBy)\n+                .map(\n+                        result -> {\n+                            verifyProjection(table, result.getProjections(), result.getAssignments(), aggregations.size());\n+\n+                            return new AggregationPushdownResult<>(\n+                                    new TableHandle(catalogName, result.getHandle(), table.getTransaction(), Optional.empty()),\n+                                    result.getProjections(),\n+                                    result.getAssignments());\n+                        });\n+    }\n+\n+    private void verifyProjection(TableHandle table, List<ConnectorExpression> projections, List<Assignment> assignments, int expectedProjectionSize)\n+    {\n+        projections.forEach(projection -> requireNonNull(projection, \"one of the projections is null\"));\n+        assignments.forEach(assignment -> requireNonNull(assignment, \"one of the assignments is null\"));\n+\n+        verify(\n+                expectedProjectionSize == projections.size(),\n+                \"ConnectorMetadata returned invalid number of projections: %s instead of %s for %s\",\n+                projections.size(),\n+                expectedProjectionSize,\n+                table);\n+\n+        Set<String> assignedVariables = assignments.stream()\n+                .map(Assignment::getVariable)\n+                .collect(toImmutableSet());\n+        projections.stream()\n+                .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n+                .map(Variable::getName)\n+                .filter(variableName -> !assignedVariables.contains(variableName))\n+                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130165", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MzU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\nindex 9ee303fae8..f12a45082b 100644\n--- a/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n+++ b/presto-main/src/main/java/io/prestosql/metadata/MetadataManager.java\n", "chunk": "@@ -1150,7 +1158,8 @@ public final class MetadataManager\n                 .flatMap(connectorExpression -> ConnectorExpressions.extractVariables(connectorExpression).stream())\n                 .map(Variable::getName)\n                 .filter(variableName -> !assignedVariables.contains(variableName))\n-                .findAny().ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n+                .findAny()\n+                .ifPresent(variableName -> { throw new IllegalStateException(\"Unbound variable: \" + variableName); });\n     }\n \n     @Override\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464294", "body": "Put the first argument on the next line", "bodyText": "Put the first argument on the next line", "bodyHTML": "<p dir=\"auto\">Put the first argument on the next line</p>", "author": "martint", "createdAt": "2020-05-21T06:12:12Z", "path": "presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java", "diffHunk": "@@ -447,6 +449,16 @@ public boolean usesLegacyTableLayouts(Session session, TableHandle table)\n         return Optional.empty();\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDE0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130143", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java b/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\nindex 8f1b567a1d..bd686f74d1 100644\n--- a/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\n+++ b/presto-main/src/test/java/io/prestosql/metadata/AbstractMockMetadata.java\n", "chunk": "@@ -450,11 +450,12 @@ public abstract class AbstractMockMetadata\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<TableHandle>> applyAggregation(Session session,\n+    public Optional<AggregationApplicationResult<TableHandle>> applyAggregation(\n+            Session session,\n             TableHandle table,\n             List<AggregateFunction> aggregations,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428464387", "body": "First argument on the next line", "bodyText": "First argument on the next line", "bodyHTML": "<p dir=\"auto\">First argument on the next line</p>", "author": "martint", "createdAt": "2020-05-21T06:12:30Z", "path": "presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java", "diffHunk": "@@ -687,6 +689,18 @@ public ConnectorTableProperties getTableProperties(ConnectorSession session, Con\n         }\n     }\n \n+    @Override\n+    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEyMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130121", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NDM4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java b/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\nindex 8655333c1b..3a1eb0a5e5 100644\n--- a/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\n+++ b/presto-plugin-toolkit/src/main/java/io/prestosql/plugin/base/classloader/ClassLoaderSafeConnectorMetadata.java\n", "chunk": "@@ -690,14 +698,15 @@ public class ClassLoaderSafeConnectorMetadata\n     }\n \n     @Override\n-    public Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(ConnectorSession session,\n+    public Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n             ConnectorTableHandle table,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         try (ThreadContextClassLoader ignored = new ThreadContextClassLoader(classLoader)) {\n-            return delegate.applyAggregation(session, table, aggregates, assignments, groupBy);\n+            return delegate.applyAggregation(session, table, aggregates, assignments, groupingSets);\n         }\n     }\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428465443", "body": "It's not a great idea to piggyback on `Map.Entry` to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named `SortItem`.", "bodyText": "It's not a great idea to piggyback on Map.Entry to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named SortItem.", "bodyHTML": "<p dir=\"auto\">It's not a great idea to piggyback on <code>Map.Entry</code> to represent a sort item. For one, it doesn't clearly convey what the key and value represent. Let's create a dedicated class named <code>SortItem</code>.</p>", "author": "martint", "createdAt": "2020-05-21T06:15:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDEwNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130104", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NTQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n", "chunk": "@@ -31,24 +28,26 @@ public class AggregateFunction\n     private final String functionName;\n     private final Type outputType;\n     private final List<ConnectorExpression> inputs;\n-    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final List<SortItem> sortItems;\n     private final boolean isDistinct;\n-    private final Optional<String> filter;\n+    private final Optional<ConnectorExpression> filter;\n \n     public AggregateFunction(\n             String aggregateFunctionName,\n             Type outputType,\n             List<ConnectorExpression> inputs,\n-            List<Map.Entry<String, SortOrder>> sortOrder,\n+            List<SortItem> sortItems,\n             boolean isDistinct,\n-            Optional<String> filter)\n+            Optional<ConnectorExpression> filter)\n     {\n         this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n         this.outputType = requireNonNull(outputType, \"outputType is null\");\n-        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n-        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n-        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n-        this.filter = filter;\n+        requireNonNull(inputs, \"inputs is null\");\n+        requireNonNull(sortItems, \"sortOrder is null\");\n+        this.inputs = List.copyOf(inputs);\n+        this.sortItems = List.copyOf(sortItems);\n+        this.isDistinct = isDistinct;\n+        this.filter = requireNonNull(filter, \"filter is null\");\n     }\n \n     public String getFunctionName()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428466207", "body": "requireNonNull", "bodyText": "requireNonNull", "bodyHTML": "<p dir=\"auto\">requireNonNull</p>", "author": "martint", "createdAt": "2020-05-21T06:18:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n+        this.filter = filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA4OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130089", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NjIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n", "chunk": "@@ -31,24 +28,26 @@ public class AggregateFunction\n     private final String functionName;\n     private final Type outputType;\n     private final List<ConnectorExpression> inputs;\n-    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final List<SortItem> sortItems;\n     private final boolean isDistinct;\n-    private final Optional<String> filter;\n+    private final Optional<ConnectorExpression> filter;\n \n     public AggregateFunction(\n             String aggregateFunctionName,\n             Type outputType,\n             List<ConnectorExpression> inputs,\n-            List<Map.Entry<String, SortOrder>> sortOrder,\n+            List<SortItem> sortItems,\n             boolean isDistinct,\n-            Optional<String> filter)\n+            Optional<ConnectorExpression> filter)\n     {\n         this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n         this.outputType = requireNonNull(outputType, \"outputType is null\");\n-        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n-        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n-        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n-        this.filter = filter;\n+        requireNonNull(inputs, \"inputs is null\");\n+        requireNonNull(sortItems, \"sortOrder is null\");\n+        this.inputs = List.copyOf(inputs);\n+        this.sortItems = List.copyOf(sortItems);\n+        this.isDistinct = isDistinct;\n+        this.filter = requireNonNull(filter, \"filter is null\");\n     }\n \n     public String getFunctionName()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428467051", "body": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use `List.copyOf()`:\r\n\r\n```suggestion\r\n        requireNonNull(inputs, \"inputs is null\");\r\n        requireNonNull(sortOrder, \"sortOrder is null\")\r\n        \r\n        this.inputs = List.copyOf(inputs);\r\n        this.sortOrder = List.copyOf(inputs);\r\n```\r\n\r\n", "bodyText": "Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use List.copyOf():\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n          \n          \n            \n                    this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n          \n          \n            \n                    requireNonNull(inputs, \"inputs is null\");\n          \n          \n            \n                    requireNonNull(sortOrder, \"sortOrder is null\")\n          \n          \n            \n                    \n          \n          \n            \n                    this.inputs = List.copyOf(inputs);\n          \n          \n            \n                    this.sortOrder = List.copyOf(inputs);", "bodyHTML": "<p dir=\"auto\">Move the requireNonNull for the arguments outside of the call. Having them inline muddles the code and makes it harder to read. Also, use <code>List.copyOf()</code>:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>inputs <span class=\"pl-k\">=</span> unmodifiableList(<span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(requireNonNull(inputs, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>inputs is null<span class=\"pl-pds\">\"</span></span>)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>sortOrder <span class=\"pl-k\">=</span> unmodifiableList(<span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(requireNonNull(sortOrder, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>sortOrder is null<span class=\"pl-pds\">\"</span></span>)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        requireNonNull(inputs, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>inputs is null<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        requireNonNull(sortOrder, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>sortOrder is null<span class=\"pl-pds\">\"</span></span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        </td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>inputs <span class=\"pl-k\">=</span> <span class=\"pl-smi\">List</span><span class=\"pl-k\">.</span>copyOf(inputs);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>sortOrder <span class=\"pl-k\">=</span> <span class=\"pl-smi\">List</span><span class=\"pl-k\">.</span>copyOf(inputs);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T06:20:53Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130058", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2NzA1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n", "chunk": "@@ -31,24 +28,26 @@ public class AggregateFunction\n     private final String functionName;\n     private final Type outputType;\n     private final List<ConnectorExpression> inputs;\n-    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final List<SortItem> sortItems;\n     private final boolean isDistinct;\n-    private final Optional<String> filter;\n+    private final Optional<ConnectorExpression> filter;\n \n     public AggregateFunction(\n             String aggregateFunctionName,\n             Type outputType,\n             List<ConnectorExpression> inputs,\n-            List<Map.Entry<String, SortOrder>> sortOrder,\n+            List<SortItem> sortItems,\n             boolean isDistinct,\n-            Optional<String> filter)\n+            Optional<ConnectorExpression> filter)\n     {\n         this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n         this.outputType = requireNonNull(outputType, \"outputType is null\");\n-        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n-        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n-        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n-        this.filter = filter;\n+        requireNonNull(inputs, \"inputs is null\");\n+        requireNonNull(sortItems, \"sortOrder is null\");\n+        this.inputs = List.copyOf(inputs);\n+        this.sortItems = List.copyOf(sortItems);\n+        this.isDistinct = isDistinct;\n+        this.filter = requireNonNull(filter, \"filter is null\");\n     }\n \n     public String getFunctionName()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428468099", "body": "```suggestion\r\n        requireNonNull(projections, \"projections is null\");\r\n        requireNonNull(assignments, \"assignment is null\");\r\n        this.projections = List.copyOf(projections);\r\n        this.assignments = List.copyOf(assignments);\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n          \n          \n            \n                    this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n          \n          \n            \n                    requireNonNull(projections, \"projections is null\");\n          \n          \n            \n                    requireNonNull(assignments, \"assignment is null\");\n          \n          \n            \n                    this.projections = List.copyOf(projections);\n          \n          \n            \n                    this.assignments = List.copyOf(assignments);", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>projections <span class=\"pl-k\">=</span> unmodifiableList(<span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(requireNonNull(projections, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>projections is null<span class=\"pl-pds\">\"</span></span>)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>assignments <span class=\"pl-k\">=</span> unmodifiableList(<span class=\"pl-k\">new</span> <span class=\"pl-k\">ArrayList&lt;&gt;</span>(requireNonNull(assignments, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>assignment is null<span class=\"pl-pds\">\"</span></span>)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        requireNonNull(projections, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>projections is null<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        requireNonNull(assignments, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>assignment is null<span class=\"pl-pds\">\"</span></span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>projections <span class=\"pl-k\">=</span> <span class=\"pl-smi\">List</span><span class=\"pl-k\">.</span>copyOf(projections);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>assignments <span class=\"pl-k\">=</span> <span class=\"pl-smi\">List</span><span class=\"pl-k\">.</span>copyOf(assignments);</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T06:24:07Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregationPushdownResult<T>\n+{\n+    private final T handle;\n+    private final List<ConnectorExpression> projections;\n+    private final List<Assignment> assignments;\n+\n+    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    {\n+        this.handle = requireNonNull(handle, \"handle is null\");\n+        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n+        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDA0OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130048", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2ODA5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nsimilarity index 58%\nrename from presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\nrename to presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\nindex f1ace05a19..943361e42b 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationPushdownResult.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregationApplicationResult.java\n", "chunk": "@@ -15,23 +15,31 @@ package io.prestosql.spi.connector;\n \n import io.prestosql.spi.expression.ConnectorExpression;\n \n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n \n-import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n-public class AggregationPushdownResult<T>\n+public class AggregationApplicationResult<T>\n {\n     private final T handle;\n     private final List<ConnectorExpression> projections;\n     private final List<Assignment> assignments;\n+    private final Map<ColumnHandle, ColumnHandle> groupingColumnMapping;\n \n-    public AggregationPushdownResult(T handle, List<ConnectorExpression> projections, List<Assignment> assignments)\n+    public AggregationApplicationResult(\n+            T handle,\n+            List<ConnectorExpression> projections,\n+            List<Assignment> assignments,\n+            Map<ColumnHandle, ColumnHandle> groupingColumnMapping)\n     {\n         this.handle = requireNonNull(handle, \"handle is null\");\n-        this.projections = unmodifiableList(new ArrayList<>(requireNonNull(projections, \"projections is null\")));\n-        this.assignments = unmodifiableList(new ArrayList<>(requireNonNull(assignments, \"assignment is null\")));\n+        requireNonNull(groupingColumnMapping, \"goupingSetMapping is null\");\n+        requireNonNull(projections, \"projections is null\");\n+        requireNonNull(assignments, \"assignment is null\");\n+        this.groupingColumnMapping = Map.copyOf(groupingColumnMapping);\n+        this.projections = List.copyOf(projections);\n+        this.assignments = List.copyOf(assignments);\n     }\n \n     public T getHandle()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906338", "body": "We generally place the `.stream()` call next to the previous one as it's immaterial to understanding what the transformation does:\r\n\r\n```suggestion\r\n                .entrySet().stream()\r\n```", "bodyText": "We generally place the .stream() call next to the previous one as it's immaterial to understanding what the transformation does:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .entrySet()\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .entrySet().stream()", "bodyHTML": "<p dir=\"auto\">We generally place the <code>.stream()</code> call next to the previous one as it's immaterial to understanding what the transformation does:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .entrySet()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .stream()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .entrySet()<span class=\"pl-k\">.</span>stream()</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T20:49:22Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEzMDAzMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432130031", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjMzOA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428906526", "body": "```suggestion\r\n        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n          \n          \n            \n                            .stream()\n          \n          \n            \n                    List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations.stream()", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">AggregateFunction</span>&gt;</span> aggregateFunctions <span class=\"pl-k\">=</span> toAggregateFunction(aggregations</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .stream()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">List&lt;<span class=\"pl-smi\">AggregateFunction</span>&gt;</span> aggregateFunctions <span class=\"pl-k\">=</span> toAggregateFunction(aggregations<span class=\"pl-k\">.</span>stream()</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T20:49:43Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwODUwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428908508", "bodyText": "If you change toAggregateFunction to process a single aggregation, you can rewrite this as:\nList<AggregateFunction> aggregateFunctions = aggregations.stream()\n        .map(Entry::getValue)\n        .map(this::toAggregateFunction)\n        .collect(toImmutableList());\nAlso, since some aggregations are not candidates to be pushed down (e.g., if they contain lambda expressions), add a check before that bails out early if the condition doesn't hold, although it'd be it'd be better to add this condition to the pattern:\n    private static final Pattern<AggregationNode> PATTERN = aggregation()\n            .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences) // skip arguments that are, for instance, lambda expressions\n            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n\n    private static boolean allArgumentsAreSimpleReferences(AggregationNode node)\n    {\n        return node.getAggregations()\n                .values().stream()\n                .flatMap(aggregation -> aggregation.getArguments().stream())\n                .allMatch(SymbolReference.class::isInstance)\n    }", "author": "martint", "createdAt": "2020-05-21T20:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk4Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129983", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNjUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428912880", "body": "Add this to the pattern:\r\n\r\n```java\r\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\r\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\r\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\r\n```", "bodyText": "Add this to the pattern:\nprivate static final Pattern<AggregationNode> PATTERN = aggregation()\n        .matching(node -> node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "bodyHTML": "<p dir=\"auto\">Add this to the pattern:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private static final Pattern&lt;AggregationNode&gt; PATTERN = aggregation()\n        .matching(node -&gt; node.getGroupingSets().getGroupingSetCount() == 1)\n        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\"><pre><span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">Pattern&lt;<span class=\"pl-smi\">AggregationNode</span>&gt;</span> <span class=\"pl-c1\">PATTERN</span> <span class=\"pl-k\">=</span> aggregation()\n        .matching(node <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> node<span class=\"pl-k\">.</span>getGroupingSets()<span class=\"pl-k\">.</span>getGroupingSetCount() <span class=\"pl-k\">==</span> <span class=\"pl-c1\">1</span>)\n        .with(source()<span class=\"pl-k\">.</span>matching(tableScan()<span class=\"pl-k\">.</span>capturedAs(<span class=\"pl-c1\">TABLE_SCAN</span>)));</pre></div>", "author": "martint", "createdAt": "2020-05-21T21:02:29Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTk1OA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129958", "bodyText": "Changed the pattern to capture this and no masks.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxMjg4MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428918734", "body": "These variables are used only once. Inline them where they are referenced.", "bodyText": "These variables are used only once. Inline them where they are referenced.", "bodyHTML": "<p dir=\"auto\">These variables are used only once. Inline them where they are referenced.</p>", "author": "martint", "createdAt": "2020-05-21T21:15:35Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTY1Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129656", "bodyText": "Done", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxODczNA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919130", "body": "This should unnecessary once you add the filter to the pattern as described above.", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "bodyHTML": "<p dir=\"auto\">This should unnecessary once you add the filter to the pattern as described above.</p>", "author": "martint", "createdAt": "2020-05-21T21:16:24Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTYzMg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129632", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919710", "body": "This can only be a SymbolReference, so it'd be more appropriate to do:\r\n\r\n```suggestion\r\n                    .map(Symbol::from)\r\n```", "bodyText": "This can only be a SymbolReference, so it'd be more appropriate to do:\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .map(SymbolsExtractor::extractUnique)\n          \n          \n            \n                                .flatMap(Collection::stream)\n          \n          \n            \n                                .map(Symbol::from)", "bodyHTML": "<p dir=\"auto\">This can only be a SymbolReference, so it'd be more appropriate to do:</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    .map(<span class=\"pl-smi\">SymbolsExtractor</span><span class=\"pl-k\">::</span>extractUnique)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                    .flatMap(<span class=\"pl-smi\">Collection</span><span class=\"pl-k\">::</span>stream)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .map(<span class=\"pl-smi\">Symbol</span><span class=\"pl-k\">::</span>from)</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-21T21:17:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTU4NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129585", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428919842", "body": "This should unnecessary once you add the filter to the pattern as described above.", "bodyText": "This should unnecessary once you add the filter to the pattern as described above.", "bodyHTML": "<p dir=\"auto\">This should unnecessary once you add the filter to the pattern as described above.</p>", "author": "martint", "createdAt": "2020-05-21T21:18:06Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    {\n+        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n+        for (AggregationNode.Aggregation aggregation : aggregations) {\n+            Signature signature = aggregation.getResolvedFunction().getSignature();\n+            Type returnType = metadata.getType(signature.getReturnType());\n+            String name = signature.getName();\n+            List<Expression> arguments = aggregation.getArguments();\n+            List<Symbol> symbols = arguments.stream()\n+                    .filter(expression -> expression instanceof SymbolReference)\n+                    .map(SymbolsExtractor::extractUnique)\n+                    .flatMap(Collection::stream)\n+                    .collect(toImmutableList());\n+\n+            if (arguments.size() != symbols.size()) {\n+                return ImmutableList.of();\n+            }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTUwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129500", "bodyText": "removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxOTg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428922849", "body": "Once you apply all the suggestions above and below, this method can simplify to:\r\n\r\n```java\r\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\r\n{\r\n    Signature signature = aggregation.getResolvedFunction().getSignature();\r\n\r\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\r\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\r\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\r\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\r\n    }\r\n\r\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\r\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\r\n            orderings.getOrderBy().stream()\r\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\r\n                            orderBy.getName(),\r\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\r\n                    .collect(toImmutableList()));\r\n\r\n    return new AggregateFunction(\r\n            signature.getName(),\r\n            metadata.getType(signature.getReturnType()),\r\n            arguments.build(),\r\n            sortBy.orElse(ImmutableList.of()),\r\n            aggregation.isDistinct(),\r\n            aggregation.getFilter().map(Symbol::getName));\r\n}\r\n```", "bodyText": "Once you apply all the suggestions above and below, this method can simplify to:\nprivate AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n    for (int i = 0; i < aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n    Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n            orderings.getOrderBy().stream()\n                    .map(orderBy -> new AbstractMap.SimpleEntry<>(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}", "bodyHTML": "<p dir=\"auto\">Once you apply all the suggestions above and below, this method can simplify to:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"private AggregateFunction toAggregateFunction(AggregationNode.Aggregation aggregation)\n{\n    Signature signature = aggregation.getResolvedFunction().getSignature();\n\n    ImmutableList.Builder&lt;ConnectorExpression&gt; arguments = new ImmutableList.Builder&lt;&gt;();\n    for (int i = 0; i &lt; aggregation.getArguments().size(); i++) {\n        SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n        arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n    }\n\n    Optional&lt;OrderingScheme&gt; orderingScheme = aggregation.getOrderingScheme();\n    Optional&lt;List&lt;Map.Entry&lt;String, SortOrder&gt;&gt;&gt; sortBy = orderingScheme.map(orderings -&gt;\n            orderings.getOrderBy().stream()\n                    .map(orderBy -&gt; new AbstractMap.SimpleEntry&lt;&gt;(\n                            orderBy.getName(),\n                            SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n                    .collect(toImmutableList()));\n\n    return new AggregateFunction(\n            signature.getName(),\n            metadata.getType(signature.getReturnType()),\n            arguments.build(),\n            sortBy.orElse(ImmutableList.of()),\n            aggregation.isDistinct(),\n            aggregation.getFilter().map(Symbol::getName));\n}\n\"><pre><span class=\"pl-k\">private</span> <span class=\"pl-smi\">AggregateFunction</span> toAggregateFunction(<span class=\"pl-smi\">AggregationNode</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">Aggregation</span> aggregation)\n{\n    <span class=\"pl-smi\">Signature</span> signature <span class=\"pl-k\">=</span> aggregation<span class=\"pl-k\">.</span>getResolvedFunction()<span class=\"pl-k\">.</span>getSignature();\n\n    <span class=\"pl-smi\">ImmutableList</span><span class=\"pl-k\">.</span><span class=\"pl-k\">Builder&lt;<span class=\"pl-smi\">ConnectorExpression</span>&gt;</span> arguments <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ImmutableList</span>.<span class=\"pl-k\">Builder&lt;&gt;</span>();\n    <span class=\"pl-k\">for</span> (<span class=\"pl-k\">int</span> i <span class=\"pl-k\">=</span> <span class=\"pl-c1\">0</span>; i <span class=\"pl-k\">&lt;</span> aggregation<span class=\"pl-k\">.</span>getArguments()<span class=\"pl-k\">.</span>size(); i<span class=\"pl-k\">++</span>) {\n        <span class=\"pl-smi\">SymbolReference</span> argument <span class=\"pl-k\">=</span> (<span class=\"pl-smi\">SymbolReference</span>) aggregation<span class=\"pl-k\">.</span>getArguments()<span class=\"pl-k\">.</span>get(i);\n        arguments<span class=\"pl-k\">.</span>add(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">Variable</span>(argument<span class=\"pl-k\">.</span>getName(), metadata<span class=\"pl-k\">.</span>getType(signature<span class=\"pl-k\">.</span>getArgumentTypes()<span class=\"pl-k\">.</span>get(i))));\n    }\n\n    <span class=\"pl-k\">Optional&lt;<span class=\"pl-smi\">OrderingScheme</span>&gt;</span> orderingScheme <span class=\"pl-k\">=</span> aggregation<span class=\"pl-k\">.</span>getOrderingScheme();\n    <span class=\"pl-k\">Optional&lt;<span class=\"pl-k\">List&lt;<span class=\"pl-smi\">Map</span>.Entry&lt;<span class=\"pl-smi\">String</span>, <span class=\"pl-smi\">SortOrder</span>&gt;</span>&gt;</span><span class=\"pl-k\">&gt;</span> sortBy <span class=\"pl-k\">=</span> orderingScheme<span class=\"pl-k\">.</span>map(orderings <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span>\n            orderings<span class=\"pl-k\">.</span>getOrderBy()<span class=\"pl-k\">.</span>stream()\n                    .map(orderBy <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">AbstractMap</span>.<span class=\"pl-k\">SimpleEntry&lt;&gt;</span>(\n                            orderBy<span class=\"pl-k\">.</span>getName(),\n                            <span class=\"pl-smi\">SortOrder</span><span class=\"pl-k\">.</span>valueOf(orderings<span class=\"pl-k\">.</span>getOrderings()<span class=\"pl-k\">.</span>get(orderBy)<span class=\"pl-k\">.</span>name())))\n                    .collect(toImmutableList()));\n\n    <span class=\"pl-k\">return</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">AggregateFunction</span>(\n            signature<span class=\"pl-k\">.</span>getName(),\n            metadata<span class=\"pl-k\">.</span>getType(signature<span class=\"pl-k\">.</span>getReturnType()),\n            arguments<span class=\"pl-k\">.</span>build(),\n            sortBy<span class=\"pl-k\">.</span>orElse(<span class=\"pl-smi\">ImmutableList</span><span class=\"pl-k\">.</span>of()),\n            aggregation<span class=\"pl-k\">.</span>isDistinct(),\n            aggregation<span class=\"pl-k\">.</span>getFilter()<span class=\"pl-k\">.</span>map(<span class=\"pl-smi\">Symbol</span><span class=\"pl-k\">::</span>getName));\n}</pre></div>", "author": "martint", "createdAt": "2020-05-21T21:24:03Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+\n+        return Result.ofPlanNode(\n+                new ProjectNode(\n+                        context.getIdAllocator().getNextId(),\n+                        TableScanNode.newInstance(\n+                                context.getIdAllocator().getNextId(),\n+                                handle,\n+                                newScanOutputs.build(),\n+                                newScanAssignments.build()),\n+                        assignmentBuilder.build()));\n+    }\n+\n+    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTAwNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899005", "bodyText": "what about aggregation.getMask()? we should verify aggregation.getMask() is not present (yet).", "author": "findepi", "createdAt": "2020-05-25T12:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTQyNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129424", "bodyText": "Done, added check for masks in pattern.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMjg0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r428924290", "body": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "bodyText": "This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.", "bodyHTML": "<p dir=\"auto\">This is incorrect. The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.</p>", "author": "martint", "createdAt": "2020-05-21T21:26:50Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyOTM2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432129365", "bodyText": "comment removed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNDI5MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429864990", "body": "https://github.com/prestosql/presto/commit/6d9d47e0909b3fe9367584ba8450827dbbb8e1d7", "bodyText": "6d9d47e", "bodyHTML": "<p dir=\"auto\"><a class=\"commit-link\" data-hovercard-type=\"commit\" data-hovercard-url=\"https://github.com/trinodb/trino/commit/6d9d47e0909b3fe9367584ba8450827dbbb8e1d7/hovercard\" href=\"https://github.com/trinodb/trino/commit/6d9d47e0909b3fe9367584ba8450827dbbb8e1d7\"><tt>6d9d47e</tt></a></p>", "author": "findepi", "createdAt": "2020-05-25T10:37:23Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODczMQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128731", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NDk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429866335", "body": "Why not `ImmutableList.of(groupByColumns)` always?\r\n\r\n`[ [] ]` would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "bodyText": "Why not ImmutableList.of(groupByColumns) always?\n[ [] ] would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.", "bodyHTML": "<p dir=\"auto\">Why not <code>ImmutableList.of(groupByColumns)</code> always?</p>\n<p dir=\"auto\"><code>[ [] ]</code> would correctly describe the fact that there is 1 grouping set and that it is a global aggregation.</p>", "author": "findepi", "createdAt": "2020-05-25T10:41:05Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODcwOQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128709", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NjMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429870514", "body": "i think https://github.com/prestosql/presto/pull/3697#discussion_r425071399 is still waiting for final resolution. @martint ?\r\n\r\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "bodyText": "i think #3697 (comment) is still waiting for final resolution. @martint ?\n(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)", "bodyHTML": "<p dir=\"auto\">i think <a class=\"issue-link js-issue-link\" data-error-text=\"Failed to load title\" data-id=\"616036785\" data-permission-text=\"Title is private\" data-url=\"https://github.com/trinodb/trino/issues/3697\" data-hovercard-type=\"pull_request\" data-hovercard-url=\"/trinodb/trino/pull/3697/hovercard?comment_id=425071399&amp;comment_type=review_comment\" href=\"https://github.com/trinodb/trino/pull/3697#discussion_r425071399\">#3697 (comment)</a> is still waiting for final resolution. <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/martint/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martint\">@martint</a> ?</p>\n<p dir=\"auto\">(nit: if this stays, would be good to avoid \"unioned\" as intellij spellchecker highlights this)</p>", "author": "findepi", "createdAt": "2020-05-25T10:51:58Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODY3OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128679", "bodyText": "unioned removed. I have assumed @martint 's last comment is what we want the API to do and changed both the contract and docs to reflect that. Let me know if there is a gap in my understanding vs what is expected.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MDUxNA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871095", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">     </span><span class=\"pl-k x x-last\">*</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T10:53:23Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA2Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128062", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871499", "body": "```suggestion\r\n     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\r\n```\r\n\r\notherwise you would need to use `&lt;` `&gt;`", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n          \n          \n            \n                 *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n          \n      \n    \n    \n  \n\notherwise you would need to use &lt; &gt;", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>              { functionName<span class=\"pl-k\">=</span>agg_fn1, outputType <span class=\"pl-k\">=</span> <span class=\"pl-k x x-first x-last\">&lt;</span>some presto type<span class=\"pl-k x x-first x-last\">&gt;</span> inputs <span class=\"pl-k\">=</span> [{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} a]} ,</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>              { functionName<span class=\"pl-k\">=</span>agg_fn1, outputType <span class=\"pl-k\">=</span> <span class=\"x x-first x-last\">\u00ab</span>some presto type<span class=\"x x-first x-last\">\u00bb</span> inputs <span class=\"pl-k\">=</span> [{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} a]} ,</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">otherwise you would need to use <code>&amp;lt;</code> <code>&amp;gt;</code></p>", "author": "findepi", "createdAt": "2020-05-25T10:54:24Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODA0MQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128041", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTQ5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MTkwOA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429871908", "body": "```suggestion\r\n     * group_by=[[{@link ColumnHandle} CH2]]\r\n```\r\n(it's list of lists)", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * group_by=[{@link ColumnHandle} CH2]\n          \n          \n            \n                 * group_by=[[{@link ColumnHandle} CH2]]\n          \n      \n    \n    \n  \n\n(it's list of lists)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> group_by<span class=\"pl-k\">=</span>[{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">ColumnHandle</span>} <span class=\"pl-c1\">CH2</span>]</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> group_by<span class=\"pl-k\">=</span>[<span class=\"x x-first x-last\">[</span>{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">ColumnHandle</span>} <span class=\"pl-c1\">CH2</span><span class=\"x x-first x-last\">]</span>]</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">(it's list of lists)</p>", "author": "findepi", "createdAt": "2020-05-25T10:55:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjA5OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872099", "body": "```suggestion\r\n     * assignments = {a = CH0, b = CH1, c = CH2}\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * assignments = {a = CH0, b=CH1, c=CH2}\n          \n          \n            \n                 * assignments = {a = CH0, b = CH1, c = CH2}", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> assignments <span class=\"pl-k\">=</span> {a <span class=\"pl-k\">=</span> <span class=\"pl-c1\">CH0</span>, b<span class=\"pl-k x x-first x-last\">=</span><span class=\"pl-c1\">CH1</span>, c<span class=\"pl-k x x-first x-last\">=</span><span class=\"pl-c1\">CH2</span>}</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> assignments <span class=\"pl-k\">=</span> {a <span class=\"pl-k\">=</span> <span class=\"pl-c1\">CH0</span>, b<span class=\"x x-first\"> </span><span class=\"pl-k x\">=</span><span class=\"x x-last\"> </span><span class=\"pl-c1\">CH1</span>, c<span class=\"x x-first\"> </span><span class=\"pl-k x\">=</span><span class=\"x x-last\"> </span><span class=\"pl-c1\">CH2</span>}</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T10:56:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MjgzNA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872834", "body": "`c` assignments seems redundant, as there is no `c` variable", "bodyText": "c assignments seems redundant, as there is no c variable", "bodyHTML": "<p dir=\"auto\"><code>c</code> assignments seems redundant, as there is no <code>c</code> variable</p>", "author": "findepi", "createdAt": "2020-05-25T10:57:50Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mjk5Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429872996", "body": "```suggestion\r\n     *  - aggregation (GROUP BY c)\r\n     *          variable0 = agg_fn1(a)\r\n     *          variable1 = agg_fn2(b, 2)\r\n     *          variable2 = c\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *  - aggregation\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = group_by c\n          \n          \n            \n                 *  - aggregation (GROUP BY c)\n          \n          \n            \n                 *          variable0 = agg_fn1(a)\n          \n          \n            \n                 *          variable1 = agg_fn2(b, 2)\n          \n          \n            \n                 *          variable2 = c", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>  <span class=\"pl-k\">-</span> aggregation</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>          variable0 <span class=\"pl-k\">=</span> agg_fn1(a)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>          variable1 <span class=\"pl-k\">=</span> agg_fn2(b, <span class=\"pl-c1\">2</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span>          variable2 <span class=\"pl-k\">=</span> <span class=\"x x-first x-last\">group_by </span>c</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>  <span class=\"pl-k\">-</span> aggregation<span class=\"x x-first\"> (</span><span class=\"pl-c1 x\">GROUP</span><span class=\"x\"> </span><span class=\"pl-c1 x\">BY</span><span class=\"x x-last\"> c)</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>          variable0 <span class=\"pl-k\">=</span> agg_fn1(a)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>          variable1 <span class=\"pl-k\">=</span> agg_fn2(b, <span class=\"pl-c1\">2</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span>          variable2 <span class=\"pl-k\">=</span> c</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T10:58:15Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -833,28 +842,26 @@ public interface ConnectorMetadata\n         return Optional.empty();\n     }\n \n-    /***\n+    /**\n      * Attempt to push down the aggregates into the table.\n      * <p>\n      * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n      * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n-     * <p>\n+     * </p>\n      * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n      * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n      * to loop indefinitely.\n-     * </p>\n      * <p>\n-     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * If the method returns a result, the list of assignments in the result will be merged with existing assignments. The projections\n      * returned by the method must have the same order as the given input list of aggregates.\n-     * <p>\n+     * </p>\n      * As an example, given the following plan:\n      *\n      * <pre>\n-     *\n-     *  - aggregation\n+     *  - aggregation  (GROUP BY c)\n      *          variable0 = agg_fn1(a)\n      *          variable1 = agg_fn2(b, 2)\n-     *          variable2 = group_by c\n+     *          variable2 = c\n      *          - scan (TH0)\n      *              a = CH0\n      *              b = CH1\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzM3Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873373", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"886\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">     </span><span class=\"pl-k x x-last\">*</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T10:59:19Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3MzY1Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873653", "body": "i like the way you wrote this!\r\n\r\njust consider adding an indent (here and following). \r\n```suggestion\r\n     * {@link AggregationPushdownResult} {\r\n     *     handle = TH1\r\n```", "bodyText": "i like the way you wrote this!\njust consider adding an indent (here and following).\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 * handle = TH1\n          \n          \n            \n                 * {@link AggregationPushdownResult} {\n          \n          \n            \n                 *     handle = TH1", "bodyHTML": "<p dir=\"auto\">i like the way you wrote this!</p>\n<p dir=\"auto\">just consider adding an indent (here and following).</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">AggregationPushdownResult</span>} {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> handle <span class=\"pl-k\">=</span> <span class=\"pl-c1\">TH1</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">AggregationPushdownResult</span>} {</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"x x-first x-last\">    </span>handle <span class=\"pl-k\">=</span> <span class=\"pl-c1\">TH1</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T11:00:01Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3Mzk3MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429873970", "body": "```suggestion\r\n     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n          \n          \n            \n                 * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> projections <span class=\"pl-k\">=</span> [{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} synthetic_name0, {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} synthetic_name1] <span class=\"pl-k\">&lt;</span>b<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">The</span> order in the list must be same as input list of aggregates<span class=\"pl-k\">&lt;</span><span class=\"pl-k\">/</span>b<span class=\"pl-k\">&gt;</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> projections <span class=\"pl-k\">=</span> [{<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} synthetic_name0, {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Variable</span>} synthetic_name1] <span class=\"pl-k x x-first\">--</span><span class=\"x x-last\"> </span><span class=\"pl-k\">&lt;</span>b<span class=\"pl-k\">&gt;</span><span class=\"pl-smi\">The</span> order in the list must be same as input list of aggregates<span class=\"pl-k\">&lt;</span><span class=\"pl-k\">/</span>b<span class=\"pl-k\">&gt;</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T11:00:51Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDIxNw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874217", "body": "CH0, CH1, and CH2 are already used above", "bodyText": "CH0, CH1, and CH2 are already used above", "bodyHTML": "<p dir=\"auto\">CH0, CH1, and CH2 are already used above</p>", "author": "findepi", "createdAt": "2020-05-25T11:01:31Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDQxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874415", "body": "```suggestion\r\n     * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n          \n          \n            \n                 * if the connector only knows how to handle {@code agg_fn1}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">if</span> the connector only knows how to handle agg_fn1<span class=\"x x-first x-last\"> </span>, it should <span class=\"pl-k\">return</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Optional</span>#empty()}<span class=\"pl-c1\">.</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">     <span class=\"pl-k\">*</span> <span class=\"pl-k\">if</span> the connector only knows how to handle <span class=\"x x-first\">{</span><span class=\"pl-k x\">@code</span><span class=\"x x-last\"> </span>agg_fn1<span class=\"x x-first\">}, but not {</span><span class=\"pl-k x\">@code</span><span class=\"x x-last\"> agg_fn2}</span>, it should <span class=\"pl-k\">return</span> {<span class=\"pl-k\">@link</span> <span class=\"pl-smi\">Optional</span>#empty()}<span class=\"pl-c1\">.</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T11:02:03Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NDc2OQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429874769", "body": "Should we call this `groupingSets`? @martint ?", "bodyText": "Should we call this groupingSets? @martint ?", "bodyHTML": "<p dir=\"auto\">Should we call this <code>groupingSets</code>? <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/martint/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/martint\">@martint</a> ?</p>", "author": "findepi", "createdAt": "2020-05-25T11:03:00Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java", "diffHunk": "@@ -831,6 +833,72 @@ default ConnectorTableProperties getTableProperties(ConnectorSession session, Co\n         return Optional.empty();\n     }\n \n+    /***\n+     * Attempt to push down the aggregates into the table.\n+     * <p>\n+     * Connectors can indicate whether they don't support aggregate pushdown or that the action had no effect\n+     * by returning {@link Optional#empty()}. Connectors should expect this method may be called multiple times.\n+     * <p>\n+     * <b>Note</b>: it's critical for connectors to return {@link Optional#empty()} if calling this method has no effect for that\n+     * invocation, even if the connector generally supports pushdown. Doing otherwise can cause the optimizer\n+     * to loop indefinitely.\n+     * </p>\n+     * <p>\n+     * If the method returns a result, the list of assignments in the result will be unioned with existing assignments. The projections\n+     * returned by the method must have the same order as the given input list of aggregates.\n+     * <p>\n+     * As an example, given the following plan:\n+     *\n+     * <pre>\n+     *\n+     *  - aggregation\n+     *          variable0 = agg_fn1(a)\n+     *          variable1 = agg_fn2(b, 2)\n+     *          variable2 = group_by c\n+     *          - scan (TH0)\n+     *              a = CH0\n+     *              b = CH1\n+     *              c = CH2\n+     * </pre>\n+     * <p>\n+     * The optimizer would call this method with the following arguments:\n+     *\n+     * <pre>\n+     * handle = TH0\n+     * aggregates = [\n+     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *              ]\n+     * group_by=[{@link ColumnHandle} CH2]\n+     * assignments = {a = CH0, b=CH1, c=CH2}\n+     * </pre>\n+     * <p>\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     *\n+     * <pre>\n+     *\n+     * {@link AggregationPushdownResult} {\n+     * handle = TH1\n+     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n+     * assignments = {\n+     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n+     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     */\n+    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+            ConnectorSession session,\n+            ConnectorTableHandle handle,\n+            List<AggregateFunction> aggregates,\n+            Map<String, ColumnHandle> assignments,\n+            List<List<ColumnHandle>> groupBy)", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\nindex ff5d135dd1..8decc2a4bd 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/ConnectorMetadata.java\n", "chunk": "@@ -864,37 +871,56 @@ public interface ConnectorMetadata\n      * The optimizer would call this method with the following arguments:\n      *\n      * <pre>\n-     * handle = TH0\n-     * aggregates = [\n-     *              { functionName=agg_fn1, outputType = <some presto type> inputs = [{@link Variable} a]} ,\n-     *              { functionName=agg_fn2, outputType = <some presto type> inputs = [{@link Variable} b, {@link Constant} 2]}\n-     *              ]\n-     * group_by=[{@link ColumnHandle} CH2]\n-     * assignments = {a = CH0, b=CH1, c=CH2}\n+     *      handle = TH0\n+     *      aggregates = [\n+     *              { functionName=agg_fn1, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} a]} ,\n+     *              { functionName=agg_fn2, outputType = \u00absome presto type\u00bb inputs = [{@link Variable} b, {@link Constant} 2]}\n+     *      ]\n+     *      groupingSets=[[{@link ColumnHandle} CH2]]\n+     *      assignments = {a = CH0, b = CH1, c = CH2}\n      * </pre>\n-     * <p>\n-     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n+     * </p>\n      *\n+     * Assuming the connector knows how to handle {@code agg_fn1(...)} and {@code agg_fn2(...)}, it would return:\n      * <pre>\n      *\n-     * {@link AggregationPushdownResult} {\n-     * handle = TH1\n-     * projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] <b>The order in the list must be same as input list of aggregates</b>\n-     * assignments = {\n-     *     synthetic_name0 = CH0 (synthetic column for agg_fn1(a))\n-     *     synthetic_name1 = CH1 (synthetic column for agg_fn2(b,2))\n-     *     }\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (synthetic column for agg_fn1(a))\n+     *          synthetic_name1 = CH4 (synthetic column for agg_fn2(b,2))\n+     *      }\n      * }\n      * </pre>\n      *\n-     * if the connector only knows how to handle agg_fn1 , it should return {@link Optional#empty()}.\n+     * if the connector only knows how to handle {@code agg_fn1(...)}, but not {@code agg_fn2}, it should return {@link Optional#empty()}.\n+     *\n+     * <p>\n+     * Another example is where the connector wants to handle the aggregate function by pointing to a pre-materialized table.\n+     * In this case the input can stay same as in the above example and the connector can return\n+     * <pre>\n+     * {@link AggregationApplicationResult} {\n+     *      handle = TH1 (could capture information about which pre-materialized table to use)\n+     *      projections = [{@link Variable} synthetic_name0, {@link Variable} synthetic_name1] -- <b>The order in the list must be same as input list of aggregates</b>\n+     *      assignments = {\n+     *          synthetic_name0 = CH3 (reference to the column in pre-materialized table that has agg_fn1(a) calculated)\n+     *          synthetic_name1 = CH4 (reference to the column in pre-materialized table that has agg_fn2(b,2) calculated)\n+     *          synthetic_name2 = CH5 (reference to the column in pre-materialized table that has the group by column c)\n+     *      }\n+     *      groupingColumnMapping = {\n+     *          CH2 -> CH5 (CH2 in the original assignment should now be replaced by CH5 in the new assignment)\n+     *      }\n+     * }\n+     * </pre>\n+     * </p>\n      */\n-    default Optional<AggregationPushdownResult<ConnectorTableHandle>> applyAggregation(\n+    default Optional<AggregationApplicationResult<ConnectorTableHandle>> applyAggregation(\n             ConnectorSession session,\n             ConnectorTableHandle handle,\n             List<AggregateFunction> aggregates,\n             Map<String, ColumnHandle> assignments,\n-            List<List<ColumnHandle>> groupBy)\n+            List<List<ColumnHandle>> groupingSets)\n     {\n         return Optional.empty();\n     }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg3NTY5NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429875695", "body": "`isDistinct` is primitive, so\r\n\r\n```suggestion\r\n        this.isDistinct = isDistinct;\r\n```", "bodyText": "isDistinct is primitive, so\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n          \n          \n            \n                    this.isDistinct = isDistinct;", "bodyHTML": "<p dir=\"auto\"><code>isDistinct</code> is primitive, so</p>\n  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>isDistinct <span class=\"pl-k\">=</span> <span class=\"x x-first x-last\">requireNonNull(</span>isDistinct<span class=\"x x-first\">, </span><span class=\"pl-s\"><span class=\"pl-pds x\">\"</span><span class=\"x\">isDistinct is null</span><span class=\"pl-pds x\">\"</span></span><span class=\"x x-last\">)</span>;</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-c1\">this</span><span class=\"pl-k\">.</span>isDistinct <span class=\"pl-k\">=</span> isDistinct;</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "findepi", "createdAt": "2020-05-25T11:05:33Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;\n+\n+    public AggregateFunction(\n+            String aggregateFunctionName,\n+            Type outputType,\n+            List<ConnectorExpression> inputs,\n+            List<Map.Entry<String, SortOrder>> sortOrder,\n+            boolean isDistinct,\n+            Optional<String> filter)\n+    {\n+        this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n+        this.outputType = requireNonNull(outputType, \"outputType is null\");\n+        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n+        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n+        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n", "chunk": "@@ -31,24 +28,26 @@ public class AggregateFunction\n     private final String functionName;\n     private final Type outputType;\n     private final List<ConnectorExpression> inputs;\n-    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final List<SortItem> sortItems;\n     private final boolean isDistinct;\n-    private final Optional<String> filter;\n+    private final Optional<ConnectorExpression> filter;\n \n     public AggregateFunction(\n             String aggregateFunctionName,\n             Type outputType,\n             List<ConnectorExpression> inputs,\n-            List<Map.Entry<String, SortOrder>> sortOrder,\n+            List<SortItem> sortItems,\n             boolean isDistinct,\n-            Optional<String> filter)\n+            Optional<ConnectorExpression> filter)\n     {\n         this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n         this.outputType = requireNonNull(outputType, \"outputType is null\");\n-        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n-        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n-        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n-        this.filter = filter;\n+        requireNonNull(inputs, \"inputs is null\");\n+        requireNonNull(sortItems, \"sortOrder is null\");\n+        this.inputs = List.copyOf(inputs);\n+        this.sortItems = List.copyOf(sortItems);\n+        this.isDistinct = isDistinct;\n+        this.filter = requireNonNull(filter, \"filter is null\");\n     }\n \n     public String getFunctionName()\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NTY5Mw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429885693", "body": "Moving out `Assignment` as a top level class touches a lot of files, that are otherwise unrelated to the change.\r\nCan you please extract this to a preparatory commit?", "bodyText": "Moving out Assignment as a top level class touches a lot of files, that are otherwise unrelated to the change.\nCan you please extract this to a preparatory commit?", "bodyHTML": "<p dir=\"auto\">Moving out <code>Assignment</code> as a top level class touches a lot of files, that are otherwise unrelated to the change.<br>\nCan you please extract this to a preparatory commit?</p>", "author": "findepi", "createdAt": "2020-05-25T11:31:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PruneTableScanColumns.java", "diffHunk": "@@ -91,7 +92,7 @@ public PruneTableScanColumns(Metadata metadata, TypeAnalyzer typeAnalyzer)\n             handle = result.get().getHandle();\n \n             Map<String, ColumnHandle> assignments = result.get().getAssignments().stream()\n-                    .collect(toImmutableMap(ProjectionApplicationResult.Assignment::getVariable, ProjectionApplicationResult.Assignment::getColumn));\n+                    .collect(toImmutableMap(Assignment::getVariable, Assignment::getColumn));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4Nzg2NQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429887865", "body": "Why?\r\n\r\nIf you remove this, the rule would be applicable also for queries like\r\n```\r\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;\r\n```\r\n\r\n", "bodyText": "Why?\nIf you remove this, the rule would be applicable also for queries like\nSELECT DISTINCT regionkey FROM tpch.tiny.nation;", "bodyHTML": "<p dir=\"auto\">Why?</p>\n<p dir=\"auto\">If you remove this, the rule would be applicable also for queries like</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"SELECT DISTINCT regionkey FROM tpch.tiny.nation;\"><pre><code>SELECT DISTINCT regionkey FROM tpch.tiny.nation;\n</code></pre></div>", "author": "findepi", "createdAt": "2020-05-25T11:36:51Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -89,52 +108,42 @@ public class PushAggregationIntoTableScan\n                 .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n \n         List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n-                .entrySet()\n-                .stream()\n+                .entrySet().stream()\n                 .collect(toImmutableList());\n \n-        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n-                .stream()\n+        List<AggregateFunction> aggregateFunctions = aggregations.stream()\n                 .map(Entry::getValue)\n-                .collect(toImmutableList()));\n+                .map(aggregation -> toAggregateFunction(context, aggregation))\n+                .collect(toImmutableList());\n+\n         List<Symbol> aggregationOutputSymbols = aggregations.stream()\n                 .map(Entry::getKey)\n                 .collect(toImmutableList());\n \n-        if (aggregateFunctions.isEmpty()) {\n-            return Result.empty();\n-        }\n-\n         GroupingSetDescriptor groupingSets = node.getGroupingSets();\n \n-        if (groupingSets.getGroupingSetCount() > 1) {\n-            return Result.empty();\n-        }\n-\n         List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n                 .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n                 .collect(toImmutableList());\n \n-        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+        Optional<AggregationApplicationResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n                 context.getSession(),\n                 tableScan.getTable(),\n                 aggregateFunctions,\n                 assignments,\n-                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+                ImmutableList.of(groupByColumns));\n \n-        if (!aggregationPushdownResult.isPresent()) {\n+        if (aggregationPushdownResult.isEmpty()) {\n             return Result.empty();\n         }\n \n-        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+        AggregationApplicationResult<TableHandle> result = aggregationPushdownResult.get();\n \n-        TableHandle handle = result.getHandle();\n-\n-        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        // The new scan outputs should be the symbols associated with grouping columns plus the symbols associated with aggregations.\n         ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n         newScanOutputs.addAll(tableScan.getOutputSymbols());\n \n-        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        ImmutableBiMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableBiMap.Builder<>();\n         newScanAssignments.putAll(tableScan.getAssignments());\n \n         Map<String, Symbol> variableMappings = new HashMap<>();\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429891044", "body": "```suggestion\r\n        private static final Pattern<AggregationNode> PATTERN =\r\n            aggregation()\r\n                    .with(step().equalTo(SINGLE))\r\n                    .matching(node -> node.getGroupingSetCount() == 1)\r\n                    .matching(node -> node.getGroupIdSymbol().isEmpty())\r\n                    .matching(node -> node.getHashSymbol().isEmpty())\r\n                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\r\n```\r\n\r\n- a few additional checks\r\n- if you move `aggregation()` to new line, this fill be formatted better\r\n", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Pattern<AggregationNode> PATTERN = aggregation()\n          \n          \n            \n                        .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n          \n            \n                    private static final Pattern<AggregationNode> PATTERN =\n          \n          \n            \n                        aggregation()\n          \n          \n            \n                                .with(step().equalTo(SINGLE))\n          \n          \n            \n                                .matching(node -> node.getGroupingSetCount() == 1)\n          \n          \n            \n                                .matching(node -> node.getGroupIdSymbol().isEmpty())\n          \n          \n            \n                                .matching(node -> node.getHashSymbol().isEmpty())\n          \n          \n            \n                                .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n          \n      \n    \n    \n  \n\n\na few additional checks\nif you move aggregation() to new line, this fill be formatted better", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">Pattern&lt;<span class=\"pl-smi\">AggregationNode</span>&gt;</span> <span class=\"pl-c1\">PATTERN</span> <span class=\"pl-k\">=</span> aggregation()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">            .with(source()<span class=\"pl-k\">.</span>matching(tableScan()<span class=\"pl-k\">.</span>capturedAs(<span class=\"pl-c1\">TABLE_SCAN</span>)));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-k\">private</span> <span class=\"pl-k\">static</span> <span class=\"pl-k\">final</span> <span class=\"pl-k\">Pattern&lt;<span class=\"pl-smi\">AggregationNode</span>&gt;</span> <span class=\"pl-c1\">PATTERN</span> <span class=\"pl-k\">=</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">            aggregation()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .with(step()<span class=\"pl-k\">.</span>equalTo(<span class=\"pl-c1\">SINGLE</span>))</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .matching(node <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> node<span class=\"pl-k\">.</span>getGroupingSetCount() <span class=\"pl-k\">==</span> <span class=\"pl-c1\">1</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .matching(node <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> node<span class=\"pl-k\">.</span>getGroupIdSymbol()<span class=\"pl-k\">.</span>isEmpty())</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .matching(node <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> node<span class=\"pl-k\">.</span>getHashSymbol()<span class=\"pl-k\">.</span>isEmpty())</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                    .with(source()<span class=\"pl-k\">.</span>matching(tableScan()<span class=\"pl-k\">.</span>capturedAs(<span class=\"pl-c1\">TABLE_SCAN</span>)));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<ul dir=\"auto\">\n<li>a few additional checks</li>\n<li>if you move <code>aggregation()</code> to new line, this fill be formatted better</li>\n</ul>", "author": "findepi", "createdAt": "2020-05-25T11:44:49Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5OTM5MA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429899390", "bodyText": "plus additional conditions\n\n@martint 's all agg args are symbols condition\nagg mask is not present\nanything else?", "author": "findepi", "createdAt": "2020-05-25T12:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MTA0NA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -64,8 +62,13 @@ public class PushAggregationIntoTableScan\n {\n     private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n \n-    private static final Pattern<AggregationNode> PATTERN = aggregation()\n-            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+    private static final Pattern<AggregationNode> PATTERN =\n+            aggregation()\n+                    // skip arguments that are, for instance, lambda expressions\n+                    .matching(PushAggregationIntoTableScan::allArgumentsAreSimpleReferences)\n+                    .matching(node -> node.getGroupingSets().getGroupingSetCount() <= 1)\n+                    .matching(PushAggregationIntoTableScan::hasNoMasks)\n+                    .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n \n     private final Metadata metadata;\n \n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429892713", "body": "what does \"partial project\" mean here? (can this be  `newProjections`?)", "bodyText": "what does \"partial project\" mean here? (can this be  newProjections?)", "bodyHTML": "<p dir=\"auto\">what does \"partial project\" mean here? (can this be  <code>newProjections</code>?)</p>", "author": "findepi", "createdAt": "2020-05-25T11:49:02Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyODAxNQ==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432128015", "bodyText": "renamed.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MjcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429893130", "body": "```suggestion\r\n        groupingSets.getGroupingKeys()\r\n                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\r\n```\r\n\r\n-- use Collection#forEach without going thru Stream", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    groupingSets.getGroupingKeys().stream()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n          \n            \n                    groupingSets.getGroupingKeys()\n          \n          \n            \n                            .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n          \n      \n    \n    \n  \n\n-- use Collection#forEach without going thru Stream", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        groupingSets<span class=\"pl-k\">.</span>getGroupingKeys()<span class=\"pl-k x x-first\">.</span><span class=\"x x-last\">stream()</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .forEach(groupBySymbol <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> assignmentBuilder<span class=\"pl-k\">.</span>put(groupBySymbol, groupBySymbol<span class=\"pl-k\">.</span>toSymbolReference()));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        groupingSets<span class=\"pl-k\">.</span>getGroupingKeys()</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .forEach(groupBySymbol <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> assignmentBuilder<span class=\"pl-k\">.</span>put(groupBySymbol, groupBySymbol<span class=\"pl-k\">.</span>toSymbolReference()));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">-- use Collection#forEach without going thru Stream</p>", "author": "findepi", "createdAt": "2020-05-25T11:50:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+\n+        // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n+        groupingSets.getGroupingKeys().stream()\n+                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcxNg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127716", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5MzEzMA=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429894946", "body": "add `verify(aggregationOutputSymbols.size() == newPartialProjections.size());` just before this line as this is where you depend on this\r\n\r\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "bodyText": "add verify(aggregationOutputSymbols.size() == newPartialProjections.size()); just before this line as this is where you depend on this\nno need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here", "bodyHTML": "<p dir=\"auto\">add <code>verify(aggregationOutputSymbols.size() == newPartialProjections.size());</code> just before this line as this is where you depend on this</p>\n<p dir=\"auto\">no need for good exc msg, since it's in fact already validated in MetadataManager, so it's more for documenting assumptions/dependencies of the code here</p>", "author": "findepi", "createdAt": "2020-05-25T11:54:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.metadata.Metadata;\n+import io.prestosql.metadata.Signature;\n+import io.prestosql.metadata.TableHandle;\n+import io.prestosql.spi.connector.AggregateFunction;\n+import io.prestosql.spi.connector.AggregationPushdownResult;\n+import io.prestosql.spi.connector.Assignment;\n+import io.prestosql.spi.connector.ColumnHandle;\n+import io.prestosql.spi.connector.SortOrder;\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.expression.Variable;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.ConnectorExpressionTranslator;\n+import io.prestosql.sql.planner.LiteralEncoder;\n+import io.prestosql.sql.planner.OrderingScheme;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.SymbolsExtractor;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.AggregationNode;\n+import io.prestosql.sql.planner.plan.AggregationNode.GroupingSetDescriptor;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.plan.Patterns.aggregation;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+\n+public class PushAggregationIntoTableScan\n+        implements Rule<AggregationNode>\n+{\n+    private static final Capture<TableScanNode> TABLE_SCAN = newCapture();\n+\n+    private static final Pattern<AggregationNode> PATTERN = aggregation()\n+            .with(source().matching(tableScan().capturedAs(TABLE_SCAN)));\n+\n+    private final Metadata metadata;\n+\n+    public PushAggregationIntoTableScan(Metadata metadata)\n+    {\n+        this.metadata = metadata;\n+    }\n+\n+    @Override\n+    public Pattern<AggregationNode> getPattern()\n+    {\n+        return PATTERN;\n+    }\n+\n+    @Override\n+    public Result apply(AggregationNode node, Captures captures, Context context)\n+    {\n+        TableScanNode tableScan = captures.get(TABLE_SCAN);\n+        Map<String, ColumnHandle> assignments = tableScan.getAssignments()\n+                .entrySet().stream()\n+                .collect(toImmutableMap(entry -> entry.getKey().getName(), Entry::getValue));\n+\n+        List<Entry<Symbol, AggregationNode.Aggregation>> aggregations = node.getAggregations()\n+                .entrySet()\n+                .stream()\n+                .collect(toImmutableList());\n+\n+        List<AggregateFunction> aggregateFunctions = toAggregateFunction(aggregations\n+                .stream()\n+                .map(Entry::getValue)\n+                .collect(toImmutableList()));\n+        List<Symbol> aggregationOutputSymbols = aggregations.stream()\n+                .map(Entry::getKey)\n+                .collect(toImmutableList());\n+\n+        if (aggregateFunctions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        GroupingSetDescriptor groupingSets = node.getGroupingSets();\n+\n+        if (groupingSets.getGroupingSetCount() > 1) {\n+            return Result.empty();\n+        }\n+\n+        List<ColumnHandle> groupByColumns = groupingSets.getGroupingKeys().stream()\n+                .map(groupByColumn -> assignments.get(groupByColumn.getName()))\n+                .collect(toImmutableList());\n+\n+        Optional<AggregationPushdownResult<TableHandle>> aggregationPushdownResult = metadata.applyAggregation(\n+                context.getSession(),\n+                tableScan.getTable(),\n+                aggregateFunctions,\n+                assignments,\n+                groupByColumns.isEmpty() ? ImmutableList.of() : ImmutableList.of(groupByColumns));\n+\n+        if (!aggregationPushdownResult.isPresent()) {\n+            return Result.empty();\n+        }\n+\n+        AggregationPushdownResult<TableHandle> result = aggregationPushdownResult.get();\n+\n+        TableHandle handle = result.getHandle();\n+\n+        // The new scan outputs and assignments are union of existing and the ones returned by connector pushdown.\n+        ImmutableList.Builder<Symbol> newScanOutputs = new ImmutableList.Builder<>();\n+        newScanOutputs.addAll(tableScan.getOutputSymbols());\n+\n+        ImmutableMap.Builder<Symbol, ColumnHandle> newScanAssignments = new ImmutableMap.Builder<>();\n+        newScanAssignments.putAll(tableScan.getAssignments());\n+\n+        Map<String, Symbol> variableMappings = new HashMap<>();\n+\n+        for (Assignment assignment : result.getAssignments()) {\n+            Symbol symbol = context.getSymbolAllocator().newSymbol(assignment.getVariable(), assignment.getType());\n+\n+            newScanOutputs.add(symbol);\n+            newScanAssignments.put(symbol, assignment.getColumn());\n+            variableMappings.put(assignment.getVariable(), symbol);\n+        }\n+\n+        List<Expression> newPartialProjections = result.getProjections().stream()\n+                .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n+                .collect(toImmutableList());\n+\n+        Assignments.Builder assignmentBuilder = Assignments.builder();\n+        IntStream.range(0, aggregationOutputSymbols.size())\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzcwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127700", "bodyText": "Done.", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NDk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\nindex 6813017f1c..0f8a4bc45d 100644\n--- a/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n+++ b/presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/PushAggregationIntoTableScan.java\n", "chunk": "@@ -147,68 +156,66 @@ public class PushAggregationIntoTableScan\n             variableMappings.put(assignment.getVariable(), symbol);\n         }\n \n-        List<Expression> newPartialProjections = result.getProjections().stream()\n+        List<Expression> newProjections = result.getProjections().stream()\n                 .map(expression -> ConnectorExpressionTranslator.translate(expression, variableMappings, new LiteralEncoder(metadata)))\n                 .collect(toImmutableList());\n \n+        verify(aggregationOutputSymbols.size() == newProjections.size());\n+\n         Assignments.Builder assignmentBuilder = Assignments.builder();\n         IntStream.range(0, aggregationOutputSymbols.size())\n-                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newPartialProjections.get(index)));\n+                .forEach(index -> assignmentBuilder.put(aggregationOutputSymbols.get(index), newProjections.get(index)));\n \n+        ImmutableBiMap<Symbol, ColumnHandle> scanAssignments = newScanAssignments.build();\n+        ImmutableBiMap<ColumnHandle, Symbol> columnHandleToSymbol = scanAssignments.inverse();\n         // projections assignmentBuilder should have both agg and group by so we add all the group bys as symbol references\n-        groupingSets.getGroupingKeys().stream()\n-                .forEach(groupBySymbol -> assignmentBuilder.put(groupBySymbol, groupBySymbol.toSymbolReference()));\n+        groupingSets.getGroupingKeys()\n+                .forEach(groupBySymbol -> {\n+                    // if the connector returned a new mapping from oldColumnHandle to newColumnHandle, groupBy needs to point to\n+                    // new columnHandle's symbol reference, otherwise it will continue pointing at oldColumnHandle.\n+                    ColumnHandle originalColumnHandle = assignments.get(groupBySymbol.getName());\n+                    ColumnHandle groupByColumnHandle = result.getGroupingColumnMapping().getOrDefault(originalColumnHandle, originalColumnHandle);\n+                    assignmentBuilder.put(groupBySymbol, columnHandleToSymbol.get(groupByColumnHandle).toSymbolReference());\n+                });\n \n         return Result.ofPlanNode(\n                 new ProjectNode(\n                         context.getIdAllocator().getNextId(),\n                         TableScanNode.newInstance(\n                                 context.getIdAllocator().getNextId(),\n-                                handle,\n+                                result.getHandle(),\n                                 newScanOutputs.build(),\n-                                newScanAssignments.build()),\n+                                scanAssignments),\n                         assignmentBuilder.build()));\n     }\n \n-    private List<AggregateFunction> toAggregateFunction(List<AggregationNode.Aggregation> aggregations)\n+    private AggregateFunction toAggregateFunction(Context context, AggregationNode.Aggregation aggregation)\n     {\n-        ImmutableList.Builder<AggregateFunction> aggregateFunctionBuilder = ImmutableList.builder();\n-        for (AggregationNode.Aggregation aggregation : aggregations) {\n-            Signature signature = aggregation.getResolvedFunction().getSignature();\n-            Type returnType = metadata.getType(signature.getReturnType());\n-            String name = signature.getName();\n-            List<Expression> arguments = aggregation.getArguments();\n-            List<Symbol> symbols = arguments.stream()\n-                    .filter(expression -> expression instanceof SymbolReference)\n-                    .map(SymbolsExtractor::extractUnique)\n-                    .flatMap(Collection::stream)\n-                    .collect(toImmutableList());\n-\n-            if (arguments.size() != symbols.size()) {\n-                return ImmutableList.of();\n-            }\n-\n-            ImmutableList.Builder<ConnectorExpression> args = new ImmutableList.Builder<>();\n-            for (int i = 0; i < arguments.size(); i++) {\n-                args.add(new Variable(symbols.get(i).getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n-            }\n-\n-            Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n-            Optional<List<Map.Entry<String, SortOrder>>> sortBy = orderingScheme.map(orderings ->\n-                    orderings.getOrderBy().stream()\n-                            .map(orderBy -> new AbstractMap.SimpleEntry<String, SortOrder>(\n-                                    orderBy.getName(),\n-                                    SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n-                            .collect(toImmutableList()));\n-\n-            aggregateFunctionBuilder.add(new AggregateFunction(\n-                    name,\n-                    returnType,\n-                    args.build(),\n-                    sortBy.orElse(ImmutableList.of()),\n-                    aggregation.isDistinct(),\n-                    aggregation.getFilter().map(Symbol::getName)));\n+        Signature signature = aggregation.getResolvedFunction().getSignature();\n+\n+        ImmutableList.Builder<ConnectorExpression> arguments = new ImmutableList.Builder<>();\n+        for (int i = 0; i < aggregation.getArguments().size(); i++) {\n+            SymbolReference argument = (SymbolReference) aggregation.getArguments().get(i);\n+            arguments.add(new Variable(argument.getName(), metadata.getType(signature.getArgumentTypes().get(i))));\n         }\n-        return aggregateFunctionBuilder.build();\n+\n+        Optional<OrderingScheme> orderingScheme = aggregation.getOrderingScheme();\n+        Optional<List<SortItem>> sortBy = orderingScheme.map(orderings ->\n+                orderings.getOrderBy().stream()\n+                        .map(orderBy -> new SortItem(\n+                                orderBy.getName(),\n+                                SortOrder.valueOf(orderings.getOrderings().get(orderBy).name())))\n+                        .collect(toImmutableList()));\n+\n+        Optional<ConnectorExpression> filter = aggregation.getFilter()\n+                .map(symbol -> new Variable(symbol.getName(), context.getSymbolAllocator().getTypes().get(symbol)));\n+\n+        return new AggregateFunction(\n+                signature.getName(),\n+                metadata.getType(signature.getReturnType()),\n+                arguments.build(),\n+                sortBy.orElse(ImmutableList.of()),\n+                aggregation.isDistinct(),\n+                filter);\n     }\n }\n", "next_change": null}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r429896486", "body": "`Optional<Variable>` ", "bodyText": "Optional<Variable>", "bodyHTML": "<p dir=\"auto\"><code>Optional&lt;Variable&gt;</code></p>", "author": "findepi", "createdAt": "2020-05-25T11:58:16Z", "path": "presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.spi.connector;\n+\n+import io.prestosql.spi.expression.ConnectorExpression;\n+import io.prestosql.spi.type.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.StringJoiner;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class AggregateFunction\n+{\n+    private final String functionName;\n+    private final Type outputType;\n+    private final List<ConnectorExpression> inputs;\n+    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final boolean isDistinct;\n+    private final Optional<String> filter;", "originalCommit": "5e5678d6e95e33b16ca634ac45a6350cfe43cdd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjEyNzY4Mg==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432127682", "bodyText": "Not sure about this, Why would this need to be a variable given the filter on the agg side is just a Symbol?", "author": "Parth-Brahmbhatt", "createdAt": "2020-05-28T21:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NTI5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r432385294", "bodyText": "Symbols (engine things) are mapped to Variables in ConnectorExpression.\nUsing Variable here would give semantics to this field -- connector would know it needs to check assignments to know which column handle this is.", "author": "findepi", "createdAt": "2020-05-29T10:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTYwMA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r434531600", "bodyText": "BTW why isn't filter a Optional<ConnectorExpression> (or ConnectorExpression without Optional,  using new Constant(true, BOOLEAN) instead of empty).\n@Parth-Brahmbhatt  @martint did you discuss this bit already?", "author": "findepi", "createdAt": "2020-06-03T12:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1NTM5NA==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436055394", "bodyText": "We haven't discussed this, originally I did not have mask or filter as I couldn't quite understand how those were used. I will figure out how to get the corresponding connector expression from the symbol and update the PR today.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T17:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDUxMw==", "url": "https://github.com/trinodb/trino/pull/3697#discussion_r436144513", "bodyText": "we haven't discussed this, I originally had no filters or masks as I did not completely understand what masks are for. @martint asked to add the filter in this PR in the first pass so the connectors have to explicitly decide to not handle them. For the current rule given it will only be matched when agg is followed by scan node the only possible place to look for filter symbol is tablescan assignment so I think it makes sense to just map it to Variable for now. I can't think of a scenario where we match this rule and it has a filter but the symbol is not in tablescan assignment so I have not added a check for that If you think we should add a defensive check I can add a condition.\nI personally prefer Optional so I have kept it as is, let me know if you would like me to remove Optional.", "author": "Parth-Brahmbhatt", "createdAt": "2020-06-05T20:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "0a598fdfffa13d60136ab89df3370bf637b362a1", "changed_code": [{"header": "diff --git a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\nindex badf41db1e..eca20e8c0c 100644\n--- a/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n+++ b/presto-spi/src/main/java/io/prestosql/spi/connector/AggregateFunction.java\n", "chunk": "@@ -31,24 +28,26 @@ public class AggregateFunction\n     private final String functionName;\n     private final Type outputType;\n     private final List<ConnectorExpression> inputs;\n-    private final List<Map.Entry<String, SortOrder>> sortOrder;\n+    private final List<SortItem> sortItems;\n     private final boolean isDistinct;\n-    private final Optional<String> filter;\n+    private final Optional<ConnectorExpression> filter;\n \n     public AggregateFunction(\n             String aggregateFunctionName,\n             Type outputType,\n             List<ConnectorExpression> inputs,\n-            List<Map.Entry<String, SortOrder>> sortOrder,\n+            List<SortItem> sortItems,\n             boolean isDistinct,\n-            Optional<String> filter)\n+            Optional<ConnectorExpression> filter)\n     {\n         this.functionName = requireNonNull(aggregateFunctionName, \"name is null\");\n         this.outputType = requireNonNull(outputType, \"outputType is null\");\n-        this.inputs = unmodifiableList(new ArrayList<>(requireNonNull(inputs, \"inputs is null\")));\n-        this.sortOrder = unmodifiableList(new ArrayList<>(requireNonNull(sortOrder, \"sortOrder is null\")));\n-        this.isDistinct = requireNonNull(isDistinct, \"isDistinct is null\");\n-        this.filter = filter;\n+        requireNonNull(inputs, \"inputs is null\");\n+        requireNonNull(sortItems, \"sortOrder is null\");\n+        this.inputs = List.copyOf(inputs);\n+        this.sortItems = List.copyOf(sortItems);\n+        this.isDistinct = isDistinct;\n+        this.filter = requireNonNull(filter, \"filter is null\");\n     }\n \n     public String getFunctionName()\n", "next_change": null}]}}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "commit"}, {"oid": "0a598fdfffa13d60136ab89df3370bf637b362a1", "url": "https://github.com/trinodb/trino/commit/0a598fdfffa13d60136ab89df3370bf637b362a1", "message": "Add support for aggregation pushdow", "committedDate": "2020-06-11T18:05:43Z", "type": "forcePushed"}]}