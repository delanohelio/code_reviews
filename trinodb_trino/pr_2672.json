{"pr_number": 2672, "pr_title": "Dereference Projection Pushdown in Query Plan", "pr_author": "phd3", "pr_createdAt": "2020-01-29T21:34:43Z", "pr_url": "https://github.com/trinodb/trino/pull/2672", "timeline": [{"oid": "5259429e761205470cdb0ff1d0747b15fe10378b", "url": "https://github.com/trinodb/trino/commit/5259429e761205470cdb0ff1d0747b15fe10378b", "message": "(drop this commit) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-04-22T04:49:27Z", "type": "forcePushed"}, {"oid": "86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "url": "https://github.com/trinodb/trino/commit/86e5d867cf745a1e010a1dcb1b2d4971470e62a5", "message": "(drop this commit before merging) Verify behavior of TestDereferencePushdown tests in hive", "committedDate": "2020-05-06T17:59:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMzI4Nw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423223287", "body": "Referring to this as \"dereference chain\" is more idiomatic.", "bodyText": "Referring to this as \"dereference chain\" is more idiomatic.", "bodyHTML": "<p dir=\"auto\">Referring to this as \"dereference chain\" is more idiomatic.</p>", "author": "martint", "createdAt": "2020-05-11T18:06:32Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyNjczMA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423226730", "body": "```suggestion\r\n                .filter(DereferenceExpression.class::isInstance)\r\n                .map(DereferenceExpression.class::cast)\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .filter(expression -> (expression instanceof DereferenceExpression))\n          \n          \n            \n                            .map(expression -> (DereferenceExpression) expression)\n          \n          \n            \n                            .filter(DereferenceExpression.class::isInstance)\n          \n          \n            \n                            .map(DereferenceExpression.class::cast)", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .filter(<span class=\"x x-first\">expression </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x\"> (expression </span><span class=\"pl-k x\">instanceof</span><span class=\"x x-last\"> </span><span class=\"pl-smi\">DereferenceExpression</span><span class=\"x x-first x-last\">)</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                .map(<span class=\"x x-first\">expression </span><span class=\"pl-k x\">-</span><span class=\"pl-k x\">&gt;</span><span class=\"x x-last\"> (</span><span class=\"pl-smi\">DereferenceExpression</span><span class=\"x x-first x-last\">) expression</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .filter(<span class=\"pl-smi\">DereferenceExpression</span><span class=\"pl-k x x-first\">.</span><span class=\"x\">class</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">isInstance</span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                .map(<span class=\"pl-smi\">DereferenceExpression</span><span class=\"pl-k x x-first\">.</span><span class=\"x\">class</span><span class=\"pl-k x\">::</span><span class=\"x x-last\">cast</span>)</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "martint", "createdAt": "2020-05-11T18:12:42Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTIxNw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235217", "body": "Pass the session and symbol allocator directly instead of `Rule.Context`. Creating a symbol does not inherently need a rule context.", "bodyText": "Pass the session and symbol allocator directly instead of Rule.Context. Creating a symbol does not inherently need a rule context.", "bodyHTML": "<p dir=\"auto\">Pass the session and symbol allocator directly instead of <code>Rule.Context</code>. Creating a symbol does not inherently need a rule context.</p>", "author": "martint", "createdAt": "2020-05-11T18:28:04Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)\n+    {\n+        Set<Expression> symbolReferencesAndDereferences = expressions.stream()\n+                .flatMap(expression -> getSymbolReferencesAndDereferences(expression).stream())\n+                .collect(Collectors.toSet());\n+\n+        // Remove overlap if required\n+        Set<Expression> candidateExpressions = symbolReferencesAndDereferences;\n+        if (noOverlap) {\n+            candidateExpressions = symbolReferencesAndDereferences.stream()\n+                    .filter(expression -> !prefixExists(expression, symbolReferencesAndDereferences))\n+                    .collect(Collectors.toSet());\n+        }\n+\n+        Set<DereferenceExpression> dereferencesToPushdown = candidateExpressions.stream()\n+                .filter(expression -> (expression instanceof DereferenceExpression))\n+                .map(expression -> (DereferenceExpression) expression)\n+                .collect(Collectors.toSet());\n+\n+        return dereferencesToPushdown.stream()\n+                .collect(toImmutableMap(Function.identity(), expression -> newSymbol(expression, context, typeAnalyzer)));\n+    }\n+\n+    public static Symbol getBase(DereferenceExpression expression)\n+    {\n+        return getOnlyElement(extractAll(expression));\n+    }\n+\n+    /**\n+     * Extract the sub-expressions of type {@link DereferenceExpression} or {@link SymbolReference} from the {@param expression}\n+     * in a top-down manner. The expressions within the base of a valid {@link DereferenceExpression} sequence are not extracted.\n+     */\n+    private static List<Expression> getSymbolReferencesAndDereferences(Expression expression)\n+    {\n+        ImmutableList.Builder<Expression> builder = ImmutableList.builder();\n+\n+        new DefaultExpressionTraversalVisitor<ImmutableList.Builder<Expression>>()\n+        {\n+            @Override\n+            protected Void visitDereferenceExpression(DereferenceExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                if (isDereferenceSequence(node)) {\n+                    context.add(node);\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitSymbolReference(SymbolReference node, ImmutableList.Builder<Expression> context)\n+            {\n+                context.add(node);\n+                return null;\n+            }\n+\n+            @Override\n+            protected Void visitLambdaExpression(LambdaExpression node, ImmutableList.Builder<Expression> context)\n+            {\n+                return null;\n+            }\n+        }.process(expression, builder);\n+\n+        return builder.build();\n+    }\n+\n+    private static boolean isDereferenceSequence(DereferenceExpression expression)\n+    {\n+        return (expression.getBase() instanceof SymbolReference) ||\n+            ((expression.getBase() instanceof DereferenceExpression) && isDereferenceSequence((DereferenceExpression) (expression.getBase())));\n+    }\n+\n+    private static Symbol newSymbol(Expression expression, Rule.Context context, TypeAnalyzer typeAnalyzer)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIzNTcwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423235704", "body": "It'd be cleaner to split this method into two -- currently it's doing too much:\r\n* `extractDereferences(Collection<Expression> expressions, boolean noOverlap)`\r\n* `createAssignments(Collection<Expression>,  session, symbolAllocator, typeAnalyzer)`\r\n\r\nDepending on how the result of the latter is being used, it could even go into the `Assignments` class and return an Assignments object or builder directly:\r\n\r\n```java\r\npublic static Assignments of(Collection<? extends Expression> expressions, Session session, SymbolAllocator symbolAllocator, TypeAnalyzer typeAnalyzer)\r\n{\r\n    Assignments.Builder assignments = Assignments.builder();\r\n\r\n    for (Expression expression : expressions) {\r\n        Type type = typeAnalyzer.getType(session, symbolAllocator.getTypes(), expression);\r\n        assignments.put(symbolAllocator.newSymbol(expression, type), expression);\r\n    }                                                                                    \r\n\r\n    return assignments.build();\r\n}\r\n```\r\n", "bodyText": "It'd be cleaner to split this method into two -- currently it's doing too much:\n\nextractDereferences(Collection<Expression> expressions, boolean noOverlap)\ncreateAssignments(Collection<Expression>,  session, symbolAllocator, typeAnalyzer)\n\nDepending on how the result of the latter is being used, it could even go into the Assignments class and return an Assignments object or builder directly:\npublic static Assignments of(Collection<? extends Expression> expressions, Session session, SymbolAllocator symbolAllocator, TypeAnalyzer typeAnalyzer)\n{\n    Assignments.Builder assignments = Assignments.builder();\n\n    for (Expression expression : expressions) {\n        Type type = typeAnalyzer.getType(session, symbolAllocator.getTypes(), expression);\n        assignments.put(symbolAllocator.newSymbol(expression, type), expression);\n    }                                                                                    \n\n    return assignments.build();\n}", "bodyHTML": "<p dir=\"auto\">It'd be cleaner to split this method into two -- currently it's doing too much:</p>\n<ul dir=\"auto\">\n<li><code>extractDereferences(Collection&lt;Expression&gt; expressions, boolean noOverlap)</code></li>\n<li><code>createAssignments(Collection&lt;Expression&gt;,  session, symbolAllocator, typeAnalyzer)</code></li>\n</ul>\n<p dir=\"auto\">Depending on how the result of the latter is being used, it could even go into the <code>Assignments</code> class and return an Assignments object or builder directly:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public static Assignments of(Collection&lt;? extends Expression&gt; expressions, Session session, SymbolAllocator symbolAllocator, TypeAnalyzer typeAnalyzer)\n{\n    Assignments.Builder assignments = Assignments.builder();\n\n    for (Expression expression : expressions) {\n        Type type = typeAnalyzer.getType(session, symbolAllocator.getTypes(), expression);\n        assignments.put(symbolAllocator.newSymbol(expression, type), expression);\n    }                                                                                    \n\n    return assignments.build();\n}\"><pre><span class=\"pl-k\">public</span> <span class=\"pl-k\">static</span> <span class=\"pl-smi\">Assignments</span> of(<span class=\"pl-k\">Collection&lt;? extends <span class=\"pl-smi\">Expression</span>&gt;</span> expressions, <span class=\"pl-smi\">Session</span> session, <span class=\"pl-smi\">SymbolAllocator</span> symbolAllocator, <span class=\"pl-smi\">TypeAnalyzer</span> typeAnalyzer)\n{\n    <span class=\"pl-smi\">Assignments</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">Builder</span> assignments <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Assignments</span><span class=\"pl-k\">.</span>builder();\n\n    <span class=\"pl-k\">for</span> (<span class=\"pl-smi\">Expression</span> expression <span class=\"pl-k\">:</span> expressions) {\n        <span class=\"pl-smi\">Type</span> type <span class=\"pl-k\">=</span> typeAnalyzer<span class=\"pl-k\">.</span>getType(session, symbolAllocator<span class=\"pl-k\">.</span>getTypes(), expression);\n        assignments<span class=\"pl-k\">.</span>put(symbolAllocator<span class=\"pl-k\">.</span>newSymbol(expression, type), expression);\n    }                                                                                    \n\n    <span class=\"pl-k\">return</span> assignments<span class=\"pl-k\">.</span>build();\n}</pre></div>", "author": "martint", "createdAt": "2020-05-11T18:28:52Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI0MTEwNA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423241104", "body": "Switch to `allowOverlap`. Trying to read double-negatives is more confusing: `validaDereferences(...., noOverlap = false)` vs `validDereferences(..., allowOverlap = true)`", "bodyText": "Switch to allowOverlap. Trying to read double-negatives is more confusing: validaDereferences(...., noOverlap = false) vs validDereferences(..., allowOverlap = true)", "bodyHTML": "<p dir=\"auto\">Switch to <code>allowOverlap</code>. Trying to read double-negatives is more confusing: <code>validaDereferences(...., noOverlap = false)</code> vs <code>validDereferences(..., allowOverlap = true)</code></p>", "author": "martint", "createdAt": "2020-05-11T18:39:09Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/DereferencePushdown.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.spi.type.Type;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.tree.DefaultExpressionTraversalVisitor;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.LambdaExpression;\n+import io.prestosql.sql.tree.SymbolReference;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.google.common.base.Verify.verify;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static io.prestosql.sql.planner.SymbolsExtractor.extractAll;\n+\n+/**\n+ * Provides helper methods to push down dereferences in the query plan.\n+ */\n+class DereferencePushdown\n+{\n+    private DereferencePushdown() {}\n+\n+    /**\n+     * Create new symbols for dereference expressions extracted from {@param expressions}\n+     */\n+    public static Map<DereferenceExpression, Symbol> validDereferences(\n+            Collection<Expression> expressions,\n+            Rule.Context context,\n+            TypeAnalyzer typeAnalyzer,\n+            boolean noOverlap)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MTg1NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423251854", "body": "With the suggestions in DereferencePushdown, this could become:\r\n\r\n```java\r\nSet<DereferenceExpression> dereferences = extractDereferences(ImmutableList.of(node.getPredicate()), false);\r\nif (dereferences.isEmpty()) {\r\n    return Result.empty();\r\n}\r\n\r\nAssignments assignments = Assignments.of(dereferences, context.getSession(), context.getSymbolAllocator(), typeAnalyzer);\r\nMap<Expression, SymbolReference> mappings = HashBiMap.create(assignments.getMap())\r\n        .inverse()\r\n        .entrySet().stream()\r\n        .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue().toSymbolReference()));\r\n\r\nPlanNode source = node.getSource();\r\nreturn Result.ofPlanNode(new ProjectNode(\r\n        context.getIdAllocator().getNextId(),\r\n        new FilterNode(\r\n                context.getIdAllocator().getNextId(),\r\n                new ProjectNode(\r\n                        context.getIdAllocator().getNextId(),\r\n                        source,\r\n                        Assignments.builder()\r\n                                .putIdentities(source.getOutputSymbols())\r\n                                .putAll(assignments)\r\n                                .build()),\r\n                replaceExpression(node.getPredicate(), mappings)),\r\n        Assignments.identity(node.getOutputSymbols())));\r\n```", "bodyText": "With the suggestions in DereferencePushdown, this could become:\nSet<DereferenceExpression> dereferences = extractDereferences(ImmutableList.of(node.getPredicate()), false);\nif (dereferences.isEmpty()) {\n    return Result.empty();\n}\n\nAssignments assignments = Assignments.of(dereferences, context.getSession(), context.getSymbolAllocator(), typeAnalyzer);\nMap<Expression, SymbolReference> mappings = HashBiMap.create(assignments.getMap())\n        .inverse()\n        .entrySet().stream()\n        .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue().toSymbolReference()));\n\nPlanNode source = node.getSource();\nreturn Result.ofPlanNode(new ProjectNode(\n        context.getIdAllocator().getNextId(),\n        new FilterNode(\n                context.getIdAllocator().getNextId(),\n                new ProjectNode(\n                        context.getIdAllocator().getNextId(),\n                        source,\n                        Assignments.builder()\n                                .putIdentities(source.getOutputSymbols())\n                                .putAll(assignments)\n                                .build()),\n                replaceExpression(node.getPredicate(), mappings)),\n        Assignments.identity(node.getOutputSymbols())));", "bodyHTML": "<p dir=\"auto\">With the suggestions in DereferencePushdown, this could become:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Set&lt;DereferenceExpression&gt; dereferences = extractDereferences(ImmutableList.of(node.getPredicate()), false);\nif (dereferences.isEmpty()) {\n    return Result.empty();\n}\n\nAssignments assignments = Assignments.of(dereferences, context.getSession(), context.getSymbolAllocator(), typeAnalyzer);\nMap&lt;Expression, SymbolReference&gt; mappings = HashBiMap.create(assignments.getMap())\n        .inverse()\n        .entrySet().stream()\n        .collect(toImmutableMap(Map.Entry::getKey, entry -&gt; entry.getValue().toSymbolReference()));\n\nPlanNode source = node.getSource();\nreturn Result.ofPlanNode(new ProjectNode(\n        context.getIdAllocator().getNextId(),\n        new FilterNode(\n                context.getIdAllocator().getNextId(),\n                new ProjectNode(\n                        context.getIdAllocator().getNextId(),\n                        source,\n                        Assignments.builder()\n                                .putIdentities(source.getOutputSymbols())\n                                .putAll(assignments)\n                                .build()),\n                replaceExpression(node.getPredicate(), mappings)),\n        Assignments.identity(node.getOutputSymbols())));\n\"><pre><span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">DereferenceExpression</span>&gt;</span> dereferences <span class=\"pl-k\">=</span> extractDereferences(<span class=\"pl-smi\">ImmutableList</span><span class=\"pl-k\">.</span>of(node<span class=\"pl-k\">.</span>getPredicate()), <span class=\"pl-c1\">false</span>);\n<span class=\"pl-k\">if</span> (dereferences<span class=\"pl-k\">.</span>isEmpty()) {\n    <span class=\"pl-k\">return</span> <span class=\"pl-smi\">Result</span><span class=\"pl-k\">.</span>empty();\n}\n\n<span class=\"pl-smi\">Assignments</span> assignments <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Assignments</span><span class=\"pl-k\">.</span>of(dereferences, context<span class=\"pl-k\">.</span>getSession(), context<span class=\"pl-k\">.</span>getSymbolAllocator(), typeAnalyzer);\n<span class=\"pl-k\">Map&lt;<span class=\"pl-smi\">Expression</span>, <span class=\"pl-smi\">SymbolReference</span>&gt;</span> mappings <span class=\"pl-k\">=</span> <span class=\"pl-smi\">HashBiMap</span><span class=\"pl-k\">.</span>create(assignments<span class=\"pl-k\">.</span>getMap())\n        .inverse()\n        .entrySet()<span class=\"pl-k\">.</span>stream()\n        .collect(toImmutableMap(<span class=\"pl-smi\">Map</span><span class=\"pl-k\">.</span><span class=\"pl-smi\">Entry</span><span class=\"pl-k\">::</span>getKey, entry <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> entry<span class=\"pl-k\">.</span>getValue()<span class=\"pl-k\">.</span>toSymbolReference()));\n\n<span class=\"pl-smi\">PlanNode</span> source <span class=\"pl-k\">=</span> node<span class=\"pl-k\">.</span>getSource();\n<span class=\"pl-k\">return</span> <span class=\"pl-smi\">Result</span><span class=\"pl-k\">.</span>ofPlanNode(<span class=\"pl-k\">new</span> <span class=\"pl-smi\">ProjectNode</span>(\n        context<span class=\"pl-k\">.</span>getIdAllocator()<span class=\"pl-k\">.</span>getNextId(),\n        <span class=\"pl-k\">new</span> <span class=\"pl-smi\">FilterNode</span>(\n                context<span class=\"pl-k\">.</span>getIdAllocator()<span class=\"pl-k\">.</span>getNextId(),\n                <span class=\"pl-k\">new</span> <span class=\"pl-smi\">ProjectNode</span>(\n                        context<span class=\"pl-k\">.</span>getIdAllocator()<span class=\"pl-k\">.</span>getNextId(),\n                        source,\n                        <span class=\"pl-smi\">Assignments</span><span class=\"pl-k\">.</span>builder()\n                                .putIdentities(source<span class=\"pl-k\">.</span>getOutputSymbols())\n                                .putAll(assignments)\n                                .build()),\n                replaceExpression(node<span class=\"pl-k\">.</span>getPredicate(), mappings)),\n        <span class=\"pl-smi\">Assignments</span><span class=\"pl-k\">.</span>identity(node<span class=\"pl-k\">.</span>getOutputSymbols())));</pre></div>", "author": "martint", "createdAt": "2020-05-11T18:57:53Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/ExtractDereferencesFromFilterAboveScan.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.planner.plan.TableScanNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.ExpressionNodeInliner.replaceExpression;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static io.prestosql.sql.planner.plan.Patterns.tableScan;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * This optimizer extracts all dereference expressions from a filter node located above a table scan into a ProjectNode.\n+ *\n+ * Extracting dereferences from a filter (eg. FilterNode(a.x = 5)) can be suboptimal if full columns are being accessed up the\n+ * plan tree (eg. a), because it can result in replicated shuffling of fields (eg. a.x). So it is safer to pushdown dereferences from\n+ * Filter only when there's an explicit projection on top of the filter node (Ref PushDereferencesThroughFilter).\n+ *\n+ * In case of a FilterNode on top of TableScanNode, we want to push all dereferences into a new ProjectNode below, so that\n+ * PushProjectionIntoTableScan optimizer can push those columns in the connector, and provide new column handles for the\n+ * projected subcolumns. PushPredicateIntoTableScan optimizer can then push predicates on these subcolumns into the connector.\n+ */\n+public class ExtractDereferencesFromFilterAboveScan\n+        implements Rule<FilterNode>\n+{\n+    private static final Capture<TableScanNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public ExtractDereferencesFromFilterAboveScan(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<FilterNode> getPattern()\n+    {\n+        return filter()\n+                .with(source().matching(tableScan().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(FilterNode node, Captures captures, Context context)\n+    {\n+        BiMap<DereferenceExpression, Symbol> expressions =\n+                HashBiMap.create(validDereferences(ImmutableList.of(node.getPredicate()), context, typeAnalyzer, false));\n+\n+        if (expressions.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = node.getSource();\n+        Assignments assignments = Assignments.builder()\n+                .putIdentities(source.getOutputSymbols())\n+                .putAll(expressions.inverse())\n+                .build();\n+\n+        return Result.ofPlanNode(new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                new FilterNode(\n+                        context.getIdAllocator().getNextId(),\n+                        new ProjectNode(context.getIdAllocator().getNextId(), source, assignments),\n+                        replaceExpression(\n+                                node.getPredicate(),\n+                                expressions.entrySet().stream()\n+                                        .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())))),\n+                Assignments.identity(node.getOutputSymbols())));\n+    }", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MDAyMw==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423260023", "body": "Why not just `ExpressionNodeInliner.replaceExpression(filterNode.getPredicate(), <mappings>)`?", "bodyText": "Why not just ExpressionNodeInliner.replaceExpression(filterNode.getPredicate(), <mappings>)?", "bodyHTML": "<p dir=\"auto\">Why not just <code>ExpressionNodeInliner.replaceExpression(filterNode.getPredicate(), &lt;mappings&gt;)</code>?</p>", "author": "martint", "createdAt": "2020-05-11T19:12:54Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughFilter.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.FilterNode;\n+import io.prestosql.sql.planner.plan.PlanNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+import io.prestosql.sql.tree.Expression;\n+import io.prestosql.sql.tree.ExpressionTreeRewriter;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.filter;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(a_x := a.x, b := b)\n+ *      Filter(a.x.y = 5 AND b.m = 3)\n+ *          Source(a, b)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(a_x := expr, b := b)\n+ *      Filter(expr.y = 5 AND b.m = 3)\n+ *          Project(a := a, b := b, expr := a.x)\n+ *              Source(a, b)\n+ * </pre>\n+ *\n+ * Pushes down dereference projections in project node assignments and filter node predicate.\n+ */\n+public class PushDownDereferenceThroughFilter\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<FilterNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughFilter(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(filter().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Rule.Context context)\n+    {\n+        FilterNode filterNode = captures.get(CHILD);\n+\n+        // Pushdown superset of dereference expressions from projections and filtering predicate\n+        List<Expression> expressions = ImmutableList.<Expression>builder()\n+                .addAll(node.getAssignments().getExpressions())\n+                .add(filterNode.getPredicate())\n+                .build();\n+\n+        Map<DereferenceExpression, Symbol> pushdownDereferences = validDereferences(expressions, context, typeAnalyzer, true);\n+\n+        if (pushdownDereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        PlanNode source = filterNode.getSource();\n+\n+        ProjectNode projectNode = new ProjectNode(\n+                context.getIdAllocator().getNextId(),\n+                source,\n+                Assignments.builder()\n+                    .putIdentities(source.getOutputSymbols())\n+                    .putAll(HashBiMap.create(pushdownDereferences).inverse())\n+                    .build());\n+\n+        ExpressionNodeInliner dereferenceReplacer = new ExpressionNodeInliner(pushdownDereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference())));\n+\n+        PlanNode newFilterNode = new FilterNode(\n+                context.getIdAllocator().getNextId(),\n+                projectNode,\n+                ExpressionTreeRewriter.rewriteWith(dereferenceReplacer, filterNode.getPredicate()));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MjU4NA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423262584", "body": "You can use the `Function<Expression, Expression>` variant of `Assignments.rewrite()`:\r\n\r\n```java\r\nAssignments assignments = node.getAssignments().rewrite(expression -> replaceExpression(expression, mappings))\r\n```", "bodyText": "You can use the Function<Expression, Expression> variant of Assignments.rewrite():\nAssignments assignments = node.getAssignments().rewrite(expression -> replaceExpression(expression, mappings))", "bodyHTML": "<p dir=\"auto\">You can use the <code>Function&lt;Expression, Expression&gt;</code> variant of <code>Assignments.rewrite()</code>:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Assignments assignments = node.getAssignments().rewrite(expression -&gt; replaceExpression(expression, mappings))\"><pre><span class=\"pl-smi\">Assignments</span> assignments <span class=\"pl-k\">=</span> node<span class=\"pl-k\">.</span>getAssignments()<span class=\"pl-k\">.</span>rewrite(expression <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> replaceExpression(expression, mappings))</pre></div>", "author": "martint", "createdAt": "2020-05-11T19:17:37Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferenceThroughProject.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.getBase;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)\n+ *    Project(msg := msg)\n+ *      Source(msg)\n+ *  </pre>\n+ * to:\n+ * <pre>\n+ *  Project(msg_x := symbol)\n+ *    Project(msg := msg, symbol := msg.x)\n+ *      Source(msg)\n+ * </pre>\n+ */\n+public class PushDownDereferenceThroughProject\n+        implements Rule<ProjectNode>\n+{\n+    private static final Capture<ProjectNode> CHILD = newCapture();\n+    private final TypeAnalyzer typeAnalyzer;\n+\n+    public PushDownDereferenceThroughProject(TypeAnalyzer typeAnalyzer)\n+    {\n+        this.typeAnalyzer = requireNonNull(typeAnalyzer, \"typeAnalyzer is null\");\n+    }\n+\n+    @Override\n+    public Pattern<ProjectNode> getPattern()\n+    {\n+        return project()\n+                .with(source().matching(project().capturedAs(CHILD)));\n+    }\n+\n+    @Override\n+    public Result apply(ProjectNode node, Captures captures, Context context)\n+    {\n+        ProjectNode child = captures.get(CHILD);\n+\n+        // Extract dereferences from assignments for pushdown\n+        Map<DereferenceExpression, Symbol> dereferences = validDereferences(node.getAssignments().getExpressions(), context, typeAnalyzer, true).entrySet().stream()\n+                .filter(entry -> child.getSource().getOutputSymbols().contains(getBase(entry.getKey()))) // exclude dereferences on symbols being synthesized within child\n+                .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        if (dereferences.isEmpty()) {\n+            return Result.empty();\n+        }\n+\n+        // Prepare new assignments replacing dereferences with new symbols\n+        Assignments assignments = node.getAssignments().rewrite(new ExpressionNodeInliner(dereferences.entrySet().stream()\n+                .collect(toImmutableMap(Map.Entry::getKey, mapping -> mapping.getValue().toSymbolReference()))));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NjQ4OA==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423386488", "body": "It'd be worth adding more projections to the example, otherwise it's not immediately obvious why the rule doesn't just push the whole projection below the limit:\r\n\r\n```\r\nProject(msg_x := msg.x, y = f(...))\r\n   Limit\r\n\r\n->\r\n\r\nProject(msg_x := symbol, y = f(...))\r\n   Limit\r\n      Project(msg := msg, symbol := msg.x)\r\n```\r\n\r\nThe same comment applies to all other examples.", "bodyText": "It'd be worth adding more projections to the example, otherwise it's not immediately obvious why the rule doesn't just push the whole projection below the limit:\nProject(msg_x := msg.x, y = f(...))\n   Limit\n\n->\n\nProject(msg_x := symbol, y = f(...))\n   Limit\n      Project(msg := msg, symbol := msg.x)\n\nThe same comment applies to all other examples.", "bodyHTML": "<p dir=\"auto\">It'd be worth adding more projections to the example, otherwise it's not immediately obvious why the rule doesn't just push the whole projection below the limit:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Project(msg_x := msg.x, y = f(...))\n   Limit\n\n-&gt;\n\nProject(msg_x := symbol, y = f(...))\n   Limit\n      Project(msg := msg, symbol := msg.x)\n\"><pre><code>Project(msg_x := msg.x, y = f(...))\n   Limit\n\n-&gt;\n\nProject(msg_x := symbol, y = f(...))\n   Limit\n      Project(msg := msg, symbol := msg.x)\n</code></pre></div>\n<p dir=\"auto\">The same comment applies to all other examples.</p>", "author": "martint", "createdAt": "2020-05-12T00:00:01Z", "path": "presto-main/src/main/java/io/prestosql/sql/planner/iterative/rule/dereference/PushDownDereferencesThroughLimit.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.prestosql.sql.planner.iterative.rule.dereference;\n+\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import io.prestosql.matching.Capture;\n+import io.prestosql.matching.Captures;\n+import io.prestosql.matching.Pattern;\n+import io.prestosql.sql.planner.ExpressionNodeInliner;\n+import io.prestosql.sql.planner.Symbol;\n+import io.prestosql.sql.planner.TypeAnalyzer;\n+import io.prestosql.sql.planner.iterative.Rule;\n+import io.prestosql.sql.planner.plan.Assignments;\n+import io.prestosql.sql.planner.plan.LimitNode;\n+import io.prestosql.sql.planner.plan.ProjectNode;\n+import io.prestosql.sql.tree.DereferenceExpression;\n+\n+import java.util.Map;\n+\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static io.prestosql.matching.Capture.newCapture;\n+import static io.prestosql.sql.planner.iterative.rule.dereference.DereferencePushdown.validDereferences;\n+import static io.prestosql.sql.planner.plan.Patterns.limit;\n+import static io.prestosql.sql.planner.plan.Patterns.project;\n+import static io.prestosql.sql.planner.plan.Patterns.source;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Transforms:\n+ * <pre>\n+ *  Project(msg_x := msg.x)", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NzQ1Mg==", "url": "https://github.com/trinodb/trino/pull/2672#discussion_r423467452", "body": "Why are these commented out? Remove them if no longer relevant", "bodyText": "Why are these commented out? Remove them if no longer relevant", "bodyHTML": "<p dir=\"auto\">Why are these commented out? Remove them if no longer relevant</p>", "author": "martint", "createdAt": "2020-05-12T05:18:05Z", "path": "presto-main/src/test/java/io/prestosql/sql/planner/iterative/rule/TestPushProjectionThroughUnion.java", "diffHunk": "@@ -73,29 +80,37 @@ public void test()\n                     Symbol a = p.symbol(\"a\");\n                     Symbol b = p.symbol(\"b\");\n                     Symbol c = p.symbol(\"c\");\n+                    Symbol d = p.symbol(\"d\", MSG_TYPE);\n                     Symbol cTimes3 = p.symbol(\"c_times_3\");\n+                    Symbol dX = p.symbol(\"d_x\");\n+                    Symbol z = p.symbol(\"z\", MSG_TYPE);\n+                    Symbol w = p.symbol(\"w\", MSG_TYPE);\n                     return p.project(\n-                            Assignments.of(cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\"))),\n+                            Assignments.of(\n+                                    cTimes3, new ArithmeticBinaryExpression(ArithmeticBinaryExpression.Operator.MULTIPLY, c.toSymbolReference(), new LongLiteral(\"3\")),\n+                                    dX, PlanBuilder.expression(\"d.x\")),\n                             p.union(\n                                     ImmutableListMultimap.<Symbol, Symbol>builder()\n                                             .put(c, a)\n                                             .put(c, b)\n+                                            .put(d, z)\n+                                            .put(d, w)\n                                             .build(),\n                                     ImmutableList.of(\n-                                            p.values(a),\n-                                            p.values(b))));\n+                                            p.values(a, z),\n+                                            p.values(b, w))));\n                 })\n                 .matches(\n                         union(\n                                 project(\n-                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\")),\n-                                        values(ImmutableList.of(\"a\"))),\n+                                        ImmutableMap.of(\"a_times_3\", expression(\"a * 3\"), \"z_x\", expression(\"z.x\")),\n+                                        values(ImmutableList.of(\"a\", \"z\"))),\n                                 project(\n-                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\")),\n-                                        values(ImmutableList.of(\"b\"))))\n-                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n-                                .withNumberOfOutputColumns(1)\n-                                .withAlias(\"a_times_3\")\n-                                .withAlias(\"b_times_3\"));\n+                                        ImmutableMap.of(\"b_times_3\", expression(\"b * 3\"), \"w_x\", expression(\"w.x\")),\n+                                        values(ImmutableList.of(\"b\", \"w\")))));\n+//                                // verify that data originally on symbols aliased as x1 and x2 is part of exchange output\n+//                                .withNumberOfOutputColumns(1)\n+//                                .withAlias(\"a_times_3\")\n+//                                .withAlias(\"b_times_3\"));", "originalCommit": "989fdad61fd8b088717e8826e570c94294fe4c66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "url": "https://github.com/trinodb/trino/commit/6e1e576d234eb7e6d8a876c8ea3576f1766bf02b", "message": "Remove unused method", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8b1ef81409b543076e283aadcab6b30754dc127e", "url": "https://github.com/trinodb/trino/commit/8b1ef81409b543076e283aadcab6b30754dc127e", "message": "Fix error message in WindowNode.Function constructor", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "8389ea85979249e9ac2ec20de2a44ee565fb81fe", "url": "https://github.com/trinodb/trino/commit/8389ea85979249e9ac2ec20de2a44ee565fb81fe", "message": "Support multiple unnest outputs in unnest matcher", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "url": "https://github.com/trinodb/trino/commit/0163c39cafa7ad4b6a4e271f19c2d2398707cd5c", "message": "Pushdown dereference expressions in the query plan\n\nCo-authored-by: qqibrow <qqibrow@gmail.com>\nCo-authored-by: Zhenxiao Luo <luoz@uber.com>", "committedDate": "2020-05-21T02:06:41Z", "type": "commit"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "commit"}, {"oid": "f95f644432676d0b00eaa20a73f4aa980cd87e29", "url": "https://github.com/trinodb/trino/commit/f95f644432676d0b00eaa20a73f4aa980cd87e29", "message": "Plan assertions for end to end dereference pushdown in hive", "committedDate": "2020-05-21T16:40:53Z", "type": "forcePushed"}]}