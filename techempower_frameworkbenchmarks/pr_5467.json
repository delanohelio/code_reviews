{"pr_number": 5467, "pr_title": "[add] Implementation of JSON/plaintext for Servicetalk", "pr_author": "arthur-techempower", "pr_createdAt": "2020-02-04T20:52:48Z", "pr_url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467", "timeline": [{"oid": "6e96c308f8a967e9b388df0a61210598000f1a6f", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/6e96c308f8a967e9b388df0a61210598000f1a6f", "message": "[add] Implementation of JSON/plaintext for Servicetalk", "committedDate": "2020-02-04T20:45:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MDIyMw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374960223", "body": "For comments within Java methods, use `// comments like this` or `/* comments like this */`, not `/** javadoc like this */`.  The double asterisk is for javadoc, which can be applied at the class level or member (field or method) level, but not within a method.", "bodyText": "For comments within Java methods, use // comments like this or /* comments like this */, not /** javadoc like this */.  The double asterisk is for javadoc, which can be applied at the class level or member (field or method) level, but not within a method.", "bodyHTML": "<p dir=\"auto\">For comments within Java methods, use <code>// comments like this</code> or <code>/* comments like this */</code>, not <code>/** javadoc like this */</code>.  The double asterisk is for javadoc, which can be applied at the class level or member (field or method) level, but not within a method.</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:30:37Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4e0ebe390c3d64389ac6234898b7c6c8e7d29d41", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..c76e0802e 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,20 +26,20 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n", "next_change": {"commit": "61dc1f06dc978334168b83945d1f293461f77768", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex c76e0802e..f3bd997e2 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -45,45 +45,42 @@ public final class Server {\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n     public static String GetCurrentTime() {\n", "next_change": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex f3bd997e2..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -83,15 +84,14 @@ public final class Server {\n             .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MTAwMA==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374961000", "body": "You might as well not have the `try` and `catch` then.  Your main method declared `throws Exception`, so no good comes out of catching this.  The only thing it can do is hide errors from us.", "bodyText": "You might as well not have the try and catch then.  Your main method declared throws Exception, so no good comes out of catching this.  The only thing it can do is hide errors from us.", "bodyHTML": "<p dir=\"auto\">You might as well not have the <code>try</code> and <code>catch</code> then.  Your main method declared <code>throws Exception</code>, so no good comes out of catching this.  The only thing it can do is hide errors from us.</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:32:18Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61dc1f06dc978334168b83945d1f293461f77768", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..f3bd997e2 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,64 +26,61 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n     public static String GetCurrentTime() {\n", "next_change": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex f3bd997e2..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -83,15 +84,14 @@ public final class Server {\n             .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2Mjg4MA==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374962880", "body": "This can return 10001, which is an invalid world id.  Also, you should use `ThreadLocalRandom`, which shares one `Random` instance with each thread instead of constructing a new `Random` instance for every number.  Do something like this instead:  https://github.com/TechEmpower/FrameworkBenchmarks/blob/f510e947b5480b83cdda66f397d31be7166a40d6/frameworks/Java/undertow/src/main/java/hello/HelloWebServer.java#L255", "bodyText": "This can return 10001, which is an invalid world id.  Also, you should use ThreadLocalRandom, which shares one Random instance with each thread instead of constructing a new Random instance for every number.  Do something like this instead:  \n  \n    \n      FrameworkBenchmarks/frameworks/Java/undertow/src/main/java/hello/HelloWebServer.java\n    \n    \n         Line 255\n      in\n      f510e94\n    \n    \n    \n    \n\n        \n          \n           return 1 + ThreadLocalRandom.current().nextInt(10000);", "bodyHTML": "<p dir=\"auto\">This can return 10001, which is an invalid world id.  Also, you should use <code>ThreadLocalRandom</code>, which shares one <code>Random</code> instance with each thread instead of constructing a new <code>Random</code> instance for every number.  Do something like this instead:  <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/TechEmpower/FrameworkBenchmarks/blob/f510e947b5480b83cdda66f397d31be7166a40d6/frameworks/Java/undertow/src/main/java/hello/HelloWebServer.java#L255\">FrameworkBenchmarks/frameworks/Java/undertow/src/main/java/hello/HelloWebServer.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n         Line 255\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/TechEmpower/FrameworkBenchmarks/commit/f510e947b5480b83cdda66f397d31be7166a40d6\">f510e94</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L255\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"255\"></td>\n          <td id=\"LC255\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> <span class=\"pl-k\">return</span> <span class=\"pl-c1\">1</span> <span class=\"pl-k\">+</span> <span class=\"pl-smi\">ThreadLocalRandom</span><span class=\"pl-k\">.</span>current()<span class=\"pl-k\">.</span>nextInt(<span class=\"pl-c1\">10000</span>); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:36:32Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();\n+        return formatter.format(date);\n+    }\n+\n+    private static int GetRandomNumber() {\n+        Random random = new Random();\n+        return random.nextInt(10001) + 1;", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,75 +27,71 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", getRandomNumber())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", getCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2MzMxNA==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374963314", "body": "The near-universal convention in Java is that methods are `lowerCamelCase`, not `UpperCamelCase`.", "bodyText": "The near-universal convention in Java is that methods are lowerCamelCase, not UpperCamelCase.", "bodyHTML": "<p dir=\"auto\">The near-universal convention in Java is that methods are <code>lowerCamelCase</code>, not <code>UpperCamelCase</code>.</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:37:34Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();\n+        return formatter.format(date);\n+    }\n+\n+    private static int GetRandomNumber() {", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,75 +27,71 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", getRandomNumber())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", getCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NjMwNg==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374966306", "body": "`Date` and `SimpleDateFormat` are part of the legacy Java time libraries, which were effectively replaced by the new `java.time` libraries in Java 8.  Here, what you're looking for is `DateTimeFormatter`.  Other frameworks show how to use it.  Example:  https://github.com/TechEmpower/FrameworkBenchmarks/blob/b843c9ea4f9096435ae52bf99b0182737a2c1edc/frameworks/Java/armeria/src/main/java/hello/App.java#L25-L27\r\n\r\nNote that `DateTimeFormatter` is immutable, so a single instance can be reused every time you want to format a date.  And luckily there is already a built-in `DateTimeFormatter` constant that has the format you want here.  One of `SimpleDateFormat`'s problems is that it is mutable -- formatting a date modifies the `SimpleDateFormat` instance -- so you have to construct a new instance for each date like this.", "bodyText": "Date and SimpleDateFormat are part of the legacy Java time libraries, which were effectively replaced by the new java.time libraries in Java 8.  Here, what you're looking for is DateTimeFormatter.  Other frameworks show how to use it.  Example:  \n  \n    \n      FrameworkBenchmarks/frameworks/Java/armeria/src/main/java/hello/App.java\n    \n    \n        Lines 25 to 27\n      in\n      b843c9e\n    \n    \n    \n    \n\n        \n          \n           ctx.addAdditionalResponseHeader(HttpHeaderNames.DATE, \n        \n\n        \n          \n                                           DateTimeFormatter.RFC_1123_DATE_TIME.format( \n        \n\n        \n          \n                                                   ZonedDateTime.now(ZoneOffset.UTC))); \n        \n    \n  \n\n\nNote that DateTimeFormatter is immutable, so a single instance can be reused every time you want to format a date.  And luckily there is already a built-in DateTimeFormatter constant that has the format you want here.  One of SimpleDateFormat's problems is that it is mutable -- formatting a date modifies the SimpleDateFormat instance -- so you have to construct a new instance for each date like this.", "bodyHTML": "<p dir=\"auto\"><code>Date</code> and <code>SimpleDateFormat</code> are part of the legacy Java time libraries, which were effectively replaced by the new <code>java.time</code> libraries in Java 8.  Here, what you're looking for is <code>DateTimeFormatter</code>.  Other frameworks show how to use it.  Example:  <div class=\"border rounded-1 my-2\">\n  <div class=\"f6 px-3 py-2 lh-condensed border-bottom color-bg-subtle\">\n    <p class=\"mb-0 text-bold\">\n      <a href=\"https://github.com/TechEmpower/FrameworkBenchmarks/blob/b843c9ea4f9096435ae52bf99b0182737a2c1edc/frameworks/Java/armeria/src/main/java/hello/App.java#L25-L27\">FrameworkBenchmarks/frameworks/Java/armeria/src/main/java/hello/App.java</a>\n    </p>\n    <p class=\"mb-0 color-fg-muted\">\n        Lines 25 to 27\n      in\n      <a data-pjax=\"true\" class=\"commit-tease-sha\" href=\"/TechEmpower/FrameworkBenchmarks/commit/b843c9ea4f9096435ae52bf99b0182737a2c1edc\">b843c9e</a>\n    </p>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper blob-wrapper-embedded data\">\n    <table class=\"highlight tab-size mb-0 js-file-line-container\" data-tab-size=\"8\" data-paste-markdown-skip=\"\">\n\n        <tbody><tr class=\"border-0\">\n          <td id=\"L25\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"25\"></td>\n          <td id=\"LC25\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\"> ctx<span class=\"pl-k\">.</span>addAdditionalResponseHeader(<span class=\"pl-smi\">HttpHeaderNames</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>DATE</span>, </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L26\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"26\"></td>\n          <td id=\"LC26\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                                 <span class=\"pl-smi\">DateTimeFormatter</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>RFC_1123_DATE_TIME</span><span class=\"pl-k\">.</span>format( </td>\n        </tr>\n\n        <tr class=\"border-0\">\n          <td id=\"L27\" class=\"blob-num border-0 px-3 py-0 color-bg-default js-line-number\" data-line-number=\"27\"></td>\n          <td id=\"LC27\" class=\"blob-code border-0 px-3 py-0 color-bg-default blob-code-inner js-file-line\">                                         <span class=\"pl-smi\">ZonedDateTime</span><span class=\"pl-k\">.</span>now(<span class=\"pl-smi\">ZoneOffset</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>UTC</span>))); </td>\n        </tr>\n    </tbody></table>\n  </div>\n</div>\n</p>\n<p dir=\"auto\">Note that <code>DateTimeFormatter</code> is immutable, so a single instance can be reused every time you want to format a date.  And luckily there is already a built-in <code>DateTimeFormatter</code> constant that has the format you want here.  One of <code>SimpleDateFormat</code>'s problems is that it is mutable -- formatting a date modifies the <code>SimpleDateFormat</code> instance -- so you have to construct a new instance for each date like this.</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:44:29Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                    };\n+                    return null;\n+                })\n+                .awaitShutdown();\n+        } catch (Exception e) {\n+//            logging is not allowed\n+        }\n+    }\n+\n+    public static String GetCurrentTime() {\n+        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n+        Date date = new Date();", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61dc1f06dc978334168b83945d1f293461f77768", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..f3bd997e2 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,64 +26,61 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n     public static String GetCurrentTime() {\n", "next_change": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex f3bd997e2..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -83,15 +84,14 @@ public final class Server {\n             .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}]}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2Njc1Mw==", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/pull/5467#discussion_r374966753", "body": "`\"TFB\" --> \"ServiceTalk\"`.  The convention we use is that the`Server` header contains the name of the framework.", "bodyText": "\"TFB\" --> \"ServiceTalk\".  The convention we use is that theServer header contains the name of the framework.", "bodyHTML": "<p dir=\"auto\"><code>\"TFB\" --&gt; \"ServiceTalk\"</code>.  The convention we use is that the<code>Server</code> header contains the name of the framework.</p>", "author": "michaelhixson", "createdAt": "2020-02-04T22:45:38Z", "path": "frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package servicetalk;\n+\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.http.api.*;\n+import io.servicetalk.http.netty.HttpProtocolConfigs;\n+import io.servicetalk.http.netty.HttpServers;\n+import io.servicetalk.data.jackson.JacksonSerializationProvider;\n+import io.servicetalk.transport.api.ConnectionAcceptor;\n+import io.servicetalk.transport.api.ConnectionContext;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.*;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+\n+\n+public final class Server {\n+\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        /**\n+         * Disable  AsyncContext\n+         */\n+        AsyncContext.disable();\n+\n+        /**\n+        *   Factory to implement io pooling\n+        */\n+        IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n+          Runtime.getRuntime().availableProcessors(),\n+          new IoThreadFactory(\"io-pool\")\n+        );\n+\n+        /**\n+         * Factory to disable headers validation\n+         */\n+\n+        DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n+\n+        try{\n+            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+//            Create a custom server builder with performance enhancements\n+            HttpServers\n+              .forPort(8080)\n+              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+              .ioExecutor(ioExecutor)\n+              .disableDrainingRequestPayloadBody()\n+              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+                  @Override\n+                  public Completable accept(ConnectionContext context) {\n+                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                      return delegate.accept(context);\n+                  }\n+              })\n+              .listenAndAwait((ctx, request, responseFactory) -> {\n+                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+                  if(request.path().equals(\"/json\")) {\n+                      Map<String, String> obj = new HashMap<String, String>();\n+                      obj.put(\"message\", \"Hello, World!\");\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(obj, serializer.serializerFor(Map.class))\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));\n+                  }\n+\n+                  if(request.path().equals(\"/plaintext\")) {\n+                      return succeeded(responseFactory.ok()\n+                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                        .addHeader(\"Date\", GetCurrentTime())\n+                        .addHeader(\"Server\", \"TFB\"));", "originalCommit": "6e96c308f8a967e9b388df0a61210598000f1a6f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "61dc1f06dc978334168b83945d1f293461f77768", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex a21b2989f..f3bd997e2 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -26,64 +26,61 @@ public final class Server {\n \n     public static void main(String[] args) throws Exception {\n \n-        /**\n+        /*\n          * Disable  AsyncContext\n          */\n         AsyncContext.disable();\n \n-        /**\n-        *   Factory to implement io pooling\n-        */\n+        /*\n+         *   Factory to implement io pooling\n+         */\n         IoExecutor ioExecutor = NettyIoExecutors.createIoExecutor(\n           Runtime.getRuntime().availableProcessors(),\n           new IoThreadFactory(\"io-pool\")\n         );\n \n-        /**\n+        /*\n          * Factory to disable headers validation\n          */\n \n         DefaultHttpHeadersFactory headersFactory = new DefaultHttpHeadersFactory(false,false);\n \n-        try{\n-            HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n+\n+        HttpSerializationProvider serializer = HttpSerializationProviders.jsonSerializer(new JacksonSerializationProvider());\n //            Create a custom server builder with performance enhancements\n-            HttpServers\n-              .forPort(8080)\n-              .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n-              .ioExecutor(ioExecutor)\n-              .disableDrainingRequestPayloadBody()\n-              .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-              .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n-                  @Override\n-                  public Completable accept(ConnectionContext context) {\n-                      ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n-                      return delegate.accept(context);\n-                  }\n-              })\n-              .listenAndAwait((ctx, request, responseFactory) -> {\n-                  ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-                  if(request.path().equals(\"/json\")) {\n-                      Map<String, String> obj = new HashMap<String, String>();\n-                      obj.put(\"message\", \"Hello, World!\");\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(obj, serializer.serializerFor(Map.class))\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                  }\n-\n-                  if(request.path().equals(\"/plaintext\")) {\n-                      return succeeded(responseFactory.ok()\n-                        .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                        .addHeader(\"Date\", GetCurrentTime())\n-                        .addHeader(\"Server\", \"TFB\"));\n-                    };\n-                    return null;\n-                })\n-                .awaitShutdown();\n-        } catch (Exception e) {\n-//            logging is not allowed\n-        }\n+        HttpServers\n+          .forPort(8080)\n+          .executionStrategy(HttpExecutionStrategies.noOffloadsStrategy())\n+          .ioExecutor(ioExecutor)\n+          .disableDrainingRequestPayloadBody()\n+          .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+              @Override\n+              public Completable accept(ConnectionContext context) {\n+                  ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n+                  return delegate.accept(context);\n+              }\n+          })\n+          .listenAndAwait((ctx, request, responseFactory) -> {\n+              ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n+              if(request.path().equals(\"/json\")) {\n+                  Map<String, String> obj = new HashMap<String, String>();\n+                  obj.put(\"message\", \"Hello, World!\");\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(obj, serializer.serializerFor(Map.class))\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+              }\n+\n+              if(request.path().equals(\"/plaintext\")) {\n+                  return succeeded(responseFactory.ok()\n+                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                    .addHeader(\"Date\", GetCurrentTime())\n+                    .addHeader(\"Server\", \"TFB\"));\n+                };\n+                return null;\n+            })\n+            .awaitShutdown();\n     }\n \n     public static String GetCurrentTime() {\n", "next_change": {"commit": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex f3bd997e2..3041776d0 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -83,15 +84,14 @@ public final class Server {\n             .awaitShutdown();\n     }\n \n-    public static String GetCurrentTime() {\n+    public static String getCurrentTime() {\n         SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n         Date date = new Date();\n         return formatter.format(date);\n     }\n \n-    private static int GetRandomNumber() {\n-        Random random = new Random();\n-        return random.nextInt(10001) + 1;\n+    private static int getRandomNumber() {\n+        return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n \n", "next_change": {"commit": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "changed_code": [{"header": "diff --git a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\nindex 3041776d0..b6823a537 100644\n--- a/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n+++ b/frameworks/Java/servicetalk/src/main/java/servicetalk/Server.java\n", "chunk": "@@ -55,42 +56,48 @@ public final class Server {\n           .ioExecutor(ioExecutor)\n           .disableDrainingRequestPayloadBody()\n           .protocols(HttpProtocolConfigs.h1().headersFactory(headersFactory).build())\n-          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor() {\n+          .appendConnectionAcceptorFilter(delegate -> new ConnectionAcceptor()\n+          {\n               @Override\n-              public Completable accept(ConnectionContext context) {\n+              public Completable accept(ConnectionContext context)\n+              {\n                   ((NettyConnectionContext)context).updateFlushStrategy((current, isOrig) -> FlushStrategies.flushOnEnd());\n                   return delegate.accept(context);\n               }\n           })\n-          .listenAndAwait((ctx, request, responseFactory) -> {\n+          .listenAndAwait((ctx, request, responseFactory) ->\n+            {\n               ((NettyConnectionContext)ctx).updateFlushStrategy(((current, isCurrentOriginal) -> FlushStrategies.flushOnEach()));\n-              if(request.path().equals(\"/json\")) {\n-                  Map<String, String> obj = new HashMap<String, String>();\n-                  obj.put(\"message\", \"Hello, World!\");\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(obj, serializer.serializerFor(Map.class))\n-                    .addHeader(\"Date\", getRandomNumber())\n-                    .addHeader(\"Server\", \"TFB\"));\n+              if(request.path().equals(\"/json\"))\n+              {\n+                Map<String, String> obj = new HashMap<String, String>();\n+                obj.put(\"message\", \"Hello, World!\");\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(obj, serializer.serializerFor(Map.class))\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n               }\n \n-              if(request.path().equals(\"/plaintext\")) {\n-                  return succeeded(responseFactory.ok()\n-                    .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n-                    .addHeader(\"Date\", getCurrentTime())\n-                    .addHeader(\"Server\", \"TFB\"));\n-                };\n-                return null;\n+              if(request.path().equals(\"/plaintext\"))\n+              {\n+                return succeeded(responseFactory.ok()\n+                  .payloadBody(\"Hello, World!\", HttpSerializationProviders.textSerializer())\n+                  .addHeader(\"Date\", getCurrentTime())\n+                  .addHeader(\"Server\", \"ServiceTalk\"));\n+              };\n+              return null;\n             })\n             .awaitShutdown();\n     }\n \n-    public static String getCurrentTime() {\n-        SimpleDateFormat formatter = new SimpleDateFormat(\"EE, dd MMM yyyy kk:mm:ss z  \");\n-        Date date = new Date();\n-        return formatter.format(date);\n+    public static String getCurrentTime()\n+    {\n+        return DateTimeFormatter.RFC_1123_DATE_TIME.format(\n+          ZonedDateTime.now(ZoneOffset.UTC));\n     }\n \n-    private static int getRandomNumber() {\n+    private static int getRandomNumber()\n+    {\n         return 1 + ThreadLocalRandom.current().nextInt(10000);\n     }\n }\n", "next_change": null}]}}]}}]}}, {"oid": "4e0ebe390c3d64389ac6234898b7c6c8e7d29d41", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/4e0ebe390c3d64389ac6234898b7c6c8e7d29d41", "message": "[fix] Comments", "committedDate": "2020-02-04T23:01:41Z", "type": "commit"}, {"oid": "61dc1f06dc978334168b83945d1f293461f77768", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/61dc1f06dc978334168b83945d1f293461f77768", "message": "[fix] Remove try/catch block", "committedDate": "2020-02-04T23:02:36Z", "type": "commit"}, {"oid": "d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/d2cdb597cc860ede77f5f2fb0f36289d3aee99c9", "message": "[fix] Naming convention + random number", "committedDate": "2020-02-04T23:13:36Z", "type": "commit"}, {"oid": "a96d5af23dcb07a109cebd7412efb3330da96fa0", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/a96d5af23dcb07a109cebd7412efb3330da96fa0", "message": "[fix] Replace date libraries + Server name", "committedDate": "2020-02-05T00:52:13Z", "type": "commit"}, {"oid": "e3bb57cbdf65d8387e18d7777e13ece8db456ed5", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/e3bb57cbdf65d8387e18d7777e13ece8db456ed5", "message": "[fix] version numbers", "committedDate": "2020-02-05T01:07:58Z", "type": "commit"}, {"oid": "6a782d924b4bc5df0eacbca5e4a04efc18a9348f", "url": "https://github.com/TechEmpower/FrameworkBenchmarks/commit/6a782d924b4bc5df0eacbca5e4a04efc18a9348f", "message": "[fix] Clean pom.xml", "committedDate": "2020-02-05T19:11:59Z", "type": "commit"}]}