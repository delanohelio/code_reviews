{"pr_number": 1005, "pr_title": "Tag expressions: Tag exception message", "pr_author": "cyocum", "pr_createdAt": "2020-05-20T08:40:13Z", "pr_url": "https://github.com/cucumber/common/pull/1005", "merge_commit": "0a3309556dc33c06506f467de8b52538c9f56488", "timeline": [{"oid": "1968be2f4de234c62761cdb0f8d32482422f480c", "url": "https://github.com/cucumber/common/commit/1968be2f4de234c62761cdb0f8d32482422f480c", "message": "Updated error messages to contain the full expression\n\n* Updated error messages to contain the full expression and reason for\n  exception\n* Marked variables as final where appropriate", "committedDate": "2020-05-19T14:43:02Z", "type": "commit"}, {"oid": "eefdeaba6b5bfaf09f36c63978c636c8c901d6e4", "url": "https://github.com/cucumber/common/commit/eefdeaba6b5bfaf09f36c63978c636c8c901d6e4", "message": "Fixed mistake in argument number in test", "committedDate": "2020-05-20T08:13:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NTQwMg==", "url": "https://github.com/cucumber/common/pull/1005#discussion_r427845402", "body": "I'd love to be rid of this bit of mutable state. \r\n\r\nPerhaps we can do this:\r\n\r\n```\r\nExpression exp = TagExpressionParser.parse(\"@food\");\r\n```\r\n\r\nAnd then internally\r\n```\r\npublic static Expression parse(String infix){\r\n  return new TagExpressionParser(infix).parse();\r\n}\r\n", "bodyText": "I'd love to be rid of this bit of mutable state.\nPerhaps we can do this:\nExpression exp = TagExpressionParser.parse(\"@food\");\n\nAnd then internally\npublic static Expression parse(String infix){\n  return new TagExpressionParser(infix).parse();\n}", "bodyHTML": "<p dir=\"auto\">I'd love to be rid of this bit of mutable state.</p>\n<p dir=\"auto\">Perhaps we can do this:</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Expression exp = TagExpressionParser.parse(&quot;@food&quot;);\"><pre><code>Expression exp = TagExpressionParser.parse(\"@food\");\n</code></pre></div>\n<p dir=\"auto\">And then internally</p>\n<div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"public static Expression parse(String infix){\n  return new TagExpressionParser(infix).parse();\n}\"><pre><code>public static Expression parse(String infix){\n  return new TagExpressionParser(infix).parse();\n}\n</code></pre></div>", "author": "mpkorstanje", "createdAt": "2020-05-20T08:49:55Z", "path": "tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java", "diffHunk": "@@ -21,15 +21,19 @@\n         put(\"not\", 2);\n     }};\n     private static final char ESCAPING_CHAR = '\\\\';\n+    private String infix;", "originalCommit": "eefdeaba6b5bfaf09f36c63978c636c8c901d6e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0ODI3MQ==", "url": "https://github.com/cucumber/common/pull/1005#discussion_r427848271", "bodyText": "That would be nice but I needed the mutable state because the infix is needed in more than one function and I did not initially want to pass that around to multiple functions when something simple would work.  I could pass the infix string around but that seems not good as well.", "author": "cyocum", "createdAt": "2020-05-20T08:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NTQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0ODk0OQ==", "url": "https://github.com/cucumber/common/pull/1005#discussion_r427848949", "bodyText": "That's why I'm suggesting to create a tag parser object per infix that is parsed.", "author": "mpkorstanje", "createdAt": "2020-05-20T08:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0NTQwMg=="}], "type": "inlineReview", "revised_code": {"commit": "31cfcdc537e8bdcaf1685de22fc69ce373795f9e", "changed_code": [{"header": "diff --git a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\nindex 66e6231ef..edb979e3b 100644\n--- a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n+++ b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n", "chunk": "@@ -21,19 +21,24 @@ public class TagExpressionParser {\n         put(\"not\", 2);\n     }};\n     private static final char ESCAPING_CHAR = '\\\\';\n-    private String infix;\n+    private final String infix;\n \n-    \n-    public Expression parse(final String infix) {\n+    public static Expression parse(String infix) {\n+\treturn new TagExpressionParser(infix).parse();\n+    }\n+\n+    private TagExpressionParser(String infix) {\n \tthis.infix = infix;\n-\t\n-        final List<String> tokens = tokenize(infix);\n+    }\n+    \n+    private Expression parse() {\t\n+        List<String> tokens = tokenize(infix);\n         if(tokens.isEmpty()) return new True();\n \n-        final Deque<String> operators = new ArrayDeque<>();\n-        final Deque<Expression> expressions = new ArrayDeque<>();\n+        Deque<String> operators = new ArrayDeque<>();\n+        Deque<Expression> expressions = new ArrayDeque<>();\n         TokenType expectedTokenType = TokenType.OPERAND;\n-        for (final String token : tokens) {\n+        for (String token : tokens) {\n             if (isUnary(token)) {\n                 check(expectedTokenType, TokenType.OPERAND);\n                 operators.push(token);\n", "next_change": null}]}, "revised_code_in_main": {"commit": "0a3309556dc33c06506f467de8b52538c9f56488", "changed_code": [{"header": "diff --git a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\nindex 66e6231ef..9131c4dbd 100644\n--- a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n+++ b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n", "chunk": "@@ -7,13 +7,13 @@ import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n-public class TagExpressionParser {\n-    private static Map<String, Assoc> ASSOC = new HashMap<String, Assoc>() {{\n+public final class TagExpressionParser {\n+    private static final Map<String, Assoc> ASSOC = new HashMap<String, Assoc>() {{\n         put(\"or\", Assoc.LEFT);\n         put(\"and\", Assoc.LEFT);\n         put(\"not\", Assoc.RIGHT);\n     }};\n-    private static Map<String, Integer> PREC = new HashMap<String, Integer>() {{\n+    private static final Map<String, Integer> PREC = new HashMap<String, Integer>() {{\n         put(\"(\", -2);\n         put(\")\", -1);\n         put(\"or\", 0);\n", "next_change": {"commit": "8bfe5be44d3fdc385fcfa072dc25db006b988629", "changed_code": [{"header": "diff --git a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\ndeleted file mode 100644\nindex 9131c4dbd..000000000\n--- a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n+++ /dev/null\n", "chunk": "@@ -1,268 +0,0 @@\n-package io.cucumber.tagexpressions;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class TagExpressionParser {\n-    private static final Map<String, Assoc> ASSOC = new HashMap<String, Assoc>() {{\n-        put(\"or\", Assoc.LEFT);\n-        put(\"and\", Assoc.LEFT);\n-        put(\"not\", Assoc.RIGHT);\n-    }};\n-    private static final Map<String, Integer> PREC = new HashMap<String, Integer>() {{\n-        put(\"(\", -2);\n-        put(\")\", -1);\n-        put(\"or\", 0);\n-        put(\"and\", 1);\n-        put(\"not\", 2);\n-    }};\n-    private static final char ESCAPING_CHAR = '\\\\';\n-    private final String infix;\n-\n-    public static Expression parse(String infix) {\n-\treturn new TagExpressionParser(infix).parse();\n-    }\n-\n-    private TagExpressionParser(String infix) {\n-\tthis.infix = infix;\n-    }\n-    \n-    private Expression parse() {\t\n-        List<String> tokens = tokenize(infix);\n-        if(tokens.isEmpty()) return new True();\n-\n-        Deque<String> operators = new ArrayDeque<>();\n-        Deque<Expression> expressions = new ArrayDeque<>();\n-        TokenType expectedTokenType = TokenType.OPERAND;\n-        for (String token : tokens) {\n-            if (isUnary(token)) {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (isBinary(token)) {\n-                check(expectedTokenType, TokenType.OPERATOR);\n-                while (operators.size() > 0 && isOperator(operators.peek()) && (\n-                        (ASSOC.get(token) == Assoc.LEFT && PREC.get(token) <= PREC.get(operators.peek()))\n-                                ||\n-                                (ASSOC.get(token) == Assoc.RIGHT && PREC.get(token) < PREC.get(operators.peek())))\n-                        ) {\n-                    pushExpr(pop(operators), expressions);\n-                }\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (\"(\".equals(token)) {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (\")\".equals(token)) {\n-                check(expectedTokenType, TokenType.OPERATOR);\n-                while (operators.size() > 0 && !\"(\".equals(operators.peek())) {\n-                    pushExpr(pop(operators), expressions);\n-                }\n-                if (operators.size() == 0) {\n-                    throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: unmatched )\", this.infix);\n-                }\n-                if (\"(\".equals(operators.peek())) {\n-                    pop(operators);\n-                }\n-                expectedTokenType = TokenType.OPERATOR;\n-            } else {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                pushExpr(token, expressions);\n-                expectedTokenType = TokenType.OPERATOR;\n-            }\n-        }\n-\n-        while (operators.size() > 0) {\n-            if (\"(\".equals(operators.peek())) {\n-                throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: unmatched (\", infix);\n-            }\n-            pushExpr(pop(operators), expressions);\n-        }\n-\n-        return expressions.pop();\n-    }\n-\n-    private static List<String> tokenize(String expr) {\n-        List<String> tokens = new ArrayList<>();\n-\n-        boolean isEscaped = false;\n-        StringBuilder token = null;\n-        for (int i = 0; i < expr.length(); i++) {\n-            char c = expr.charAt(i);\n-            if (ESCAPING_CHAR == c) {\n-                isEscaped = true;\n-            } else {\n-                if (Character.isWhitespace(c)) { // skip\n-                    if (null != token) { // end of token\n-                        tokens.add(token.toString());\n-                        token = null;\n-                    }\n-                } else {\n-                    switch (c) {\n-                        case '(':\n-                        case ')':\n-                            if (!isEscaped) {\n-                                if (null != token) { // end of token\n-                                    tokens.add(token.toString());\n-                                    token = null;\n-                                }\n-                                tokens.add(String.valueOf(c));\n-                                break;\n-                            }\n-                        default:\n-                            if (null == token) { // start of token\n-                                token = new StringBuilder();\n-                            }\n-                            token.append(c);\n-                            break;\n-                    }\n-                }\n-                isEscaped = false;\n-            }\n-        }\n-        if (null != token) { // end of token\n-            tokens.add(token.toString());\n-        }\n-        return tokens;\n-    }\n-\n-    private void check(TokenType expectedTokenType, TokenType tokenType) {\n-        if (expectedTokenType != tokenType) {\n-            throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: expected %s\", infix, expectedTokenType.toString().toLowerCase());\n-        }\n-    }\n-\n-    private <T> T pop(Deque<T> stack) {\n-        if (stack.isEmpty()) throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of an empty stack\", infix);\n-        return stack.pop();\n-    }\n-\n-    private void pushExpr(String token, Deque<Expression> stack) {\n-        switch (token) {\n-            case \"and\":\n-                Expression rightAndExpr = pop(stack);\n-                stack.push(new And(pop(stack), rightAndExpr));\n-                break;\n-            case \"or\":\n-                Expression rightOrExpr = pop(stack);\n-                stack.push(new Or(pop(stack), rightOrExpr));\n-                break;\n-            case \"not\":\n-                stack.push(new Not(pop(stack)));\n-                break;\n-            default:\n-                stack.push(new Literal(token));\n-                break;\n-        }\n-    }\n-\n-    private boolean isUnary(String token) {\n-        return \"not\".equals(token);\n-    }\n-\n-    private boolean isBinary(String token) {\n-        return \"or\".equals(token) || \"and\".equals(token);\n-    }\n-\n-    private boolean isOperator(String token) {\n-        return ASSOC.get(token) != null;\n-    }\n-\n-    private enum TokenType {\n-        OPERAND,\n-        OPERATOR\n-    }\n-\n-    private enum Assoc {\n-        LEFT,\n-        RIGHT\n-    }\n-\n-    private class Literal implements Expression {\n-        private final String value;\n-\n-        Literal(String value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return variables.contains(value);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return value.replaceAll(\"\\\\(\", \"\\\\\\\\(\").replaceAll(\"\\\\)\", \"\\\\\\\\)\");\n-        }\n-    }\n-\n-    private class Or implements Expression {\n-        private final Expression left;\n-        private final Expression right;\n-\n-        Or(Expression left, Expression right) {\n-            this.left = left;\n-            this.right = right;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return left.evaluate(variables) || right.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"( \" + left.toString() + \" or \" + right.toString() + \" )\";\n-        }\n-    }\n-\n-    private class And implements Expression {\n-        private final Expression left;\n-        private final Expression right;\n-\n-        And(Expression left, Expression right) {\n-            this.left = left;\n-            this.right = right;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return left.evaluate(variables) && right.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"( \" + left.toString() + \" and \" + right.toString() + \" )\";\n-        }\n-    }\n-\n-    private class Not implements Expression {\n-        private final Expression expr;\n-\n-        Not(Expression expr) {\n-            this.expr = expr;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return !expr.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"not ( \" + expr.toString() + \" )\";\n-        }\n-    }\n-\n-    private class True implements Expression {\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return true;\n-        }\n-    }\n-}\n", "next_change": null}]}}, {"header": "diff --git a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\nindex 66e6231ef..9131c4dbd 100644\n--- a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n+++ b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n", "chunk": "@@ -21,19 +21,24 @@ public class TagExpressionParser {\n         put(\"not\", 2);\n     }};\n     private static final char ESCAPING_CHAR = '\\\\';\n-    private String infix;\n+    private final String infix;\n \n-    \n-    public Expression parse(final String infix) {\n+    public static Expression parse(String infix) {\n+\treturn new TagExpressionParser(infix).parse();\n+    }\n+\n+    private TagExpressionParser(String infix) {\n \tthis.infix = infix;\n-\t\n-        final List<String> tokens = tokenize(infix);\n+    }\n+    \n+    private Expression parse() {\t\n+        List<String> tokens = tokenize(infix);\n         if(tokens.isEmpty()) return new True();\n \n-        final Deque<String> operators = new ArrayDeque<>();\n-        final Deque<Expression> expressions = new ArrayDeque<>();\n+        Deque<String> operators = new ArrayDeque<>();\n+        Deque<Expression> expressions = new ArrayDeque<>();\n         TokenType expectedTokenType = TokenType.OPERAND;\n-        for (final String token : tokens) {\n+        for (String token : tokens) {\n             if (isUnary(token)) {\n                 check(expectedTokenType, TokenType.OPERAND);\n                 operators.push(token);\n", "next_change": {"commit": "8bfe5be44d3fdc385fcfa072dc25db006b988629", "changed_code": [{"header": "diff --git a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java b/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\ndeleted file mode 100644\nindex 9131c4dbd..000000000\n--- a/tag-expressions/java/src/main/java/io/cucumber/tagexpressions/TagExpressionParser.java\n+++ /dev/null\n", "chunk": "@@ -1,268 +0,0 @@\n-package io.cucumber.tagexpressions;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-public final class TagExpressionParser {\n-    private static final Map<String, Assoc> ASSOC = new HashMap<String, Assoc>() {{\n-        put(\"or\", Assoc.LEFT);\n-        put(\"and\", Assoc.LEFT);\n-        put(\"not\", Assoc.RIGHT);\n-    }};\n-    private static final Map<String, Integer> PREC = new HashMap<String, Integer>() {{\n-        put(\"(\", -2);\n-        put(\")\", -1);\n-        put(\"or\", 0);\n-        put(\"and\", 1);\n-        put(\"not\", 2);\n-    }};\n-    private static final char ESCAPING_CHAR = '\\\\';\n-    private final String infix;\n-\n-    public static Expression parse(String infix) {\n-\treturn new TagExpressionParser(infix).parse();\n-    }\n-\n-    private TagExpressionParser(String infix) {\n-\tthis.infix = infix;\n-    }\n-    \n-    private Expression parse() {\t\n-        List<String> tokens = tokenize(infix);\n-        if(tokens.isEmpty()) return new True();\n-\n-        Deque<String> operators = new ArrayDeque<>();\n-        Deque<Expression> expressions = new ArrayDeque<>();\n-        TokenType expectedTokenType = TokenType.OPERAND;\n-        for (String token : tokens) {\n-            if (isUnary(token)) {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (isBinary(token)) {\n-                check(expectedTokenType, TokenType.OPERATOR);\n-                while (operators.size() > 0 && isOperator(operators.peek()) && (\n-                        (ASSOC.get(token) == Assoc.LEFT && PREC.get(token) <= PREC.get(operators.peek()))\n-                                ||\n-                                (ASSOC.get(token) == Assoc.RIGHT && PREC.get(token) < PREC.get(operators.peek())))\n-                        ) {\n-                    pushExpr(pop(operators), expressions);\n-                }\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (\"(\".equals(token)) {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                operators.push(token);\n-                expectedTokenType = TokenType.OPERAND;\n-            } else if (\")\".equals(token)) {\n-                check(expectedTokenType, TokenType.OPERATOR);\n-                while (operators.size() > 0 && !\"(\".equals(operators.peek())) {\n-                    pushExpr(pop(operators), expressions);\n-                }\n-                if (operators.size() == 0) {\n-                    throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: unmatched )\", this.infix);\n-                }\n-                if (\"(\".equals(operators.peek())) {\n-                    pop(operators);\n-                }\n-                expectedTokenType = TokenType.OPERATOR;\n-            } else {\n-                check(expectedTokenType, TokenType.OPERAND);\n-                pushExpr(token, expressions);\n-                expectedTokenType = TokenType.OPERATOR;\n-            }\n-        }\n-\n-        while (operators.size() > 0) {\n-            if (\"(\".equals(operators.peek())) {\n-                throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: unmatched (\", infix);\n-            }\n-            pushExpr(pop(operators), expressions);\n-        }\n-\n-        return expressions.pop();\n-    }\n-\n-    private static List<String> tokenize(String expr) {\n-        List<String> tokens = new ArrayList<>();\n-\n-        boolean isEscaped = false;\n-        StringBuilder token = null;\n-        for (int i = 0; i < expr.length(); i++) {\n-            char c = expr.charAt(i);\n-            if (ESCAPING_CHAR == c) {\n-                isEscaped = true;\n-            } else {\n-                if (Character.isWhitespace(c)) { // skip\n-                    if (null != token) { // end of token\n-                        tokens.add(token.toString());\n-                        token = null;\n-                    }\n-                } else {\n-                    switch (c) {\n-                        case '(':\n-                        case ')':\n-                            if (!isEscaped) {\n-                                if (null != token) { // end of token\n-                                    tokens.add(token.toString());\n-                                    token = null;\n-                                }\n-                                tokens.add(String.valueOf(c));\n-                                break;\n-                            }\n-                        default:\n-                            if (null == token) { // start of token\n-                                token = new StringBuilder();\n-                            }\n-                            token.append(c);\n-                            break;\n-                    }\n-                }\n-                isEscaped = false;\n-            }\n-        }\n-        if (null != token) { // end of token\n-            tokens.add(token.toString());\n-        }\n-        return tokens;\n-    }\n-\n-    private void check(TokenType expectedTokenType, TokenType tokenType) {\n-        if (expectedTokenType != tokenType) {\n-            throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of syntax error: expected %s\", infix, expectedTokenType.toString().toLowerCase());\n-        }\n-    }\n-\n-    private <T> T pop(Deque<T> stack) {\n-        if (stack.isEmpty()) throw new TagExpressionException(\"Tag expression '%s' could not be parsed because of an empty stack\", infix);\n-        return stack.pop();\n-    }\n-\n-    private void pushExpr(String token, Deque<Expression> stack) {\n-        switch (token) {\n-            case \"and\":\n-                Expression rightAndExpr = pop(stack);\n-                stack.push(new And(pop(stack), rightAndExpr));\n-                break;\n-            case \"or\":\n-                Expression rightOrExpr = pop(stack);\n-                stack.push(new Or(pop(stack), rightOrExpr));\n-                break;\n-            case \"not\":\n-                stack.push(new Not(pop(stack)));\n-                break;\n-            default:\n-                stack.push(new Literal(token));\n-                break;\n-        }\n-    }\n-\n-    private boolean isUnary(String token) {\n-        return \"not\".equals(token);\n-    }\n-\n-    private boolean isBinary(String token) {\n-        return \"or\".equals(token) || \"and\".equals(token);\n-    }\n-\n-    private boolean isOperator(String token) {\n-        return ASSOC.get(token) != null;\n-    }\n-\n-    private enum TokenType {\n-        OPERAND,\n-        OPERATOR\n-    }\n-\n-    private enum Assoc {\n-        LEFT,\n-        RIGHT\n-    }\n-\n-    private class Literal implements Expression {\n-        private final String value;\n-\n-        Literal(String value) {\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return variables.contains(value);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return value.replaceAll(\"\\\\(\", \"\\\\\\\\(\").replaceAll(\"\\\\)\", \"\\\\\\\\)\");\n-        }\n-    }\n-\n-    private class Or implements Expression {\n-        private final Expression left;\n-        private final Expression right;\n-\n-        Or(Expression left, Expression right) {\n-            this.left = left;\n-            this.right = right;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return left.evaluate(variables) || right.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"( \" + left.toString() + \" or \" + right.toString() + \" )\";\n-        }\n-    }\n-\n-    private class And implements Expression {\n-        private final Expression left;\n-        private final Expression right;\n-\n-        And(Expression left, Expression right) {\n-            this.left = left;\n-            this.right = right;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return left.evaluate(variables) && right.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"( \" + left.toString() + \" and \" + right.toString() + \" )\";\n-        }\n-    }\n-\n-    private class Not implements Expression {\n-        private final Expression expr;\n-\n-        Not(Expression expr) {\n-            this.expr = expr;\n-        }\n-\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return !expr.evaluate(variables);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"not ( \" + expr.toString() + \" )\";\n-        }\n-    }\n-\n-    private class True implements Expression {\n-        @Override\n-        public boolean evaluate(List<String> variables) {\n-            return true;\n-        }\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "0a3309556dc33c06506f467de8b52538c9f56488", "message": "Merge commit", "committedDate": null}, {"oid": "2bec745084e7a11702f7a3410bba959e0b88cbc9", "committedDate": "2021-10-08 08:03:47 -0700", "message": "tag-expressions: support escape backslashes in tag expressions (#1778)"}, {"oid": "8bfe5be44d3fdc385fcfa072dc25db006b988629", "committedDate": "2021-10-11 09:21:17 -0700", "message": "Remove tag-expressions (#1790)"}]}, {"oid": "65c8c5041b5b6a412b7826501b1f77582b6e42bc", "url": "https://github.com/cucumber/common/commit/65c8c5041b5b6a412b7826501b1f77582b6e42bc", "message": "Removed unnecessary finals", "committedDate": "2020-05-20T09:09:07Z", "type": "commit"}, {"oid": "31cfcdc537e8bdcaf1685de22fc69ce373795f9e", "url": "https://github.com/cucumber/common/commit/31cfcdc537e8bdcaf1685de22fc69ce373795f9e", "message": "Removed more unnecessary finals and updated based on feedback\n\n* Removed more unnecessary finals\n* Added only one entry static point for parsing which allowed for\n  immutable state for the original string tag expression within the\n  parser itself.\n* Updated tests to reflect the new arrangement", "committedDate": "2020-05-20T09:46:46Z", "type": "commit"}, {"oid": "a253c350014d86ad51f0716a8e7cacae414e3ec0", "url": "https://github.com/cucumber/common/commit/a253c350014d86ad51f0716a8e7cacae414e3ec0", "message": "Restored final to fields in classes that needed it", "committedDate": "2020-05-20T10:47:32Z", "type": "commit"}, {"oid": "0648c1e13b19a7c961825d050b1dc37759a5c36f", "url": "https://github.com/cucumber/common/commit/0648c1e13b19a7c961825d050b1dc37759a5c36f", "message": "Added CHANGELOG entry", "committedDate": "2020-05-20T11:05:25Z", "type": "commit"}, {"oid": "4e2bac0467364107fe676d340a5a234738725867", "url": "https://github.com/cucumber/common/commit/4e2bac0467364107fe676d340a5a234738725867", "message": "Clean up public API", "committedDate": "2020-05-21T13:38:24Z", "type": "commit"}, {"oid": "a7b31f3020a911cdcb9c159a57f979d3c40c3331", "url": "https://github.com/cucumber/common/commit/a7b31f3020a911cdcb9c159a57f979d3c40c3331", "message": "Update changelog", "committedDate": "2020-05-21T13:39:55Z", "type": "commit"}, {"oid": "a3e1f9fa320d7f7e085e7864bb7f644f1c19e59d", "url": "https://github.com/cucumber/common/commit/a3e1f9fa320d7f7e085e7864bb7f644f1c19e59d", "message": "Junit5  doesn't require public", "committedDate": "2020-05-21T13:44:14Z", "type": "commit"}]}