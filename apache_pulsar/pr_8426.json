{"pr_number": 8426, "pr_title": "[Transaction]Transaction pendingack server implement patch", "pr_author": "congbobo184", "pr_createdAt": "2020-11-02T09:44:21Z", "pr_url": "https://github.com/apache/pulsar/pull/8426", "timeline": [{"oid": "efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "url": "https://github.com/apache/pulsar/commit/efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "message": "Patch 8256", "committedDate": "2020-11-02T09:42:22Z", "type": "commit"}, {"oid": "e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "url": "https://github.com/apache/pulsar/commit/e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "message": "recover", "committedDate": "2020-11-02T10:01:30Z", "type": "commit"}, {"oid": "7760fba5ecad21223a442eab86056214d629798d", "url": "https://github.com/apache/pulsar/commit/7760fba5ecad21223a442eab86056214d629798d", "message": "Redeliver move to server", "committedDate": "2020-11-04T02:07:31Z", "type": "commit"}, {"oid": "7769465800cce281c4b7b66def010fdddf6dab4c", "url": "https://github.com/apache/pulsar/commit/7769465800cce281c4b7b66def010fdddf6dab4c", "message": "Delete cache in broker memory", "committedDate": "2020-11-05T10:54:37Z", "type": "commit"}, {"oid": "d15164a78f318218734211cce987f27019ac157a", "url": "https://github.com/apache/pulsar/commit/d15164a78f318218734211cce987f27019ac157a", "message": "Move ack set util postion", "committedDate": "2020-11-05T11:08:48Z", "type": "commit"}, {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "url": "https://github.com/apache/pulsar/commit/855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "message": "Add the clear broker memory test", "committedDate": "2020-11-06T07:47:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjk0Nw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518636947", "body": "It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition", "bodyText": "It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition", "bodyHTML": "<p dir=\"auto\">It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition</p>", "author": "codelipenghui", "createdAt": "2020-11-06T09:47:43Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzOTI3MA==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518639270", "body": "Why otherPosition's ackSet is null then return the result?", "bodyText": "Why otherPosition's ackSet is null then return the result?", "bodyHTML": "<p dir=\"auto\">Why otherPosition's ackSet is null then return the result?</p>", "author": "codelipenghui", "createdAt": "2020-11-06T09:51:45Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0NDAyOA==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518644028", "body": "I think we can use an empty ackset to simplify these lines.", "bodyText": "I think we can use an empty ackset to simplify these lines.", "bodyHTML": "<p dir=\"auto\">I think we can use an empty ackset to simplify these lines.</p>", "author": "codelipenghui", "createdAt": "2020-11-06T09:59:53Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }\n+\n+            BitSetRecyclable otherAckSet;\n+            if (currentPosition.getAckSet() == null) {\n+                if (otherPosition.getAckSet() != null) {\n+                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+                    if (otherAckSet.isEmpty()) {\n+                        otherAckSet.recycle();\n+                        return result;\n+                    } else {\n+                        otherAckSet.recycle();\n+                        return 1;\n+                    }\n+\n+                }\n+                return result;\n+            }\n+            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            otherAckSet.recycle();\n+            thisAckSet.recycle();", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODg0Mg==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518648842", "body": "If this for normal ack, shall we need to return TransactionConflictException?", "bodyText": "If this for normal ack, shall we need to return TransactionConflictException?", "bodyHTML": "<p dir=\"auto\">If this for normal ack, shall we need to return TransactionConflictException?</p>", "author": "codelipenghui", "createdAt": "2020-11-06T10:08:26Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MDc0Nw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518650747", "body": "Looks there is much duplicate code with the `individualAckNormal`, is it possible to refine it?", "bodyText": "Looks there is much duplicate code with the individualAckNormal, is it possible to refine it?", "bodyHTML": "<p dir=\"auto\">Looks there is much duplicate code with the <code>individualAckNormal</code>, is it possible to refine it?</p>", "author": "codelipenghui", "createdAt": "2020-11-06T10:11:59Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));\n+                    }\n+                    ((PersistentSubscription) subscription)\n+                            .syncBatchPositionBitSetForPendingAck(new MutablePair<>(position, batchSizePair.first));\n+                    //check if the position can remove from the consumer pending acks.\n+                    // the bit set is empty in pending ack handle.\n+                    if (((PersistentSubscription) subscription).checkIsCanDeleteConsumerPendingAck(position)) {\n+                        removePendingAcks(position);\n+                    }\n                 }\n+            } else {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n+            }\n+            positionsAcked.add(position);\n+            if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n+                removePendingAcks(position);\n+            }\n \n-                if (ack.hasValidationError()) {\n-                    log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n-                            consumerId, position, ack.getValidationError());\n-                }\n+            if (ack.hasValidationError()) {\n+                log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n+                        consumerId, position, ack.getValidationError());\n             }\n-            if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Individual);\n+        }\n+        subscription.acknowledgeMessage(positionsAcked, AckType.Individual, properties);\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    //this method is for individual ack carry the transaction\n+    private CompletableFuture<Void> individualAckWithTransaction(CommandAck ack) {", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUwMjQwNw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r519502407", "body": "Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.", "bodyText": "Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.", "bodyHTML": "<p dir=\"auto\">Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.</p>", "author": "codelipenghui", "createdAt": "2020-11-09T00:40:34Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -131,12 +132,13 @@\n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n     private PositionImpl readPositionWhenJoining;\n+    private final boolean isTransactionEnabled;", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "url": "https://github.com/apache/pulsar/commit/704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "message": "Fix some comments", "committedDate": "2020-11-09T05:54:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI2NDEyNg==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r520264126", "body": "```suggestion\r\n    //this method will return a copy of the position's ack set\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //this method will return the a copy of the position's ack set\n          \n          \n            \n                //this method will return a copy of the position's ack set", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span>this method will return <span class=\"x x-first x-last\">the </span>a copy of the position's ack set</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">    <span class=\"pl-c\"><span class=\"pl-c\">//</span>this method will return a copy of the position's ack set</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "gaoran10", "createdAt": "2020-11-10T03:31:48Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2773,6 +2773,24 @@ public boolean isMessageDeleted(Position position) {\n                 ((PositionImpl) position).getEntryId()) || ((PositionImpl) position).compareTo(markDeletePosition) <= 0 ;\n     }\n \n+    //this method will return the a copy of the position's ack set", "originalCommit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc5618040c5df285f01d94044040eee71efaaaac", "url": "https://github.com/apache/pulsar/commit/bc5618040c5df285f01d94044040eee71efaaaac", "message": "Update managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\nCo-authored-by: ran <gaoran_10@126.com>", "committedDate": "2020-11-10T12:09:30Z", "type": "commit"}, {"oid": "bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "url": "https://github.com/apache/pulsar/commit/bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "message": "Modify the exception when can't find batch size", "committedDate": "2020-11-10T12:51:12Z", "type": "commit"}, {"oid": "310bd78645a0093ee3cb8724f738a0d1093ae0d4", "url": "https://github.com/apache/pulsar/commit/310bd78645a0093ee3cb8724f738a0d1093ae0d4", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_server_implement", "committedDate": "2020-11-10T12:52:09Z", "type": "commit"}, {"oid": "51bbcb4de293338443e535b43625bc3005910feb", "url": "https://github.com/apache/pulsar/commit/51bbcb4de293338443e535b43625bc3005910feb", "message": "Merge remote-tracking branch 'origin/congbobo184_transaction_pendingack_server_implement' into congbobo184_transaction_pendingack_server_implement", "committedDate": "2020-11-10T12:53:10Z", "type": "commit"}, {"oid": "81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "url": "https://github.com/apache/pulsar/commit/81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "message": "add the judement", "committedDate": "2020-11-11T02:38:41Z", "type": "commit"}, {"oid": "48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "url": "https://github.com/apache/pulsar/commit/48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "message": "Fix the exception return", "committedDate": "2020-11-11T03:51:58Z", "type": "commit"}]}