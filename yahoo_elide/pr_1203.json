{"pr_number": 1203, "pr_title": "Elide 5.x async", "pr_author": "Abhino", "pr_createdAt": "2020-02-26T22:40:34Z", "pr_url": "https://github.com/yahoo/elide/pull/1203", "merge_commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "timeline": [{"oid": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "url": "https://github.com/yahoo/elide/commit/58d1f0feb452839cbbb06efc9460b3410a79a88c", "message": "Singleton for Cleaner Service\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-04-02T23:57:04Z", "type": "commit"}, {"oid": "0fc51739a27fbf1828172e16f150ab3555a0cc67", "url": "https://github.com/yahoo/elide/commit/0fc51739a27fbf1828172e16f150ab3555a0cc67", "message": "Singleton for Cleaner Service\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-04-03T00:09:27Z", "type": "commit"}, {"oid": "0031731c426fff44ad21eaae4e30f890864f68da", "url": "https://github.com/yahoo/elide/commit/0031731c426fff44ad21eaae4e30f890864f68da", "message": "Singleton for Cleaner Service\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-04-03T00:11:59Z", "type": "commit"}, {"oid": "09f137109e11ee682a14db111dcd3392069d80d8", "url": "https://github.com/yahoo/elide/commit/09f137109e11ee682a14db111dcd3392069d80d8", "message": "Singleton for Executor Service\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-04-04T23:33:21Z", "type": "commit"}, {"oid": "dca87e2651f100294dbae473e969961f8041d66c", "url": "https://github.com/yahoo/elide/commit/dca87e2651f100294dbae473e969961f8041d66c", "message": "Sync with Standalone Value", "committedDate": "2020-04-09T17:47:56Z", "type": "commit"}, {"oid": "c40e5afd00bf2204c090b93de2b1d96721ebf191", "url": "https://github.com/yahoo/elide/commit/c40e5afd00bf2204c090b93de2b1d96721ebf191", "message": "Merge branch 'elide-5.x' into elide-5.x-async", "committedDate": "2020-04-15T15:50:32Z", "type": "commit"}, {"oid": "4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "url": "https://github.com/yahoo/elide/commit/4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "message": "Changes to change UUID columns type as varchar(36)", "committedDate": "2020-04-15T19:36:38Z", "type": "commit"}, {"oid": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "url": "https://github.com/yahoo/elide/commit/61f93eedadc588ddf31a7024038fb36cea0ecda5", "message": "Merge branch 'elide-5.x-async' of github.com:yahoo/elide into elide-5.x-async", "committedDate": "2020-04-15T19:36:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzIyOA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411667228", "body": "Copyright.", "bodyText": "Copyright.", "bodyHTML": "<p dir=\"auto\">Copyright.</p>", "author": "aklish", "createdAt": "2020-04-20T20:24:18Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.yahoo.elide.async.models;", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzQ4Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411667482", "bodyText": "My guess is elide-async is not running checkstyles.  Otherwise the build would break and catch this.", "author": "aklish", "createdAt": "2020-04-20T20:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2NzIyOA=="}], "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex a8cf25861..b58e05fdc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -1,5 +1,14 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.models;\n \n+import com.yahoo.elide.annotation.Exclude;\n+\n+import lombok.Getter;\n+\n import java.util.Date;\n import java.util.UUID;\n \n", "next_change": null}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex a8cf25861..b58e05fdc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -1,5 +1,14 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.models;\n \n+import com.yahoo.elide.annotation.Exclude;\n+\n+import lombok.Getter;\n+\n import java.util.Date;\n import java.util.UUID;\n \n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex b58e05fdc..fe0d455b0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -8,29 +8,24 @@ package com.yahoo.elide.async.models;\n import com.yahoo.elide.annotation.Exclude;\n \n import lombok.Getter;\n+import lombok.Setter;\n \n import java.util.Date;\n import java.util.UUID;\n \n import javax.persistence.MappedSuperclass;\n-import javax.persistence.PrePersist;\n import javax.persistence.PreUpdate;\n \n @MappedSuperclass\n public abstract class AsyncBase {\n \n-    @Getter private Date createdOn;\n+    @Getter private Date createdOn = new Date();\n \n-    @Getter private Date updatedOn;\n+    @Getter @Setter private Date updatedOn = new Date();\n \n     @Exclude\n     protected String naturalKey = UUID.randomUUID().toString();\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n     @PreUpdate\n     public void preUpdate() {\n         this.updatedOn = new Date();\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\ndeleted file mode 100644\nindex fe0d455b0..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ /dev/null\n", "chunk": "@@ -1,47 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.models;\n-\n-import com.yahoo.elide.annotation.Exclude;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-\n-import java.util.Date;\n-import java.util.UUID;\n-\n-import javax.persistence.MappedSuperclass;\n-import javax.persistence.PreUpdate;\n-\n-@MappedSuperclass\n-public abstract class AsyncBase {\n-\n-    @Getter private Date createdOn = new Date();\n-\n-    @Getter @Setter private Date updatedOn = new Date();\n-\n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n-            return false;\n-        }\n-\n-        return ((AsyncBase) obj).naturalKey.equals(naturalKey);\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3NzUwNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411677504", "body": "I don't remember the reason - but why don't we pass a filter expression here (instead of a collection) and then filter and update in single DAO call?", "bodyText": "I don't remember the reason - but why don't we pass a filter expression here (instead of a collection) and then filter and update in single DAO call?", "bodyHTML": "<p dir=\"auto\">I don't remember the reason - but why don't we pass a filter expression here (instead of a collection) and then filter and update in single DAO call?</p>", "author": "aklish", "createdAt": "2020-04-20T20:41:28Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n+\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n+     */\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+\n+    /**\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n+     */\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -55,10 +55,11 @@ public interface AsyncQueryDAO {\n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -55,10 +47,11 @@ public interface AsyncQueryDAO {\n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3OTE5MQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411679191", "body": "We should only update to COMPLETE after we've created the response.  Swap this line with the next.", "bodyText": "We should only update to COMPLETE after we've created the response.  Swap this line with the next.", "bodyHTML": "<p dir=\"auto\">We should only update to COMPLETE after we've created the response.  Swap this line with the next.</p>", "author": "aklish", "createdAt": "2020-04-20T20:44:17Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -61,21 +61,26 @@ public class AsyncQueryThread implements Runnable {\n                 MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n                 log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n                 response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n             else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n                 response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response == null){\n+            if (response == null) {\n                 throw new NoHttpResponseException(\"Response for request returned as null\");\n             }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n+\n             // If we receive a response update Query Status to complete\n             asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n-\n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n             if (e.getClass().equals(InterruptedException.class)) {\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -61,21 +61,26 @@ public class AsyncQueryThread implements Runnable {\n                 MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n                 log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n                 response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n             else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n                 response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response == null){\n+            if (response == null) {\n                 throw new NoHttpResponseException(\"Response for request returned as null\");\n             }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n+\n             // If we receive a response update Query Status to complete\n             asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n-\n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n             if (e.getClass().equals(InterruptedException.class)) {\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..0749ebc54 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,83 +18,87 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n+ * Callable thread for executing the query provided in Async Query.\n  * It will also update the query status and result object at different\n  * stages of execution.\n  */\n @Slf4j\n @Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n+\n+public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n \n     private AsyncQuery queryObj;\n+    private AsyncQueryResult queryResultObj;\n     private User user;\n     private Elide elide;\n-    private QueryRunner runner;\n+    private final QueryRunner runner;\n     private AsyncQueryDAO asyncQueryDao;\n+    private String apiVersion;\n \n     @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n+         return processQuery();\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n+            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.asyncQueryDao = asyncQueryDao;\n+        this.apiVersion = apiVersion;\n+    }\n+\n+\n+   /**\n+    * This is the main method which processes the Async Query request, executes the query and updates\n+    * values for AsyncQuery and AsyncQueryResult models accordingly.\n+    * @return AsyncQueryResult\n+    * @throws URISyntaxException\n+    * @throws NoHttpResponseException\n     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n+\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+            log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+            response = elide.get(getPath(queryObj.getQuery()), queryParams, user, apiVersion);\n+            log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                    response.getResponseCode(), response.getBody());\n         }\n+        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = runner.run(queryObj.getQuery(), user);\n+            log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                    response.getResponseCode(), response.getBody());\n+        }\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+\n+        // Create AsyncQueryResult entry for AsyncQuery\n+\n+        queryResultObj = new AsyncQueryResult();\n+        queryResultObj.setHttpStatus(response.getResponseCode());\n+        queryResultObj.setResponseBody(response.getBody());\n+        queryResultObj.setContentLength(response.getBody().length());\n+        queryResultObj.setResultType(ResultType.EMBEDDED);\n+        queryResultObj.setCompletedOn(new Date());\n+\n+        return queryResultObj;\n     }\n \n     /**\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 0749ebc54..0eaaa06b9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -95,7 +100,6 @@ public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n         queryResultObj.setHttpStatus(response.getResponseCode());\n         queryResultObj.setResponseBody(response.getBody());\n         queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setResultType(ResultType.EMBEDDED);\n         queryResultObj.setCompletedOn(new Date());\n \n         return queryResultObj;\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 0eaaa06b9..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -75,27 +74,15 @@ public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n         ElideResponse response = null;\n         log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n         if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-            log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-            //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-            response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-            log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                    response.getResponseCode(), response.getBody());\n+            response = executeJsonApiRequest(queryObj, requestId);\n         }\n         else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-\n-            response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-            log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                    response.getResponseCode(), response.getBody());\n-        }\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n+            response = executeGraphqlRequest(queryObj, requestId);\n         }\n \n-        // Create AsyncQueryResult entry for AsyncQuery\n+        nullResponseCheck(response);\n \n+        // Create AsyncQueryResult entry for AsyncQuery\n         queryResultObj = new AsyncQueryResult();\n         queryResultObj.setHttpStatus(response.getResponseCode());\n         queryResultObj.setResponseBody(response.getBody());\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex f748263e1..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -29,79 +30,51 @@ import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n     private String apiVersion;\n \n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n         this.queryObj = queryObj;\n         this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n+        this.service = service;\n         this.apiVersion = apiVersion;\n     }\n \n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n         ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n         if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n-\n         nullResponseCheck(response);\n \n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NTgzNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411685834", "body": "This can be moved outside the try block (by making it final).", "bodyText": "This can be moved outside the try block (by making it final).", "bodyHTML": "<p dir=\"auto\">This can be moved outside the try block (by making it final).</p>", "author": "aklish", "createdAt": "2020-04-20T20:55:26Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n+\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n+    }\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status) {\n+        return updateAsyncQueryCollection(asyncQueryList, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                updateFunction.update(query);\n+                tx.save(query, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg0Mzk1Ng==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411843956", "bodyText": "We are unable to move this outside the try block because the ParseException is thrown by the filterParser.parseFilterExpression method itself.", "author": "moizarafat", "createdAt": "2020-04-21T03:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NTgzNA=="}], "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -107,9 +129,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                (tx, scope) -> {\n             try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                        AsyncQuery.class, false);\n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n                         .filterExpression(filter)\n", "next_change": {"commit": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..df24fd5e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -129,11 +130,15 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+\n+            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                    (tx, scope) -> {\n+\n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n                         .filterExpression(filter)\n", "next_change": {"commit": "13a2a0dc04534cc5d10706ab6a6ce6b8be3dcf2a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex df24fd5e5..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -130,14 +130,10 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = null;\n-\n         try {\n             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n                     AsyncQuery.class, false);\n-\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n+            executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -107,9 +130,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+            executeInTransaction(dataStore, (tx, scope) -> {\n+\n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n                         .filterExpression(filter)\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1802b87dc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -127,13 +133,13 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     @SuppressWarnings(\"unchecked\")\n     public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = null;\n \n         try {\n             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n                     AsyncQuery.class, false);\n-            executeInTransaction(dataStore, (tx, scope) -> {\n+            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n \n                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n                         .type(AsyncQuery.class)\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1802b87dc..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -97,89 +81,75 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n      * @return query object list updated\n      */\n     @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n             UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n \n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                        (tx, scope) -> {\n-                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                         .type(AsyncQuery.class)\n-                         .filterExpression(filter)\n-                         .build();\n-\n-                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                 Iterator<Object> itr = loaded.iterator();\n-\n-                 while (itr.hasNext()) {\n-                     AsyncQuery query = (AsyncQuery) itr.next();\n-                     updateFunction.update(query);\n-                     tx.save(query, scope);\n-                 }\n-                 return loaded;\n-             });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                    (tx, scope) -> {\n+             EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                     .type(AsyncQuery.class)\n+                     .filterExpression(filterExpression)\n+                     .build();\n+\n+             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+             Iterator<Object> itr = loaded.iterator();\n+\n+             while (itr.hasNext()) {\n+                 AsyncQuery query = (AsyncQuery) itr.next();\n+                 updateFunction.update(query);\n+                 tx.save(query, scope);\n+             }\n+             return loaded;\n+         });\n         return asyncQueryList;\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-\n         Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filterExpression)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+\n+            while (itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                if (query != null) {\n+                    tx.delete(query, scope);\n                 }\n-                return loaded;\n-            });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+            }\n+            return loaded;\n+        });\n         return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4Njk1OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411686959", "body": "Spacing is off.", "bodyText": "Spacing is off.", "bodyHTML": "<p dir=\"auto\">Spacing is off.</p>", "author": "aklish", "createdAt": "2020-04-20T20:57:24Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n+\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n+    }\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -46,8 +46,8 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-    \tthis.elide = elide;\n-    \tthis.dataStore = dataStore;\n+        this.elide = elide;\n+        this.dataStore = dataStore;\n     }\n \n     @Override\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -46,8 +46,8 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-    \tthis.elide = elide;\n-    \tthis.dataStore = dataStore;\n+        this.elide = elide;\n+        this.dataStore = dataStore;\n     }\n \n     @Override\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1802b87dc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -48,6 +54,8 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n         this.elide = elide;\n         this.dataStore = dataStore;\n+        dictionary = elide.getElideSettings().getDictionary();\n+        filterParser = new RSQLFilterDialect(dictionary);\n     }\n \n     @Override\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1802b87dc..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -59,24 +58,15 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n-        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(status);\n-        });\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQuery The AsyncQuery Object which will be updated\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQuery\");\n+    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            updateFunction.update(asyncQuery);\n-            tx.save(asyncQuery, scope);\n-            return asyncQuery;\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setStatus(status);\n+            tx.save(query, scope);\n+            return query;\n         });\n         return queryObj;\n     }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -72,7 +66,7 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status) {\n         return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n             asyncQuery.setStatus(status);\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5NzExMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411697111", "body": "Maybe return the default one here?", "bodyText": "Maybe return the default one here?", "bodyHTML": "<p dir=\"auto\">Maybe return the default one here?</p>", "author": "aklish", "createdAt": "2020-04-20T21:15:11Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -167,6 +168,60 @@ default boolean enableJSONAPI() {\n     default boolean enableGraphQL() {\n         return true;\n     }\n+    \n+    /**\n+     * Enable the support for Async querying feature. If false, the async feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsync() {\n+        return false;\n+    }\n+\n+    /**\n+     * Enable the support for cleaning up Async query history. If false, the async cleanup feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsyncCleanup() {\n+        return false;\n+    }\n+\n+    /**\n+     * Thread Size for Async queries to run in parallel.\n+     *\n+     * @return Default: 5\n+     */\n+    default Integer getAsyncThreadSize() {\n+        return 5;\n+    }\n+\n+    /**\n+     * Maximum Query Run time for Async Queries to mark as TIMEDOUT.\n+     *\n+     * @return Default: 60\n+     */\n+    default Integer getAsyncMaxRunTimeMinutes() {\n+        return 60;\n+    }\n+\n+    /**\n+     * Number of days history to retain for async query executions and results.\n+     *\n+     * @return Default: 7\n+     */\n+    default Integer getAsyncQueryCleanupDays() {\n+        return 7;\n+    }\n+\n+    /**\n+     * Implementation of AsyncQueryDAO to use.\n+     *\n+     * @return AsyncQueryDAO type object.\n+     */\n+    default AsyncQueryDAO getAsyncQueryDAO() {\n+        return null;", "originalCommit": "61f93eedadc588ddf31a7024038fb36cea0ecda5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex d40569f6f..2bcd7903c 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -220,7 +220,7 @@ public interface ElideStandaloneSettings {\n      * @return AsyncQueryDAO type object.\n      */\n     default AsyncQueryDAO getAsyncQueryDAO() {\n-        return null;\n+        return new DefaultAsyncQueryDAO();\n     }\n \n     /**\n", "next_change": {"commit": "5ad702fc971d04fce1efd41a179a3fc68015ed1b", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex 2bcd7903c..ddab851a0 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -220,7 +220,7 @@ public interface ElideStandaloneSettings {\n      * @return AsyncQueryDAO type object.\n      */\n     default AsyncQueryDAO getAsyncQueryDAO() {\n-        return new DefaultAsyncQueryDAO();\n+        return null;\n     }\n \n     /**\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "9387412f7a4fa31f3f4818933be0537ee0baa6bd", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex d40569f6f..b6da96d9c 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -168,66 +178,12 @@ public interface ElideStandaloneSettings {\n     default boolean enableGraphQL() {\n         return true;\n     }\n-    \n-    /**\n-     * Enable the support for Async querying feature. If false, the async feature will be disabled.\n-     *\n-     * @return Default: False\n-     */\n-    default boolean enableAsync() {\n-        return false;\n-    }\n-\n-    /**\n-     * Enable the support for cleaning up Async query history. If false, the async cleanup feature will be disabled.\n-     *\n-     * @return Default: False\n-     */\n-    default boolean enableAsyncCleanup() {\n-        return false;\n-    }\n-\n-    /**\n-     * Thread Size for Async queries to run in parallel.\n-     *\n-     * @return Default: 5\n-     */\n-    default Integer getAsyncThreadSize() {\n-        return 5;\n-    }\n-\n-    /**\n-     * Maximum Query Run time for Async Queries to mark as TIMEDOUT.\n-     *\n-     * @return Default: 60\n-     */\n-    default Integer getAsyncMaxRunTimeMinutes() {\n-        return 60;\n-    }\n-\n-    /**\n-     * Number of days history to retain for async query executions and results.\n-     *\n-     * @return Default: 7\n-     */\n-    default Integer getAsyncQueryCleanupDays() {\n-        return 7;\n-    }\n-\n-    /**\n-     * Implementation of AsyncQueryDAO to use.\n-     *\n-     * @return AsyncQueryDAO type object.\n-     */\n-    default AsyncQueryDAO getAsyncQueryDAO() {\n-        return null;\n-    }\n \n     /**\n      * Whether Dates should be ISO8601 strings (true) or epochs (false).\n      * @return\n      */\n-    default boolean enableISO8601Dates() {\n+    default boolean enableIS06081Dates() {\n         return true;\n     }\n \n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex b6da96d9c..00b641dbb 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -178,12 +165,66 @@ public interface ElideStandaloneSettings {\n     default boolean enableGraphQL() {\n         return true;\n     }\n+    \n+    /**\n+     * Enable the support for Async querying feature. If false, the async feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsync() {\n+        return false;\n+    }\n+\n+    /**\n+     * Enable the support for cleaning up Async query history. If false, the async cleanup feature will be disabled.\n+     *\n+     * @return Default: False\n+     */\n+    default boolean enableAsyncCleanup() {\n+        return false;\n+    }\n+\n+    /**\n+     * Thread Size for Async queries to run in parallel.\n+     *\n+     * @return Default: 5\n+     */\n+    default Integer getAsyncThreadSize() {\n+        return 5;\n+    }\n+\n+    /**\n+     * Maximum Query Run time for Async Queries to mark as TIMEDOUT.\n+     *\n+     * @return Default: 60\n+     */\n+    default Integer getAsyncMaxRunTimeMinutes() {\n+        return 60;\n+    }\n+\n+    /**\n+     * Number of days history to retain for async query executions and results.\n+     *\n+     * @return Default: 7\n+     */\n+    default Integer getAsyncQueryCleanupDays() {\n+        return 7;\n+    }\n+\n+    /**\n+     * Implementation of AsyncQueryDAO to use.\n+     *\n+     * @return AsyncQueryDAO type object.\n+     */\n+    default AsyncQueryDAO getAsyncQueryDAO() {\n+        return null;\n+    }\n \n     /**\n      * Whether Dates should be ISO8601 strings (true) or epochs (false).\n      * @return\n      */\n-    default boolean enableIS06081Dates() {\n+    default boolean enableISO8601Dates() {\n         return true;\n     }\n \n", "next_change": {"commit": "95b3031194e0e0f2394228d6a6525a80f13fef04", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex 00b641dbb..8bda402cd 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -222,7 +238,7 @@ public interface ElideStandaloneSettings {\n \n     /**\n      * Whether Dates should be ISO8601 strings (true) or epochs (false).\n-     * @return\n+     * @return whether ISO8601Dates are enabled.\n      */\n     default boolean enableISO8601Dates() {\n         return true;\n", "next_change": null}, {"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex 00b641dbb..8bda402cd 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -231,18 +247,57 @@ public interface ElideStandaloneSettings {\n     /**\n      * Whether or not Codahale metrics, healthchecks, thread, ping, and admin servlet\n      * should be enabled.\n-     * @return\n+     * @return  whether ServiceMonitoring is enabled.\n      */\n     default boolean enableServiceMonitoring() {\n         return true;\n     }\n \n     /**\n-     * Enable swagger documentation by returning non empty list.\n+     * Enable swagger documentation.\n+     * @return whether Swagger is enabled;\n+     */\n+    default boolean enableSwagger() {\n+        return false;\n+    }\n+\n+    /**\n+     * Swagger documentation requires an API version.\n+     * The models with the same version are included.\n+     * @return swagger version;\n+     */\n+    default String getSwaggerVersion() {\n+        return NO_VERSION;\n+    }\n+\n+    /**\n+     * Swagger documentation requires an API name.\n+     * @return swagger service name;\n+     */\n+    default String getSwaggerName() {\n+        return \"Elide Service\";\n+    }\n+\n+    /**\n+     * Creates a singular swagger document for JSON-API.\n+     * @param dictionary Contains the static metadata about Elide models. .\n      * @return list of swagger registration objects.\n      */\n-    default List<DocEndpoint.SwaggerRegistration> enableSwagger() {\n-        return new ArrayList<>();\n+    default List<DocEndpoint.SwaggerRegistration> buildSwagger(EntityDictionary dictionary) {\n+        Info info = new Info()\n+                .title(getSwaggerName())\n+                .version(getSwaggerVersion());\n+\n+        SwaggerBuilder builder = new SwaggerBuilder(dictionary, info);\n+\n+        String moduleBasePath = getJsonApiPathSpec().replaceAll(\"/\\\\*\", \"\");\n+\n+        Swagger swagger = builder.build().basePath(moduleBasePath);\n+\n+        List<DocEndpoint.SwaggerRegistration> docs = new ArrayList<>();\n+        docs.add(new DocEndpoint.SwaggerRegistration(\"test\", swagger));\n+\n+        return docs;\n     }\n \n     /**\n", "next_change": {"commit": "addfbff81e285c6f4f106bb6e3dd93fa7e05e9fa", "changed_code": [{"header": "diff --git a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\nindex 8bda402cd..36bc00e65 100644\n--- a/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n+++ b/elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java\n", "chunk": "@@ -254,48 +315,56 @@ public interface ElideStandaloneSettings {\n     }\n \n     /**\n-     * Enable swagger documentation.\n-     * @return whether Swagger is enabled;\n+     * Enable OpenAPI documentation.\n+     * @return whether OpenAPI is enabled;\n      */\n-    default boolean enableSwagger() {\n+    default boolean enableApiDocs() {\n         return false;\n     }\n \n     /**\n-     * Swagger documentation requires an API version.\n-     * The models with the same version are included.\n-     * @return swagger version;\n+     * The OpenAPI Specification Version to generate.\n+     * @return the OpenAPI Specification Version to generate\n      */\n-    default String getSwaggerVersion() {\n-        return NO_VERSION;\n+    default OpenApiVersion getOpenApiVersion() {\n+        return OpenApiVersion.OPENAPI_3_0;\n     }\n \n     /**\n-     * Swagger documentation requires an API name.\n-     * @return swagger service name;\n+     * The service base URL that clients use in queries.  Elide will reference this name\n+     * in any callback URLs returned by the service.  If not set, Elide uses the API request to generate the base URL.\n+     * @return The base URL of the service.\n      */\n-    default String getSwaggerName() {\n-        return \"Elide Service\";\n+    default String getBaseUrl() {\n+        return \"\";\n     }\n \n     /**\n-     * Creates a singular swagger document for JSON-API.\n-     * @param dictionary Contains the static metadata about Elide models. .\n-     * @return list of swagger registration objects.\n+     * OpenAPI documentation requires an API name.\n+     * @return open api service name;\n      */\n-    default List<DocEndpoint.SwaggerRegistration> buildSwagger(EntityDictionary dictionary) {\n-        Info info = new Info()\n-                .title(getSwaggerName())\n-                .version(getSwaggerVersion());\n-\n-        SwaggerBuilder builder = new SwaggerBuilder(dictionary, info);\n-\n-        String moduleBasePath = getJsonApiPathSpec().replaceAll(\"/\\\\*\", \"\");\n-\n-        Swagger swagger = builder.build().basePath(moduleBasePath);\n+    default String getApiTitle() {\n+        return \"Elide Service\";\n+    }\n \n-        List<DocEndpoint.SwaggerRegistration> docs = new ArrayList<>();\n-        docs.add(new DocEndpoint.SwaggerRegistration(\"test\", swagger));\n+    /**\n+     * Creates a singular OpenAPI document for JSON-API.\n+     * @param dictionary Contains the static metadata about Elide models. .\n+     * @return list of OpenAPI registration objects.\n+     */\n+    default List<ApiDocsEndpoint.ApiDocsRegistration> buildApiDocs(EntityDictionary dictionary) {\n+        List<ApiDocsEndpoint.ApiDocsRegistration> docs = new ArrayList<>();\n+\n+        dictionary.getApiVersions().stream().forEach(apiVersion -> {\n+            Info info = new Info()\n+                    .title(getApiTitle())\n+                    .version(apiVersion);\n+            OpenApiBuilder builder = new OpenApiBuilder(dictionary).apiVersion(apiVersion);\n+            String moduleBasePath = getJsonApiPathSpec().replace(\"/*\", \"\");\n+            OpenAPI openApi = builder.build().info(info).addServersItem(new Server().url(moduleBasePath));\n+            docs.add(new ApiDocsEndpoint.ApiDocsRegistration(\"test\", () -> openApi, getOpenApiVersion().getValue(),\n+                    apiVersion));\n+        });\n \n         return docs;\n     }\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9387412f7a4fa31f3f4818933be0537ee0baa6bd", "committedDate": "2020-05-18 13:58:16 -0500", "message": "Add Eclipse import order (#1327)"}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "95b3031194e0e0f2394228d6a6525a80f13fef04", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x dynamic config standalone (#1259)"}, {"oid": "81dde7567aa8a6a00822a9a8f0bf901806a962e8", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Add caching support to SQLQueryEngine (#1319)"}, {"oid": "9c897058ce0b9656bf2aef2318d0addc474f278a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "implement cancel function (#1367)"}, {"oid": "9ff0eb6bfa7f8f0135d21cf68cb1e44c5d515d91", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Enable query caching by default (#1378)"}, {"oid": "8fece2b8f1b3078ce2598ddb03dca66bb984df46", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Aggregation DataStore QueryLogger Implementation (#1448)"}, {"oid": "7c8fece25f8dddbe975f0072bf0267def2610ff4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Disable Aggregation DataStore by default (#1468)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "ca35ad817f2fde68b2f9c39d0d4d9c9d44ebffd5", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Query Engine and Aggregation Store Changes for Multi Data Source Support (#1523)"}, {"oid": "bbbfb1a7522b64ef2f7fc42bae2c0f65491d1c04", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Update timegrain serde to return java.sql.Date instead of java.util.Date (#1552)"}, {"oid": "b8d0918e2f6f438eda12c12e58354a8cad3719dd", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Added item expiration to AggregationDataStore cache (#1564)"}, {"oid": "1933cc3eb6788be5fce69b1d97c6ae589623495f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Add slf4j query logger (#1618)"}, {"oid": "26bef0c192b549ed701287814055e5e7ac175a50", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Collapsed contrib directory into top level modules (#1670)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "cf1726f19ece846111b004b8f01fd1c135fa39b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Create separate class for Analytics settings (#1669)"}, {"oid": "c14096bec256faf80e7674fbef22bccff1f955a3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Moved contrib.dynamicconfighelpers to modelconfig package (#1676)"}, {"oid": "800ba874c21672a727aed4e1beacb294bfb5022e", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x MetaDataStore enable/disable flag (#1696)"}, {"oid": "bea43ef0f244ba01c2f7d4216b9f08f0ef4e83a4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Optionally compile hjson configs while running CLI (#1693)"}, {"oid": "6ce117b6c68f6a2fc484e3c9ba7b76ace9c596ff", "committedDate": "2021-01-08 17:36:00 -0600", "message": "Added baseUrl configuration setting for Spring and Standalone"}, {"oid": "79b23531edc46cebc43e889d7ac4727540a72105", "committedDate": "2021-01-19 14:16:37 -0600", "message": "Syntax Fixes"}, {"oid": "de9883d363ba8b4171be5d8ad508564664f6fc90", "committedDate": "2021-01-19 14:16:37 -0600", "message": "Review comments"}, {"oid": "fe3198d3cacec95d4b064ccae7109874e58d9e96", "committedDate": "2021-01-20 10:43:28 -0600", "message": "Review Comments"}, {"oid": "bca9aca28661c202a018a1c929ea888eaf8d83c7", "committedDate": "2021-01-20 10:43:28 -0600", "message": "Review Comments"}, {"oid": "93ebb969254204bd315de860bd064ca77e70cfab", "committedDate": "2021-01-29 11:36:47 -0500", "message": "TableExportHook Binding (#1802)"}, {"oid": "dcb6336070c158b923a8e5a7ec92502ea57f36ee", "committedDate": "2021-02-09 10:45:00 -0600", "message": "Add dynamic table type (#1815)"}, {"oid": "d77f1240a3fa5abf824aea54d0533be844235359", "committedDate": "2021-02-11 10:18:49 -0600", "message": "Created new interface for dynamic configuration (#1830)"}, {"oid": "af0aad2498f81659177eff1bbcfbf49213baf7b9", "committedDate": "2021-02-15 13:19:22 -0500", "message": "Exclude Models based on Conditions (#1835)"}, {"oid": "2eb90f1b8513e246930e5419e838b3fb1f7bbb98", "committedDate": "2021-02-18 11:42:05 -0600", "message": "Integration Tests for Table Export (#1842)"}, {"oid": "e2005d6babde1a0da3ba66fc507fc6ecf5773052", "committedDate": "2021-02-22 10:34:54 -0600", "message": "Cleanup unnecessary syntax (#1854)"}, {"oid": "6c97725cec25be900fd1466f627d3d0e722ed508", "committedDate": "2021-03-09 15:24:33 -0600", "message": "Add experimental n plus1 improvement (#1876)"}, {"oid": "8274a6341e06c7201049e8e8f0a48f07bd99a0ef", "committedDate": "2021-03-10 16:38:34 -0600", "message": "Cleanup IDE warnings (#1894)"}, {"oid": "c19d8c2237e960d792dc2ef6375356433b4fac21", "committedDate": "2021-03-11 17:10:26 -0600", "message": "Classtype cleanup (#1905)"}, {"oid": "e1e07dbeabb690560754c84200b67e7a8d4d9229", "committedDate": "2021-03-22 09:06:06 -0500", "message": "Part 4 of Query Plan Optimization : Fix Metric Nesting (#1924)"}, {"oid": "ed941827e1027083367b4df9794501909279c667", "committedDate": "2021-03-25 22:55:35 -0400", "message": "diamonds to reduce duplication (#1947)"}, {"oid": "dc7a367e14c9f43b2d013f5037341055a29f0491", "committedDate": "2021-03-26 10:31:26 -0400", "message": "Issue 1929 - Address Sonar suggestions (#1925)"}, {"oid": "43598e8411d544b31d9807ded4f248e25ef334a4", "committedDate": "2021-04-01 17:32:17 -0500", "message": "Add Table Level Query Hints (#1981)"}, {"oid": "6143d108eb7b1a2250370409d5362c6722c95b23", "committedDate": "2021-04-26 16:28:58 -0500", "message": "Cleanup (#2026)"}, {"oid": "ea57369f2b8af263efd9de99bfe59cae1b88202a", "committedDate": "2021-04-29 21:02:18 -0500", "message": "Test Cases + Enable Namespace in Standalone and Spring (#2040)"}, {"oid": "0a3776bacb5809845d9a04a1263db9760f117b92", "committedDate": "2021-05-13 13:25:15 -0500", "message": "Injection Protection for parameterized metrics/dimensions (#2090)"}, {"oid": "c55eca8c6cc828610faf39d0ea62d2a0a897696b", "committedDate": "2021-08-05 09:52:57 -0500", "message": "Add simple configuration to enable verbose errors. (#2236)"}, {"oid": "fe7009353573baf0206f7bb58617db97e067f900", "committedDate": "2021-09-02 11:31:12 -0500", "message": "Refactor class scanning for quarkus (#2284)"}, {"oid": "65eaaa12fc2b805135285287d4912d2329bc676d", "committedDate": "2021-09-13 14:02:45 -0500", "message": "Add ability to map unknown exceptions to custom exceptions (#2205)"}, {"oid": "6a319f244f5b611d3702e46013c5f8c988b5a957", "committedDate": "2021-09-30 13:42:41 -0500", "message": "GraphQL Subscriptions: Part 5 (#2308)"}, {"oid": "64325a03c2d0e965e2543c3c52a9ddc0de570c03", "committedDate": "2021-10-07 14:58:50 -0500", "message": "Aggregation Store: Relaxing rules for how filter templates are compared against filter e\u2026 (#2329)"}, {"oid": "6f26ba6377010a22403698d48d49ef2a4f897fde", "committedDate": "2021-10-17 15:04:42 -0500", "message": "Changing Oath to Yahoo in Copyright messages (#2340)"}, {"oid": "5064f8a5a351b1f77b8025f68b20efc1b76d101e", "committedDate": "2021-10-19 11:25:38 -0500", "message": "Elide 6 : Refactor DataStoreTransaction Interface. (#2334)"}, {"oid": "54cdcb9fe67225cd463e1bf9357f0e1d2a42c152", "committedDate": "2021-12-02 15:11:51 -0600", "message": "HJSON Configuration Models and DataStore (#2418)"}, {"oid": "d0552c5750608391d52e3e3286469901726a7d06", "committedDate": "2022-01-28 16:02:28 -0600", "message": "Support filters on query plans (#2526)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "fd6f86b4529245b6291cdc9f50f04972b9abae54", "committedDate": "2023-04-30 15:20:02 -0500", "message": "Fix setting `DataFetcherExceptionHandler` (#2964)"}, {"oid": "a67858ed4997700aaaf37cd83c13a7690b3d388f", "committedDate": "2023-04-30 20:02:40 -0500", "message": "Add Spring PlatformTransactionManager aware transaction support (#2953)"}, {"oid": "addfbff81e285c6f4f106bb6e3dd93fa7e05e9fa", "committedDate": "2023-05-07 20:03:16 -0500", "message": "Upgrade to OpenAPI 3 (#2977)"}, {"oid": "30816cbe1496c349c05a778b105efa87ec51a7c2", "committedDate": "2023-05-29 20:07:44 -0500", "message": "Refactor configuration (#2997)"}]}, {"oid": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "url": "https://github.com/yahoo/elide/commit/8f118c6ed355db72cdad6ef8e1bc65d52d504128", "message": "Review Comments", "committedDate": "2020-04-21T17:39:19Z", "type": "commit"}, {"oid": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "url": "https://github.com/yahoo/elide/commit/2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "message": "Review Comments", "committedDate": "2020-04-21T19:16:02Z", "type": "commit"}, {"oid": "13a2a0dc04534cc5d10706ab6a6ce6b8be3dcf2a", "url": "https://github.com/yahoo/elide/commit/13a2a0dc04534cc5d10706ab6a6ce6b8be3dcf2a", "message": "Fix review comments\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-04-21T20:00:46Z", "type": "commit"}, {"oid": "5ad702fc971d04fce1efd41a179a3fc68015ed1b", "url": "https://github.com/yahoo/elide/commit/5ad702fc971d04fce1efd41a179a3fc68015ed1b", "message": "Updating per review comments", "committedDate": "2020-04-21T22:07:33Z", "type": "commit"}, {"oid": "6a93b9f6429e42e4599b368d0ce873609f4744c2", "url": "https://github.com/yahoo/elide/commit/6a93b9f6429e42e4599b368d0ce873609f4744c2", "message": "Remove unused import", "committedDate": "2020-04-21T22:32:35Z", "type": "commit"}, {"oid": "23ec6e16bf492e6054c6e04c360fed32acc034c2", "url": "https://github.com/yahoo/elide/commit/23ec6e16bf492e6054c6e04c360fed32acc034c2", "message": "Removing status change to Queued", "committedDate": "2020-04-22T17:59:49Z", "type": "commit"}, {"oid": "2326a43900a5a731cb653afc08643a58293b1433", "url": "https://github.com/yahoo/elide/commit/2326a43900a5a731cb653afc08643a58293b1433", "message": "removing unused import", "committedDate": "2020-04-22T18:02:23Z", "type": "commit"}, {"oid": "2ad63946c2dc4678df23ae5b70316c1aecb47adb", "url": "https://github.com/yahoo/elide/commit/2ad63946c2dc4678df23ae5b70316c1aecb47adb", "message": "prepersist for status", "committedDate": "2020-04-22T18:09:53Z", "type": "commit"}, {"oid": "ab5010759aa47ef5b766ae624a96ae96cfa32db2", "url": "https://github.com/yahoo/elide/commit/ab5010759aa47ef5b766ae624a96ae96cfa32db2", "message": "Merge branch 'elide-5.x' into elide-5.x-async", "committedDate": "2020-04-22T19:21:15Z", "type": "commit"}, {"oid": "5533530593f0fdfae9287a2341b39a861e060b82", "url": "https://github.com/yahoo/elide/commit/5533530593f0fdfae9287a2341b39a861e060b82", "message": "Adding Async Entity Models\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-25T21:12:45Z", "type": "commit"}, {"oid": "25bf86a18195408978d8cf85651cce6699e127f4", "url": "https://github.com/yahoo/elide/commit/25bf86a18195408978d8cf85651cce6699e127f4", "message": "Adding async module and fixing parent pom version\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-25T21:46:34Z", "type": "commit"}, {"oid": "2e52636f29d6446967fa6d63229a2fd14476863f", "url": "https://github.com/yahoo/elide/commit/2e52636f29d6446967fa6d63229a2fd14476863f", "message": "Adding async service classes, security and cleanup services\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-25T23:07:30Z", "type": "commit"}, {"oid": "9a735db86f0a93ae65931ca947faa443c18a6b0b", "url": "https://github.com/yahoo/elide/commit/9a735db86f0a93ae65931ca947faa443c18a6b0b", "message": "Adding Copyright License Header to Async module classes\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-25T23:13:13Z", "type": "commit"}, {"oid": "7a9d1e677d7b33f0d94ade2d311efdf16d3285a2", "url": "https://github.com/yahoo/elide/commit/7a9d1e677d7b33f0d94ade2d311efdf16d3285a2", "message": "Using new request scope for datastore transactions\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-26T01:48:05Z", "type": "commit"}, {"oid": "2c33710f46d1f426da5d65d8ad61ed9fd9e7ac2f", "url": "https://github.com/yahoo/elide/commit/2c33710f46d1f426da5d65d8ad61ed9fd9e7ac2f", "message": "Remove thread sleep used in testing\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-26T20:56:08Z", "type": "commit"}, {"oid": "767b4c5607f1e8c807347622fd70d2318c18d4ba", "url": "https://github.com/yahoo/elide/commit/767b4c5607f1e8c807347622fd70d2318c18d4ba", "message": "Fixing based on code quality review from codacy\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-26T22:53:44Z", "type": "commit"}, {"oid": "b5234add7d3dade7b010032c176e1c146174de10", "url": "https://github.com/yahoo/elide/commit/b5234add7d3dade7b010032c176e1c146174de10", "message": " Fixing additional issues based on code quality review from codacy\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-26T23:32:51Z", "type": "commit"}, {"oid": "ad3d6ded474fe081fc4d79d03ed32c0ff06c3101", "url": "https://github.com/yahoo/elide/commit/ad3d6ded474fe081fc4d79d03ed32c0ff06c3101", "message": "Adding getter for AsyncQueryResult\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-27T00:02:08Z", "type": "commit"}, {"oid": "be563fe606cf6e3ecba989b0d12863d23b4afe3d", "url": "https://github.com/yahoo/elide/commit/be563fe606cf6e3ecba989b0d12863d23b4afe3d", "message": "Reformatting.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-02-27T04:39:51Z", "type": "commit"}, {"oid": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "url": "https://github.com/yahoo/elide/commit/c88d08a94c994f16ee51c6a51c39694411fb8c59", "message": "Adding mappedBy.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-02-27T15:44:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNjU3OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385226578", "body": "You can use lombok `@Data` and remove a lot of boilerplate.", "bodyText": "You can use lombok @Data and remove a lot of boilerplate.", "bodyHTML": "<p dir=\"auto\">You can use lombok <code>@Data</code> and remove a lot of boilerplate.</p>", "author": "aklish", "createdAt": "2020-02-27T16:35:31Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -35,24 +32,15 @@ import lombok.extern.slf4j.Slf4j;\n  * stages of execution.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryThread implements Runnable {\n \n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n-        log.debug(\"New Async Query thread created\");\n-        this.query = query;\n-        this.queryType = queryType;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.id = id;\n-    }\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..ed261b707 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -36,11 +43,12 @@ import lombok.extern.slf4j.Slf4j;\n @AllArgsConstructor\n public class AsyncQueryThread implements Runnable {\n \n-    private AsyncQuery queryObj;\n-    private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n \n     @Override\n     public void run() {\n", "next_change": {"commit": "7058821b3ed64054ebb7c7206d52cd5f97d020b1", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex ed261b707..c435335f3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -43,12 +38,12 @@ import lombok.extern.slf4j.Slf4j;\n @AllArgsConstructor\n public class AsyncQueryThread implements Runnable {\n \n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n+    private String query;\n+    private QueryType queryType;\n+    private Principal user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n \n     @Override\n     public void run() {\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex c435335f3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,133 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private String query;\n-    private QueryType queryType;\n-    private Principal user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private UUID id;\n-\n-    @Override\n-    public void run() {\n-        processQuery();\n-    }\n-\n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-            asyncDbUtil.updateAsyncQuery(QueryStatus.PROCESSING, id);\n-            Thread.sleep(180000);\n-            ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n-            }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n-            }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.FAILURE, id);\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n-\n-            // Add queryResult object to query object\n-            asyncDbUtil.updateAsyncQuery(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-            // If a DB transaction fails we might need to set query status to FAILURE\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        log.debug(\"QueryParams: {}\", queryParams);\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n-        return uri.getPath();\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nnew file mode 100644\nindex 000000000..6a21419e4\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -0,0 +1,208 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate RequestScope scope;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, RequestScope scope, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            //Just doing sleep for async testing\n+            Thread.sleep(60000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            Principal principal = ((Principal) scope.getUser().getOpaqueUser());\n+            log.debug(\"Principal name: {}\", principal.getName());\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, scope.getUser().getOpaqueUser());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, principal);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }  catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6a21419e4..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -137,72 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 4debedb0a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -126,7 +119,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -5,54 +5,42 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.ElideResponse;\n import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.request.EntityProjection;\n+import com.yahoo.elide.security.User;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.utils.URIBuilder;\n \n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n /**\n  * Runnable thread for executing the query provided in Async Query.\n  * It will also update the query status and result object at different\n  * stages of execution.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryThread implements Runnable {\n \n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n-        log.debug(\"New Async Query thread created\");\n-        this.query = query;\n-        this.queryType = queryType;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.id = id;\n-    }\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..c06cce503 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -39,8 +39,9 @@ public class AsyncQueryThread implements Runnable {\n     private AsyncQuery queryObj;\n     private User user;\n     private Elide elide;\n-    private QueryRunner runner;\n+    private final QueryRunner runner;\n     private AsyncQueryDAO asyncQueryDao;\n+    private String apiVersion;\n \n     @Override\n     public void run() {\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex c06cce503..0749ebc54 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -44,57 +47,58 @@ public class AsyncQueryThread implements Runnable {\n     private String apiVersion;\n \n     @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n+         return processQuery();\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n+            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.asyncQueryDao = asyncQueryDao;\n+        this.apiVersion = apiVersion;\n+    }\n+\n+\n+   /**\n+    * This is the main method which processes the Async Query request, executes the query and updates\n+    * values for AsyncQuery and AsyncQueryResult models accordingly.\n+    * @return AsyncQueryResult\n+    * @throws URISyntaxException\n+    * @throws NoHttpResponseException\n     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user, apiVersion);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n+\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+            log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+            response = elide.get(getPath(queryObj.getQuery()), queryParams, user, apiVersion);\n+            log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                    response.getResponseCode(), response.getBody());\n         }\n+        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = runner.run(queryObj.getQuery(), user);\n+            log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                    response.getResponseCode(), response.getBody());\n+        }\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+\n+        // Create AsyncQueryResult entry for AsyncQuery\n+\n+        queryResultObj = new AsyncQueryResult();\n+        queryResultObj.setHttpStatus(response.getResponseCode());\n+        queryResultObj.setResponseBody(response.getBody());\n+        queryResultObj.setContentLength(response.getBody().length());\n+        queryResultObj.setResultType(ResultType.EMBEDDED);\n+        queryResultObj.setCompletedOn(new Date());\n+\n+        return queryResultObj;\n     }\n \n     /**\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 0749ebc54..0eaaa06b9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -95,7 +100,6 @@ public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n         queryResultObj.setHttpStatus(response.getResponseCode());\n         queryResultObj.setResponseBody(response.getBody());\n         queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setResultType(ResultType.EMBEDDED);\n         queryResultObj.setCompletedOn(new Date());\n \n         return queryResultObj;\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 0eaaa06b9..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -75,27 +74,15 @@ public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n         ElideResponse response = null;\n         log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n         if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-            log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-            //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-            response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-            log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                    response.getResponseCode(), response.getBody());\n+            response = executeJsonApiRequest(queryObj, requestId);\n         }\n         else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-\n-            response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-            log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                    response.getResponseCode(), response.getBody());\n-        }\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n+            response = executeGraphqlRequest(queryObj, requestId);\n         }\n \n-        // Create AsyncQueryResult entry for AsyncQuery\n+        nullResponseCheck(response);\n \n+        // Create AsyncQueryResult entry for AsyncQuery\n         queryResultObj = new AsyncQueryResult();\n         queryResultObj.setHttpStatus(response.getResponseCode());\n         queryResultObj.setResponseBody(response.getBody());\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex f748263e1..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -29,79 +30,51 @@ import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n     private String apiVersion;\n \n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n         this.queryObj = queryObj;\n         this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n+        this.service = service;\n         this.apiVersion = apiVersion;\n     }\n \n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n         ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n         if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n-\n         nullResponseCheck(response);\n \n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385228950", "body": "GraphQL can return response codes of 200 and still have errors.  Let's discuss with UI and figure out what we want to do in this case.", "bodyText": "GraphQL can return response codes of 200 and still have errors.  Let's discuss with UI and figure out what we want to do in this case.", "bodyHTML": "<p dir=\"auto\">GraphQL can return response codes of 200 and still have errors.  Let's discuss with UI and figure out what we want to do in this case.</p>", "author": "aklish", "createdAt": "2020-02-27T16:39:07Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwODgzMw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385908833", "bodyText": "@jkusa", "author": "aklish", "createdAt": "2020-02-28T20:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk5MDU5MQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r388990591", "bodyText": "If we can fetch the query status (whether the query failed or succeeded) we should return a 200.", "author": "jkusa", "createdAt": "2020-03-06T16:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyODk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -66,42 +54,40 @@ public class AsyncQueryThread implements Runnable {\n     protected void processQuery() {\n         try {\n             // Change async query to processing\n-            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n             }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-            // Add queryResult object to query object\n-            updateAsyncQueryStatus(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n         } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+            } else {\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+            }\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..ed261b707 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +58,53 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n             }\n \n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n \n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+            // If a DB transaction fails we might need to set query status to FAILURE\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n         } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+            log.error(\"Exception: {}\", e.getMessage());\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex ed261b707..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,216 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-import com.yahoo.elide.security.User;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    @Override\n-    public void run() {\n-        processQuery();\n-    }\n-\n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n-            ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n-            }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n-            }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n-\n-            // Add queryResult object to query object\n-            updateAsyncQueryStatus(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-            // If a DB transaction fails we might need to set query status to FAILURE\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        log.debug(\"QueryParams: {}\", queryParams);\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n-        return uri.getPath();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nnew file mode 100644\nindex 000000000..6a21419e4\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -0,0 +1,208 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate RequestScope scope;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, RequestScope scope, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            //Just doing sleep for async testing\n+            Thread.sleep(60000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            Principal principal = ((Principal) scope.getUser().getOpaqueUser());\n+            log.debug(\"Principal name: {}\", principal.getName());\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, scope.getUser().getOpaqueUser());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, principal);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }  catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6a21419e4..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -137,72 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 4debedb0a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -126,7 +119,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -62,52 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n         try {\n             // Change async query to processing\n-            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n             }\n \n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-            // Add queryResult object to query object\n-            updateAsyncQueryStatus(asyncQueryResult, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n         } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+            } else {\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+            }\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyOTUzOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385229539", "body": "We need to put this in a try block to make sure the tx gets closed if there is an exception.  Otherwise we may leak DB connections.", "bodyText": "We need to put this in a try block to make sure the tx gets closed if there is an exception.  Otherwise we may leak DB connections.", "bodyHTML": "<p dir=\"auto\">We need to put this in a try block to make sure the tx gets closed if there is an exception.  Otherwise we may leak DB connections.</p>", "author": "aklish", "createdAt": "2020-02-27T16:40:05Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNzYxNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385327614", "bodyText": "Right now this method throws a exception and is caught by the surrounding try - catch block in the processQuery method. That try catch block should catch any of the leaked leak DB connections cause by the database transactions. Should we put a try catch block in each of the DB transactions methods separately?", "author": "Abhino", "createdAt": "2020-02-27T19:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyOTUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +118,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..ed261b707 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -118,6 +130,87 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex ed261b707..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,84 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex 4debedb0a..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,132 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    @Override\n-    public void run() {\n-        processQuery();\n-    }\n-\n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-            asyncDbUtil.updateAsyncQuery(QueryStatus.PROCESSING, id);\n-            ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n-            }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n-            }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.FAILURE, id);\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n-\n-            // Add queryResult object to query object\n-            asyncDbUtil.updateAsyncQuery(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-            // If a DB transaction fails we might need to set query status to FAILURE\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        log.debug(\"QueryParams: {}\", queryParams);\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n-        return uri.getPath();\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nnew file mode 100644\nindex 000000000..6a21419e4\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -0,0 +1,208 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate RequestScope scope;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, RequestScope scope, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            //Just doing sleep for async testing\n+            Thread.sleep(60000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            Principal principal = ((Principal) scope.getUser().getOpaqueUser());\n+            log.debug(\"Principal name: {}\", principal.getName());\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, scope.getUser().getOpaqueUser());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, principal);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }  catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6a21419e4..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -137,72 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 4debedb0a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -126,7 +119,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +123,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -125,4 +121,29 @@ public class AsyncQueryThread implements Runnable {\n         uri = new URIBuilder(query);\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": {"commit": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex f748263e1..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,149 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.NoHttpResponseException;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.net.URISyntaxException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.Callable;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n-    private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n-    private String apiVersion;\n-\n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n-        this.queryObj = queryObj;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n-        this.apiVersion = apiVersion;\n-    }\n-\n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n-        ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n-        }\n-\n-        nullResponseCheck(response);\n-\n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        return uri.getPath();\n-    }\n-\n-    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMDk4Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385230983", "body": "Instead of setting these parameters to null, I would Mimic elide.get:\r\n\r\n```java\r\n            JsonApiDocument jsonApiDoc = new JsonApiDocument();\r\n            RequestScope requestScope = new RequestScope(path, jsonApiDoc, tx, user, queryParams, elideSettings);\r\n```\r\n\r\nThe user should be set to the principal object.", "bodyText": "Instead of setting these parameters to null, I would Mimic elide.get:\n            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n            RequestScope requestScope = new RequestScope(path, jsonApiDoc, tx, user, queryParams, elideSettings);\nThe user should be set to the principal object.", "bodyHTML": "<p dir=\"auto\">Instead of setting these parameters to null, I would Mimic elide.get:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n            RequestScope requestScope = new RequestScope(path, jsonApiDoc, tx, user, queryParams, elideSettings);\"><pre>            <span class=\"pl-smi\">JsonApiDocument</span> jsonApiDoc <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">JsonApiDocument</span>();\n            <span class=\"pl-smi\">RequestScope</span> requestScope <span class=\"pl-k\">=</span> <span class=\"pl-k\">new</span> <span class=\"pl-smi\">RequestScope</span>(path, jsonApiDoc, tx, user, queryParams, elideSettings);</pre></div>\n<p dir=\"auto\">The user should be set to the principal object.</p>", "author": "aklish", "createdAt": "2020-02-27T16:42:19Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +118,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..ed261b707 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -118,6 +130,87 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex ed261b707..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,84 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex 4debedb0a..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,132 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    @Override\n-    public void run() {\n-        processQuery();\n-    }\n-\n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-            asyncDbUtil.updateAsyncQuery(QueryStatus.PROCESSING, id);\n-            ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n-            }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n-            }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.FAILURE, id);\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n-\n-            // Add queryResult object to query object\n-            asyncDbUtil.updateAsyncQuery(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-            // If a DB transaction fails we might need to set query status to FAILURE\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        log.debug(\"QueryParams: {}\", queryParams);\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n-        return uri.getPath();\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nnew file mode 100644\nindex 000000000..6a21419e4\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -0,0 +1,208 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate RequestScope scope;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, RequestScope scope, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            //Just doing sleep for async testing\n+            Thread.sleep(60000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            Principal principal = ((Principal) scope.getUser().getOpaqueUser());\n+            log.debug(\"Principal name: {}\", principal.getName());\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, scope.getUser().getOpaqueUser());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, principal);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }  catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6a21419e4..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -137,72 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 4debedb0a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -126,7 +119,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +123,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -125,4 +121,29 @@ public class AsyncQueryThread implements Runnable {\n         uri = new URIBuilder(query);\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": {"commit": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex f748263e1..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,149 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.NoHttpResponseException;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.net.URISyntaxException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.Callable;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n-    private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n-    private String apiVersion;\n-\n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n-        this.queryObj = queryObj;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n-        this.apiVersion = apiVersion;\n-    }\n-\n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n-        ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n-        }\n-\n-        nullResponseCheck(response);\n-\n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        return uri.getPath();\n-    }\n-\n-    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMjg2Nw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385232867", "body": "Rather than duplicate the transaction setup and teardown, make a general function 'updateAsynQuery' and pass a function argument to it that actually updates the AsyncQuery object.  Then you can reuse the logic for all of your updates.", "bodyText": "Rather than duplicate the transaction setup and teardown, make a general function 'updateAsynQuery' and pass a function argument to it that actually updates the AsyncQuery object.  Then you can reuse the logic for all of your updates.", "bodyHTML": "<p dir=\"auto\">Rather than duplicate the transaction setup and teardown, make a general function 'updateAsynQuery' and pass a function argument to it that actually updates the AsyncQuery object.  Then you can reuse the logic for all of your updates.</p>", "author": "aklish", "createdAt": "2020-02-27T16:45:32Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate Principal user;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, Principal user, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.user = user;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzNTA2NA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385335064", "bodyText": "Right now we have a overloaded method for updateAsyncQueryStatus - one of them is used to update Query Status and the other one is used to add the AsyncQueryResult Object. We do it this way because at any instance we only need to update either the query status or add the result object.  Could you please elaborate on how we can create this generic updateAsyncQuery function ?", "author": "Abhino", "createdAt": "2020-02-27T19:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIzMjg2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +118,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..ed261b707 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -118,6 +130,87 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex ed261b707..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,84 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex 4debedb0a..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,132 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.net.URISyntaxException;\n-import java.security.Principal;\n-import java.util.UUID;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-\tprivate String query;\n-\tprivate QueryType queryType;\n-\tprivate Principal user;\n-\tprivate Elide elide;\n-\tprivate QueryRunner runner;\n-\tprivate UUID id;\n-\n-    @Override\n-    public void run() {\n-        processQuery();\n-    }\n-\n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-            asyncDbUtil.updateAsyncQuery(QueryStatus.PROCESSING, id);\n-            ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n-            }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n-            }\n-            // if 200 - response code then Change async query to complete else change to Failure\n-            if (response.getResponseCode() == 200) {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.COMPLETE, id);\n-            } else {\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(QueryStatus.FAILURE, id);\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery\n-            asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n-\n-            // Add queryResult object to query object\n-            asyncDbUtil.updateAsyncQuery(asyncQueryResult, id);\n-\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n-            // If a DB transaction fails we might need to set query status to FAILURE\n-        } catch (URISyntaxException e) {\n-            log.error(\"URISyntaxException: {}\", e.getMessage());\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        log.debug(\"QueryParams: {}\", queryParams);\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n-        return uri.getPath();\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nnew file mode 100644\nindex 000000000..6a21419e4\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -0,0 +1,208 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.net.URISyntaxException;\n+import java.security.Principal;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+public class AsyncQueryThread implements Runnable {\n+\n+\tprivate String query;\n+\tprivate QueryType queryType;\n+\tprivate RequestScope scope;\n+\tprivate Elide elide;\n+\tprivate QueryRunner runner;\n+\tprivate UUID id;\n+\n+    public AsyncQueryThread(String query, QueryType queryType, RequestScope scope, Elide elide, QueryRunner runner, UUID id){\n+        log.debug(\"New Async Query thread created\");\n+        this.query = query;\n+        this.queryType = queryType;\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.runner = runner;\n+        this.id = id;\n+    }\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            updateAsyncQueryStatus(QueryStatus.PROCESSING, id);\n+            //Just doing sleep for async testing\n+            Thread.sleep(60000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            Principal principal = ((Principal) scope.getUser().getOpaqueUser());\n+            log.debug(\"Principal name: {}\", principal.getName());\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, scope.getUser().getOpaqueUser());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, principal);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            // if 200 - response code then Change async query to complete else change to Failure\n+            if (response.getResponseCode() == 200) {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.COMPLETE, id);\n+            } else {\n+                asyncQuery = updateAsyncQueryStatus(QueryStatus.FAILURE, id);\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery\n+            asyncQueryResult = createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+            // Add queryResult object to query object\n+            updateAsyncQueryStatus(asyncQueryResult, id);\n+\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (URISyntaxException e) {\n+            log.error(\"URISyntaxException: {}\", e.getMessage());\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }  catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");\n+        return uri.getPath();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setQueryStatus(status);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with result object,\n+     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     */\n+    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n+        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        query.setResult(asyncQueryResult);\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6a21419e4..4debedb0a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -137,72 +129,4 @@ public class AsyncQueryThread implements Runnable {\n         log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 4debedb0a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -126,7 +119,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 6d1acea7f..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -133,87 +123,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setQueryStatus(status);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with result object,\n-     * @param asyncQueryResult AsyncQueryResult object to be associated with the AsyncQuery object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     */\n-    protected void updateAsyncQueryStatus(AsyncQueryResult asyncQueryResult, UUID asyncQueryId) throws IOException {\n-        log.debug(\"Updating AsyncQueryResult to {}\", asyncQueryResult);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        query.setResult(asyncQueryResult);\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-\t\tlog.debug(\"Adding AsyncQueryResult entry\");\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n }\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -125,4 +121,29 @@ public class AsyncQueryThread implements Runnable {\n         uri = new URIBuilder(query);\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": {"commit": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex f748263e1..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,149 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.NoHttpResponseException;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.net.URISyntaxException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.Callable;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n-    private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n-    private String apiVersion;\n-\n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n-        this.queryObj = queryObj;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n-        this.apiVersion = apiVersion;\n-    }\n-\n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n-        ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n-        }\n-\n-        nullResponseCheck(response);\n-\n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        return uri.getPath();\n-    }\n-\n-    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjE1OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385246158", "body": "Can we use lombok and get rid of all the boilerplate getters & setters?", "bodyText": "Can we use lombok and get rid of all the boilerplate getters & setters?", "bodyHTML": "<p dir=\"auto\">Can we use lombok and get rid of all the boilerplate getters &amp; setters?</p>", "author": "aklish", "createdAt": "2020-02-27T17:06:19Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Override\n+\tpublic String getPrincipalName() {\n+\t\treturn principalName;\n+\t}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    public void setResult(AsyncQueryResult result) {\n+        this.result = result;\n+    }\n+\n+    public Date getUpdatedOn() {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,59 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Override\n-\tpublic String getPrincipalName() {\n-\t\treturn principalName;\n-\t}\n-\n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n-    public void setResult(AsyncQueryResult result) {\n-        this.result = result;\n-    }\n-\n-    public Date getUpdatedOn() {\n-        return this.updatedOn;\n-    }\n-\n-    public Date getCreatedOn() {\n-        return this.createdOn;\n-    }\n-\n-    public QueryStatus getQueryStatus() {\n-        return status;\n-    }\n+    @Exclude\n+    private String principalName;\n \n-    public void setQueryStatus(QueryStatus status) {\n-        this.status = status;\n+    @Override\n+    public String getPrincipalName() {\n+        return principalName;\n     }\n \n-    public AsyncQueryResult getResult() {\n-        return result;\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n+\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,12 +65,11 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n \n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n-    \tsetPrincipalName(scope.getUser().getName());\n+        setPrincipalName(scope.getUser().getName());\n     }\n-    \n+\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n-\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..531bb03d2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,28 +50,35 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @OneToOne\n     private AsyncQueryResult result;\n \n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Exclude\n-    private String principalName;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+\tpublic String getPrincipalName() {\n+\t\treturn principalName;\n+\t}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n     }\n \n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n     }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 531bb03d2..88e89eba8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -73,12 +59,23 @@ public class AsyncQuery implements PrincipalOwned {\n \n     @PreUpdate\n     public void preUpdate() {\n-        this.updatedOn = new Date();\n+        updatedOn = new Date();\n+    }\n+\n+    public void setResult(AsyncQueryResult result) {\n+        this.result = result;\n     }\n \n-    @OnCreatePostCommit\n-    public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n+    public Date getCreatedOn() {\n+        return this.createdOn;\n     }\n+\n+    public QueryStatus getQueryStatus() {\n+        return status;\n+    }\n+\n+    public void setQueryStatus(QueryStatus status) {\n+        this.status = status;\n+    }\n+\n }\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 88e89eba8..75406ca27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -78,4 +79,13 @@ public class AsyncQuery implements PrincipalOwned {\n         this.status = status;\n     }\n \n+    @Inject\n+    @Transient\n+    AsyncExecutorService asyncExecutorService;\n+\n+    @OnCreatePostCommit\n+    public void executeQueryFromExecutor(RequestScope scope) {\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope, id);\n+    }\n }\n", "next_change": {"commit": "7d991b72b662a24ccf68e7af36ea4a7063edaafa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 75406ca27..60717ebc2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -86,6 +92,6 @@ public class AsyncQuery implements PrincipalOwned {\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope, id);\n+        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n     }\n }\n", "next_change": {"commit": "92a57364ba5b0c8dad63852f186398adcab90dd8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 60717ebc2..9b805d6a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -87,7 +88,7 @@ public class AsyncQuery implements PrincipalOwned {\n \n     @Inject\n     @Transient\n-    AsyncExecutorService asyncExecutorService;\n+    private AsyncExecutorService asyncExecutorService;\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n", "next_change": {"commit": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 9b805d6a9..7b39e02c0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -86,10 +94,6 @@ public class AsyncQuery implements PrincipalOwned {\n         this.status = status;\n     }\n \n-    @Inject\n-    @Transient\n-    private AsyncExecutorService asyncExecutorService;\n-\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n", "next_change": {"commit": "d2f0dadf431e37f7caf90340392f71e1a385757b", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 7b39e02c0..a52892469 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -94,6 +94,10 @@ public class AsyncQuery implements PrincipalOwned {\n         this.status = status;\n     }\n \n+    public AsyncQueryResult getResult() {\n+        return result;\n+    }\n+\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex a52892469..596a673f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -74,30 +76,6 @@ public class AsyncQuery implements PrincipalOwned {\n         this.updatedOn = new Date();\n     }\n \n-    public void setResult(AsyncQueryResult result) {\n-        this.result = result;\n-    }\n-\n-    public Date getUpdatedOn() {\n-        return this.updatedOn;\n-    }\n-\n-    public Date getCreatedOn() {\n-        return this.createdOn;\n-    }\n-\n-    public QueryStatus getQueryStatus() {\n-        return status;\n-    }\n-\n-    public void setQueryStatus(QueryStatus status) {\n-        this.status = status;\n-    }\n-\n-    public AsyncQueryResult getResult() {\n-        return result;\n-    }\n-\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n", "next_change": {"commit": "1845f8caa84de070025956fffcca5e11bf741acd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 596a673f2..95bc8348b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -79,6 +80,6 @@ public class AsyncQuery implements PrincipalOwned {\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n     }\n }\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 95bc8348b..bc8eb6b76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -82,4 +85,18 @@ public class AsyncQuery implements PrincipalOwned {\n         log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n         asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+    }\n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bc8eb6b76..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = id.toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,59 +49,33 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Override\n-\tpublic String getPrincipalName() {\n-\t\treturn principalName;\n-\t}\n+    @Exclude\n+    private String principalName;\n \n     @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n-    public void setResult(AsyncQueryResult result) {\n-        this.result = result;\n-    }\n-\n-    public Date getUpdatedOn() {\n-        return this.updatedOn;\n-    }\n-\n-    public Date getCreatedOn() {\n-        return this.createdOn;\n-    }\n-\n-    public QueryStatus getQueryStatus() {\n-        return status;\n+    public void prePersistStatus() {\n+        status = QueryStatus.QUEUED;\n     }\n \n-    public void setQueryStatus(QueryStatus status) {\n-        this.status = status;\n+    @Override\n+    public String getPrincipalName() {\n+        return principalName;\n     }\n \n-    public AsyncQueryResult getResult() {\n-        return result;\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+        setPrincipalName(scope.getUser().getName());\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, (Principal) scope.getUser().getOpaqueUser(), id);\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n }\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -68,14 +59,4 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return principalName;\n     }\n-\n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n-    }\n-\n-    @OnCreatePostCommit\n-    public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n-    }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,24 +40,39 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjgzMw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385246833", "body": "What about DeletePermission?", "bodyText": "What about DeletePermission?", "bodyHTML": "<p dir=\"auto\">What about DeletePermission?</p>", "author": "aklish", "createdAt": "2020-02-27T17:07:30Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMjU5OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385312598", "bodyText": "Will make the DeletePermission as None?", "author": "moizarafat", "createdAt": "2020-02-27T19:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NjgzMw=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,40 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.security.Principal;\n-import java.util.Date;\n import java.util.UUID;\n \n import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n-import lombok.extern.slf4j.Slf4j;\n+import lombok.Data;\n \n /**\n  * Model for Async Query\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n-public class AsyncQuery implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..da84d07a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -37,6 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition=\"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex da84d07a9..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -38,7 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition=\"varchar(36)\")\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..531bb03d2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,44 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n-import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n import lombok.Data;\n-\n-import java.util.UUID;\n-\n-import javax.inject.Inject;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-import javax.persistence.Transient;\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Model for Async Query.\n+ * Model for Async Query\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n+@Include(type = \"query\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n+public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n+    //Extracted from the Principal object\n+    private String principalName;\n+\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "12232236cb3d500701eaad32a1b2b509ff207563", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 531bb03d2..596a673f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -50,7 +50,7 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne\n+    @OneToOne(mappedBy = \"query\")\n     private AsyncQueryResult result;\n \n     private Date createdOn;\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 596a673f2..88e89eba8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,31 +27,25 @@ import lombok.extern.slf4j.Slf4j;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @Slf4j\n-@Data\n public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    private UUID id; //Can be generated or provided.\n+    UUID id; //Can be generated or provided.\n \n     //Extracted from the Principal object\n-    private String principalName;\n+    String principalName;\n \n-    private String query;  //JSON-API PATH or GraphQL payload.\n+    String query;  //JSON-API PATH or GraphQL payload.\n \n-    private QueryType queryType; //GRAPHQL, JSONAPI\n+    QueryType queryType; //GRAPHQL, JSONAPI\n \n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status;\n-\n-    @OneToOne(mappedBy = \"query\")\n-    private AsyncQueryResult result;\n-\n-    private Date createdOn;\n+    QueryStatus status;\n \n-    private Date updatedOn;\n+    @OneToOne\n+    AsyncQueryResult result;\n \n-    @Inject\n-    @Transient\n-    private AsyncExecutorService asyncExecutorService;\n+    Date createdOn;\n+    Date updatedOn;\n \n     @Override\n \tpublic String getPrincipalName() {\n", "next_change": {"commit": "92a57364ba5b0c8dad63852f186398adcab90dd8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 88e89eba8..9b805d6a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -29,23 +36,24 @@ import lombok.extern.slf4j.Slf4j;\n @Slf4j\n public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    UUID id; //Can be generated or provided.\n+    private UUID id; //Can be generated or provided.\n \n     //Extracted from the Principal object\n-    String principalName;\n+    private String principalName;\n \n-    String query;  //JSON-API PATH or GraphQL payload.\n+    private String query;  //JSON-API PATH or GraphQL payload.\n \n-    QueryType queryType; //GRAPHQL, JSONAPI\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n \n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    QueryStatus status;\n+    private QueryStatus status;\n \n     @OneToOne\n-    AsyncQueryResult result;\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n \n-    Date createdOn;\n-    Date updatedOn;\n+    private Date updatedOn;\n \n     @Override\n \tpublic String getPrincipalName() {\n", "next_change": {"commit": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 9b805d6a9..7b39e02c0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -55,6 +55,10 @@ public class AsyncQuery implements PrincipalOwned {\n \n     private Date updatedOn;\n \n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n     @Override\n \tpublic String getPrincipalName() {\n \t\treturn principalName;\n", "next_change": {"commit": "510ec3c07ac159cc9688a6416686b33672895234", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 7b39e02c0..9cabfa092 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -60,9 +64,9 @@ public class AsyncQuery implements PrincipalOwned {\n     private AsyncExecutorService asyncExecutorService;\n \n     @Override\n-\tpublic String getPrincipalName() {\n-\t\treturn principalName;\n-\t}\n+    public String getPrincipalName() {\n+        return principalName;\n+    }\n \n     @PrePersist\n     public void prePersist() {\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 9cabfa092..bc8eb6b76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,6 +62,9 @@ public class AsyncQuery implements PrincipalOwned {\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n+    @Transient\n+    protected String naturalKey = id.toString();\n+\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "f4fdcf277bd434ac388b28a36dae9167804d4895", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bc8eb6b76..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,7 +63,7 @@ public class AsyncQuery implements PrincipalOwned {\n     private AsyncExecutorService asyncExecutorService;\n \n     @Transient\n-    protected String naturalKey = id.toString();\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n     public String getPrincipalName() {\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..065a844f4 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -62,7 +60,10 @@ public class AsyncQuery implements PrincipalOwned {\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n+    @Exclude\n+    private String principalName;\n+\n+    @Exclude\n     protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 065a844f4..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,24 +56,11 @@ public class AsyncQuery implements PrincipalOwned {\n     @Exclude\n     private String principalName;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n     \tsetPrincipalName(scope.getUser().getName());\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,43 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.security.Principal;\n-import java.util.Date;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+\n import java.util.UUID;\n \n import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.OnCreatePostCommit;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-import com.yahoo.elide.async.service.AsyncExecutorService;\n-import com.yahoo.elide.core.RequestScope;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n /**\n- * Model for Async Query\n+ * Model for Async Query.\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n-public class AsyncQuery implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -40,7 +35,7 @@ import javax.persistence.Transient;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Can be generated or provided.\n+    private UUID id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..2443509aa 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,7 +35,9 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+            message = \"id not of pattern UUID\")\n+    private String id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 2443509aa..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -36,25 +41,38 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n     @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-            message = \"id not of pattern UUID\")\n-    private String id; //Provided.\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzAzMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385247031", "body": "What about DeletePermission", "bodyText": "What about DeletePermission", "bodyHTML": "<p dir=\"auto\">What about DeletePermission</p>", "author": "aklish", "createdAt": "2020-02-27T17:07:49Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+public class AsyncQueryResult implements PrincipalOwned {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMjk1NA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385312954", "bodyText": "Should we set the DeletePermission as None for the AsyncQueryResult ?", "author": "Abhino", "createdAt": "2020-02-27T19:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,30 +5,32 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.util.Date;\n import java.util.UUID;\n \n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n \n import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n+import lombok.Data;\n+\n /**\n  * Model for Async Query Result\n  */\n @Entity\n-@Include(type=\"queryResult\")\n+@Include(type=\"asyncQueryResult\")\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n-public class AsyncQueryResult implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     @Id\n     private UUID id; //Matches UUID in query.\n \n", "next_change": {"commit": "4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex a8eba3d7e..43ae83cee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -32,6 +33,7 @@ import lombok.Data;\n @Data\n public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition=\"varchar(36)\")\n     private UUID id; //Matches UUID in query.\n \n     private Integer contentLength;\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 43ae83cee..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -33,7 +33,7 @@ import lombok.Data;\n @Data\n public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition=\"varchar(36)\")\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Matches UUID in query.\n \n     private Integer contentLength;\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -14,26 +22,17 @@ import com.yahoo.elide.annotation.UpdatePermission;\n \n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-\n /**\n- * Model for Async Query Result.\n+ * Model for Async Query Result\n  */\n @Entity\n-@Include(type = \"asyncQueryResult\")\n+@Include(type=\"queryResult\")\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n+public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Matches UUID in query.\n \n     private Integer contentLength;\n", "next_change": {"commit": "993f2510bdc2c8ce895b82001d2128d55ecbae4f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..45397a797 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -30,6 +31,7 @@ import lombok.Data;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 45397a797..1fe8f4448 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -31,24 +23,21 @@ import lombok.Data;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n-@Data\n public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n-    private UUID id; //Matches UUID in query.\n+    UUID id; //Matches UUID in query.\n \n-    private Integer contentLength;\n+    Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    String responseBody; //success or errors\n \n-    private Integer status; // HTTP Status\n+    Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n+    Date createdOn;\n+    Date updatedOn;\n \n     @OneToOne\n-    private AsyncQuery query;\n+    AsyncQuery query;\n \n     @Exclude\n     public String getPrincipalName() {\n", "next_change": {"commit": "92a57364ba5b0c8dad63852f186398adcab90dd8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 1fe8f4448..f59992f9a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -25,19 +30,20 @@ import com.yahoo.elide.annotation.UpdatePermission;\n @CreatePermission(expression = \"Prefab.Role.None\")\n public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n-    UUID id; //Matches UUID in query.\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n \n-    Integer contentLength;\n+    private String responseBody; //success or errors\n \n-    String responseBody; //success or errors\n+    private Integer status; // HTTP Status\n \n-    Integer status; // HTTP Status\n+    private Date createdOn;\n \n-    Date createdOn;\n-    Date updatedOn;\n+    private Date updatedOn;\n \n     @OneToOne\n-    AsyncQuery query;\n+    private AsyncQuery query;\n \n     @Exclude\n     public String getPrincipalName() {\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex f59992f9a..d44a8f341 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -42,6 +48,9 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Date updatedOn;\n \n+    @Transient\n+    protected String naturalKey = id.toString();\n+\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "f4fdcf277bd434ac388b28a36dae9167804d4895", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex d44a8f341..7487cb92c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,7 +49,7 @@ public class AsyncQueryResult implements PrincipalOwned {\n     private Date updatedOn;\n \n     @Transient\n-    protected String naturalKey = id.toString();\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @OneToOne\n     private AsyncQuery query;\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 7487cb92c..9eb57da04 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,12 +47,12 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Date updatedOn;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @OneToOne\n     private AsyncQuery query;\n \n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9eb57da04..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -43,42 +40,12 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -42,6 +41,10 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..1fe8f4448 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -30,23 +23,21 @@ import lombok.Data;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n-@Data\n public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n-    private UUID id; //Matches UUID in query.\n+    UUID id; //Matches UUID in query.\n \n-    private Integer contentLength;\n+    Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    String responseBody; //success or errors\n \n-    private Integer status; // HTTP Status\n+    Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n+    Date createdOn;\n+    Date updatedOn;\n \n     @OneToOne\n-    private AsyncQuery query;\n+    AsyncQuery query;\n \n     @Exclude\n     public String getPrincipalName() {\n", "next_change": {"commit": "92a57364ba5b0c8dad63852f186398adcab90dd8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 1fe8f4448..f59992f9a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -25,19 +30,20 @@ import com.yahoo.elide.annotation.UpdatePermission;\n @CreatePermission(expression = \"Prefab.Role.None\")\n public class AsyncQueryResult implements PrincipalOwned {\n     @Id\n-    UUID id; //Matches UUID in query.\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n \n-    Integer contentLength;\n+    private String responseBody; //success or errors\n \n-    String responseBody; //success or errors\n+    private Integer status; // HTTP Status\n \n-    Integer status; // HTTP Status\n+    private Date createdOn;\n \n-    Date createdOn;\n-    Date updatedOn;\n+    private Date updatedOn;\n \n     @OneToOne\n-    AsyncQuery query;\n+    private AsyncQuery query;\n \n     @Exclude\n     public String getPrincipalName() {\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex f59992f9a..d44a8f341 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -42,6 +48,9 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Date updatedOn;\n \n+    @Transient\n+    protected String naturalKey = id.toString();\n+\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "f4fdcf277bd434ac388b28a36dae9167804d4895", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex d44a8f341..7487cb92c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,7 +49,7 @@ public class AsyncQueryResult implements PrincipalOwned {\n     private Date updatedOn;\n \n     @Transient\n-    protected String naturalKey = id.toString();\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @OneToOne\n     private AsyncQuery query;\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 7487cb92c..9eb57da04 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,12 +47,12 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Date updatedOn;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @OneToOne\n     private AsyncQuery query;\n \n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9eb57da04..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -43,42 +40,12 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,31 +5,35 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.util.Date;\n-import java.util.UUID;\n-\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n-\n import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n+import lombok.Data;\n+\n+import java.util.UUID;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+\n /**\n- * Model for Async Query Result\n+ * Model for Async Query Result.\n  */\n @Entity\n-@Include(type=\"queryResult\")\n+@Include(type = \"asyncQueryResult\")\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @CreatePermission(expression = \"Prefab.Role.None\")\n-public class AsyncQueryResult implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Matches UUID in query.\n \n     private Integer contentLength;\n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..fc3e19205 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -34,7 +32,7 @@ import javax.persistence.OneToOne;\n public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Matches UUID in query.\n+    private String id; //Matches id in query.\n \n     private Integer contentLength;\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex fc3e19205..05e163c2b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,46 +5,31 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.CreatePermission;\n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-\n import lombok.Data;\n \n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n+import java.util.Date;\n+\n+import javax.persistence.Embeddable;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n \n /**\n  * Model for Async Query Result.\n  */\n-@Entity\n-@Include(type = \"asyncQueryResult\")\n-@ReadPermission(expression = \"Principal is Owner\")\n-@UpdatePermission(expression = \"Prefab.Role.None\")\n-@CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Embeddable\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    private String id; //Matches id in query.\n+\n+public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    private String responseBody;  //URL or Response body\n+\n+    private Integer httpStatus; // HTTP Status\n \n-    private Integer status; // HTTP Status\n+    @Enumerated(EnumType.STRING)\n+    private ResultType resultType; //EMBEDDED, DOWNLOAD\n \n-    @OneToOne\n-    private AsyncQuery query;\n+    private Date completedOn = new Date();\n \n-    @Exclude\n-    public String getPrincipalName() {\n-        return query.getPrincipalName();\n-    }\n }\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 05e163c2b..9d83aaf8f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -23,13 +21,12 @@ public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n+    private Integer recordCount;\n+\n     private String responseBody;  //URL or Response body\n \n     private Integer httpStatus; // HTTP Status\n \n-    @Enumerated(EnumType.STRING)\n-    private ResultType resultType; //EMBEDDED, DOWNLOAD\n-\n     private Date completedOn = new Date();\n \n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9d83aaf8f..b7bba5fc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -16,17 +14,8 @@ import javax.persistence.Embeddable;\n  */\n @Embeddable\n @Data\n-\n-public class AsyncQueryResult {\n-\n+public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n-    private Integer recordCount;\n-\n     private String responseBody;  //URL or Response body\n-\n-    private Integer httpStatus; // HTTP Status\n-\n-    private Date completedOn = new Date();\n-\n }\n", "next_change": {"commit": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex b7bba5fc1..6fd4e986c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -17,5 +18,6 @@ import javax.persistence.Embeddable;\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n+    @Lob\n     private String responseBody;  //URL or Response body\n }\n", "next_change": {"commit": "80060c6b960497b346c7325408dcc2459bbdfd70", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6fd4e986c..3be5b3f38 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -15,6 +16,7 @@ import javax.persistence.Lob;\n  */\n @Embeddable\n @Data\n+@EqualsAndHashCode(callSuper = true)\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n", "next_change": null}]}}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1708)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0NzIyOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385247229", "body": "Let's use lombok to remove getters & setters.", "bodyText": "Let's use lombok to remove getters & setters.", "bodyHTML": "<p dir=\"auto\">Let's use lombok to remove getters &amp; setters.</p>", "author": "aklish", "createdAt": "2020-02-27T17:08:13Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @OneToOne\n+    private AsyncQuery query;\n+\n+    @Exclude\n+    public String getPrincipalName() {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -38,10 +40,6 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex a8eba3d7e..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -47,5 +49,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,4 +52,14 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..1fe8f4448 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -62,4 +53,24 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n+\n+    public void setContentLength(Integer contentLength) {\n+        this.contentLength = contentLength;\n+    }\n+\n+    public void setResponseBody(String responseBody) {\n+        this.responseBody = responseBody;\n+    }\n+\n+    public void setStatus(Integer status) {\n+        this.status = status;\n+    }\n+\n+    public void setQuery(AsyncQuery query) {\n+        this.query = query;\n+    }\n+\n+    public void setId(UUID id) {\n+        this.id = id;\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 1fe8f4448..3f1cd64d0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -73,4 +79,40 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void setId(UUID id) {\n         this.id = id;\n     }\n+\n+\tpublic Date getCreatedOn() {\n+\t\treturn createdOn;\n+\t}\n+\n+\tpublic void setCreatedOn(Date createdOn) {\n+\t\tthis.createdOn = createdOn;\n+\t}\n+\n+\tpublic Date getUpdatedOn() {\n+\t\treturn updatedOn;\n+\t}\n+\n+\tpublic void setUpdatedOn(Date updatedOn) {\n+\t\tthis.updatedOn = updatedOn;\n+\t}\n+\n+\tpublic UUID getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic Integer getContentLength() {\n+\t\treturn contentLength;\n+\t}\n+\n+\tpublic String getResponseBody() {\n+\t\treturn responseBody;\n+\t}\n+\n+\tpublic Integer getStatus() {\n+\t\treturn status;\n+\t}\n+\n+\tpublic AsyncQuery getQuery() {\n+\t\treturn query;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -59,60 +62,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n-\n-    public void setContentLength(Integer contentLength) {\n-        this.contentLength = contentLength;\n-    }\n-\n-    public void setResponseBody(String responseBody) {\n-        this.responseBody = responseBody;\n-    }\n-\n-    public void setStatus(Integer status) {\n-        this.status = status;\n-    }\n-\n-    public void setQuery(AsyncQuery query) {\n-        this.query = query;\n-    }\n-\n-    public void setId(UUID id) {\n-        this.id = id;\n-    }\n-\n-\tpublic Date getCreatedOn() {\n-\t\treturn createdOn;\n-\t}\n-\n-\tpublic void setCreatedOn(Date createdOn) {\n-\t\tthis.createdOn = createdOn;\n-\t}\n-\n-\tpublic Date getUpdatedOn() {\n-\t\treturn updatedOn;\n-\t}\n-\n-\tpublic void setUpdatedOn(Date updatedOn) {\n-\t\tthis.updatedOn = updatedOn;\n-\t}\n-\n-\tpublic UUID getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic Integer getContentLength() {\n-\t\treturn contentLength;\n-\t}\n-\n-\tpublic String getResponseBody() {\n-\t\treturn responseBody;\n-\t}\n-\n-\tpublic Integer getStatus() {\n-\t\treturn status;\n-\t}\n-\n-\tpublic AsyncQuery getQuery() {\n-\t\treturn query;\n-\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..d44a8f341 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -62,4 +68,18 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex d44a8f341..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -59,27 +48,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -50,69 +48,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    public void setContentLength(Integer contentLength) {\n-        this.contentLength = contentLength;\n-    }\n-\n-    public void setResponseBody(String responseBody) {\n-        this.responseBody = responseBody;\n-    }\n-\n-    public void setStatus(Integer status) {\n-        this.status = status;\n-    }\n-\n-    public void setQuery(AsyncQuery query) {\n-        this.query = query;\n-    }\n-\n-    public void setId(UUID id) {\n-        this.id = id;\n-    }\n-\n-\tpublic Date getCreatedOn() {\n-\t\treturn createdOn;\n-\t}\n-\n-\tpublic void setCreatedOn(Date createdOn) {\n-\t\tthis.createdOn = createdOn;\n-\t}\n-\n-\tpublic Date getUpdatedOn() {\n-\t\treturn updatedOn;\n-\t}\n-\n-\tpublic void setUpdatedOn(Date updatedOn) {\n-\t\tthis.updatedOn = updatedOn;\n-\t}\n-\n-\tpublic UUID getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic Integer getContentLength() {\n-\t\treturn contentLength;\n-\t}\n-\n-\tpublic String getResponseBody() {\n-\t\treturn responseBody;\n-\t}\n-\n-\tpublic Integer getStatus() {\n-\t\treturn status;\n-\t}\n-\n-\tpublic AsyncQuery getQuery() {\n-\t\treturn query;\n-\t}\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex a8eba3d7e..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -47,5 +49,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,4 +52,14 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..1fe8f4448 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -62,4 +53,24 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n+\n+    public void setContentLength(Integer contentLength) {\n+        this.contentLength = contentLength;\n+    }\n+\n+    public void setResponseBody(String responseBody) {\n+        this.responseBody = responseBody;\n+    }\n+\n+    public void setStatus(Integer status) {\n+        this.status = status;\n+    }\n+\n+    public void setQuery(AsyncQuery query) {\n+        this.query = query;\n+    }\n+\n+    public void setId(UUID id) {\n+        this.id = id;\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 1fe8f4448..3f1cd64d0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -73,4 +79,40 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void setId(UUID id) {\n         this.id = id;\n     }\n+\n+\tpublic Date getCreatedOn() {\n+\t\treturn createdOn;\n+\t}\n+\n+\tpublic void setCreatedOn(Date createdOn) {\n+\t\tthis.createdOn = createdOn;\n+\t}\n+\n+\tpublic Date getUpdatedOn() {\n+\t\treturn updatedOn;\n+\t}\n+\n+\tpublic void setUpdatedOn(Date updatedOn) {\n+\t\tthis.updatedOn = updatedOn;\n+\t}\n+\n+\tpublic UUID getId() {\n+\t\treturn id;\n+\t}\n+\n+\tpublic Integer getContentLength() {\n+\t\treturn contentLength;\n+\t}\n+\n+\tpublic String getResponseBody() {\n+\t\treturn responseBody;\n+\t}\n+\n+\tpublic Integer getStatus() {\n+\t\treturn status;\n+\t}\n+\n+\tpublic AsyncQuery getQuery() {\n+\t\treturn query;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..6c9cff63d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -59,60 +62,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n-\n-    public void setContentLength(Integer contentLength) {\n-        this.contentLength = contentLength;\n-    }\n-\n-    public void setResponseBody(String responseBody) {\n-        this.responseBody = responseBody;\n-    }\n-\n-    public void setStatus(Integer status) {\n-        this.status = status;\n-    }\n-\n-    public void setQuery(AsyncQuery query) {\n-        this.query = query;\n-    }\n-\n-    public void setId(UUID id) {\n-        this.id = id;\n-    }\n-\n-\tpublic Date getCreatedOn() {\n-\t\treturn createdOn;\n-\t}\n-\n-\tpublic void setCreatedOn(Date createdOn) {\n-\t\tthis.createdOn = createdOn;\n-\t}\n-\n-\tpublic Date getUpdatedOn() {\n-\t\treturn updatedOn;\n-\t}\n-\n-\tpublic void setUpdatedOn(Date updatedOn) {\n-\t\tthis.updatedOn = updatedOn;\n-\t}\n-\n-\tpublic UUID getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic Integer getContentLength() {\n-\t\treturn contentLength;\n-\t}\n-\n-\tpublic String getResponseBody() {\n-\t\treturn responseBody;\n-\t}\n-\n-\tpublic Integer getStatus() {\n-\t\treturn status;\n-\t}\n-\n-\tpublic AsyncQuery getQuery() {\n-\t\treturn query;\n-\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6c9cff63d..d44a8f341 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -62,4 +68,18 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public void preUpdate() {\n         updatedOn = new Date();\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex d44a8f341..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -59,27 +48,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -38,10 +42,6 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..05e163c2b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,48 +5,31 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.CreatePermission;\n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n+import java.util.Date;\n \n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n \n /**\n  * Model for Async Query Result.\n  */\n-@Entity\n-@Include(type = \"asyncQueryResult\")\n-@ReadPermission(expression = \"Principal is Owner\")\n-@UpdatePermission(expression = \"Prefab.Role.None\")\n-@CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Embeddable\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Matches UUID in query.\n+\n+public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    private String responseBody;  //URL or Response body\n+\n+    private Integer httpStatus; // HTTP Status\n \n-    private Integer status; // HTTP Status\n+    @Enumerated(EnumType.STRING)\n+    private ResultType resultType; //EMBEDDED, DOWNLOAD\n \n-    @OneToOne\n-    private AsyncQuery query;\n+    private Date completedOn = new Date();\n \n-    @Exclude\n-    public String getPrincipalName() {\n-        return query.getPrincipalName();\n-    }\n }\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 05e163c2b..9d83aaf8f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -23,13 +21,12 @@ public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n+    private Integer recordCount;\n+\n     private String responseBody;  //URL or Response body\n \n     private Integer httpStatus; // HTTP Status\n \n-    @Enumerated(EnumType.STRING)\n-    private ResultType resultType; //EMBEDDED, DOWNLOAD\n-\n     private Date completedOn = new Date();\n \n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9d83aaf8f..b7bba5fc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -16,17 +14,8 @@ import javax.persistence.Embeddable;\n  */\n @Embeddable\n @Data\n-\n-public class AsyncQueryResult {\n-\n+public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n-    private Integer recordCount;\n-\n     private String responseBody;  //URL or Response body\n-\n-    private Integer httpStatus; // HTTP Status\n-\n-    private Date completedOn = new Date();\n-\n }\n", "next_change": {"commit": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex b7bba5fc1..6fd4e986c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -17,5 +18,6 @@ import javax.persistence.Embeddable;\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n+    @Lob\n     private String responseBody;  //URL or Response body\n }\n", "next_change": {"commit": "80060c6b960497b346c7325408dcc2459bbdfd70", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6fd4e986c..3be5b3f38 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -15,6 +16,7 @@ import javax.persistence.Lob;\n  */\n @Embeddable\n @Data\n+@EqualsAndHashCode(callSuper = true)\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 3f1cd64d0..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,70 +49,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    public void setContentLength(Integer contentLength) {\n-        this.contentLength = contentLength;\n-    }\n-\n-    public void setResponseBody(String responseBody) {\n-        this.responseBody = responseBody;\n-    }\n-\n-    public void setStatus(Integer status) {\n-        this.status = status;\n-    }\n-\n-    public void setQuery(AsyncQuery query) {\n-        this.query = query;\n-    }\n-\n-    public void setId(UUID id) {\n-        this.id = id;\n-    }\n-\n-\tpublic Date getCreatedOn() {\n-\t\treturn createdOn;\n-\t}\n-\n-\tpublic void setCreatedOn(Date createdOn) {\n-\t\tthis.createdOn = createdOn;\n-\t}\n-\n-\tpublic Date getUpdatedOn() {\n-\t\treturn updatedOn;\n-\t}\n-\n-\tpublic void setUpdatedOn(Date updatedOn) {\n-\t\tthis.updatedOn = updatedOn;\n-\t}\n-\n-\tpublic UUID getId() {\n-\t\treturn id;\n-\t}\n-\n-\tpublic Integer getContentLength() {\n-\t\treturn contentLength;\n-\t}\n-\n-\tpublic String getResponseBody() {\n-\t\treturn responseBody;\n-\t}\n-\n-\tpublic Integer getStatus() {\n-\t\treturn status;\n-\t}\n-\n-\tpublic AsyncQuery getQuery() {\n-\t\treturn query;\n-\t}\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..05e163c2b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,48 +5,31 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.CreatePermission;\n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n+import java.util.Date;\n \n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n \n /**\n  * Model for Async Query Result.\n  */\n-@Entity\n-@Include(type = \"asyncQueryResult\")\n-@ReadPermission(expression = \"Principal is Owner\")\n-@UpdatePermission(expression = \"Prefab.Role.None\")\n-@CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Embeddable\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Matches UUID in query.\n+\n+public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    private String responseBody;  //URL or Response body\n+\n+    private Integer httpStatus; // HTTP Status\n \n-    private Integer status; // HTTP Status\n+    @Enumerated(EnumType.STRING)\n+    private ResultType resultType; //EMBEDDED, DOWNLOAD\n \n-    @OneToOne\n-    private AsyncQuery query;\n+    private Date completedOn = new Date();\n \n-    @Exclude\n-    public String getPrincipalName() {\n-        return query.getPrincipalName();\n-    }\n }\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 05e163c2b..9d83aaf8f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -23,13 +21,12 @@ public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n+    private Integer recordCount;\n+\n     private String responseBody;  //URL or Response body\n \n     private Integer httpStatus; // HTTP Status\n \n-    @Enumerated(EnumType.STRING)\n-    private ResultType resultType; //EMBEDDED, DOWNLOAD\n-\n     private Date completedOn = new Date();\n \n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9d83aaf8f..b7bba5fc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -16,17 +14,8 @@ import javax.persistence.Embeddable;\n  */\n @Embeddable\n @Data\n-\n-public class AsyncQueryResult {\n-\n+public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n-    private Integer recordCount;\n-\n     private String responseBody;  //URL or Response body\n-\n-    private Integer httpStatus; // HTTP Status\n-\n-    private Date completedOn = new Date();\n-\n }\n", "next_change": {"commit": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex b7bba5fc1..6fd4e986c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -17,5 +18,6 @@ import javax.persistence.Embeddable;\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n+    @Lob\n     private String responseBody;  //URL or Response body\n }\n", "next_change": {"commit": "80060c6b960497b346c7325408dcc2459bbdfd70", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6fd4e986c..3be5b3f38 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -15,6 +16,7 @@ import javax.persistence.Lob;\n  */\n @Embeddable\n @Data\n+@EqualsAndHashCode(callSuper = true)\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1708)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0ODM3MQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385248371", "body": "Cast to PrincipalOwned.  Then you don't need to handle the two cases differently.  \r\n\r\nAlso - let's file a ticket to move this to a FilterExpressionCheck", "bodyText": "Cast to PrincipalOwned.  Then you don't need to handle the two cases differently.\nAlso - let's file a ticket to move this to a FilterExpressionCheck", "bodyHTML": "<p dir=\"auto\">Cast to PrincipalOwned.  Then you don't need to handle the two cases differently.</p>\n<p dir=\"auto\">Also - let's file a ticket to move this to a FilterExpressionCheck</p>", "author": "aklish", "createdAt": "2020-02-27T17:10:05Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models.security;\n+\n+import java.security.Principal;\n+import java.util.Optional;\n+\n+import com.yahoo.elide.annotation.SecurityCheck;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.security.ChangeSpec;\n+import com.yahoo.elide.security.RequestScope;\n+import com.yahoo.elide.security.checks.OperationCheck;\n+\n+/**\n+ * Operation Checks on the Async Query and Result objects.\n+ */\n+public class AsyncQueryOperationChecks {\n+    @SecurityCheck(AsyncQueryOwner.PRINCIPAL_IS_OWNER)\n+    public static class AsyncQueryOwner extends OperationCheck<Object> {\n+\n+        public static final String PRINCIPAL_IS_OWNER = \"Principal is Owner\";\n+\n+        @Override\n+        public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n+            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n+\n+            if(object.getClass().equals(AsyncQuery.class)) {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2MTQzNw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385461437", "bodyText": "I can not remember the reason, but can you explain what will be the advantage of moving this to FilterExpressionCheck vs the OperationCheck?", "author": "moizarafat", "createdAt": "2020-02-28T01:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI0ODM3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nindex 6aae80870..29dd066ca 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -27,13 +27,8 @@ public class AsyncQueryOperationChecks {\n \n         @Override\n         public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n-            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n-\n-            if(object.getClass().equals(AsyncQuery.class)) {\n-                return ((AsyncQuery) object).getPrincipalName().equals(principal.getName());\n-            } else {\n-                return ((AsyncQueryResult) object).getPrincipalName().equals(principal.getName());\n-            }\n+            Principal principal = requestScope.getUser().getPrincipal();\n+            return ((PrincipalOwned) object).getPrincipalName().equals(principal.getName());\n         }\n     }\n \n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nindex 29dd066ca..4557c052f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -27,7 +28,7 @@ public class AsyncQueryOperationChecks {\n \n         @Override\n         public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n-            Principal principal = requestScope.getUser().getPrincipal();\n+            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n             return ((PrincipalOwned) object).getPrincipalName().equals(principal.getName());\n         }\n     }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\ndeleted file mode 100644\nindex 4557c052f..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ /dev/null\n", "chunk": "@@ -1,46 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.models.security;\n-\n-import java.security.Principal;\n-import java.util.Optional;\n-\n-import com.yahoo.elide.annotation.SecurityCheck;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.PrincipalOwned;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.security.ChangeSpec;\n-import com.yahoo.elide.security.RequestScope;\n-import com.yahoo.elide.security.checks.OperationCheck;\n-\n-/**\n- * Operation Checks on the Async Query and Result objects.\n- */\n-public class AsyncQueryOperationChecks {\n-    @SecurityCheck(AsyncQueryOwner.PRINCIPAL_IS_OWNER)\n-    public static class AsyncQueryOwner extends OperationCheck<Object> {\n-\n-        public static final String PRINCIPAL_IS_OWNER = \"Principal is Owner\";\n-\n-        @Override\n-        public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n-            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n-            return ((PrincipalOwned) object).getPrincipalName().equals(principal.getName());\n-        }\n-    }\n-\n-    @SecurityCheck(AsyncQueryStatusValue.VALUE_IS_CANCELLED)\n-    public static class AsyncQueryStatusValue extends OperationCheck<AsyncQuery> {\n-\n-        public static final String VALUE_IS_CANCELLED = \"value is Cancelled\";\n-\n-        @Override\n-        public boolean ok(AsyncQuery object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n-            return changeSpec.get().getModified().toString().equals(QueryStatus.CANCELLED.name());\n-        }\n-    }\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nnew file mode 100644\nindex 000000000..f7477cb9f\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -0,0 +1,45 @@\n+package com.yahoo.elide.async.models.security;\n+\n+import java.security.Principal;\n+import java.util.Optional;\n+\n+import com.yahoo.elide.annotation.SecurityCheck;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.security.ChangeSpec;\n+import com.yahoo.elide.security.RequestScope;\n+import com.yahoo.elide.security.checks.OperationCheck;\n+\n+/**\n+ * Operation Checks on the Async Query and Result objects.\n+ */\n+public class AsyncQueryOperationChecks {\n+    @SecurityCheck(AsyncQueryOwner.PRINCIPAL_IS_OWNER)\n+    public static class AsyncQueryOwner extends OperationCheck<Object> {\n+\n+        public static final String PRINCIPAL_IS_OWNER = \"Principal is Owner\";\n+\n+        @Override\n+        public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n+            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n+\n+            if(object.getClass().equals(AsyncQuery.class)) {\n+                return ((AsyncQuery) object).getPrincipalName().equals(principal.getName());\n+            } else {\n+                return ((AsyncQueryResult) object).getPrincipalName().equals(principal.getName());\n+            }\n+        }\n+    }\n+\n+    @SecurityCheck(AsyncQueryStatusValue.VALUE_IS_CANCELLED)\n+    public static class AsyncQueryStatusValue extends OperationCheck<AsyncQuery> {\n+\n+        public static final String VALUE_IS_CANCELLED = \"value is Cancelled\";\n+\n+        @Override\n+        public boolean ok(AsyncQuery object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n+            return changeSpec.get().getModified().toString().equals(QueryStatus.CANCELLED.name());\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nindex 6aae80870..cb9a87b7a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -27,13 +27,8 @@ public class AsyncQueryOperationChecks {\n \n         @Override\n         public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n-            Principal principal = ((Principal) requestScope.getUser().getOpaqueUser());\n-\n-            if(object.getClass().equals(AsyncQuery.class)) {\n-                return ((AsyncQuery) object).getPrincipalName().equals(principal.getName());\n-            } else {\n-                return ((AsyncQueryResult) object).getPrincipalName().equals(principal.getName());\n-            }\n+            Principal principal = requestScope.getUser().getPrincipal();\n+            return ((PrincipalOwned) object).getPrincipalName().equals(principal.getName());\n         }\n     }\n \n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nindex cb9a87b7a..24477afaf 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -28,7 +28,14 @@ public class AsyncQueryOperationChecks {\n         @Override\n         public boolean ok(Object object, RequestScope requestScope, Optional<ChangeSpec> changeSpec) {\n             Principal principal = requestScope.getUser().getPrincipal();\n-            return ((PrincipalOwned) object).getPrincipalName().equals(principal.getName());\n+            boolean status = false;\n+            String principalName = ((PrincipalOwned) object).getPrincipalName();\n+            if (principalName == null && (principal == null || principal.getName() == null)) {\n+                status = true;\n+            } else {\n+                status = principalName.equals(principal.getName());\n+            }\n+            return status;\n         }\n     }\n \n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nindex 24477afaf..411fb93d2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n", "chunk": "@@ -32,7 +32,7 @@ public class AsyncQueryOperationChecks {\n             String principalName = ((PrincipalOwned) object).getPrincipalName();\n             if (principalName == null && (principal == null || principal.getName() == null)) {\n                 status = true;\n-            } else {\n+            } else if (principalName != null && principal != null && principal.getName() != null) {\n                 status = principalName.equals(principal.getName());\n             }\n             return status;\n", "next_change": {"commit": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryInlineChecks.java\nsimilarity index 66%\nrename from elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryInlineChecks.java\nindex 411fb93d2..10b739af2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryOperationChecks.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/security/AsyncQueryInlineChecks.java\n", "chunk": "@@ -39,6 +41,20 @@ public class AsyncQueryOperationChecks {\n         }\n     }\n \n+    @SecurityCheck(AsyncQueryAdmin.PRINCIPAL_IS_ADMIN)\n+    public static class AsyncQueryAdmin extends UserCheck {\n+\n+        public static final String PRINCIPAL_IS_ADMIN = \"Principal is Admin\";\n+\n+        @Override\n+        public boolean ok(User user) {\n+            if (user != null && user.getPrincipal() != null) {\n+                return user.isInRole(\"admin\");\n+            }\n+            return false;\n+        }\n+    }\n+\n     @SecurityCheck(AsyncQueryStatusValue.VALUE_IS_CANCELLED)\n     public static class AsyncQueryStatusValue extends OperationCheck<AsyncQuery> {\n \n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MTE0OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385251148", "body": "Move all this math to a separate function:\r\n\r\n```java\r\nboolean isTimedOut(AsyncQuery query) { .. }\r\n```", "bodyText": "Move all this math to a separate function:\nboolean isTimedOut(AsyncQuery query) { .. }", "bodyHTML": "<p dir=\"auto\">Move all this math to a separate function:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"boolean isTimedOut(AsyncQuery query) { .. }\"><pre><span class=\"pl-k\">boolean</span> isTimedOut(<span class=\"pl-smi\">AsyncQuery</span> query) { <span class=\"pl-c1\">..</span> }</pre></div>", "author": "aklish", "createdAt": "2020-02-27T17:14:19Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -48,48 +44,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -27,59 +34,70 @@ import java.util.Date;\n @AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTimeMinutes;\n+    private int maxRunTime;\n     private Elide elide;\n-    private int queryCleanupDays;\n-    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n-        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n \n-    }\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            long currentTime = new Date().getTime();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n \n-    /**\n-     * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n-\n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+                if(isTimedOut(currentTime, query)) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "91f71412e524f9d469df5e0abd86917b2ff58da4", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\ndeleted file mode 100644\nindex d01de2318..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ /dev/null\n", "chunk": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for updating AsyncQueryThread status\n- * beyond the max run time and if not terminated by interrupt process\n- * due to app/host crash or restart.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryCleanerThread implements Runnable {\n-\n-    private int maxRunTimeMinutes;\n-    private Elide elide;\n-\n-    @Override\n-    public void run() {\n-        timeoutAsyncQuery();\n-    }\n-\n-    /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nnew file mode 100644\nindex 000000000..980ea1495\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -0,0 +1,90 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    int maxRunTime;\n+    Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 980ea1495..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -87,4 +88,16 @@ public class AsyncQueryCleanerThread implements Runnable {\n             }\n         }\n     }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "0c9e427d8e81871808703670b16c472ca851512d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "ada611df1d33adab5d052d0be4957a7fbb02b405", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex d01de2318..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -46,51 +47,72 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n     }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);\n+            });\n     }\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -5,91 +5,81 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n /**\n- * Runnable thread for updating AsyncQueryThread status\n+ * Runnable thread for updating AsyncQueryThread status.\n  * beyond the max run time and if not terminated by interrupt process\n  * due to app/host crash or restart.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTime;\n+    private int maxRunTimeMinutes;\n     private Elide elide;\n-\n-    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n-        log.debug(\"New Async Query Cleaner thread created\");\n-        this.maxRunTime = maxRunTime;\n-        this.elide = elide;\n-    }\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n+        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+    }\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    /**\n+     * This method updates the status of long running async query which\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MTM2OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385251368", "body": "Do the date.getTime outside the loop once.  There could be a lot of records.", "bodyText": "Do the date.getTime outside the loop once.  There could be a lot of records.", "bodyHTML": "<p dir=\"auto\">Do the date.getTime outside the loop once.  There could be a lot of records.</p>", "author": "aklish", "createdAt": "2020-02-27T17:14:44Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -48,48 +44,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -27,59 +34,70 @@ import java.util.Date;\n @AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTimeMinutes;\n+    private int maxRunTime;\n     private Elide elide;\n-    private int queryCleanupDays;\n-    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n-        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n \n-    }\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            long currentTime = new Date().getTime();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n \n-    /**\n-     * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n-\n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+                if(isTimedOut(currentTime, query)) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "91f71412e524f9d469df5e0abd86917b2ff58da4", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\ndeleted file mode 100644\nindex d01de2318..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ /dev/null\n", "chunk": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for updating AsyncQueryThread status\n- * beyond the max run time and if not terminated by interrupt process\n- * due to app/host crash or restart.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryCleanerThread implements Runnable {\n-\n-    private int maxRunTimeMinutes;\n-    private Elide elide;\n-\n-    @Override\n-    public void run() {\n-        timeoutAsyncQuery();\n-    }\n-\n-    /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nnew file mode 100644\nindex 000000000..980ea1495\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -0,0 +1,90 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    int maxRunTime;\n+    Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 980ea1495..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -87,4 +88,16 @@ public class AsyncQueryCleanerThread implements Runnable {\n             }\n         }\n     }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "0c9e427d8e81871808703670b16c472ca851512d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "ada611df1d33adab5d052d0be4957a7fbb02b405", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex d01de2318..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -46,51 +47,72 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n     }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);\n+            });\n     }\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -5,91 +5,81 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n /**\n- * Runnable thread for updating AsyncQueryThread status\n+ * Runnable thread for updating AsyncQueryThread status.\n  * beyond the max run time and if not terminated by interrupt process\n  * due to app/host crash or restart.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTime;\n+    private int maxRunTimeMinutes;\n     private Elide elide;\n-\n-    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n-        log.debug(\"New Async Query Cleaner thread created\");\n-        this.maxRunTime = maxRunTime;\n-        this.elide = elide;\n-    }\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n+        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+    }\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    /**\n+     * This method updates the status of long running async query which\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1Mjc0Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385252743", "body": "This thread should delete the query rather than timing it out.", "bodyText": "This thread should delete the query rather than timing it out.", "bodyHTML": "<p dir=\"auto\">This thread should delete the query rather than timing it out.</p>", "author": "aklish", "createdAt": "2020-02-27T17:17:07Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTime;\n+    private Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwNDUzMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385304531", "bodyText": "If we delete the Query entry on the restart, it will confuse the user where the query went because an application crash or restart will not be known to him.", "author": "moizarafat", "createdAt": "2020-02-27T18:52:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1Mjc0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -48,48 +44,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -27,59 +34,70 @@ import java.util.Date;\n @AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTimeMinutes;\n+    private int maxRunTime;\n     private Elide elide;\n-    private int queryCleanupDays;\n-    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n-        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n \n-    }\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            long currentTime = new Date().getTime();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n \n-    /**\n-     * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n-\n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+                if(isTimedOut(currentTime, query)) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "91f71412e524f9d469df5e0abd86917b2ff58da4", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\ndeleted file mode 100644\nindex d01de2318..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ /dev/null\n", "chunk": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for updating AsyncQueryThread status\n- * beyond the max run time and if not terminated by interrupt process\n- * due to app/host crash or restart.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryCleanerThread implements Runnable {\n-\n-    private int maxRunTimeMinutes;\n-    private Elide elide;\n-\n-    @Override\n-    public void run() {\n-        timeoutAsyncQuery();\n-    }\n-\n-    /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nnew file mode 100644\nindex 000000000..980ea1495\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -0,0 +1,90 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    int maxRunTime;\n+    Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 980ea1495..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -87,4 +88,16 @@ public class AsyncQueryCleanerThread implements Runnable {\n             }\n         }\n     }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "0c9e427d8e81871808703670b16c472ca851512d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "ada611df1d33adab5d052d0be4957a7fbb02b405", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex d01de2318..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -46,51 +47,72 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n     }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);\n+            });\n     }\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -5,91 +5,81 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n /**\n- * Runnable thread for updating AsyncQueryThread status\n+ * Runnable thread for updating AsyncQueryThread status.\n  * beyond the max run time and if not terminated by interrupt process\n  * due to app/host crash or restart.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTime;\n+    private int maxRunTimeMinutes;\n     private Elide elide;\n-\n-    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n-        log.debug(\"New Async Query Cleaner thread created\");\n-        this.maxRunTime = maxRunTime;\n-        this.elide = elide;\n-    }\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n+        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+    }\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    /**\n+     * This method updates the status of long running async query which\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MzE4Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385253182", "body": "Let's make these configurable.", "bodyText": "Let's make these configurable.", "bodyHTML": "<p dir=\"auto\">Let's make these configurable.</p>", "author": "aklish", "createdAt": "2020-02-27T17:17:58Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxNTg4Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385315882", "bodyText": "interruptTime is set when the elide instance comes up based on the properties/settings set by the user in application.yaml/settings.java and it gets applied to all the queries. If the user does not set it, its defaulted to 60 minutes.  Do you mean it should be an attribute in AsyncQuery and every query should have its own timeout provided by the user? if not provided, we default it.", "author": "moizarafat", "createdAt": "2020-02-27T19:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1MzE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..addbc716c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,36 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n             \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if(interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n-\n+    \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex addbc716c..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -75,7 +74,7 @@ public class AsyncQueryInterruptThread implements Runnable {\n     private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n         long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n         long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n+\n         return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 59b7e3571..c8b6cd1ca 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -46,35 +50,55 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n             // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n         } catch (ExecutionException e) {\n             // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n         } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n+            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n         }\n     }\n \n     /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n      */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        return interruptTimeMillies;\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex c8b6cd1ca..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -65,38 +63,9 @@ public class AsyncQueryInterruptThread implements Runnable {\n         } catch (TimeoutException e) {\n             log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "993f2510bdc2c8ce895b82001d2128d55ecbae4f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex b83dc04e5..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,86 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private UUID id;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-            \n-            if(interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e.getMessage());\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e.getMessage());\n-            task.cancel(true);\n-            try {\n-                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n-            } catch (IOException e1) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread \n-     * in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nnew file mode 100644\nindex 000000000..8718fd66c\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -0,0 +1,98 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private RequestScope scope;\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(RequestScope scope, Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);\n+            }\n+\n+            if(!task.isDone()) {\n+                log.debug(\"Interrupting the task\");\n+                task.cancel(true);\n+                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            }\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     */\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setQueryStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 8718fd66c..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -48,49 +45,27 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * the maximum run time.\n      */\n     protected void interruptQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             long interruptTimeInMillies = interruptTime * 60 * 1000;\n             long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n             if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n             log.error(\"InterruptedException: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n+            task.cancel(true);\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "510ec3c07ac159cc9688a6416686b33672895234", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,35 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n-            \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n \n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if (interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n \n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex 59b7e3571..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,80 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.Date;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private AsyncQuery asyncQuery;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-    private AsyncQueryDAO asyncQueryDao;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n-            task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n-        }\n-    }\n-\n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-\n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NDQ4NQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385254485", "body": "Instead of sleeping here, just wait on the future with the given timeout:\r\n```java\r\nfuture.get(long\u00a0timeout,\u00a0TimeUnit\u00a0unit)\r\n```\r\nIf the task returns early, this thread can exit early too.", "bodyText": "Instead of sleeping here, just wait on the future with the given timeout:\nfuture.get(long\u00a0timeout,\u00a0TimeUnit\u00a0unit)\nIf the task returns early, this thread can exit early too.", "bodyHTML": "<p dir=\"auto\">Instead of sleeping here, just wait on the future with the given timeout:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"future.get(long\u00a0timeout,\u00a0TimeUnit\u00a0unit)\"><pre>future<span class=\"pl-k\">.</span>get(<span class=\"pl-k\">long</span>\u00a0timeout,\u00a0<span class=\"pl-smi\">TimeUnit</span>\u00a0unit)</pre></div>\n<p dir=\"auto\">If the task returns early, this thread can exit early too.</p>", "author": "aklish", "createdAt": "2020-02-27T17:20:11Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..addbc716c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,36 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n             \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if(interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n-\n+    \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex addbc716c..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -75,7 +74,7 @@ public class AsyncQueryInterruptThread implements Runnable {\n     private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n         long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n         long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n+\n         return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 59b7e3571..c8b6cd1ca 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -46,35 +50,55 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n             // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n         } catch (ExecutionException e) {\n             // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n         } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n+            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n         }\n     }\n \n     /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n      */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        return interruptTimeMillies;\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex c8b6cd1ca..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -65,38 +63,9 @@ public class AsyncQueryInterruptThread implements Runnable {\n         } catch (TimeoutException e) {\n             log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "993f2510bdc2c8ce895b82001d2128d55ecbae4f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex b83dc04e5..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,86 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private UUID id;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-            \n-            if(interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e.getMessage());\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e.getMessage());\n-            task.cancel(true);\n-            try {\n-                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n-            } catch (IOException e1) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread \n-     * in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nnew file mode 100644\nindex 000000000..8718fd66c\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -0,0 +1,98 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private RequestScope scope;\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(RequestScope scope, Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);\n+            }\n+\n+            if(!task.isDone()) {\n+                log.debug(\"Interrupting the task\");\n+                task.cancel(true);\n+                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            }\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     */\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setQueryStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 8718fd66c..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -48,49 +45,27 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * the maximum run time.\n      */\n     protected void interruptQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             long interruptTimeInMillies = interruptTime * 60 * 1000;\n             long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n             if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n             log.error(\"InterruptedException: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n+            task.cancel(true);\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "510ec3c07ac159cc9688a6416686b33672895234", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,35 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n-            \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n \n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if (interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n \n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex 59b7e3571..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,80 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.Date;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private AsyncQuery asyncQuery;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-    private AsyncQueryDAO asyncQueryDao;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n-            task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n-        }\n-    }\n-\n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-\n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NTExNQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385255115", "body": "Let's commonize all of this logic to load an AsyncQuery and do something (pass in a function that manipulates the query).", "bodyText": "Let's commonize all of this logic to load an AsyncQuery and do something (pass in a function that manipulates the query).", "bodyHTML": "<p dir=\"auto\">Let's commonize all of this logic to load an AsyncQuery and do something (pass in a function that manipulates the query).</p>", "author": "aklish", "createdAt": "2020-02-27T17:21:15Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);\n+            }\n+\n+            if(!task.isDone()) {\n+                log.debug(\"Interrupting the task\");\n+                task.cancel(true);\n+                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            }\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     */\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..addbc716c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,36 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n             \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if(interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n-\n+    \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex addbc716c..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -75,7 +74,7 @@ public class AsyncQueryInterruptThread implements Runnable {\n     private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n         long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n         long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n+\n         return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 59b7e3571..c8b6cd1ca 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -46,35 +50,55 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n             // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n         } catch (ExecutionException e) {\n             // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n         } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n+            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n         }\n     }\n \n     /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n      */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        return interruptTimeMillies;\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n }\n", "next_change": {"commit": "12a0514cb02bc4b56c880d2a185b758edc728934", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex c8b6cd1ca..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -65,38 +63,9 @@ public class AsyncQueryInterruptThread implements Runnable {\n         } catch (TimeoutException e) {\n             log.error(\"TimeoutException: {}\", e.getMessage());\n             task.cancel(true);\n-            updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "993f2510bdc2c8ce895b82001d2128d55ecbae4f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex b83dc04e5..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,86 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private UUID id;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-            \n-            if(interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e.getMessage());\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e.getMessage());\n-            task.cancel(true);\n-            try {\n-                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n-            } catch (IOException e1) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-    \n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread \n-     * in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-        \n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nnew file mode 100644\nindex 000000000..8718fd66c\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -0,0 +1,98 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.UUID;\n+import java.util.concurrent.Future;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for terminating AsyncQueryThread executing\n+ * beyond the max run time and update status.\n+ */\n+@Slf4j\n+public class AsyncQueryInterruptThread implements Runnable {\n+\n+    private RequestScope scope;\n+    private Elide elide;\n+    private Future<?> task;\n+    private UUID id;\n+    private Date submittedOn;\n+    private int interruptTime;\n+\n+    public AsyncQueryInterruptThread(RequestScope scope, Elide elide, Future<?> task, UUID id, Date submittedOn, int interruptTime){\n+        log.debug(\"New Async Query Interrupt thread created\");\n+        this.scope = scope;\n+        this.elide = elide;\n+        this.task = task;\n+        this.id = id;\n+        this.submittedOn = submittedOn;\n+        this.interruptTime = interruptTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+        interruptQuery();\n+    }\n+\n+    /**\n+     * This is the main method which interrupts the Async Query request, if it has executed beyond\n+     * the maximum run time.\n+     */\n+    protected void interruptQuery() {\n+        try {\n+            long interruptTimeInMillies = interruptTime * 60 * 1000;\n+            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            if(differenceInMillies > 0) {\n+               log.debug(\"Sleeping for {}\", differenceInMillies);\n+               Thread.sleep(differenceInMillies);\n+            }\n+\n+            if(!task.isDone()) {\n+                log.debug(\"Interrupting the task\");\n+                task.cancel(true);\n+                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            }\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed query status value.\n+     * @param status new status based on the enum QueryStatus\n+     * @param asyncQueryId queryId from asyncQuery request\n+     */\n+    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n+        log.debug(\"Updating AsyncQuery status to {}\", status);\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setQueryStatus(status);\n+            tx.save(query, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 8718fd66c..2cf97fe11 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -48,49 +45,27 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * the maximum run time.\n      */\n     protected void interruptQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             long interruptTimeInMillies = interruptTime * 60 * 1000;\n             long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n+            \n             if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n-\n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+               log.debug(\"Waiting on the future with the given timeout for {}\", differenceInMillies);\n+               task.get(differenceInMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n             log.error(\"InterruptedException: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n-     */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-            tx.close();\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e.getMessage());\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e.getMessage());\n+            task.cancel(true);\n             try {\n-                tx.close();\n-            } catch (IOException e) {\n+                asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, id);\n+            } catch (IOException e1) {\n                 log.error(\"IOException: {}\", e.getMessage());\n             }\n         }\n", "next_change": {"commit": "510ec3c07ac159cc9688a6416686b33672895234", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 2cf97fe11..ff48fd5c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -70,4 +69,18 @@ public class AsyncQueryInterruptThread implements Runnable {\n             }\n         }\n     }\n+    \n+    /**\n+     * Method to calculate the time left to interrupt since submission of thread \n+     * in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n+     */\n+    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n+        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n+        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+        \n+        return differenceMillies;\n+    }\n }\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex ff48fd5c7..b83dc04e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -77,10 +77,10 @@ public class AsyncQueryInterruptThread implements Runnable {\n      * @param submittedOn time when query was submitted\n      * @return Interrupt time left\n      */\n-    private long calculateTimeOut(long interruptTimeMinutes, Date submittedOn) {\n-        long interruptTimeMillies = interruptTimeMinutes * 60 * 1000;\n-        long differenceMillies = interruptTimeMillies - ((new Date()).getTime() - submittedOn.getTime());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n         \n-        return differenceMillies;\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\nindex 845c269b3..59b7e3571 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n", "chunk": "@@ -52,53 +46,35 @@ public class AsyncQueryInterruptThread implements Runnable {\n      */\n     protected void interruptQuery() {\n         try {\n-            long interruptTimeInMillies = interruptTime * 60 * 1000;\n-            long differenceInMillies = interruptTimeInMillies - ((new Date()).getTime() - submittedOn.getTime());\n-            \n-            if(differenceInMillies > 0) {\n-               log.debug(\"Sleeping for {}\", differenceInMillies);\n-               Thread.sleep(differenceInMillies);\n-            }\n+            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n \n-            if(!task.isDone()) {\n-                log.debug(\"Interrupting the task\");\n-                task.cancel(true);\n-                updateAsyncQueryStatus(QueryStatus.TIMEDOUT, id);\n+            if (interruptTimeMillies > 0) {\n+               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n+               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n             }\n         } catch (InterruptedException e) {\n-            log.error(\"InterruptedException: {}\", e.getMessage());\n+            // Incase the future.get is interrupted , the underlying query may still have succeeded\n+            log.error(\"InterruptedException: {}\", e);\n+        } catch (ExecutionException e) {\n+            // Query Status set to failure will be handled by the processQuery method\n+            log.error(\"ExecutionException: {}\", e);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            task.cancel(true);\n+            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n         }\n     }\n \n     /**\n-     * This method updates the model for AsyncQuery with passed query status value.\n-     * @param status new status based on the enum QueryStatus\n-     * @param asyncQueryId queryId from asyncQuery request\n+     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n+     * @param interruptTimeMinutes max duration to run the query\n+     * @param submittedOn time when query was submitted\n+     * @return Interrupt time left\n      */\n-    protected void updateAsyncQueryStatus(QueryStatus status, UUID asyncQueryId) {\n-        log.debug(\"Updating AsyncQuery status to {}\", status);\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n+        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n+        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n \n-        try {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setQueryStatus(status);\n-            tx.save(query, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        return interruptTimeMillies;\n     }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\ndeleted file mode 100644\nindex 59b7e3571..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptThread.java\n+++ /dev/null\n", "chunk": "@@ -1,80 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.util.Date;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-/**\n- * Runnable thread for terminating AsyncQueryThread executing\n- * beyond the max run time and update status.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryInterruptThread implements Runnable {\n-\n-    private Elide elide;\n-    private Future<?> task;\n-    private AsyncQuery asyncQuery;\n-    private Date submittedOn;\n-    private int maxRunTimeMinutes;\n-    private AsyncQueryDAO asyncQueryDao;\n-\n-    @Override\n-    public void run() {\n-        interruptQuery();\n-    }\n-\n-    /**\n-     * This is the main method which interrupts the Async Query request, if it has executed beyond\n-     * the maximum run time.\n-     */\n-    protected void interruptQuery() {\n-        try {\n-            long interruptTimeMillies = calculateTimeOut(maxRunTimeMinutes, submittedOn);\n-\n-            if (interruptTimeMillies > 0) {\n-               log.debug(\"Waiting on the future with the given timeout for {}\", interruptTimeMillies);\n-               task.get(interruptTimeMillies, TimeUnit.MILLISECONDS);\n-            }\n-        } catch (InterruptedException e) {\n-            // Incase the future.get is interrupted , the underlying query may still have succeeded\n-            log.error(\"InterruptedException: {}\", e);\n-        } catch (ExecutionException e) {\n-            // Query Status set to failure will be handled by the processQuery method\n-            log.error(\"ExecutionException: {}\", e);\n-        } catch (TimeoutException e) {\n-            log.error(\"TimeoutException: {}\", e);\n-            task.cancel(true);\n-            asyncQueryDao.updateStatus(asyncQuery, QueryStatus.TIMEDOUT);\n-        }\n-    }\n-\n-    /**\n-     * Method to calculate the time left to interrupt since submission of thread in Milliseconds.\n-     * @param interruptTimeMinutes max duration to run the query\n-     * @param submittedOn time when query was submitted\n-     * @return Interrupt time left\n-     */\n-    private long calculateTimeOut(long maxRunTimeMinutes, Date submittedOn) {\n-        long maxRunTimeMinutesMillies = maxRunTimeMinutes * 60 * 1000;\n-        long interruptTimeMillies = maxRunTimeMinutesMillies - ((new Date()).getTime() - submittedOn.getTime());\n-\n-        return interruptTimeMillies;\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385257177", "body": "All of the Elide models should implement hashcode & equals.  There are some best practices around how to make this work with ORMs.  You can look at BaseId in Elide to get one of the approaches.", "bodyText": "All of the Elide models should implement hashcode & equals.  There are some best practices around how to make this work with ORMs.  You can look at BaseId in Elide to get one of the approaches.", "bodyHTML": "<p dir=\"auto\">All of the Elide models should implement hashcode &amp; equals.  There are some best practices around how to make this work with ORMs.  You can look at BaseId in Elide to get one of the approaches.</p>", "author": "aklish", "createdAt": "2020-02-27T17:24:54Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+public class AsyncQuery implements PrincipalOwned {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MTA0OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385351048", "bodyText": "We are adding @Data for AsyncQuery.java which internally includes @EqualsAndHashCode. Do we need to add these separately for the models?", "author": "Abhino", "createdAt": "2020-02-27T20:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDkwMw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386490903", "bodyText": "@Data should be sufficient.", "author": "aklish", "createdAt": "2020-03-02T16:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MjA5OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386492099", "bodyText": "@Data equals & hashcode is not sufficient for use with ORMs.  Go check out BaseId in Elide.", "author": "aklish", "createdAt": "2020-03-02T16:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,40 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.security.Principal;\n-import java.util.Date;\n import java.util.UUID;\n \n import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n-import lombok.extern.slf4j.Slf4j;\n+import lombok.Data;\n \n /**\n  * Model for Async Query\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n-public class AsyncQuery implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..da84d07a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -37,6 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition=\"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex da84d07a9..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -38,7 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition=\"varchar(36)\")\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..531bb03d2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,44 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n+import java.security.Principal;\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n-import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n import lombok.Data;\n-\n-import java.util.UUID;\n-\n-import javax.inject.Inject;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-import javax.persistence.Transient;\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Model for Async Query.\n+ * Model for Async Query\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n+@Include(type = \"query\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n+public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n+    //Extracted from the Principal object\n+    private String principalName;\n+\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "12232236cb3d500701eaad32a1b2b509ff207563", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 531bb03d2..596a673f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -50,7 +50,7 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne\n+    @OneToOne(mappedBy = \"query\")\n     private AsyncQueryResult result;\n \n     private Date createdOn;\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 596a673f2..88e89eba8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,31 +27,25 @@ import lombok.extern.slf4j.Slf4j;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @Slf4j\n-@Data\n public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    private UUID id; //Can be generated or provided.\n+    UUID id; //Can be generated or provided.\n \n     //Extracted from the Principal object\n-    private String principalName;\n+    String principalName;\n \n-    private String query;  //JSON-API PATH or GraphQL payload.\n+    String query;  //JSON-API PATH or GraphQL payload.\n \n-    private QueryType queryType; //GRAPHQL, JSONAPI\n+    QueryType queryType; //GRAPHQL, JSONAPI\n \n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status;\n-\n-    @OneToOne(mappedBy = \"query\")\n-    private AsyncQueryResult result;\n-\n-    private Date createdOn;\n+    QueryStatus status;\n \n-    private Date updatedOn;\n+    @OneToOne\n+    AsyncQueryResult result;\n \n-    @Inject\n-    @Transient\n-    private AsyncExecutorService asyncExecutorService;\n+    Date createdOn;\n+    Date updatedOn;\n \n     @Override\n \tpublic String getPrincipalName() {\n", "next_change": {"commit": "92a57364ba5b0c8dad63852f186398adcab90dd8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 88e89eba8..9b805d6a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -29,23 +36,24 @@ import lombok.extern.slf4j.Slf4j;\n @Slf4j\n public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    UUID id; //Can be generated or provided.\n+    private UUID id; //Can be generated or provided.\n \n     //Extracted from the Principal object\n-    String principalName;\n+    private String principalName;\n \n-    String query;  //JSON-API PATH or GraphQL payload.\n+    private String query;  //JSON-API PATH or GraphQL payload.\n \n-    QueryType queryType; //GRAPHQL, JSONAPI\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n \n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    QueryStatus status;\n+    private QueryStatus status;\n \n     @OneToOne\n-    AsyncQueryResult result;\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n \n-    Date createdOn;\n-    Date updatedOn;\n+    private Date updatedOn;\n \n     @Override\n \tpublic String getPrincipalName() {\n", "next_change": {"commit": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 9b805d6a9..7b39e02c0 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -55,6 +55,10 @@ public class AsyncQuery implements PrincipalOwned {\n \n     private Date updatedOn;\n \n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n     @Override\n \tpublic String getPrincipalName() {\n \t\treturn principalName;\n", "next_change": {"commit": "510ec3c07ac159cc9688a6416686b33672895234", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 7b39e02c0..9cabfa092 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -60,9 +64,9 @@ public class AsyncQuery implements PrincipalOwned {\n     private AsyncExecutorService asyncExecutorService;\n \n     @Override\n-\tpublic String getPrincipalName() {\n-\t\treturn principalName;\n-\t}\n+    public String getPrincipalName() {\n+        return principalName;\n+    }\n \n     @PrePersist\n     public void prePersist() {\n", "next_change": {"commit": "2d59b4dd6e76642c2df578175859e845027ca549", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 9cabfa092..bc8eb6b76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,6 +62,9 @@ public class AsyncQuery implements PrincipalOwned {\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n+    @Transient\n+    protected String naturalKey = id.toString();\n+\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "f4fdcf277bd434ac388b28a36dae9167804d4895", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bc8eb6b76..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,7 +63,7 @@ public class AsyncQuery implements PrincipalOwned {\n     private AsyncExecutorService asyncExecutorService;\n \n     @Transient\n-    protected String naturalKey = id.toString();\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n     public String getPrincipalName() {\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..065a844f4 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -62,7 +60,10 @@ public class AsyncQuery implements PrincipalOwned {\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n+    @Exclude\n+    private String principalName;\n+\n+    @Exclude\n     protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 065a844f4..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,24 +56,11 @@ public class AsyncQuery implements PrincipalOwned {\n     @Exclude\n     private String principalName;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n     \tsetPrincipalName(scope.getUser().getName());\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex db8ea25e7..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,43 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.security.Principal;\n-import java.util.Date;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+\n import java.util.UUID;\n \n import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.OnCreatePostCommit;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-import com.yahoo.elide.async.service.AsyncExecutorService;\n-import com.yahoo.elide.core.RequestScope;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n /**\n- * Model for Async Query\n+ * Model for Async Query.\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n-public class AsyncQuery implements PrincipalOwned {\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -40,7 +35,7 @@ import javax.persistence.Transient;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Can be generated or provided.\n+    private UUID id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..2443509aa 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,7 +35,9 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+            message = \"id not of pattern UUID\")\n+    private String id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 2443509aa..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -36,25 +41,38 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n     @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-            message = \"id not of pattern UUID\")\n-    private String id; //Provided.\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385257638", "body": "To be on the safe side, I would add lombok hashcode and equals to all threads that are being managed by a thread pool.", "bodyText": "To be on the safe side, I would add lombok hashcode and equals to all threads that are being managed by a thread pool.", "bodyHTML": "<p dir=\"auto\">To be on the safe side, I would add lombok hashcode and equals to all threads that are being managed by a thread pool.</p>", "author": "aklish", "createdAt": "2020-02-27T17:25:45Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {", "originalCommit": "c88d08a94c994f16ee51c6a51c39694411fb8c59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM1MjY1MA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r385352650", "bodyText": "We are already adding @Data for AsyncQueryCleanerThread.java which internally includes @EqualsAndHashCode. Do we need to add these separately for the threads?", "author": "Abhino", "createdAt": "2020-02-27T20:26:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MDczNg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386490736", "bodyText": "@Data should be sufficient.", "author": "aklish", "createdAt": "2020-03-02T16:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI1NzYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -28,19 +25,18 @@ import lombok.extern.slf4j.Slf4j;\n  * due to app/host crash or restart.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTime;\n+    private int maxRunTimeMinutes;\n     private Elide elide;\n-\n-    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n-        log.debug(\"New Async Query Cleaner thread created\");\n-        this.maxRunTime = maxRunTime;\n-        this.elide = elide;\n-    }\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n+        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,8 +39,7 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n", "next_change": {"commit": "2fab13ce0767392ec3ff610e7753f2b98af05474", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -27,59 +34,70 @@ import java.util.Date;\n @AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTimeMinutes;\n+    private int maxRunTime;\n     private Elide elide;\n-    private int queryCleanupDays;\n-    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n-        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n \n-    }\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            long currentTime = new Date().getTime();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n \n-    /**\n-     * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n-\n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+                if(isTimedOut(currentTime, query)) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "91f71412e524f9d469df5e0abd86917b2ff58da4", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\ndeleted file mode 100644\nindex d01de2318..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ /dev/null\n", "chunk": "@@ -1,96 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Runnable thread for updating AsyncQueryThread status\n- * beyond the max run time and if not terminated by interrupt process\n- * due to app/host crash or restart.\n- */\n-@Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryCleanerThread implements Runnable {\n-\n-    private int maxRunTimeMinutes;\n-    private Elide elide;\n-\n-    @Override\n-    public void run() {\n-        timeoutAsyncQuery();\n-    }\n-\n-    /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n-}\n\\ No newline at end of file\n", "next_change": {"commit": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nnew file mode 100644\nindex 000000000..980ea1495\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -0,0 +1,90 @@\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    int maxRunTime;\n+    Elide elide;\n+\n+    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n+        log.debug(\"New Async Query Cleaner thread created\");\n+        this.maxRunTime = maxRunTime;\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void run() {\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    private void timeoutAsyncQuery() {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        try {\n+            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .filterExpression(filter)\n+                    .build();\n+\n+            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+            Iterator<Object> itr = loaded.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n+                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+                if(difference > maxRunTime * 2) {\n+                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n+                    tx.save(query, scope);\n+                    tx.commit(scope);\n+                    tx.flush(scope);\n+                }\n+            }\n+        }\n+        catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        }\n+        finally {\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "76b8fd9955c80c70877447399beb33593a07d1a6", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 980ea1495..84bf1ee3c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -87,4 +88,16 @@ public class AsyncQueryCleanerThread implements Runnable {\n             }\n         }\n     }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        if(difference > maxRunTime * 2) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "0c9e427d8e81871808703670b16c472ca851512d", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 84bf1ee3c..bc1c33cc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -94,10 +94,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        if(difference > maxRunTime * 2) {\n-            return true;\n-        } else {\n-            return false;\n-        }\n+        return (difference > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "ada611df1d33adab5d052d0be4957a7fbb02b405", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex bc1c33cc1..27b0a12cd 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -90,10 +87,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceInMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (difference > maxRunTime * 2);\n+        return (differenceMillies > maxRunTime * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "34b462ea5792da7c318220860baedcf9c08420a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 27b0a12cd..d01de2318 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -91,6 +91,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n \n         // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMillies > maxRunTime * 2);\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex d01de2318..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -46,51 +47,72 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * This method updates the status of long running async query which\n      * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            long currentTime = new Date().getTime();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-\n-                if(isTimedOut(currentTime, query)) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    asyncDbUtil.updateAsyncQuery(QueryStatus.TIMEDOUT, query.getId());\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n     }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);\n+            });\n     }\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 22a1e08b6..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -5,91 +5,81 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Date;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n /**\n- * Runnable thread for updating AsyncQueryThread status\n+ * Runnable thread for updating AsyncQueryThread status.\n  * beyond the max run time and if not terminated by interrupt process\n  * due to app/host crash or restart.\n  */\n @Slf4j\n+@Data\n+@AllArgsConstructor\n public class AsyncQueryCleanerThread implements Runnable {\n \n-    private int maxRunTime;\n+    private int maxRunTimeMinutes;\n     private Elide elide;\n-\n-    AsyncQueryCleanerThread(int maxRunTime, Elide elide) {\n-        log.debug(\"New Async Query Cleaner thread created\");\n-        this.maxRunTime = maxRunTime;\n-        this.elide = elide;\n-    }\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n \n     @Override\n     public void run() {\n+        deleteAsyncQuery();\n         timeoutAsyncQuery();\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n-    private void timeoutAsyncQuery() {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-        try {\n-            EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-            RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-            RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-            FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filter)\n-                    .build();\n+    }\n \n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                long differenceInMillies = Math.abs((new Date()).getTime() - query.getCreatedOn().getTime());\n-                long difference = TimeUnit.MINUTES.convert(differenceInMillies, TimeUnit.MILLISECONDS);\n+    /**\n+     * This method updates the status of long running async query which\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n \n-                // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-                if(difference > maxRunTime * 2) {\n-                    log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                    query.setQueryStatus(QueryStatus.TIMEDOUT);\n-                    tx.save(query, scope);\n-                    tx.commit(scope);\n-                    tx.flush(scope);\n-                }\n-            }\n-        }\n-        catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        }\n-        finally {\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"oid": "2fab13ce0767392ec3ff610e7753f2b98af05474", "url": "https://github.com/yahoo/elide/commit/2fab13ce0767392ec3ff610e7753f2b98af05474", "message": "Fixing several review comments - pom, lombok, thread exec\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-27T20:36:12Z", "type": "commit"}, {"oid": "12232236cb3d500701eaad32a1b2b509ff207563", "url": "https://github.com/yahoo/elide/commit/12232236cb3d500701eaad32a1b2b509ff207563", "message": "Merge branch 'elide-5.x-async' of github.com:yahoo/elide into elide-5.x-async", "committedDate": "2020-02-27T20:36:43Z", "type": "commit"}, {"oid": "65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "url": "https://github.com/yahoo/elide/commit/65cf55b9a0263afff80e7d9f34028dd2ec0abacd", "message": "Fixing codacity errors\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-27T20:43:43Z", "type": "commit"}, {"oid": "12a0514cb02bc4b56c880d2a185b758edc728934", "url": "https://github.com/yahoo/elide/commit/12a0514cb02bc4b56c880d2a185b758edc728934", "message": "Moving all the DB ORM logic to a utility class for Async\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-02-28T19:46:13Z", "type": "commit"}, {"oid": "993f2510bdc2c8ce895b82001d2128d55ecbae4f", "url": "https://github.com/yahoo/elide/commit/993f2510bdc2c8ce895b82001d2128d55ecbae4f", "message": "Remove dependency on number of hosts, delete permission, separate method for interrupttime calculation\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-01T21:05:51Z", "type": "commit"}, {"oid": "91f71412e524f9d469df5e0abd86917b2ff58da4", "url": "https://github.com/yahoo/elide/commit/91f71412e524f9d469df5e0abd86917b2ff58da4", "message": "Variable Naming convention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-01T21:09:55Z", "type": "commit"}, {"oid": "2b5784452773277d23e6eb31b81bf0f150bc9f56", "url": "https://github.com/yahoo/elide/commit/2b5784452773277d23e6eb31b81bf0f150bc9f56", "message": "Variable Naming convention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-01T21:15:30Z", "type": "commit"}, {"oid": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20", "url": "https://github.com/yahoo/elide/commit/490d1a1437efd4347ce2b6ca3d0876b53b0d7c20", "message": "Removing unwanted params.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-01T22:02:02Z", "type": "commit"}, {"oid": "7c315d81e856126b6de48a8e709a99e32ad08b8e", "url": "https://github.com/yahoo/elide/commit/7c315d81e856126b6de48a8e709a99e32ad08b8e", "message": "Making cleaner a separate service.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-02T16:19:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NTk5OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r386495998", "body": "My comments about using functional style here still applies.", "bodyText": "My comments about using functional style here still applies.", "bodyHTML": "<p dir=\"auto\">My comments about using functional style here still applies.</p>", "author": "aklish", "createdAt": "2020-03-02T16:19:38Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+public class AsyncDbUtil {\n+\n+\tprivate Elide elide;\n+\tprivate static AsyncDbUtil asyncUtil;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+\tprotected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+\t}\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n+            query.setStatus((QueryStatus) updatedAttribute);\n+        }\n+        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n+            query.setResult((AsyncQueryResult)updatedAttribute);\n+        }\n+        tx.save(query, scope);", "originalCommit": "490d1a1437efd4347ce2b6ca3d0876b53b0d7c20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 9cb3a5b11..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,100 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-public class AsyncDbUtil {\n-\n-\tprivate Elide elide;\n-\tprivate static AsyncDbUtil asyncUtil;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-\tprotected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-\t}\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n-            query.setStatus((QueryStatus) updatedAttribute);\n-        }\n-        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n-            query.setResult((AsyncQueryResult)updatedAttribute);\n-        }\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n-\n-}\n", "next_change": {"commit": "8fce3fbcd65a9077442e8276620d677279b85eb5", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nnew file mode 100644\nindex 000000000..9cb3a5b11\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+public class AsyncDbUtil {\n+\n+\tprivate Elide elide;\n+\tprivate static AsyncDbUtil asyncUtil;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+\tprotected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+\t}\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n+            query.setStatus((QueryStatus) updatedAttribute);\n+        }\n+        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n+            query.setResult((AsyncQueryResult)updatedAttribute);\n+        }\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+\n+}\n", "next_change": {"commit": "b93bece9f2fb0985684f52a49a7a7f9ba89ad3bc", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nindex 9cb3a5b11..bdf4f189f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -74,27 +108,43 @@ public class AsyncDbUtil {\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n      * @return AsyncQueryResult Object\n      */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n         asyncQueryResult.setStatus(status);\n         asyncQueryResult.setResponseBody(responseBody);\n         asyncQueryResult.setContentLength(responseBody.length());\n         asyncQueryResult.setId(asyncQueryId);\n         asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n         return asyncQueryResult;\n     }\n \n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        DataStoreTransaction tx = dataStore.beginTransaction();\n+        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+        Object result = action.execute(tx, scope);\n+        try {\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        }\n+        return result;\n+    }\n+\n }\n", "next_change": {"commit": "e8558c84c6d4fcf6aeca6d786802757d5c3bbad2", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nindex bdf4f189f..67cfc8d57 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -132,17 +136,25 @@ public class AsyncDbUtil {\n      * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n     public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n         DataStoreTransaction tx = dataStore.beginTransaction();\n         JsonApiDocument jsonApiDoc = new JsonApiDocument();\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = action.execute(tx, scope);\n+        Object result = null;\n         try {\n+            result = action.execute(tx, scope);\n             tx.commit(scope);\n             tx.flush(scope);\n-            tx.close();\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            // Finally block to close a transaction incase of DB Exceptions\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n         }\n         return result;\n     }\n", "next_change": {"commit": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 67cfc8d57..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,162 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQuery object from database.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQuery(UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQuery\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return query;\n-        });\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryResultCollection = EntityProjection.builder()\n-                    .type(AsyncQueryResult.class)\n-                    .build();\n-            AsyncQueryResult queryResult = (AsyncQueryResult) tx.loadObject(asyncQueryResultCollection, asyncQueryResultId, scope);\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": {"commit": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nnew file mode 100644\nindex 000000000..9cb3a5b11\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+public class AsyncDbUtil {\n+\n+\tprivate Elide elide;\n+\tprivate static AsyncDbUtil asyncUtil;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+\tprotected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+\t}\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+        EntityProjection asyncQueryCollection = EntityProjection.builder()\n+            .type(AsyncQuery.class)\n+            .build();\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n+            query.setStatus((QueryStatus) updatedAttribute);\n+        }\n+        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n+            query.setResult((AsyncQueryResult)updatedAttribute);\n+        }\n+        tx.save(query, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return query;\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @throws IOException IOException from DataStoreTransaction\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n+        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n+\n+        // Creating new RequestScope for Datastore transaction\n+        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n+\n+        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+        asyncQueryResult.setStatus(status);\n+        asyncQueryResult.setResponseBody(responseBody);\n+        asyncQueryResult.setContentLength(responseBody.length());\n+        asyncQueryResult.setId(asyncQueryId);\n+        asyncQueryResult.setQuery(asyncQuery);\n+        tx.createObject(asyncQueryResult, scope);\n+        tx.save(asyncQueryResult, scope);\n+        tx.commit(scope);\n+        tx.flush(scope);\n+        tx.close();\n+        return asyncQueryResult;\n+    }\n+\n+}\n", "next_change": {"commit": "cd4f07d650c56391475e1f64cb4cf1b0f2b9dff2", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nindex 9cb3a5b11..bdf4f189f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -74,27 +108,43 @@ public class AsyncDbUtil {\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n      * @return AsyncQueryResult Object\n      */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n         asyncQueryResult.setStatus(status);\n         asyncQueryResult.setResponseBody(responseBody);\n         asyncQueryResult.setContentLength(responseBody.length());\n         asyncQueryResult.setId(asyncQueryId);\n         asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n         return asyncQueryResult;\n     }\n \n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        DataStoreTransaction tx = dataStore.beginTransaction();\n+        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+        Object result = action.execute(tx, scope);\n+        try {\n+            tx.commit(scope);\n+            tx.flush(scope);\n+            tx.close();\n+        } catch (IOException e) {\n+            log.error(\"IOException: {}\", e.getMessage());\n+        }\n+        return result;\n+    }\n+\n }\n", "next_change": {"commit": "dbe6bf21ac7329dcc47492b39a270f25016be3f3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nindex bdf4f189f..67cfc8d57 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -132,17 +136,25 @@ public class AsyncDbUtil {\n      * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n     public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n         DataStoreTransaction tx = dataStore.beginTransaction();\n         JsonApiDocument jsonApiDoc = new JsonApiDocument();\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = action.execute(tx, scope);\n+        Object result = null;\n         try {\n+            result = action.execute(tx, scope);\n             tx.commit(scope);\n             tx.flush(scope);\n-            tx.close();\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e.getMessage());\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            // Finally block to close a transaction incase of DB Exceptions\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n         }\n         return result;\n     }\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 67cfc8d57..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,162 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQuery object from database.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQuery(UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQuery\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return query;\n-        });\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryResultCollection = EntityProjection.builder()\n-                    .type(AsyncQueryResult.class)\n-                    .build();\n-            AsyncQueryResult queryResult = (AsyncQueryResult) tx.loadObject(asyncQueryResultCollection, asyncQueryResultId, scope);\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": null}]}}]}}]}}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 9cb3a5b11..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,100 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-public class AsyncDbUtil {\n-\n-\tprivate Elide elide;\n-\tprivate static AsyncDbUtil asyncUtil;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-\tprotected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-\t}\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param updatedAttribute Attribute from asyncQuery which needs to be updated\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(Object updatedAttribute, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-        EntityProjection asyncQueryCollection = EntityProjection.builder()\n-            .type(AsyncQuery.class)\n-            .build();\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-        AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-        if (updatedAttribute.getClass().getSimpleName().equals(\"QueryStatus\")) {\n-            query.setStatus((QueryStatus) updatedAttribute);\n-        }\n-        else if (updatedAttribute.getClass().getSimpleName().equals(\"AsyncQueryResult\")) {\n-            query.setResult((AsyncQueryResult)updatedAttribute);\n-        }\n-        tx.save(query, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return query;\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @throws IOException IOException from DataStoreTransaction\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) throws IOException {\n-        DataStoreTransaction tx = elide.getDataStore().beginTransaction();\n-\n-        // Creating new RequestScope for Datastore transaction\n-        RequestScope scope = new RequestScope(null, null, tx, null, null, elide.getElideSettings());\n-\n-        AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-        asyncQueryResult.setStatus(status);\n-        asyncQueryResult.setResponseBody(responseBody);\n-        asyncQueryResult.setContentLength(responseBody.length());\n-        asyncQueryResult.setId(asyncQueryId);\n-        asyncQueryResult.setQuery(asyncQuery);\n-        tx.createObject(asyncQueryResult, scope);\n-        tx.save(asyncQueryResult, scope);\n-        tx.commit(scope);\n-        tx.flush(scope);\n-        tx.close();\n-        return asyncQueryResult;\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"oid": "8fce3fbcd65a9077442e8276620d677279b85eb5", "url": "https://github.com/yahoo/elide/commit/8fce3fbcd65a9077442e8276620d677279b85eb5", "message": "Remove unwanted params.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-02T16:39:42Z", "type": "commit"}, {"oid": "7058821b3ed64054ebb7c7206d52cd5f97d020b1", "url": "https://github.com/yahoo/elide/commit/7058821b3ed64054ebb7c7206d52cd5f97d020b1", "message": "Remove unwanted tabs.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-02T18:08:19Z", "type": "commit"}, {"oid": "3115fd5e638e4fcac072a00a248f89512ffd6e95", "url": "https://github.com/yahoo/elide/commit/3115fd5e638e4fcac072a00a248f89512ffd6e95", "message": "Updating order of modules.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-02T19:13:25Z", "type": "commit"}, {"oid": "9ea67160d2067eeddd5466139d0fb07613bcbbef", "url": "https://github.com/yahoo/elide/commit/9ea67160d2067eeddd5466139d0fb07613bcbbef", "message": "Adding cleanup sql.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-02T20:09:53Z", "type": "commit"}, {"oid": "eec27e6d1f0a0771d610caf71248b2448e9dae2a", "url": "https://github.com/yahoo/elide/commit/eec27e6d1f0a0771d610caf71248b2448e9dae2a", "message": "Adding delete logic.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-03T01:27:08Z", "type": "commit"}, {"oid": "c9eaf8bd3f741442d5676e5d6e60fae77dd1aee2", "url": "https://github.com/yahoo/elide/commit/c9eaf8bd3f741442d5676e5d6e60fae77dd1aee2", "message": "Adding query result retention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-03T01:41:41Z", "type": "commit"}, {"oid": "eaf72d175442455711907a62ba78faac4c65251d", "url": "https://github.com/yahoo/elide/commit/eaf72d175442455711907a62ba78faac4c65251d", "message": "Resolving build error.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-03T17:50:17Z", "type": "commit"}, {"oid": "16874f7994bbd588e178190bfe806b9faa316595", "url": "https://github.com/yahoo/elide/commit/16874f7994bbd588e178190bfe806b9faa316595", "message": "Changing AsyncDbUtil to use Functional Interface\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-04T22:24:58Z", "type": "commit"}, {"oid": "f59dfd596bfb283132916ce1ca6bca0fe3cd04c1", "url": "https://github.com/yahoo/elide/commit/f59dfd596bfb283132916ce1ca6bca0fe3cd04c1", "message": "Removing sleep\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T01:41:22Z", "type": "commit"}, {"oid": "b93bece9f2fb0985684f52a49a7a7f9ba89ad3bc", "url": "https://github.com/yahoo/elide/commit/b93bece9f2fb0985684f52a49a7a7f9ba89ad3bc", "message": "Adding functional interface logic for executeInTransaction\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T06:33:42Z", "type": "commit"}, {"oid": "260ebee98d3c970c2022b2df4fe58a6626f30c17", "url": "https://github.com/yahoo/elide/commit/260ebee98d3c970c2022b2df4fe58a6626f30c17", "message": "Adding debug statements for AsyncDbUtil\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T07:01:11Z", "type": "commit"}, {"oid": "e8558c84c6d4fcf6aeca6d786802757d5c3bbad2", "url": "https://github.com/yahoo/elide/commit/e8558c84c6d4fcf6aeca6d786802757d5c3bbad2", "message": "Codacity errors, exception handling\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:15:13Z", "type": "commit"}, {"oid": "cdc11cf525aadba36eaf4e638f84da2933aa6380", "url": "https://github.com/yahoo/elide/commit/cdc11cf525aadba36eaf4e638f84da2933aa6380", "message": "Adding Async Entity Models\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "9dd5e44fdf15abf4884e373e2e78d99c00282976", "url": "https://github.com/yahoo/elide/commit/9dd5e44fdf15abf4884e373e2e78d99c00282976", "message": "Adding async module and fixing parent pom version\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "url": "https://github.com/yahoo/elide/commit/749eb3ad6aa59d66ace1bd33c1bd2cb65a59ef30", "message": "Adding async service classes, security and cleanup services\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "9e362f9d148dfbf6adce17b089dad821fc60d2b0", "url": "https://github.com/yahoo/elide/commit/9e362f9d148dfbf6adce17b089dad821fc60d2b0", "message": "Adding Copyright License Header to Async module classes\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "7d991b72b662a24ccf68e7af36ea4a7063edaafa", "url": "https://github.com/yahoo/elide/commit/7d991b72b662a24ccf68e7af36ea4a7063edaafa", "message": "Using new request scope for datastore transactions\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "72789cb76aba893163e95a980f5a2f32448ee308", "url": "https://github.com/yahoo/elide/commit/72789cb76aba893163e95a980f5a2f32448ee308", "message": "Remove thread sleep used in testing\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "92a57364ba5b0c8dad63852f186398adcab90dd8", "url": "https://github.com/yahoo/elide/commit/92a57364ba5b0c8dad63852f186398adcab90dd8", "message": "Fixing based on code quality review from codacy\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "d4e4941dd592d5a1cd823ab17567410895c1e25d", "url": "https://github.com/yahoo/elide/commit/d4e4941dd592d5a1cd823ab17567410895c1e25d", "message": " Fixing additional issues based on code quality review from codacy\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "d2f0dadf431e37f7caf90340392f71e1a385757b", "url": "https://github.com/yahoo/elide/commit/d2f0dadf431e37f7caf90340392f71e1a385757b", "message": "Adding getter for AsyncQueryResult\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "7763d5a8f524d4432542f77413d6c51bed670412", "url": "https://github.com/yahoo/elide/commit/7763d5a8f524d4432542f77413d6c51bed670412", "message": "Reformatting.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "7055771a2b516eb434a7b4eecf493ffea4cb4702", "url": "https://github.com/yahoo/elide/commit/7055771a2b516eb434a7b4eecf493ffea4cb4702", "message": "Adding mappedBy.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "76b8fd9955c80c70877447399beb33593a07d1a6", "url": "https://github.com/yahoo/elide/commit/76b8fd9955c80c70877447399beb33593a07d1a6", "message": "Fixing several review comments - pom, lombok, thread exec\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "0c9e427d8e81871808703670b16c472ca851512d", "url": "https://github.com/yahoo/elide/commit/0c9e427d8e81871808703670b16c472ca851512d", "message": "Fixing codacity errors\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "17318af1c0f1af3749d4f1c638b8f16eabd018b3", "url": "https://github.com/yahoo/elide/commit/17318af1c0f1af3749d4f1c638b8f16eabd018b3", "message": "Moving all the DB ORM logic to a utility class for Async\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:23Z", "type": "commit"}, {"oid": "510ec3c07ac159cc9688a6416686b33672895234", "url": "https://github.com/yahoo/elide/commit/510ec3c07ac159cc9688a6416686b33672895234", "message": "Remove dependency on number of hosts, delete permission, separate method for interrupttime calculation\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "ada611df1d33adab5d052d0be4957a7fbb02b405", "url": "https://github.com/yahoo/elide/commit/ada611df1d33adab5d052d0be4957a7fbb02b405", "message": "Variable Naming convention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "46f15ef30db3c5d82ed3f7fb908a88af4e2d0180", "url": "https://github.com/yahoo/elide/commit/46f15ef30db3c5d82ed3f7fb908a88af4e2d0180", "message": "Variable Naming convention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "0b34181314a6a2b469b532ac920a2721a17e028b", "url": "https://github.com/yahoo/elide/commit/0b34181314a6a2b469b532ac920a2721a17e028b", "message": "Removing unwanted params.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "34b462ea5792da7c318220860baedcf9c08420a8", "url": "https://github.com/yahoo/elide/commit/34b462ea5792da7c318220860baedcf9c08420a8", "message": "Making cleaner a separate service.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "e6210ad843e496fbcfd2956456438150b251e361", "url": "https://github.com/yahoo/elide/commit/e6210ad843e496fbcfd2956456438150b251e361", "message": "Remove unwanted params.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "f0b2dae750571b17ae9bcfe196338c92cf18d845", "url": "https://github.com/yahoo/elide/commit/f0b2dae750571b17ae9bcfe196338c92cf18d845", "message": "Remove unwanted tabs.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "0ea4b5651a395df665c49195c4a21758e0bd4f4c", "url": "https://github.com/yahoo/elide/commit/0ea4b5651a395df665c49195c4a21758e0bd4f4c", "message": "Updating order of modules.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "52ab19cbb3113b93a0813b997489d9e1e21086f2", "url": "https://github.com/yahoo/elide/commit/52ab19cbb3113b93a0813b997489d9e1e21086f2", "message": "Adding cleanup sql.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "dd1c7f605bcc055abda15c647aa56d4d05ed335a", "url": "https://github.com/yahoo/elide/commit/dd1c7f605bcc055abda15c647aa56d4d05ed335a", "message": "Adding delete logic.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "5c2d50741e25373745503021d73308699ccd2307", "url": "https://github.com/yahoo/elide/commit/5c2d50741e25373745503021d73308699ccd2307", "message": "Adding query result retention.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "dfbf21f26d1c1b63ac31eb4ff0977112d82033e1", "url": "https://github.com/yahoo/elide/commit/dfbf21f26d1c1b63ac31eb4ff0977112d82033e1", "message": "Resolving build error.\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "8dc8de6b8f0022533f9e11a679c643d0e873ec2e", "url": "https://github.com/yahoo/elide/commit/8dc8de6b8f0022533f9e11a679c643d0e873ec2e", "message": "Changing AsyncDbUtil to use Functional Interface\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "fd3e514cb9e695eca9d3b34b6c4b8f2e078a7247", "url": "https://github.com/yahoo/elide/commit/fd3e514cb9e695eca9d3b34b6c4b8f2e078a7247", "message": "Removing sleep\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "cd4f07d650c56391475e1f64cb4cf1b0f2b9dff2", "url": "https://github.com/yahoo/elide/commit/cd4f07d650c56391475e1f64cb4cf1b0f2b9dff2", "message": "Adding functional interface logic for executeInTransaction\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "e009a8aa5ae0ac9f03b57736c09d7764751ab277", "url": "https://github.com/yahoo/elide/commit/e009a8aa5ae0ac9f03b57736c09d7764751ab277", "message": "Adding debug statements for AsyncDbUtil\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "dbe6bf21ac7329dcc47492b39a270f25016be3f3", "url": "https://github.com/yahoo/elide/commit/dbe6bf21ac7329dcc47492b39a270f25016be3f3", "message": "Codacity errors, exception handling\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:17:24Z", "type": "commit"}, {"oid": "1845f8caa84de070025956fffcca5e11bf741acd", "url": "https://github.com/yahoo/elide/commit/1845f8caa84de070025956fffcca5e11bf741acd", "message": "Rebased with elide-5.x and changed User principal logic\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:27:13Z", "type": "commit"}, {"oid": "57568baad2400c6e6e0d7e613d9aee938db7d1fc", "url": "https://github.com/yahoo/elide/commit/57568baad2400c6e6e0d7e613d9aee938db7d1fc", "message": "Resolving merge conflicts\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T17:31:09Z", "type": "commit"}, {"oid": "6fd953f1b05ae74dd99ea777b39f3e1a492edb56", "url": "https://github.com/yahoo/elide/commit/6fd953f1b05ae74dd99ea777b39f3e1a492edb56", "message": "Rebase\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-05T20:02:45Z", "type": "commit"}, {"oid": "20e4560272b7f0dc095e7f6f9212886720e54efb", "url": "https://github.com/yahoo/elide/commit/20e4560272b7f0dc095e7f6f9212886720e54efb", "message": "Changing CleanerThread to use ExecuteInTransaction\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T22:02:44Z", "type": "commit"}, {"oid": "8c16d9aca3f5420ad96b10e5191afb40c7d3f50e", "url": "https://github.com/yahoo/elide/commit/8c16d9aca3f5420ad96b10e5191afb40c7d3f50e", "message": "Removing unused imports\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-05T22:13:31Z", "type": "commit"}, {"oid": "274032d64e41d7f54ad1946a0553d2afb2587e0e", "url": "https://github.com/yahoo/elide/commit/274032d64e41d7f54ad1946a0553d2afb2587e0e", "message": "Delete Method changes\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-06T15:16:10Z", "type": "commit"}, {"oid": "2d59b4dd6e76642c2df578175859e845027ca549", "url": "https://github.com/yahoo/elide/commit/2d59b4dd6e76642c2df578175859e845027ca549", "message": "Overriding hashCode and equals\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-06T16:27:35Z", "type": "commit"}, {"oid": "f4fdcf277bd434ac388b28a36dae9167804d4895", "url": "https://github.com/yahoo/elide/commit/f4fdcf277bd434ac388b28a36dae9167804d4895", "message": "Overriding hashCode and equals\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-06T18:41:36Z", "type": "commit"}, {"oid": "51a42a5ddfe6a666d6d52e11b1229a313ea89b02", "url": "https://github.com/yahoo/elide/commit/51a42a5ddfe6a666d6d52e11b1229a313ea89b02", "message": "Removing unused method\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-06T18:42:56Z", "type": "commit"}, {"oid": "bfb921004e713b2a0e0daf298761ac14cf52fcfc", "url": "https://github.com/yahoo/elide/commit/bfb921004e713b2a0e0daf298761ac14cf52fcfc", "message": "Changing response logic for AsyncQuery\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-06T20:55:33Z", "type": "commit"}, {"oid": "acf3f94963a1111820a6e5a69b907c6367fb203c", "url": "https://github.com/yahoo/elide/commit/acf3f94963a1111820a6e5a69b907c6367fb203c", "message": "Merge branch 'elide-5.x-async' of github.com:yahoo/elide into elide-5.x-async", "committedDate": "2020-03-06T23:19:17Z", "type": "commit"}, {"oid": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "url": "https://github.com/yahoo/elide/commit/63fc19ab13d7882666c47bbd0e1be53338e09f84", "message": "Adding return to delete method", "committedDate": "2020-03-09T19:43:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NDI4NA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389874284", "body": "Can we move this inside the try block?  Elide does something like:\r\n\r\n```java\r\n        try (DataStoreTransaction tx = transaction.get()) {\r\n```", "bodyText": "Can we move this inside the try block?  Elide does something like:\n        try (DataStoreTransaction tx = transaction.get()) {", "bodyHTML": "<p dir=\"auto\">Can we move this inside the try block?  Elide does something like:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"        try (DataStoreTransaction tx = transaction.get()) {\"><pre>        <span class=\"pl-k\">try</span> (<span class=\"pl-smi\">DataStoreTransaction</span> tx <span class=\"pl-k\">=</span> transaction<span class=\"pl-k\">.</span>get()) {</pre></div>", "author": "aklish", "createdAt": "2020-03-09T18:16:59Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     */\n+    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {\n+                tx.delete(queryResult, scope);\n+            }\n+            if(query != null) {\n+                tx.delete(query, scope);\n+            }\n+            return queryResult;\n+        });\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQueryResult.setQuery(asyncQuery);\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        DataStoreTransaction tx = dataStore.beginTransaction();", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex d73264f92..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,148 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nnew file mode 100644\nindex 000000000..8221a984d\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database and\n+     * returns the object deleted.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     * @return query object deleted\n+     */\n+    protected AsyncQuery deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {\n+                tx.delete(queryResult, scope);\n+            }\n+            if(query != null) {\n+                tx.delete(query, scope);\n+            }\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQueryResult.setQuery(asyncQuery);\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        DataStoreTransaction tx = dataStore.beginTransaction();\n+        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+        Object result = null;\n+        try {\n+            result = action.execute(tx, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            // Finally block to close a transaction incase of DB Exceptions\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 8221a984d..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,151 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database and\n-     * returns the object deleted.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     * @return query object deleted\n-     */\n-    protected AsyncQuery deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex d73264f92..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,148 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NTY2Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389875662", "body": "You could simplify this by changing the ORM data model for AsyncQuery to cascade deletes to the AsyncQueryResult.  Then you can simply delete the query here.\r\n\r\nCheck out the ```@Cascade``` annotation.", "bodyText": "You could simplify this by changing the ORM data model for AsyncQuery to cascade deletes to the AsyncQueryResult.  Then you can simply delete the query here.\nCheck out the @Cascade annotation.", "bodyHTML": "<p dir=\"auto\">You could simplify this by changing the ORM data model for AsyncQuery to cascade deletes to the AsyncQueryResult.  Then you can simply delete the query here.</p>\n<p dir=\"auto\">Check out the <code>@Cascade</code> annotation.</p>", "author": "aklish", "createdAt": "2020-03-09T18:19:33Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     */\n+    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex d73264f92..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,148 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\nnew file mode 100644\nindex 000000000..8221a984d\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n", "chunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+@Singleton\n+@Slf4j\n+public class AsyncDbUtil {\n+\n+    private Elide elide;\n+    private static AsyncDbUtil asyncUtil;\n+    private DataStore dataStore;\n+\n+    protected static AsyncDbUtil getInstance(Elide elide) {\n+        if (asyncUtil == null) {\n+            synchronized (AsyncDbUtil.class) {\n+                asyncUtil = new AsyncDbUtil(elide);\n+            }\n+        }\n+        return asyncUtil;\n+      }\n+\n+    protected AsyncDbUtil(Elide elide) {\n+        this.elide = elide;\n+        this.dataStore = elide.getDataStore();\n+    }\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database and\n+     * returns the object deleted.\n+     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n+     * @return query object deleted\n+     */\n+    protected AsyncQuery deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n+        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n+            AsyncQueryResult queryResult = query.getResult();\n+            if(queryResult != null) {\n+                tx.delete(queryResult, scope);\n+            }\n+            if(query != null) {\n+                tx.delete(query, scope);\n+            }\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQueryResult.setQuery(asyncQuery);\n+            tx.createObject(asyncQueryResult, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        DataStoreTransaction tx = dataStore.beginTransaction();\n+        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+        Object result = null;\n+        try {\n+            result = action.execute(tx, scope);\n+            tx.commit(scope);\n+            tx.flush(scope);\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+        } finally {\n+            // Finally block to close a transaction incase of DB Exceptions\n+            try {\n+                tx.close();\n+            } catch (IOException e) {\n+                log.error(\"IOException: {}\", e.getMessage());\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex 8221a984d..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,151 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database and\n-     * returns the object deleted.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     * @return query object deleted\n-     */\n-    protected AsyncQuery deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\ndeleted file mode 100644\nindex d73264f92..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncDbUtil.java\n+++ /dev/null\n", "chunk": "@@ -1,148 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.io.IOException;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n-/**\n- * Utility class which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n- */\n-@Singleton\n-@Slf4j\n-public class AsyncDbUtil {\n-\n-    private Elide elide;\n-    private static AsyncDbUtil asyncUtil;\n-    private DataStore dataStore;\n-\n-    protected static AsyncDbUtil getInstance(Elide elide) {\n-        if (asyncUtil == null) {\n-            synchronized (AsyncDbUtil.class) {\n-                asyncUtil = new AsyncDbUtil(elide);\n-            }\n-        }\n-        return asyncUtil;\n-      }\n-\n-    protected AsyncDbUtil(Elide elide) {\n-        this.elide = elide;\n-        this.dataStore = elide.getDataStore();\n-    }\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    protected AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n-        log.debug(\"AsyncDbUtil updateAsyncQuery\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method deletes the AsyncQueryResult and AsyncQueryResult object from database.\n-     * @param asyncQueryResultId Unique UUID for the AsyncQuery Object\n-     */\n-    protected void deleteAsyncQueryAndResult(UUID asyncQueryResultId) {\n-        log.debug(\"AsyncDbUtil deleteAsyncQueryResult\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryResultId, scope);\n-            AsyncQueryResult queryResult = query.getResult();\n-            if(queryResult != null) {\n-                tx.delete(queryResult, scope);\n-            }\n-            if(query != null) {\n-                tx.delete(query, scope);\n-            }\n-            return queryResult;\n-        });\n-    }\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n-     */\n-    protected AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"AsyncDbUtil createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQueryResult.setQuery(asyncQuery);\n-            tx.createObject(asyncQueryResult, scope);\n-            return asyncQueryResult;\n-        });\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        DataStoreTransaction tx = dataStore.beginTransaction();\n-        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n-        Object result = null;\n-        try {\n-            result = action.execute(tx, scope);\n-            tx.commit(scope);\n-            tx.flush(scope);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-        } finally {\n-            // Finally block to close a transaction incase of DB Exceptions\n-            try {\n-                tx.close();\n-            } catch (IOException e) {\n-                log.error(\"IOException: {}\", e.getMessage());\n-            }\n-        }\n-        return result;\n-    }\n-\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODcxNQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389878715", "body": "Copyright is needed.", "bodyText": "Copyright is needed.", "bodyHTML": "<p dir=\"auto\">Copyright is needed.</p>", "author": "aklish", "createdAt": "2020-03-09T18:25:13Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.yahoo.elide.async.service;", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3OTAyMA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389879020", "bodyText": "Javadoc is missing.", "author": "aklish", "createdAt": "2020-03-09T18:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\nindex 6a6e47607..9e9b68e42 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n", "chunk": "@@ -1,7 +1,15 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.async.models.AsyncQuery;\n \n+/**\n+ * Function which will be invoked for updating elide async query.\n+ */\n @FunctionalInterface\n public interface UpdateQuery {\n     public void update(AsyncQuery query);\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\nindex 9e9b68e42..6a6e47607 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n", "chunk": "@@ -1,15 +1,7 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.async.models.AsyncQuery;\n \n-/**\n- * Function which will be invoked for updating elide async query.\n- */\n @FunctionalInterface\n public interface UpdateQuery {\n     public void update(AsyncQuery query);\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\nindex 6a6e47607..9e9b68e42 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n", "chunk": "@@ -1,7 +1,15 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.async.models.AsyncQuery;\n \n+/**\n+ * Function which will be invoked for updating elide async query.\n+ */\n @FunctionalInterface\n public interface UpdateQuery {\n     public void update(AsyncQuery query);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\nindex 6a6e47607..9e9b68e42 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n", "chunk": "@@ -1,7 +1,15 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.async.models.AsyncQuery;\n \n+/**\n+ * Function which will be invoked for updating elide async query.\n+ */\n @FunctionalInterface\n public interface UpdateQuery {\n     public void update(AsyncQuery query);\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\nindex 9e9b68e42..ca5756b2c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/UpdateQuery.java\n", "chunk": "@@ -5,12 +5,13 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncAPI;\n \n /**\n- * Function which will be invoked for updating elide async query.\n+ * Function which will be invoked for updating elide async query base implementation.\n+ * @param <T> AsyncQueryBase Type Implementation.\n  */\n @FunctionalInterface\n-public interface UpdateQuery {\n-    public void update(AsyncQuery query);\n+public interface UpdateQuery<T extends AsyncAPI> {\n+    public void update(T query);\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3ODgxMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389878811", "body": "Copyright is needed as is javadoc for the class", "bodyText": "Copyright is needed as is javadoc for the class", "bodyHTML": "<p dir=\"auto\">Copyright is needed as is javadoc for the class</p>", "author": "aklish", "createdAt": "2020-03-09T18:25:27Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.yahoo.elide.async.service;", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\nindex 10e262a30..8360316a7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n", "chunk": "@@ -1,8 +1,16 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.RequestScope;\n \n+/**\n+ * Function which will be invoked for executing elide async transactions.\n+ */\n @FunctionalInterface\n public interface Transactional {\n     public Object execute(DataStoreTransaction tx, RequestScope scope);\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\nindex 8360316a7..10e262a30 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n", "chunk": "@@ -1,16 +1,8 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.RequestScope;\n \n-/**\n- * Function which will be invoked for executing elide async transactions.\n- */\n @FunctionalInterface\n public interface Transactional {\n     public Object execute(DataStoreTransaction tx, RequestScope scope);\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\nindex 10e262a30..8360316a7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n", "chunk": "@@ -1,8 +1,16 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.RequestScope;\n \n+/**\n+ * Function which will be invoked for executing elide async transactions.\n+ */\n @FunctionalInterface\n public interface Transactional {\n     public Object execute(DataStoreTransaction tx, RequestScope scope);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\nindex 10e262a30..8360316a7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/Transactional.java\n", "chunk": "@@ -1,8 +1,16 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n package com.yahoo.elide.async.service;\n \n import com.yahoo.elide.core.DataStoreTransaction;\n import com.yahoo.elide.core.RequestScope;\n \n+/**\n+ * Function which will be invoked for executing elide async transactions.\n+ */\n @FunctionalInterface\n public interface Transactional {\n     public Object execute(DataStoreTransaction tx, RequestScope scope);\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMDA4Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389900082", "body": "The principalName should be set by a lifecycle (OnCreatePreCommit) hook automatically rather than having the user provide it in the API request.", "bodyText": "The principalName should be set by a lifecycle (OnCreatePreCommit) hook automatically rather than having the user provide it in the API request.", "bodyHTML": "<p dir=\"auto\">The principalName should be set by a lifecycle (OnCreatePreCommit) hook automatically rather than having the user provide it in the API request.</p>", "author": "aklish", "createdAt": "2020-03-09T19:04:48Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NTExMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r390365111", "bodyText": "Had to use OnCreatePreSecurity as using OnCreatePreCommit threw Null Pointer Exception.", "author": "moizarafat", "createdAt": "2020-03-10T14:42:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMDA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,45 +5,40 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.util.Date;\n import java.util.UUID;\n \n import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n import javax.persistence.Entity;\n import javax.persistence.Id;\n import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n import javax.persistence.Transient;\n \n import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n \n /**\n  * Model for Async Query\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n @Data\n-public class AsyncQuery implements PrincipalOwned {\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "4c5f2032a987878e9f3b2ff1dab1aa93f030f476", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..da84d07a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -37,6 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition=\"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex da84d07a9..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -38,7 +38,7 @@ import lombok.Data;\n @Data\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition=\"varchar(36)\")\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,42 +5,45 @@\n  */\n package com.yahoo.elide.async.models;\n \n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n-import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n import lombok.Data;\n-\n-import java.util.UUID;\n-\n-import javax.inject.Inject;\n-import javax.persistence.CascadeType;\n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-import javax.persistence.Transient;\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Model for Async Query.\n+ * Model for Async Query\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n+@Include(type = \"query\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n+public class AsyncQuery implements PrincipalOwned {\n     @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n+    //Extracted from the Principal object\n+    private String principalName;\n+\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..065a844f4 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,15 +37,11 @@ import lombok.extern.slf4j.Slf4j;\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n @Data\n public class AsyncQuery implements PrincipalOwned {\n     @Id\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 065a844f4..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -38,7 +35,7 @@ import lombok.Data;\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery implements PrincipalOwned {\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     private UUID id; //Can be generated or provided.\n \n", "next_change": null}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..065a844f4 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,7 +49,7 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n     private Date createdOn;\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 065a844f4..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -52,10 +49,6 @@ public class AsyncQuery implements PrincipalOwned {\n     @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,45 +5,43 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import java.util.Date;\n-import java.util.UUID;\n-\n-import javax.inject.Inject;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n-import javax.persistence.Transient;\n-\n import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.OnCreatePreSecurity;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n import com.yahoo.elide.async.service.AsyncExecutorService;\n import com.yahoo.elide.core.RequestScope;\n \n import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.CascadeType;\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.Transient;\n \n /**\n- * Model for Async Query\n+ * Model for Async Query.\n  */\n @Entity\n-@Include(type = \"query\", rootLevel = true)\n+@Include(type = \"asyncQuery\", rootLevel = true)\n @ReadPermission(expression = \"Principal is Owner\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n-@Slf4j\n @Data\n-public class AsyncQuery implements PrincipalOwned {\n+public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n+    @Column(columnDefinition = \"varchar(36)\")\n     private UUID id; //Can be generated or provided.\n \n-    //Extracted from the Principal object\n-    private String principalName;\n-\n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -40,7 +35,7 @@ import javax.persistence.Transient;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Can be generated or provided.\n+    private UUID id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..2443509aa 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,7 +35,9 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+            message = \"id not of pattern UUID\")\n+    private String id; //Provided.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 2443509aa..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -36,25 +41,38 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n     @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-            message = \"id not of pattern UUID\")\n-    private String id; //Provided.\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMjkxMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389902911", "body": "An alternative way to generate dates is:\r\n\r\n```java\r\n    @Generated(GenerationTime.INSERT)\r\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date createdOn;\r\n\r\n    @Generated(GenerationTime.ALWAYS)\r\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\r\n    @Temporal(TemporalType.TIMESTAMP)\r\n    private Date updatedOn;\r\n```", "bodyText": "An alternative way to generate dates is:\n    @Generated(GenerationTime.INSERT)\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date createdOn;\n\n    @Generated(GenerationTime.ALWAYS)\n    @Column(updatable = false, insertable = false, columnDefinition = \"timestamp default current_timestamp\")\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date updatedOn;", "bodyHTML": "<p dir=\"auto\">An alternative way to generate dates is:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"    @Generated(GenerationTime.INSERT)\n    @Column(updatable = false, insertable = false, columnDefinition = &quot;timestamp default current_timestamp&quot;)\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date createdOn;\n\n    @Generated(GenerationTime.ALWAYS)\n    @Column(updatable = false, insertable = false, columnDefinition = &quot;timestamp default current_timestamp&quot;)\n    @Temporal(TemporalType.TIMESTAMP)\n    private Date updatedOn;\"><pre>    <span class=\"pl-k\">@Generated</span>(<span class=\"pl-smi\">GenerationTime</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>INSERT</span>)\n    <span class=\"pl-k\">@Column</span>(<span class=\"pl-c1\">updatable</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">insertable</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">columnDefinition</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>timestamp default current_timestamp<span class=\"pl-pds\">\"</span></span>)\n    <span class=\"pl-k\">@Temporal</span>(<span class=\"pl-smi\">TemporalType</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>TIMESTAMP</span>)\n    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">Date</span> createdOn;\n\n    <span class=\"pl-k\">@Generated</span>(<span class=\"pl-smi\">GenerationTime</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>ALWAYS</span>)\n    <span class=\"pl-k\">@Column</span>(<span class=\"pl-c1\">updatable</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">insertable</span> <span class=\"pl-k\">=</span> <span class=\"pl-c1\">false</span>, <span class=\"pl-c1\">columnDefinition</span> <span class=\"pl-k\">=</span> <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>timestamp default current_timestamp<span class=\"pl-pds\">\"</span></span>)\n    <span class=\"pl-k\">@Temporal</span>(<span class=\"pl-smi\">TemporalType</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>TIMESTAMP</span>)\n    <span class=\"pl-k\">private</span> <span class=\"pl-smi\">Date</span> updatedOn;</pre></div>", "author": "aklish", "createdAt": "2020-03-09T19:10:11Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk1OTg5Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389959893", "bodyText": "As discussed, we will keep as is since @Generated is hibernate annotations.", "author": "moizarafat", "createdAt": "2020-03-09T21:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMjkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,12 +65,11 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n \n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n-    \tsetPrincipalName(scope.getUser().getName());\n+        setPrincipalName(scope.getUser().getName());\n     }\n-    \n+\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n-\n }\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,28 +51,52 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @OneToOne(mappedBy = \"query\")\n     private AsyncQueryResult result;\n \n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Exclude\n-    private String principalName;\n+    @Transient\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n     }\n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +49,33 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n+\n+    @PrePersist\n+    public void prePersistStatus() {\n+        status = QueryStatus.QUEUED;\n+    }\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+        setPrincipalName(scope.getUser().getName());\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n }\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -68,14 +59,4 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return principalName;\n     }\n-\n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n-    }\n-\n-    @OnCreatePostCommit\n-    public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n-    }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,24 +40,39 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwMzUwMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389903501", "body": "The natural key needs to be persisted to get hashCode & equals to work correctly.  hashCode & equals only uses the natural key or comparisons.  Remove Transient and add Exclude.", "bodyText": "The natural key needs to be persisted to get hashCode & equals to work correctly.  hashCode & equals only uses the natural key or comparisons.  Remove Transient and add Exclude.", "bodyHTML": "<p dir=\"auto\">The natural key needs to be persisted to get hashCode &amp; equals to work correctly.  hashCode &amp; equals only uses the natural key or comparisons.  Remove Transient and add Exclude.</p>", "author": "aklish", "createdAt": "2020-03-09T19:11:16Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Transient", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,12 +65,11 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n \n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n-    \tsetPrincipalName(scope.getUser().getName());\n+        setPrincipalName(scope.getUser().getName());\n     }\n-    \n+\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n-\n }\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,28 +51,52 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @OneToOne(mappedBy = \"query\")\n     private AsyncQueryResult result;\n \n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Exclude\n-    private String principalName;\n+    @Transient\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n     }\n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +49,33 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n+\n+    @PrePersist\n+    public void prePersistStatus() {\n+        status = QueryStatus.QUEUED;\n+    }\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+        setPrincipalName(scope.getUser().getName());\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n }\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -68,14 +59,4 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return principalName;\n     }\n-\n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n-    }\n-\n-    @OnCreatePostCommit\n-    public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n-    }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,24 +40,39 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwNDM0OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389904348", "body": "Why not just pass the Query object in here instead of breaking out params for it.", "bodyText": "Why not just pass the Query object in here instead of breaking out params for it.", "bodyHTML": "<p dir=\"auto\">Why not just pass the Query object in here instead of breaking out params for it.</p>", "author": "aklish", "createdAt": "2020-03-09T19:13:01Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.inject.Inject;\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.OnCreatePostCommit;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+import com.yahoo.elide.async.service.AsyncExecutorService;\n+import com.yahoo.elide.core.RequestScope;\n+\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Model for Async Query\n+ */\n+@Entity\n+@Include(type = \"query\", rootLevel = true)\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Slf4j\n+@Data\n+public class AsyncQuery implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Can be generated or provided.\n+\n+    //Extracted from the Principal object\n+    private String principalName;\n+\n+    private String query;  //JSON-API PATH or GraphQL payload.\n+\n+    private QueryType queryType; //GRAPHQL, JSONAPI\n+\n+    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n+    private QueryStatus status;\n+\n+    @OneToOne(mappedBy = \"query\")\n+    private AsyncQueryResult result;\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Inject\n+    @Transient\n+    private AsyncExecutorService asyncExecutorService;\n+\n+    @Transient\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @Override\n+    public String getPrincipalName() {\n+        return principalName;\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    @OnCreatePostCommit\n+    public void executeQueryFromExecutor(RequestScope scope) {\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..e3b6394fc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex e3b6394fc..bf29ba524 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -63,12 +65,11 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n \n     @OnCreatePreSecurity\n     public void extractPrincipalName(RequestScope scope) {\n-    \tsetPrincipalName(scope.getUser().getName());\n+        setPrincipalName(scope.getUser().getName());\n     }\n-    \n+\n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n         asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n-\n }\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex bf29ba524..c7e3fc699 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -48,28 +51,52 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @OneToOne(mappedBy = \"query\")\n     private AsyncQueryResult result;\n \n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Exclude\n-    private String principalName;\n+    @Transient\n+    protected String naturalKey = UUID.randomUUID().toString();\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n+        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n+        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n     }\n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..57926e1ab 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +46,29 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+    \tsetPrincipalName(scope.getUser().getName());\n     }\n-\n+    \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n \n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex c7e3fc699..01f36a39f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -51,52 +49,33 @@ public class AsyncQuery implements PrincipalOwned {\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\")\n+    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n     private AsyncQueryResult result;\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @Inject\n     @Transient\n     private AsyncExecutorService asyncExecutorService;\n \n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n+    @Exclude\n+    private String principalName;\n+\n+    @PrePersist\n+    public void prePersistStatus() {\n+        status = QueryStatus.QUEUED;\n+    }\n \n     @Override\n     public String getPrincipalName() {\n         return principalName;\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n+    @OnCreatePreSecurity\n+    public void extractPrincipalName(RequestScope scope) {\n+        setPrincipalName(scope.getUser().getName());\n     }\n \n     @OnCreatePostCommit\n     public void executeQueryFromExecutor(RequestScope scope) {\n-        log.info(\"AsyncExecutorService executor object: {}\", asyncExecutorService);\n-        asyncExecutorService.executeQuery(query, queryType, scope.getUser(), id);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+        asyncExecutorService.executeQuery(this, scope.getUser());\n     }\n }\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 01f36a39f..3f112f941 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -68,14 +59,4 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return principalName;\n     }\n-\n-    @OnCreatePreSecurity\n-    public void extractPrincipalName(RequestScope scope) {\n-        setPrincipalName(scope.getUser().getName());\n-    }\n-\n-    @OnCreatePostCommit\n-    public void executeQueryFromExecutor(RequestScope scope) {\n-        asyncExecutorService.executeQuery(this, scope.getUser());\n-    }\n }\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex 3f112f941..ab09af488 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -35,24 +40,39 @@ import javax.persistence.PrePersist;\n public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Id\n     @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Provided.\n+    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n+    message = \"id not of pattern UUID\")\n+    private String id; //Provided by client or generated if missing on create.\n \n     private String query;  //JSON-API PATH or GraphQL payload.\n \n     private QueryType queryType; //GRAPHQL, JSONAPI\n \n+    @Transient\n+    @Max(10)\n+    @ComputedAttribute\n+    private Integer asyncAfterSeconds = 10;\n+\n+    private String requestId; //Client provided\n+\n     @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n     private QueryStatus status;\n \n-    @OneToOne(mappedBy = \"query\", cascade = CascadeType.REMOVE)\n+    @Embedded\n     private AsyncQueryResult result;\n \n     @Exclude\n     private String principalName;\n \n+    @Transient\n+    private AsyncQueryUpdateThread queryUpdateWorker = null;\n+\n     @PrePersist\n     public void prePersistStatus() {\n         status = QueryStatus.QUEUED;\n+        if (id == null || id.isEmpty()) {\n+            id = UUID.randomUUID().toString();\n+        }\n     }\n \n     @Override\n", "next_change": {"commit": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex ab09af488..aeacdcc32 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -67,14 +67,6 @@ public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n     @Transient\n     private AsyncQueryUpdateThread queryUpdateWorker = null;\n \n-    @PrePersist\n-    public void prePersistStatus() {\n-        status = QueryStatus.QUEUED;\n-        if (id == null || id.isEmpty()) {\n-            id = UUID.randomUUID().toString();\n-        }\n-    }\n-\n     @Override\n     public String getPrincipalName() {\n         return principalName;\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\nindex aeacdcc32..a98311044 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQuery.java\n", "chunk": "@@ -5,70 +5,33 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.ComputedAttribute;\n import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n import com.yahoo.elide.annotation.Include;\n import com.yahoo.elide.annotation.ReadPermission;\n import com.yahoo.elide.annotation.UpdatePermission;\n \n-import com.yahoo.elide.async.service.AsyncQueryUpdateThread;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n-\n-import javax.persistence.Column;\n import javax.persistence.Embedded;\n import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.Transient;\n-import javax.validation.constraints.Max;\n-import javax.validation.constraints.Pattern;\n \n /**\n  * Model for Async Query.\n- * ExecuteQueryHook and UpdatePrincipalNameHook is binded manually during the elide startup,\n+ * AsyncQueryHook is binded manually during the elide startup,\n  * after asyncexecutorservice is initialized.\n  */\n @Entity\n-@Include(type = \"asyncQuery\", rootLevel = true)\n-@ReadPermission(expression = \"Principal is Owner\")\n+@Include(type = \"asyncQuery\")\n+@ReadPermission(expression = \"Principal is Owner OR Principal is Admin\")\n @UpdatePermission(expression = \"Prefab.Role.None\")\n @DeletePermission(expression = \"Prefab.Role.None\")\n @Data\n-public class AsyncQuery extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    @Pattern(regexp = \"^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\",\n-    message = \"id not of pattern UUID\")\n-    private String id = UUID.randomUUID().toString(); //Provided by client or generated if missing on create.\n-\n-    private String query;  //JSON-API PATH or GraphQL payload.\n-\n-    private QueryType queryType; //GRAPHQL, JSONAPI\n-\n-    @Transient\n-    @Max(10)\n-    @ComputedAttribute\n-    private Integer asyncAfterSeconds = 10;\n-\n-    private String requestId; //Client provided\n-\n-    @UpdatePermission(expression = \"Principal is Owner AND value is Cancelled\")\n-    private QueryStatus status = QueryStatus.QUEUED;\n-\n+public class AsyncQuery extends AsyncAPI {\n     @Embedded\n     private AsyncQueryResult result;\n \n-    @Exclude\n-    private String principalName;\n-\n-    @Transient\n-    private AsyncQueryUpdateThread queryUpdateWorker = null;\n-\n     @Override\n-    public String getPrincipalName() {\n-        return principalName;\n+    public void setResult(AsyncAPIResult result) {\n+        this.result = (AsyncQueryResult) result;\n     }\n }\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "60e0506302134d3765fb40973af5e91630adc733", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5.x Async Create Permission Fix (#1425)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "bbb61eb57fd017dfe0af021e5edf974cd0eb9e14", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Open Async Model Read/Update Permissions to Admin (#1443)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "ed3dae2c16de155ba45ce0d70b5e0bbb36a74a9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async Filter expression check (#1505)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "f3cdee76198d8bf4e8db1abbe50752f08d02970c", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Changed Include rootLevel to default to true instead of false (#1549)"}, {"oid": "bd3754fd75f808ddeac5efb718f7a1178011d842", "committedDate": "2020-12-11 16:20:28 -0600", "message": "ResultType Default Value (#1561)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "1bb35bea711c420f00cfd97596dfa9177e15277e", "committedDate": "2021-05-10 14:36:06 -0500", "message": "Populating namespaces in metadatastore (#2071)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwNDg5OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389904898", "body": "Change to `@Exclude`", "bodyText": "Change to @Exclude", "bodyHTML": "<p dir=\"auto\">Change to <code>@Exclude</code></p>", "author": "aklish", "createdAt": "2020-03-09T19:14:08Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+import javax.persistence.Transient;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+import lombok.Data;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @Transient", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 7487cb92c..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -44,13 +40,6 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex a8eba3d7e..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -47,5 +49,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n }\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..7487cb92c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,4 +58,28 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-}\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncQuery)) {\n+            return false;\n+        }\n+\n+        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n+    }\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 7487cb92c..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -59,27 +48,4 @@ public class AsyncQueryResult implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 7487cb92c..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -44,13 +42,6 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n-    @Transient\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @OneToOne\n     private AsyncQuery query;\n \n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..05e163c2b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,48 +5,31 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.CreatePermission;\n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n+import java.util.Date;\n \n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n \n /**\n  * Model for Async Query Result.\n  */\n-@Entity\n-@Include(type = \"asyncQueryResult\")\n-@ReadPermission(expression = \"Principal is Owner\")\n-@UpdatePermission(expression = \"Prefab.Role.None\")\n-@CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Embeddable\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Matches UUID in query.\n+\n+public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    private String responseBody;  //URL or Response body\n+\n+    private Integer httpStatus; // HTTP Status\n \n-    private Integer status; // HTTP Status\n+    @Enumerated(EnumType.STRING)\n+    private ResultType resultType; //EMBEDDED, DOWNLOAD\n \n-    @OneToOne\n-    private AsyncQuery query;\n+    private Date completedOn = new Date();\n \n-    @Exclude\n-    public String getPrincipalName() {\n-        return query.getPrincipalName();\n-    }\n }\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 05e163c2b..9d83aaf8f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -23,13 +21,12 @@ public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n+    private Integer recordCount;\n+\n     private String responseBody;  //URL or Response body\n \n     private Integer httpStatus; // HTTP Status\n \n-    @Enumerated(EnumType.STRING)\n-    private ResultType resultType; //EMBEDDED, DOWNLOAD\n-\n     private Date completedOn = new Date();\n \n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9d83aaf8f..b7bba5fc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -16,17 +14,8 @@ import javax.persistence.Embeddable;\n  */\n @Embeddable\n @Data\n-\n-public class AsyncQueryResult {\n-\n+public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n-    private Integer recordCount;\n-\n     private String responseBody;  //URL or Response body\n-\n-    private Integer httpStatus; // HTTP Status\n-\n-    private Date completedOn = new Date();\n-\n }\n", "next_change": {"commit": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex b7bba5fc1..6fd4e986c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -17,5 +18,6 @@ import javax.persistence.Embeddable;\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n+    @Lob\n     private String responseBody;  //URL or Response body\n }\n", "next_change": {"commit": "80060c6b960497b346c7325408dcc2459bbdfd70", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6fd4e986c..3be5b3f38 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -15,6 +16,7 @@ import javax.persistence.Lob;\n  */\n @Embeddable\n @Data\n+@EqualsAndHashCode(callSuper = true)\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1708)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwODU0NQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389908545", "body": "Do we need both a a Cleaner and a CleanerService?  Why not just combine these into a single concept?", "bodyText": "Do we need both a a Cleaner and a CleanerService?  Why not just combine these into a single concept?", "bodyHTML": "<p dir=\"auto\">Do we need both a a Cleaner and a CleanerService?  Why not just combine these into a single concept?</p>", "author": "aklish", "createdAt": "2020-03-09T19:21:29Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Cleaner.\n+ */\n+@Singleton\n+class AsyncQueryCleaner {", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\ndeleted file mode 100644\nindex 22eba05ac..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Cleaner.\n- */\n-@Singleton\n-class AsyncQueryCleaner {\n-\n-    private static AsyncQueryCleaner cleaner;\n-    private ScheduledExecutorService cleanerService;\n-\n-    protected static AsyncQueryCleaner getInstance() {\n-        if (cleaner == null) {\n-          synchronized (AsyncQueryCleaner.class) {\n-          cleaner = new AsyncQueryCleaner();\n-          }\n-        }\n-        return cleaner;\n-    }\n-\n-    protected AsyncQueryCleaner() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    protected ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\nnew file mode 100644\nindex 000000000..22eba05ac\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\n", "chunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Cleaner.\n+ */\n+@Singleton\n+class AsyncQueryCleaner {\n+\n+    private static AsyncQueryCleaner cleaner;\n+    private ScheduledExecutorService cleanerService;\n+\n+    protected static AsyncQueryCleaner getInstance() {\n+        if (cleaner == null) {\n+          synchronized (AsyncQueryCleaner.class) {\n+          cleaner = new AsyncQueryCleaner();\n+          }\n+        }\n+        return cleaner;\n+    }\n+\n+    protected AsyncQueryCleaner() {\n+      cleanerService = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    protected ScheduledExecutorService getExecutorService() {\n+      return cleanerService;\n+    }\n+}\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\ndeleted file mode 100644\nindex 22eba05ac..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Cleaner.\n- */\n-@Singleton\n-class AsyncQueryCleaner {\n-\n-    private static AsyncQueryCleaner cleaner;\n-    private ScheduledExecutorService cleanerService;\n-\n-    protected static AsyncQueryCleaner getInstance() {\n-        if (cleaner == null) {\n-          synchronized (AsyncQueryCleaner.class) {\n-          cleaner = new AsyncQueryCleaner();\n-          }\n-        }\n-        return cleaner;\n-    }\n-\n-    protected AsyncQueryCleaner() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    protected ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\ndeleted file mode 100644\nindex 22eba05ac..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleaner.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Cleaner.\n- */\n-@Singleton\n-class AsyncQueryCleaner {\n-\n-    private static AsyncQueryCleaner cleaner;\n-    private ScheduledExecutorService cleanerService;\n-\n-    protected static AsyncQueryCleaner getInstance() {\n-        if (cleaner == null) {\n-          synchronized (AsyncQueryCleaner.class) {\n-          cleaner = new AsyncQueryCleaner();\n-          }\n-        }\n-        return cleaner;\n-    }\n-\n-    protected AsyncQueryCleaner() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    protected ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwODk2Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389908963", "body": "Do we need both an Executor and an ExecutorService?  Can we combine them?", "bodyText": "Do we need both an Executor and an ExecutorService?  Can we combine them?", "bodyHTML": "<p dir=\"auto\">Do we need both an Executor and an ExecutorService?  Can we combine them?</p>", "author": "aklish", "createdAt": "2020-03-09T19:22:20Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Executor.\n+ */\n+@Singleton\n+class AsyncQueryExecutor {", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\ndeleted file mode 100644\nindex 0cb9f9be3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Executor.\n- */\n-@Singleton\n-class AsyncQueryExecutor {\n-\n-    private static AsyncQueryExecutor executor;\n-    private ExecutorService executorService;\n-\n-    protected static AsyncQueryExecutor getInstance(int threadPoolSize) {\n-      if (executor == null) {\n-        synchronized (AsyncQueryExecutor.class) {\n-          executor = new AsyncQueryExecutor(threadPoolSize);\n-          }\n-        }\n-      return executor;\n-    }\n-\n-    protected AsyncQueryExecutor(int threadPoolSize) {\n-      executorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return executorService;\n-    }\n-}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\nnew file mode 100644\nindex 000000000..0cb9f9be3\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\n", "chunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Executor.\n+ */\n+@Singleton\n+class AsyncQueryExecutor {\n+\n+    private static AsyncQueryExecutor executor;\n+    private ExecutorService executorService;\n+\n+    protected static AsyncQueryExecutor getInstance(int threadPoolSize) {\n+      if (executor == null) {\n+        synchronized (AsyncQueryExecutor.class) {\n+          executor = new AsyncQueryExecutor(threadPoolSize);\n+          }\n+        }\n+      return executor;\n+    }\n+\n+    protected AsyncQueryExecutor(int threadPoolSize) {\n+      executorService = Executors.newFixedThreadPool(threadPoolSize);\n+    }\n+\n+    protected ExecutorService getExecutorService() {\n+      return executorService;\n+    }\n+}\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\ndeleted file mode 100644\nindex 0cb9f9be3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Executor.\n- */\n-@Singleton\n-class AsyncQueryExecutor {\n-\n-    private static AsyncQueryExecutor executor;\n-    private ExecutorService executorService;\n-\n-    protected static AsyncQueryExecutor getInstance(int threadPoolSize) {\n-      if (executor == null) {\n-        synchronized (AsyncQueryExecutor.class) {\n-          executor = new AsyncQueryExecutor(threadPoolSize);\n-          }\n-        }\n-      return executor;\n-    }\n-\n-    protected AsyncQueryExecutor(int threadPoolSize) {\n-      executorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return executorService;\n-    }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\ndeleted file mode 100644\nindex 0cb9f9be3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryExecutor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Executor.\n- */\n-@Singleton\n-class AsyncQueryExecutor {\n-\n-    private static AsyncQueryExecutor executor;\n-    private ExecutorService executorService;\n-\n-    protected static AsyncQueryExecutor getInstance(int threadPoolSize) {\n-      if (executor == null) {\n-        synchronized (AsyncQueryExecutor.class) {\n-          executor = new AsyncQueryExecutor(threadPoolSize);\n-          }\n-        }\n-      return executor;\n-    }\n-\n-    protected AsyncQueryExecutor(int threadPoolSize) {\n-      executorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return executorService;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkwOTc4OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389909788", "body": "You can move a lot of this setup code outside the closure (and hence outside the transaction).", "bodyText": "You can move a lot of this setup code outside the closure (and hence outside the transaction).", "bodyHTML": "<p dir=\"auto\">You can move a lot of this setup code outside the closure (and hence outside the transaction).</p>", "author": "aklish", "createdAt": "2020-03-09T19:23:58Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -50,44 +46,13 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n     \n     /**\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -54,30 +51,28 @@ public class AsyncQueryCleanerThread implements Runnable {\n         asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n         String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n         String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n                 + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n     /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n      * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n      * @param amount Amount of days to be subtracted from current time\n      * @return formatted filter date\n      */\n-\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n         cal.add(calendarUnit, -(amount));\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..1766b716b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -39,47 +45,96 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-    }\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n     /**\n      * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n+\t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -112,29 +109,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n             } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n+                log.error(\"Exception: {}\", e);\n             }\n             return null;\n         });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -45,96 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxMjI1Ng==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389912256", "body": "This is where using the DataStoreTransaction interface in Elide is less than ideal.  There is no bulk edit interface.  This will generate lots of round trips to the database to delete objects one at a time (rather than delete them in bulk).  We should at least change the DbUtil.deleteAsync function take a list of objects to delete - and to remove them in a single transaction.  DdUtil should be an interface that can be created and overridden (as a Spring bean) if there are performance problems with this general approach.", "bodyText": "This is where using the DataStoreTransaction interface in Elide is less than ideal.  There is no bulk edit interface.  This will generate lots of round trips to the database to delete objects one at a time (rather than delete them in bulk).  We should at least change the DbUtil.deleteAsync function take a list of objects to delete - and to remove them in a single transaction.  DdUtil should be an interface that can be created and overridden (as a Spring bean) if there are performance problems with this general approach.", "bodyHTML": "<p dir=\"auto\">This is where using the DataStoreTransaction interface in Elide is less than ideal.  There is no bulk edit interface.  This will generate lots of round trips to the database to delete objects one at a time (rather than delete them in bulk).  We should at least change the DbUtil.deleteAsync function take a list of objects to delete - and to remove them in a single transaction.  DdUtil should be an interface that can be created and overridden (as a Spring bean) if there are performance problems with this general approach.</p>", "author": "aklish", "createdAt": "2020-03-09T19:28:58Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -50,44 +46,13 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n     \n     /**\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -54,30 +51,28 @@ public class AsyncQueryCleanerThread implements Runnable {\n         asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n         String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n         String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n                 + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n     /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n      * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n      * @param amount Amount of days to be subtracted from current time\n      * @return formatted filter date\n      */\n-\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n         cal.add(calendarUnit, -(amount));\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..1766b716b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -39,47 +45,96 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-    }\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n     /**\n      * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n+\t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -112,29 +109,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n             } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n+                log.error(\"Exception: {}\", e);\n             }\n             return null;\n         });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -45,96 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxMzc4NA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389913784", "body": "Multiplying maxRunTimeMinutes by 2 should be done in a single place across all the code.", "bodyText": "Multiplying maxRunTimeMinutes by 2 should be done in a single place across all the code.", "bodyHTML": "<p dir=\"auto\">Multiplying maxRunTimeMinutes by 2 should be done in a single place across all the code.</p>", "author": "aklish", "createdAt": "2020-03-09T19:31:56Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n+    }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -96,45 +61,30 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * */\n \t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..1766b716b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -39,47 +45,96 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-    }\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n     /**\n      * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n+\t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -112,29 +109,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n             } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n+                log.error(\"Exception: {}\", e);\n             }\n             return null;\n         });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -45,96 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNTI0Nw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389915247", "body": "We can push this logic into the RSQL filter expression.", "bodyText": "We can push this logic into the RSQL filter expression.", "bodyHTML": "<p dir=\"auto\">We can push this logic into the RSQL filter expression.</p>", "author": "aklish", "createdAt": "2020-03-09T19:34:52Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n+\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n+    }\n+\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -96,45 +61,30 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * */\n \t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..1766b716b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -39,47 +45,96 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-    }\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n     /**\n      * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n+\t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -112,29 +109,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n             } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n+                log.error(\"Exception: {}\", e);\n             }\n             return null;\n         });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -45,96 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNjE5OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389916198", "body": "The two functions can generalized with a common function that does a load and takes an FilterExpression to filter the results.\r\n\r\nThe two functions can call the generalized function to do a filtered load and then either update or delete the queries respectively. ", "bodyText": "The two functions can generalized with a common function that does a load and takes an FilterExpression to filter the results.\nThe two functions can call the generalized function to do a filtered load and then either update or delete the queries respectively.", "bodyHTML": "<p dir=\"auto\">The two functions can generalized with a common function that does a load and takes an FilterExpression to filter the results.</p>\n<p dir=\"auto\">The two functions can call the generalized function to do a filtered load and then either update or delete the queries respectively.</p>", "author": "aklish", "createdAt": "2020-03-09T19:36:39Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -50,44 +46,13 @@ public class AsyncQueryCleanerThread implements Runnable {\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n     \n     /**\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -54,30 +51,28 @@ public class AsyncQueryCleanerThread implements Runnable {\n         asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n         String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n         String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n                 + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n     /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n      * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n      * @param amount Amount of days to be subtracted from current time\n      * @return formatted filter date\n      */\n-\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n         cal.add(calendarUnit, -(amount));\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..1766b716b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -39,47 +45,96 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method deletes the historical queries based on threshold.\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n+                //Calculate date to clean up\n+                Calendar cal = Calendar.getInstance();\n+                cal.setTime(new Date());\n+                cal.add(Calendar.DATE, -(queryCleanupDays));\n+                Date cleanupDate = cal.getTime();\n+                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n \n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n+                        AsyncQuery.class, false);\n+                log.debug(\"filter = {}\", filter.toString());\n \n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-    }\n+                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObjects;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n+            log.info(\"Found a query to DELETE\");\n+            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n+        }\n+    }\n+    \n     /**\n      * This method updates the status of long running async query which\n-     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n+\t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n+            try {\n+                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e.getMessage());\n+            }\n+            return null;\n+        });\n+        Iterator<Object> itr = loaded.iterator();\n+        long currentTime = new Date().getTime();\n+        while(itr.hasNext()) {\n+            AsyncQuery query = (AsyncQuery) itr.next();\n \n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+            if(isTimedOut(currentTime, query)) {\n+                log.info(\"Updating Async Query Status to TIMEDOUT\");\n+                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n+                    });\n+            }\n+        }\n     }\n \n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n+        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n+        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n+\n+        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n+        return (differenceMinutes > maxRunTimeMinutes * 2);\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..c36073e74 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -112,29 +109,10 @@ public class AsyncQueryCleanerThread implements Runnable {\n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n             } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n+                log.error(\"Exception: {}\", e);\n             }\n             return null;\n         });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n-    }\n-\n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n-    }\n+        return loaded;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -115,4 +106,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n         });\n         return loaded;\n \t}\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n+\t}\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 1766b716b..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -45,96 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-                //Calculate date to clean up\n-                Calendar cal = Calendar.getInstance();\n-                cal.setTime(new Date());\n-                cal.add(Calendar.DATE, -(queryCleanupDays));\n-                Date cleanupDate = cal.getTime();\n-                Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-                String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-                log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n-                FilterExpression filter = filterParser.parseFilterExpression(\"createdOn=le='\" + cleanupDateFormatted + \"'\",\n-                        AsyncQuery.class, false);\n-                log.debug(\"filter = {}\", filter.toString());\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n-                Iterable<Object> loadedObjects = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObjects;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n-\n-            log.info(\"Found a query to DELETE\");\n-            asyncDbUtil.deleteAsyncQueryAndResult(query.getId());\n-        }\n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n-        Iterable<Object> loaded = (Iterable<Object>) asyncDbUtil.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-                RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-                FilterExpression filter = filterParser.parseFilterExpression(\"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                        + QueryStatus.QUEUED.toString() + \")\", AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n \n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e.getMessage());\n-            }\n-            return null;\n-        });\n-        Iterator<Object> itr = loaded.iterator();\n-        long currentTime = new Date().getTime();\n-        while(itr.hasNext()) {\n-            AsyncQuery query = (AsyncQuery) itr.next();\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-            if(isTimedOut(currentTime, query)) {\n-                log.info(\"Updating Async Query Status to TIMEDOUT\");\n-                asyncDbUtil.updateAsyncQuery(query.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.TIMEDOUT);\n-                    });\n-            }\n-        }\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n     }\n \n-    private boolean isTimedOut(long currentTime, AsyncQuery query) {\n-        long differenceMillies = Math.abs(currentTime - query.getCreatedOn().getTime());\n-        long differenceMinutes = TimeUnit.MINUTES.convert(differenceMillies, TimeUnit.MILLISECONDS);\n-\n-        // Check if its twice as long as max run time. It means the host/app crashed or restarted.\n-        return (differenceMinutes > maxRunTimeMinutes * 2);\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        return filterDateFormatted;\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzM3Nw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917377", "body": "Can this be combined with the Interruptor service?", "bodyText": "Can this be combined with the Interruptor service?", "bodyHTML": "<p dir=\"auto\">Can this be combined with the Interruptor service?</p>", "author": "aklish", "createdAt": "2020-03-09T19:38:53Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Interruptor.\n+ */\n+@Singleton\n+class AsyncQueryInterruptor {", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\ndeleted file mode 100644\nindex 73587f47c..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Interruptor.\n- */\n-@Singleton\n-class AsyncQueryInterruptor {\n-\n-    private static AsyncQueryInterruptor interruptor;\n-    private ExecutorService interruptorService;\n-\n-    protected static AsyncQueryInterruptor getInstance(int threadPoolSize) {\n-      if (interruptor == null) {\n-        synchronized (AsyncQueryInterruptor.class) {\n-        interruptor = new AsyncQueryInterruptor(threadPoolSize);\n-        }\n-      }\n-      return interruptor;\n-    }\n-\n-    protected AsyncQueryInterruptor(int threadPoolSize) {\n-      interruptorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return interruptorService;\n-    }\n-}\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\nnew file mode 100644\nindex 000000000..73587f47c\n--- /dev/null\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\n", "chunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Singleton;\n+\n+/**\n+ * Class for initializing the Query Interruptor.\n+ */\n+@Singleton\n+class AsyncQueryInterruptor {\n+\n+    private static AsyncQueryInterruptor interruptor;\n+    private ExecutorService interruptorService;\n+\n+    protected static AsyncQueryInterruptor getInstance(int threadPoolSize) {\n+      if (interruptor == null) {\n+        synchronized (AsyncQueryInterruptor.class) {\n+        interruptor = new AsyncQueryInterruptor(threadPoolSize);\n+        }\n+      }\n+      return interruptor;\n+    }\n+\n+    protected AsyncQueryInterruptor(int threadPoolSize) {\n+      interruptorService = Executors.newFixedThreadPool(threadPoolSize);\n+    }\n+\n+    protected ExecutorService getExecutorService() {\n+      return interruptorService;\n+    }\n+}\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\ndeleted file mode 100644\nindex 73587f47c..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Interruptor.\n- */\n-@Singleton\n-class AsyncQueryInterruptor {\n-\n-    private static AsyncQueryInterruptor interruptor;\n-    private ExecutorService interruptorService;\n-\n-    protected static AsyncQueryInterruptor getInstance(int threadPoolSize) {\n-      if (interruptor == null) {\n-        synchronized (AsyncQueryInterruptor.class) {\n-        interruptor = new AsyncQueryInterruptor(threadPoolSize);\n-        }\n-      }\n-      return interruptor;\n-    }\n-\n-    protected AsyncQueryInterruptor(int threadPoolSize) {\n-      interruptorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return interruptorService;\n-    }\n-}\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\ndeleted file mode 100644\nindex 73587f47c..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryInterruptor.java\n+++ /dev/null\n", "chunk": "@@ -1,38 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n-import javax.inject.Singleton;\n-\n-/**\n- * Class for initializing the Query Interruptor.\n- */\n-@Singleton\n-class AsyncQueryInterruptor {\n-\n-    private static AsyncQueryInterruptor interruptor;\n-    private ExecutorService interruptorService;\n-\n-    protected static AsyncQueryInterruptor getInstance(int threadPoolSize) {\n-      if (interruptor == null) {\n-        synchronized (AsyncQueryInterruptor.class) {\n-        interruptor = new AsyncQueryInterruptor(threadPoolSize);\n-        }\n-      }\n-      return interruptor;\n-    }\n-\n-    protected AsyncQueryInterruptor(int threadPoolSize) {\n-      interruptorService = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    protected ExecutorService getExecutorService() {\n-      return interruptorService;\n-    }\n-}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzY3OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917679", "body": "Remove.", "bodyText": "Remove.", "bodyHTML": "<p dir=\"auto\">Remove.</p>", "author": "aklish", "createdAt": "2020-03-09T19:39:31Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -54,55 +52,42 @@ public class AsyncQueryThread implements Runnable {\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n      */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b626e6dc5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +52,63 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n             } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n             }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -52,63 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxNzg4OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389917889", "body": "It would be good to log the entire query object here.", "bodyText": "It would be good to log the entire query object here.", "bodyHTML": "<p dir=\"auto\">It would be good to log the entire query object here.</p>", "author": "aklish", "createdAt": "2020-03-09T19:39:57Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -54,55 +52,42 @@ public class AsyncQueryThread implements Runnable {\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n      */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b626e6dc5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +52,63 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n             } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n             }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -52,63 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxODY3OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389918679", "body": "Can we collapse these log lines into one?", "bodyText": "Can we collapse these log lines into one?", "bodyHTML": "<p dir=\"auto\">Can we collapse these log lines into one?</p>", "author": "aklish", "createdAt": "2020-03-09T19:41:32Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -54,55 +52,42 @@ public class AsyncQueryThread implements Runnable {\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n      */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b626e6dc5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +52,63 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n             } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n             }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -52,63 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxODc2MQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389918761", "body": "Cab we collapse these log lines into one?", "bodyText": "Cab we collapse these log lines into one?", "bodyHTML": "<p dir=\"auto\">Cab we collapse these log lines into one?</p>", "author": "aklish", "createdAt": "2020-03-09T19:41:43Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -54,55 +52,42 @@ public class AsyncQueryThread implements Runnable {\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n      */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b626e6dc5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +52,63 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n             } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n             }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -52,63 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTI1Ng==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389919256", "body": "Creating the response and updating the status should be done inside a single transaction to the database.", "bodyText": "Creating the response and updating the status should be done inside a single transaction to the database.", "bodyHTML": "<p dir=\"auto\">Creating the response and updating the status should be done inside a single transaction to the database.</p>", "author": "aklish", "createdAt": "2020-03-09T19:42:46Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -54,55 +52,42 @@ public class AsyncQueryThread implements Runnable {\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n      */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "63fc19ab13d7882666c47bbd0e1be53338e09f84", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b626e6dc5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +52,63 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n             ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n             }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n \n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n \n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n             } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n             }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -52,63 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n-        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n         try {\n             // Change async query to processing\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n-            //Thread.sleep(180000);\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n-            log.debug(\"query: {}\", query);\n-            log.debug(\"queryType: {}\", queryType);\n-            AsyncQuery asyncQuery;\n-            AsyncQueryResult asyncQueryResult;\n-            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n-                response = elide.get(getPath(query), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(query, user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n-                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n-                });\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n-                // Create AsyncQueryResult entry for AsyncQuery\n-                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Add queryResult object to query object\n-                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setResult(asyncQueryResult);\n-                });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e.getMessage());\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTk4OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389919988", "body": "If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.", "bodyText": "If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.", "bodyHTML": "<p dir=\"auto\">If we log the entire asyncQuery object, we won't need all of these separate, sprinkled log messages.</p>", "author": "aklish", "createdAt": "2020-03-09T19:44:10Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n+            } else {\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -120,7 +105,6 @@ public class AsyncQueryThread implements Runnable {\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n         }\n-        log.debug(\"QueryParams: {}\", queryParams);\n         return queryParams;\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -109,8 +114,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And retrieves path to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n", "next_change": {"commit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..9b205d0c8 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -114,8 +110,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And retrieves path to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -120,13 +110,12 @@ public class AsyncQueryThread implements Runnable {\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n         }\n-        log.debug(\"QueryParams: {}\", queryParams);\n         return queryParams;\n     }\n \n     /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And retrieves path to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -116,13 +85,40 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This method parses the url and gets the query params.\n      * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n+     * @param uri URIBuilder instance\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n      */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private String getPath(URIBuilder uri) {\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(Elide elide, User user, String apiVersion, UUID requestUUID)\n+            throws URISyntaxException {\n+        URIBuilder uri = new URIBuilder(queryObj.getQuery());\n+        MultivaluedMap<String, String> queryParams = getQueryParams(uri);\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(uri), queryParams, user, apiVersion, requestUUID);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(Map<String, QueryRunner> runners, User user, String apiVersion,\n+            UUID requestUUID) throws URISyntaxException {\n+        QueryRunner runner = runners.get(apiVersion);\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestUUID);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMDE5Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r389920192", "body": "Remove log statement.  Let's consolidate logging into fewer (more complete log statements).", "bodyText": "Remove log statement.  Let's consolidate logging into fewer (more complete log statements).", "bodyHTML": "<p dir=\"auto\">Remove log statement.  Let's consolidate logging into fewer (more complete log statements).</p>", "author": "aklish", "createdAt": "2020-03-09T19:44:33Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+import java.util.UUID;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private String query;\n+    private QueryType queryType;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private UUID id;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        AsyncDbUtil asyncDbUtil = AsyncDbUtil.getInstance(elide);\n+        try {\n+            // Change async query to processing\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            //Thread.sleep(180000);\n+            ElideResponse response = null;\n+            log.debug(\"query: {}\", query);\n+            log.debug(\"queryType: {}\", queryType);\n+            AsyncQuery asyncQuery;\n+            AsyncQueryResult asyncQueryResult;\n+            if (queryType.equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(query);\n+                response = elide.get(getPath(query), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"JSONAPI_V1_0 getBody: {}\", response.getBody());\n+            }\n+            else if (queryType.equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(query, user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}\", response.getResponseCode());\n+                log.debug(\"GRAPHQL_V1_0 getBody: {}\", response.getBody());\n+            }\n+            if (response != null){\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.COMPLETE);\n+                });\n+\n+                // Create AsyncQueryResult entry for AsyncQuery\n+                asyncQueryResult = asyncDbUtil.createAsyncQueryResult(response.getResponseCode(), response.getBody(), asyncQuery, id);\n+\n+                // Add queryResult object to query object\n+                asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setResult(asyncQueryResult);\n+                });\n+            } else {\n+                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // No AsyncQueryResult will be set for this case\n+                asyncQuery = asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+                 });\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e.getMessage());\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncDbUtil.updateAsyncQuery(id, (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n+        }\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return MultivaluedMap with query parameters\n+     */\n+    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+        for (NameValuePair queryParam : uri.getQueryParams()) {\n+            queryParams.add(queryParam.getName(), queryParam.getValue());\n+        }\n+        log.debug(\"QueryParams: {}\", queryParams);\n+        return queryParams;\n+    }\n+\n+    /**\n+     * This method parses the url and gets the query params and retrieves path\n+     * to be used by underlying Elide.get method\n+     * @param query query from the Async request\n+     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @return Path extracted from URI\n+     */\n+    protected String getPath(String query) throws URISyntaxException {\n+        URIBuilder uri;\n+        uri = new URIBuilder(query);\n+        log.debug(\"Retrieving path from query\");", "originalCommit": "acf3f94963a1111820a6e5a69b907c6367fb203c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -134,7 +118,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": null}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -120,13 +110,12 @@ public class AsyncQueryThread implements Runnable {\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n         }\n-        log.debug(\"QueryParams: {}\", queryParams);\n         return queryParams;\n     }\n \n     /**\n-     * This method parses the url and gets the query params and retrieves path\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And retrieves path to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -116,13 +85,40 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This method parses the url and gets the query params.\n      * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n+     * @param uri URIBuilder instance\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return Path extracted from URI\n      */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private String getPath(URIBuilder uri) {\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(Elide elide, User user, String apiVersion, UUID requestUUID)\n+            throws URISyntaxException {\n+        URIBuilder uri = new URIBuilder(queryObj.getQuery());\n+        MultivaluedMap<String, String> queryParams = getQueryParams(uri);\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(uri), queryParams, user, apiVersion, requestUUID);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(Map<String, QueryRunner> runners, User user, String apiVersion,\n+            UUID requestUUID) throws URISyntaxException {\n+        QueryRunner runner = runners.get(apiVersion);\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestUUID);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": null}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex b626e6dc5..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -134,7 +123,6 @@ public class AsyncQueryThread implements Runnable {\n     protected String getPath(String query) throws URISyntaxException {\n         URIBuilder uri;\n         uri = new URIBuilder(query);\n-        log.debug(\"Retrieving path from query\");\n         return uri.getPath();\n     }\n }\n", "next_change": {"commit": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..f748263e1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -125,4 +121,29 @@ public class AsyncQueryThread implements Runnable {\n         uri = new URIBuilder(query);\n         return uri.getPath();\n     }\n+\n+    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n+        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n+        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n+        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n+        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                response.getResponseCode(), response.getBody());\n+        return response;\n+    }\n+\n+    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n+        if (response == null) {\n+            throw new NoHttpResponseException(\"Response for request returned as null\");\n+        }\n+    }\n }\n", "next_change": {"commit": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\ndeleted file mode 100644\nindex f748263e1..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ /dev/null\n", "chunk": "@@ -1,149 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.ElideResponse;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryType;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import org.apache.http.NameValuePair;\n-import org.apache.http.NoHttpResponseException;\n-import org.apache.http.client.utils.URIBuilder;\n-\n-import lombok.Data;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.net.URISyntaxException;\n-import java.util.Date;\n-import java.util.UUID;\n-import java.util.concurrent.Callable;\n-\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Callable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n- */\n-@Slf4j\n-@Data\n-\n-public class AsyncQueryThread implements Callable<AsyncQueryResult> {\n-\n-    private AsyncQuery queryObj;\n-    private AsyncQueryResult queryResultObj;\n-    private User user;\n-    private Elide elide;\n-    private final QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n-    private String apiVersion;\n-\n-    @Override\n-    public AsyncQueryResult call() throws NoHttpResponseException, URISyntaxException {\n-         return processQuery();\n-    }\n-\n-    public AsyncQueryThread(AsyncQuery queryObj, User user, Elide elide, QueryRunner runner,\n-            AsyncQueryDAO asyncQueryDao, String apiVersion) {\n-        this.queryObj = queryObj;\n-        this.user = user;\n-        this.elide = elide;\n-        this.runner = runner;\n-        this.asyncQueryDao = asyncQueryDao;\n-        this.apiVersion = apiVersion;\n-    }\n-\n-   /**\n-    * This is the main method which processes the Async Query request, executes the query and updates\n-    * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    * @return AsyncQueryResult AsyncQueryResult\n-    * @throws URISyntaxException URISyntaxException\n-    * @throws NoHttpResponseException NoHttpResponseException\n-    */\n-    protected AsyncQueryResult processQuery() throws URISyntaxException, NoHttpResponseException {\n-        UUID requestId = UUID.fromString(queryObj.getRequestId());\n-\n-        ElideResponse response = null;\n-        log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-            response = executeJsonApiRequest(queryObj, requestId);\n-        }\n-        else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-            response = executeGraphqlRequest(queryObj, requestId);\n-        }\n-\n-        nullResponseCheck(response);\n-\n-        // Create AsyncQueryResult entry for AsyncQuery\n-        queryResultObj = new AsyncQueryResult();\n-        queryResultObj.setHttpStatus(response.getResponseCode());\n-        queryResultObj.setResponseBody(response.getBody());\n-        queryResultObj.setContentLength(response.getBody().length());\n-        queryResultObj.setCompletedOn(new Date());\n-\n-        return queryResultObj;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return MultivaluedMap with query parameters\n-     */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-        for (NameValuePair queryParam : uri.getQueryParams()) {\n-            queryParams.add(queryParam.getName(), queryParam.getValue());\n-        }\n-        return queryParams;\n-    }\n-\n-    /**\n-     * This method parses the url and gets the query params.\n-     * And retrieves path to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n-     * @return Path extracted from URI\n-     */\n-    protected String getPath(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n-        return uri.getPath();\n-    }\n-\n-    private ElideResponse executeJsonApiRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-        log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = elide.get(\"\", getPath(queryObj.getQuery()), queryParams, user, apiVersion, requestId);\n-        log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private ElideResponse executeGraphqlRequest(AsyncQuery queryObj, UUID requestId) throws URISyntaxException {\n-        //TODO - we need to add the baseUrlEndpoint to the queryObject.\n-        ElideResponse response = runner.run(\"\", queryObj.getQuery(), user, requestId);\n-        log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                response.getResponseCode(), response.getBody());\n-        return response;\n-    }\n-\n-    private void nullResponseCheck(ElideResponse response) throws NoHttpResponseException {\n-        if (response == null) {\n-            throw new NoHttpResponseException(\"Response for request returned as null\");\n-        }\n-    }\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "url": "https://github.com/yahoo/elide/commit/7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "message": "Resolving Review Comments\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-11T15:30:34Z", "type": "commit"}, {"oid": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "url": "https://github.com/yahoo/elide/commit/7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "message": "Resolving Review Comments\n\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-11T15:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5ODI1NA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391098254", "body": "I would move all of this common code to a base class like BaseId", "bodyText": "I would move all of this common code to a base class like BaseId", "bodyHTML": "<p dir=\"auto\">I would move all of this common code to a base class like BaseId</p>", "author": "aklish", "createdAt": "2020-03-11T16:25:16Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.Id;\n+import javax.persistence.OneToOne;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.CreatePermission;\n+import com.yahoo.elide.annotation.DeletePermission;\n+import com.yahoo.elide.annotation.Exclude;\n+import com.yahoo.elide.annotation.Include;\n+import com.yahoo.elide.annotation.ReadPermission;\n+import com.yahoo.elide.annotation.UpdatePermission;\n+\n+import lombok.Data;\n+\n+/**\n+ * Model for Async Query Result\n+ */\n+@Entity\n+@Include(type=\"queryResult\")\n+@ReadPermission(expression = \"Principal is Owner\")\n+@UpdatePermission(expression = \"Prefab.Role.None\")\n+@CreatePermission(expression = \"Prefab.Role.None\")\n+@DeletePermission(expression = \"Prefab.Role.None\")\n+@Data\n+public class AsyncQueryResult implements PrincipalOwned {\n+    @Id\n+    private UUID id; //Matches UUID in query.\n+\n+    private Integer contentLength;\n+\n+    private String responseBody; //success or errors\n+\n+    private Integer status; // HTTP Status\n+\n+    private Date createdOn;\n+\n+    private Date updatedOn;\n+\n+    @OneToOne\n+    private AsyncQuery query;\n+\n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @Exclude\n+    public String getPrincipalName() {\n+        return query.getPrincipalName();\n+    }\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTIwNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391099204", "bodyText": "You can even move the createdOn, updatedOn, and owner fields to a common super class.", "author": "aklish", "createdAt": "2020-03-11T16:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5ODI1NA=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9eb57da04..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -43,42 +40,12 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n \n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex a8eba3d7e..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -47,5 +49,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..711e4ecee 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -49,4 +47,5 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-}\n+\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 711e4ecee..a8eba3d7e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -48,4 +48,4 @@ public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n         return query.getPrincipalName();\n     }\n \n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9eb57da04..0b1c7252c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -43,42 +42,11 @@ public class AsyncQueryResult implements PrincipalOwned {\n \n     private Integer status; // HTTP Status\n \n-    private Date createdOn;\n-\n-    private Date updatedOn;\n-\n     @OneToOne\n     private AsyncQuery query;\n \n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n     @Exclude\n     public String getPrincipalName() {\n         return query.getPrincipalName();\n     }\n-\n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncQuery)) {\n-            return false;\n-        }\n-\n-        return ((AsyncQuery) obj).naturalKey.equals(naturalKey);\n-    }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 0b1c7252c..05e163c2b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -5,48 +5,31 @@\n  */\n package com.yahoo.elide.async.models;\n \n-import com.yahoo.elide.annotation.CreatePermission;\n-import com.yahoo.elide.annotation.DeletePermission;\n-import com.yahoo.elide.annotation.Exclude;\n-import com.yahoo.elide.annotation.Include;\n-import com.yahoo.elide.annotation.ReadPermission;\n-import com.yahoo.elide.annotation.UpdatePermission;\n-\n import lombok.Data;\n \n-import java.util.UUID;\n+import java.util.Date;\n \n-import javax.persistence.Column;\n-import javax.persistence.Entity;\n-import javax.persistence.Id;\n-import javax.persistence.OneToOne;\n+import javax.persistence.Embeddable;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n \n /**\n  * Model for Async Query Result.\n  */\n-@Entity\n-@Include(type = \"asyncQueryResult\")\n-@ReadPermission(expression = \"Principal is Owner\")\n-@UpdatePermission(expression = \"Prefab.Role.None\")\n-@CreatePermission(expression = \"Prefab.Role.None\")\n-@DeletePermission(expression = \"Prefab.Role.None\")\n+@Embeddable\n @Data\n-public class AsyncQueryResult extends AsyncBase implements PrincipalOwned {\n-    @Id\n-    @Column(columnDefinition = \"varchar(36)\")\n-    private UUID id; //Matches UUID in query.\n+\n+public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n-    private String responseBody; //success or errors\n+    private String responseBody;  //URL or Response body\n+\n+    private Integer httpStatus; // HTTP Status\n \n-    private Integer status; // HTTP Status\n+    @Enumerated(EnumType.STRING)\n+    private ResultType resultType; //EMBEDDED, DOWNLOAD\n \n-    @OneToOne\n-    private AsyncQuery query;\n+    private Date completedOn = new Date();\n \n-    @Exclude\n-    public String getPrincipalName() {\n-        return query.getPrincipalName();\n-    }\n }\n", "next_change": {"commit": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 05e163c2b..9d83aaf8f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -23,13 +21,12 @@ public class AsyncQueryResult {\n \n     private Integer contentLength;\n \n+    private Integer recordCount;\n+\n     private String responseBody;  //URL or Response body\n \n     private Integer httpStatus; // HTTP Status\n \n-    @Enumerated(EnumType.STRING)\n-    private ResultType resultType; //EMBEDDED, DOWNLOAD\n-\n     private Date completedOn = new Date();\n \n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 9d83aaf8f..b7bba5fc1 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -16,17 +14,8 @@ import javax.persistence.Embeddable;\n  */\n @Embeddable\n @Data\n-\n-public class AsyncQueryResult {\n-\n+public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n-    private Integer recordCount;\n-\n     private String responseBody;  //URL or Response body\n-\n-    private Integer httpStatus; // HTTP Status\n-\n-    private Date completedOn = new Date();\n-\n }\n", "next_change": {"commit": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex b7bba5fc1..6fd4e986c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -17,5 +18,6 @@ import javax.persistence.Embeddable;\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n+    @Lob\n     private String responseBody;  //URL or Response body\n }\n", "next_change": {"commit": "80060c6b960497b346c7325408dcc2459bbdfd70", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\nindex 6fd4e986c..3be5b3f38 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncQueryResult.java\n", "chunk": "@@ -15,6 +16,7 @@ import javax.persistence.Lob;\n  */\n @Embeddable\n @Data\n+@EqualsAndHashCode(callSuper = true)\n public class AsyncQueryResult extends AsyncAPIResult {\n     private Integer contentLength;\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "2bf1cd64b15c308983cc1c31e1fa3cc78285c498", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1708)"}, {"oid": "80060c6b960497b346c7325408dcc2459bbdfd70", "committedDate": "2021-03-22 15:47:37 -0500", "message": "Fix Lombok EqualsAndHashCode warnings (#1948)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5OTYyNg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391099626", "body": "Spacing is off in this function.", "bodyText": "Spacing is off in this function.", "bodyHTML": "<p dir=\"auto\">Spacing is off in this function.</p>", "author": "aklish", "createdAt": "2020-03-11T16:27:17Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..507b25eb3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -23,23 +22,21 @@ import lombok.extern.slf4j.Slf4j;\n  * orphan query statuses after host/app crash or restart.\n  */\n @Slf4j\n-@Singleton\n public class AsyncCleanerService {\n \n     private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n     private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n \n-    private static AsyncCleanerService asyncCleanerService;\n-    private ScheduledExecutorService cleanerService;\n+    private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+        //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+        int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n-    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n-    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n-    \t\n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n         AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 507b25eb3..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -12,61 +16,67 @@ import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n \n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses\n+ * after host/app crash or restart.\n  */\n @Slf4j\n public class AsyncCleanerService {\n \n-    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n-    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+    private final int defaultCleanupDelayMinutes = 360;\n+    private final int maxCleanupInitialDelayMinutes = 100;\n \n     private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n \n         //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n         int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n         ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n+                queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n+        //interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n+                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n     /**\n-     * Initialize the singleton AsyncCleanerService object\n+     * Initialize the singleton AsyncCleanerService object.\n+     * If already initialized earlier, no new object is created.\n      * @param elide Elide Instance\n      * @param maxRunTimeMinutes max run times in minutes\n      * @param queryCleanupDays Async Query Clean up days\n      * @param asyncQueryDao DAO Object\n      */\n-    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n-        if(asyncCleanerService == null) {\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n+        if (asyncCleanerService == null) {\n             asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n         } else {\n             log.debug(\"asyncCleanerService is already initialized.\");\n         }\n     }\n \n-    public static AsyncCleanerService getInstance() {\n+    /**\n+     * Get instance of AsyncCleanerService.\n+     * @return AsyncCleanerService Object\n+     */\n+    public synchronized static AsyncCleanerService getInstance() {\n         return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 665eff893..7d765766e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,78 +5,69 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries.\n- * It will schedule task to track long running queries and kills them.\n- * It will also schedule task to update orphan query statuses\n- * after host/app crash or restart.\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n  */\n @Slf4j\n+@Singleton\n public class AsyncCleanerService {\n \n-    private final int defaultCleanupDelayMinutes = 360;\n-    private final int maxCleanupInitialDelayMinutes = 100;\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n \n-    private static AsyncCleanerService asyncCleanerService = null;\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n \n     @Inject\n-    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n \n         //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n         int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n-                queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n-        //interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n-                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    /**\n-     * Initialize the singleton AsyncCleanerService object.\n-     * If already initialized earlier, no new object is created.\n-     * @param elide Elide Instance\n-     * @param maxRunTimeMinutes max run times in minutes\n-     * @param queryCleanupDays Async Query Clean up days\n-     * @param asyncQueryDao DAO Object\n-     */\n-    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    private static AsyncCleanerService getInstance() {\n         if (asyncCleanerService == null) {\n-            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n-        } else {\n-            log.debug(\"asyncCleanerService is already initialized.\");\n+          synchronized (AsyncCleanerService.class) {\n+        \t  asyncCleanerService = new AsyncCleanerService();\n+          }\n         }\n+        return asyncCleanerService;\n     }\n \n-    /**\n-     * Get instance of AsyncCleanerService.\n-     * @return AsyncCleanerService Object\n-     */\n-    public synchronized static AsyncCleanerService getInstance() {\n-        return asyncCleanerService;\n+    private AsyncCleanerService() {\n+      cleanerService = Executors.newSingleThreadScheduledExecutor();\n     }\n-}\n+\n+    private ScheduledExecutorService getExecutorService() {\n+      return cleanerService;\n+    }\n+\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d765766e..2a662976b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -53,21 +48,4 @@ public class AsyncCleanerService {\n         cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n-        if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n-        }\n-        return asyncCleanerService;\n-    }\n-\n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,69 +5,78 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses\n+ * after host/app crash or restart.\n  */\n @Slf4j\n-@Singleton\n public class AsyncCleanerService {\n \n-    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n-    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+    private final int defaultCleanupDelayMinutes = 360;\n+    private final int maxCleanupInitialDelayMinutes = 100;\n \n-    private static AsyncCleanerService asyncCleanerService;\n-    private ScheduledExecutorService cleanerService;\n+    private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n+\n+        //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+        int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n-    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n-    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n-    \t\n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n+                queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n+        //interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n+                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n+    /**\n+     * Initialize the singleton AsyncCleanerService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param maxRunTimeMinutes max run times in minutes\n+     * @param queryCleanupDays Async Query Clean up days\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n         if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n+            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncCleanerService is already initialized.\");\n         }\n-        return asyncCleanerService;\n     }\n \n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n+    /**\n+     * Get instance of AsyncCleanerService.\n+     * @return AsyncCleanerService Object\n+     */\n+    public synchronized static AsyncCleanerService getInstance() {\n+        return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "1c0cc338c4b7a05336dba95c781203a80d157cd5", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Tweak Cleaner Thread Delays (#1674)"}, {"oid": "1d04e914c89ad894560fe36d8d11e96fb2774981", "committedDate": "2021-01-27 17:29:45 -0500", "message": "Async Refactor: Part 1 (#1777)"}, {"oid": "98f612f023448a93324aaed11e00d6d4fa730c74", "committedDate": "2021-04-08 22:39:32 -0400", "message": "Issue 1929 - Clean up code quality (#1964)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "30816cbe1496c349c05a778b105efa87ec51a7c2", "committedDate": "2023-05-29 20:07:44 -0500", "message": "Refactor configuration (#2997)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwMDc2MA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391100760", "body": "This seems like a constructor argument rather than an interface contract.  I would remove.", "bodyText": "This seems like a constructor argument rather than an interface contract.  I would remove.", "bodyHTML": "<p dir=\"auto\">This seems like a constructor argument rather than an interface contract.  I would remove.</p>", "author": "aklish", "createdAt": "2020-03-11T16:28:55Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwMTAxNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391101014", "body": "Same comment.  We don't need this in the interface.", "bodyText": "Same comment.  We don't need this in the interface.", "bodyHTML": "<p dir=\"auto\">Same comment.  We don't need this in the interface.</p>", "author": "aklish", "createdAt": "2020-03-11T16:29:18Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNDEwOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391104109", "body": "I don't think we should expose implementation details like UpdateQuery in a DAO interface.  \r\n\r\nWe should have methods like ```updateStatus(UUID asyncQueryId, QueryStatus status)```", "bodyText": "I don't think we should expose implementation details like UpdateQuery in a DAO interface.\nWe should have methods like updateStatus(UUID asyncQueryId, QueryStatus status)", "bodyHTML": "<p dir=\"auto\">I don't think we should expose implementation details like UpdateQuery in a DAO interface.</p>\n<p dir=\"auto\">We should have methods like <code>updateStatus(UUID asyncQueryId, QueryStatus status)</code></p>", "author": "aklish", "createdAt": "2020-03-11T16:34:01Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNDM1OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391104359", "body": "Remove - see earlier comment.", "bodyText": "Remove - see earlier comment.", "bodyHTML": "<p dir=\"auto\">Remove - see earlier comment.</p>", "author": "aklish", "createdAt": "2020-03-11T16:34:23Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+\n+    /**\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,23 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -55,10 +55,11 @@ public interface AsyncQueryDAO {\n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNTA1Mg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391105052", "body": "Let's not use Object here.  This should delete a collection of AsyncQuery objects.", "bodyText": "Let's not use Object here.  This should delete a collection of AsyncQuery objects.", "bodyHTML": "<p dir=\"auto\">Let's not use Object here.  This should delete a collection of AsyncQuery objects.</p>", "author": "aklish", "createdAt": "2020-03-11T16:35:24Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNTIzMw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391105233", "body": "Remove or replace with more specific functions.", "bodyText": "Remove or replace with more specific functions.", "bodyHTML": "<p dir=\"auto\">Remove or replace with more specific functions.</p>", "author": "aklish", "createdAt": "2020-03-11T16:35:37Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjk1Ng==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391106956", "body": "Spacing is off.", "bodyText": "Spacing is off.", "bodyHTML": "<p dir=\"auto\">Spacing is off.</p>", "author": "aklish", "createdAt": "2020-03-11T16:38:04Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+        log.debug(\"deleteAsyncQueryAndResultCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n+                }\n+            }\n+\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+        log.debug(\"createAsyncQueryResult\");\n+        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n+            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n+            asyncQueryResult.setStatus(status);\n+            asyncQueryResult.setResponseBody(responseBody);\n+            asyncQueryResult.setContentLength(responseBody.length());\n+            asyncQueryResult.setQuery(asyncQuery);\n+            asyncQueryResult.setId(asyncQueryId);\n+            asyncQuery.setResult(asyncQueryResult);\n+            tx.createObject(asyncQueryResult, scope);\n+            tx.save(asyncQuery, scope);\n+            return asyncQueryResult;\n+        });\n+        return queryResultObj;\n+    }\n+\n+    @Override\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+        log.debug(\"executeInTransaction\");\n+        Object result = null;\n+        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n+\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MzQzMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411683431", "bodyText": "Spacing is still off.", "author": "aklish", "createdAt": "2020-04-20T20:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjk1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -127,8 +151,38 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+    }\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n         log.debug(\"executeInTransaction\");\n         Object result = null;\n         try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -186,9 +211,9 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         log.debug(\"executeInTransaction\");\n         Object result = null;\n         try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-\t        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-\t        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+            RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n             result = action.execute(tx, scope);\n             tx.commit(scope);\n             tx.flush(scope);\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..376eda9cb 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -176,44 +127,14 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (ParseException e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @Override\n+    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n         log.debug(\"executeInTransaction\");\n         Object result = null;\n         try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+\t        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+\t        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n             result = action.execute(tx, scope);\n             tx.commit(scope);\n             tx.flush(scope);\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -127,14 +176,20 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     */\n+    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n         log.debug(\"executeInTransaction\");\n         Object result = null;\n         try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-\t        JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-\t        MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-\t        RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+            RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n             result = action.execute(tx, scope);\n             tx.commit(scope);\n             tx.flush(scope);\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1802b87dc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -189,10 +195,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n             JsonApiDocument jsonApiDoc = new JsonApiDocument();\n             MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"query\", jsonApiDoc, tx, null, queryParams, elide.getElideSettings());\n+            RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                    tx, null, queryParams, elide.getElideSettings());\n             result = action.execute(tx, scope);\n-            tx.commit(scope);\n             tx.flush(scope);\n+            tx.commit(scope);\n         } catch (IOException e) {\n             log.error(\"IOException: {}\", e);\n         } catch (Exception e) {\n", "next_change": {"commit": "90a083d3c16c9c12fea7989652c63c37d5c75191", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1802b87dc..cea2a3a86 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -202,8 +201,7 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n             tx.commit(scope);\n         } catch (IOException e) {\n             log.error(\"IOException: {}\", e);\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n+            throw new IllegalStateException(e);\n         }\n         return result;\n     }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex cea2a3a86..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -205,4 +176,26 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n+        Collection<AsyncQuery> asyncQueryList = null;\n+        log.debug(\"loadAsyncQueryCollection\");\n+        try {\n+            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filterExpression)\n+                        .build();\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                return loaded;\n+            });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            throw new IllegalStateException(e);\n+        }\n+        return asyncQueryList;\n+    }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwODUyMQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391108521", "body": "Separate the load and delete.  This function should only delete (and not load anything).", "bodyText": "Separate the load and delete.  This function should only delete (and not load anything).", "bodyHTML": "<p dir=\"auto\">Separate the load and delete.  This function should only delete (and not load anything).</p>", "author": "aklish", "createdAt": "2020-03-11T16:40:15Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n+        return asyncQueryList;\n+    }\n+\n+    @Override\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -42,44 +51,49 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public void setElide(Elide elide) {\n-        this.elide = elide;\n-    }\n-\n-    @Override\n-    public void setDataStore(DataStore dataStore) {\n-        this.dataStore = dataStore;\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n     }\n \n-    @Override\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status) {\n+        return updateAsyncQueryCollection(asyncQueryList, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n         executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n             while(itr.hasNext()) {\n                 AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                updateFunction.update(asyncQuery);\n-                tx.save(asyncQuery, scope);\n+                updateFunction.update(query);\n+                tx.save(query, scope);\n             }\n             return asyncQueryList;\n         });\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -83,19 +84,40 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     /**\n      * This method updates a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n      * @return query object list updated\n      */\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+    @SuppressWarnings(\"unchecked\")\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+            UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                updateFunction.update(query);\n-                tx.save(query, scope);\n-            }\n-            return asyncQueryList;\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                        AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while (itr.hasNext()) {\n+                   AsyncQuery query = (AsyncQuery) itr.next();\n+                   updateFunction.update(query);\n+                   tx.save(query, scope);\n+                }\n+                return null;\n+                } catch (ParseException e) {\n+                    log.error(\"Exception: {}\", e);\n+                }\n+            return null;\n         });\n         return asyncQueryList;\n     }\n", "next_change": {"commit": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..df24fd5e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -95,30 +95,31 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                   AsyncQuery query = (AsyncQuery) itr.next();\n-                   updateFunction.update(query);\n-                   tx.save(query, scope);\n-                }\n-                return null;\n-                } catch (ParseException e) {\n-                    log.error(\"Exception: {}\", e);\n-                }\n-            return null;\n-        });\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                        (tx, scope) -> {\n+                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                         .type(AsyncQuery.class)\n+                         .filterExpression(filter)\n+                         .build();\n+\n+                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                 Iterator<Object> itr = loaded.iterator();\n+\n+                 while (itr.hasNext()) {\n+                     AsyncQuery query = (AsyncQuery) itr.next();\n+                     updateFunction.update(query);\n+                     tx.save(query, scope);\n+                 }\n+                 return itr;\n+             });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n         return asyncQueryList;\n     }\n \n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex df24fd5e5..376eda9cb 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -5,165 +5,112 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStore;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n import com.yahoo.elide.request.EntityProjection;\n \n-import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n /**\n- * Utility class which implements AsyncQueryDAO.\n+ * Utility class which implements AsyncQueryDAO\n  */\n @Singleton\n @Slf4j\n public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n+    private Elide elide;\n+    private DataStore dataStore;\n \n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n+    public DefaultAsyncQueryDAO() {}\n \n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n         this.elide = elide;\n-        this.dataStore = dataStore;\n     }\n \n     @Override\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n-        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(status);\n-        });\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n     }\n \n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQuery The AsyncQuery Object which will be updated\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            updateFunction.update(asyncQuery);\n-            tx.save(asyncQuery, scope);\n-            return asyncQuery;\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n-            UpdateQuery updateFunction) {\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                        (tx, scope) -> {\n-                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                         .type(AsyncQuery.class)\n-                         .filterExpression(filter)\n-                         .build();\n-\n-                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                 Iterator<Object> itr = loaded.iterator();\n-\n-                 while (itr.hasNext()) {\n-                     AsyncQuery query = (AsyncQuery) itr.next();\n-                     updateFunction.update(query);\n-                     tx.save(query, scope);\n-                 }\n-                 return itr;\n-             });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n         return asyncQueryList;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n                 }\n-                return itr;\n-            });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+            }\n+\n+            return asyncQueryList;\n+        });\n         return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..f608ce166 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -106,11 +123,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n             return asyncQueryList;\n         });\n-        return asyncQueryList;\n+        return (Collection<AsyncQuery>) asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "681ee7603c4c3f56341124af0f0904e2022e33a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex f608ce166..1fc29d344 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -104,26 +101,36 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+                Iterable<Object> itr = tx.loadObjects(asyncQueryCollection, scope);\n+\n+                while(((Iterator<AsyncQuery>) itr).hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) ((Iterator<AsyncQuery>) itr).next();\n+                    //asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return itr;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        return asyncQueryList;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}}]}}, {"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -87,30 +101,40 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n-\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while(itr.hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) itr.next();\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return null;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n         return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -134,7 +158,8 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n+            AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..376eda9cb 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -5,161 +5,112 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStore;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n import com.yahoo.elide.request.EntityProjection;\n \n-import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n /**\n- * Utility class which implements AsyncQueryDAO.\n+ * Utility class which implements AsyncQueryDAO\n  */\n @Singleton\n @Slf4j\n public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n+    private Elide elide;\n+    private DataStore dataStore;\n \n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n+    public DefaultAsyncQueryDAO() {}\n \n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n         this.elide = elide;\n-        this.dataStore = dataStore;\n     }\n \n     @Override\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n-        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(status);\n-        });\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n     }\n \n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQuery The AsyncQuery Object which will be updated\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            updateFunction.update(asyncQuery);\n-            tx.save(asyncQuery, scope);\n-            return asyncQuery;\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n-            UpdateQuery updateFunction) {\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                   AsyncQuery query = (AsyncQuery) itr.next();\n-                   updateFunction.update(query);\n-                   tx.save(query, scope);\n-                }\n-                return null;\n-                } catch (ParseException e) {\n-                    log.error(\"Exception: {}\", e);\n-                }\n-            return null;\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n         });\n         return asyncQueryList;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n                 }\n-                return null;\n-            } catch (ParseException e) {\n-                log.error(\"Exception: {}\", e);\n             }\n-            return null;\n+\n+            return asyncQueryList;\n         });\n         return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..f608ce166 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -106,11 +123,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n             return asyncQueryList;\n         });\n-        return asyncQueryList;\n+        return (Collection<AsyncQuery>) asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "681ee7603c4c3f56341124af0f0904e2022e33a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex f608ce166..1fc29d344 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -104,26 +101,36 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+                Iterable<Object> itr = tx.loadObjects(asyncQueryCollection, scope);\n+\n+                while(((Iterator<AsyncQuery>) itr).hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) ((Iterator<AsyncQuery>) itr).next();\n+                    //asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return itr;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        return asyncQueryList;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -5,112 +5,161 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStore;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n /**\n- * Utility class which implements AsyncQueryDAO\n+ * Utility class which implements AsyncQueryDAO.\n  */\n @Singleton\n @Slf4j\n public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n-    private Elide elide;\n-    private DataStore dataStore;\n-\n-    public DefaultAsyncQueryDAO() {}\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n \n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-    \tthis.elide = elide;\n-    \tthis.dataStore = dataStore;\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n     }\n \n-    @Override\n-    public void setElide(Elide elide) {\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n         this.elide = elide;\n+        this.dataStore = dataStore;\n     }\n \n     @Override\n-    public void setDataStore(DataStore dataStore) {\n-        this.dataStore = dataStore;\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n     }\n \n-    @Override\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status) {\n+        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return query object list updated\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+            UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                updateFunction.update(asyncQuery);\n-                tx.save(asyncQuery, scope);\n-            }\n-            return asyncQueryList;\n-        });\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                        (tx, scope) -> {\n+                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                         .type(AsyncQuery.class)\n+                         .filterExpression(filter)\n+                         .build();\n+\n+                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                 Iterator<Object> itr = loaded.iterator();\n+\n+                 while (itr.hasNext()) {\n+                     AsyncQuery query = (AsyncQuery) itr.next();\n+                     updateFunction.update(query);\n+                     tx.save(query, scope);\n+                 }\n+                 return itr;\n+             });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n         return asyncQueryList;\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n-\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+            executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while (itr.hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) itr.next();\n+                    if (query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n-            }\n-\n-            return asyncQueryList;\n-        });\n-        return asyncQueryList;\n+                return null;\n+            });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n+        return null;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n+            AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1d928df8c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,17 +154,17 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                         tx.delete(query, scope);\n                     }\n                 }\n-                return null;\n+                return loaded;\n             });\n         } catch (ParseException e) {\n             log.error(\"Exception: {}\", e);\n         }\n-        return null;\n+        return asyncQueryList;\n     }\n \n     @Override\n     public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+            AsyncQuery asyncQuery, String asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1d928df8c..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,22 +154,20 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, String asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            query.setStatus(QueryStatus.COMPLETE);\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,7 +141,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                     .build();\n             AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n             query.setResult(asyncQueryResult);\n-            query.setStatus(QueryStatus.COMPLETE);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n             tx.save(query, scope);\n             return query;\n         });\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTE4Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391109183", "body": "I don't think this function should load anything.  Load can be a separate function.", "bodyText": "I don't think this function should load anything.  Load can be a separate function.", "bodyHTML": "<p dir=\"auto\">I don't think this function should load anything.  Load can be a separate function.</p>", "author": "aklish", "createdAt": "2020-03-11T16:41:08Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Utility class which implements AsyncQueryDAO\n+ */\n+@Singleton\n+@Slf4j\n+public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n+\n+    private Elide elide;\n+    private DataStore dataStore;\n+\n+    public DefaultAsyncQueryDAO() {}\n+\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n+        this.elide = elide;\n+    }\n+\n+    @Override\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQuery\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n+        });\n+        return queryObj;\n+    }\n+\n+    @Override\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+        log.debug(\"updateAsyncQueryCollection\");\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NzYxOA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397467618", "bodyText": "Same comment still applies.  All of these objects have already been loaded.  This will result in a lot of unnecessary calls to the DB.\nInstead of loading them, just call the updateFunction and save.", "author": "aklish", "createdAt": "2020-03-24T21:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwOTE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -42,44 +51,49 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public void setElide(Elide elide) {\n-        this.elide = elide;\n-    }\n-\n-    @Override\n-    public void setDataStore(DataStore dataStore) {\n-        this.dataStore = dataStore;\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n     }\n \n-    @Override\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status) {\n+        return updateAsyncQueryCollection(asyncQueryList, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n+     */\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n         executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n             while(itr.hasNext()) {\n                 AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                updateFunction.update(asyncQuery);\n-                tx.save(asyncQuery, scope);\n+                updateFunction.update(query);\n+                tx.save(query, scope);\n             }\n             return asyncQueryList;\n         });\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -83,19 +84,40 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     /**\n      * This method updates a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n      * @return query object list updated\n      */\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+    @SuppressWarnings(\"unchecked\")\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+            UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                updateFunction.update(query);\n-                tx.save(query, scope);\n-            }\n-            return asyncQueryList;\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                        AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while (itr.hasNext()) {\n+                   AsyncQuery query = (AsyncQuery) itr.next();\n+                   updateFunction.update(query);\n+                   tx.save(query, scope);\n+                }\n+                return null;\n+                } catch (ParseException e) {\n+                    log.error(\"Exception: {}\", e);\n+                }\n+            return null;\n         });\n         return asyncQueryList;\n     }\n", "next_change": {"commit": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..df24fd5e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -95,30 +95,31 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n         RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                   AsyncQuery query = (AsyncQuery) itr.next();\n-                   updateFunction.update(query);\n-                   tx.save(query, scope);\n-                }\n-                return null;\n-                } catch (ParseException e) {\n-                    log.error(\"Exception: {}\", e);\n-                }\n-            return null;\n-        });\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                        (tx, scope) -> {\n+                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                         .type(AsyncQuery.class)\n+                         .filterExpression(filter)\n+                         .build();\n+\n+                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                 Iterator<Object> itr = loaded.iterator();\n+\n+                 while (itr.hasNext()) {\n+                     AsyncQuery query = (AsyncQuery) itr.next();\n+                     updateFunction.update(query);\n+                     tx.save(query, scope);\n+                 }\n+                 return itr;\n+             });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n         return asyncQueryList;\n     }\n \n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex df24fd5e5..376eda9cb 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -5,165 +5,112 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStore;\n import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.dialect.ParseException;\n-import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n import com.yahoo.elide.request.EntityProjection;\n \n-import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n /**\n- * Utility class which implements AsyncQueryDAO.\n+ * Utility class which implements AsyncQueryDAO\n  */\n @Singleton\n @Slf4j\n public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n+    private Elide elide;\n+    private DataStore dataStore;\n \n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n+    public DefaultAsyncQueryDAO() {}\n \n     public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n+    \tthis.elide = elide;\n+    \tthis.dataStore = dataStore;\n+    }\n+\n+    @Override\n+    public void setElide(Elide elide) {\n         this.elide = elide;\n-        this.dataStore = dataStore;\n     }\n \n     @Override\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n-        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(status);\n-        });\n+    public void setDataStore(DataStore dataStore) {\n+        this.dataStore = dataStore;\n     }\n \n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQuery The AsyncQuery Object which will be updated\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n+    @Override\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            updateFunction.update(asyncQuery);\n-            tx.save(asyncQuery, scope);\n-            return asyncQuery;\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            updateFunction.update(query);\n+            tx.save(query, scope);\n+            return query;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n-            UpdateQuery updateFunction) {\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                        (tx, scope) -> {\n-                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                         .type(AsyncQuery.class)\n-                         .filterExpression(filter)\n-                         .build();\n-\n-                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                 Iterator<Object> itr = loaded.iterator();\n-\n-                 while (itr.hasNext()) {\n-                     AsyncQuery query = (AsyncQuery) itr.next();\n-                     updateFunction.update(query);\n-                     tx.save(query, scope);\n-                 }\n-                 return itr;\n-             });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n+        });\n         return asyncQueryList;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-\n-        try {\n-            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                    AsyncQuery.class, false);\n-\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<Object> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n                 }\n-                return itr;\n-            });\n-        } catch (ParseException e) {\n-            log.error(\"Exception: {}\", e);\n-        }\n+            }\n+\n+            return asyncQueryList;\n+        });\n         return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..f608ce166 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -106,11 +123,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n             return asyncQueryList;\n         });\n-        return asyncQueryList;\n+        return (Collection<AsyncQuery>) asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "681ee7603c4c3f56341124af0f0904e2022e33a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex f608ce166..1fc29d344 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -104,26 +101,36 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+                Iterable<Object> itr = tx.loadObjects(asyncQueryCollection, scope);\n+\n+                while(((Iterator<AsyncQuery>) itr).hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) ((Iterator<AsyncQuery>) itr).next();\n+                    //asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return itr;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        return asyncQueryList;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 376eda9cb..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -5,112 +5,161 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.async.models.QueryStatus;\n import com.yahoo.elide.core.DataStore;\n import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n import com.yahoo.elide.request.EntityProjection;\n \n+import lombok.Setter;\n import lombok.extern.slf4j.Slf4j;\n \n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.UUID;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n /**\n- * Utility class which implements AsyncQueryDAO\n+ * Utility class which implements AsyncQueryDAO.\n  */\n @Singleton\n @Slf4j\n public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n-    private Elide elide;\n-    private DataStore dataStore;\n-\n-    public DefaultAsyncQueryDAO() {}\n+    @Setter private Elide elide;\n+    @Setter private DataStore dataStore;\n \n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-    \tthis.elide = elide;\n-    \tthis.dataStore = dataStore;\n+    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n+    public DefaultAsyncQueryDAO() {\n     }\n \n-    @Override\n-    public void setElide(Elide elide) {\n+    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n         this.elide = elide;\n+        this.dataStore = dataStore;\n     }\n \n     @Override\n-    public void setDataStore(DataStore dataStore) {\n-        this.dataStore = dataStore;\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status) {\n+        return updateAsyncQuery(asyncQuery, (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(status);\n+        });\n     }\n \n-    @Override\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction) {\n+    /**\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQuery The AsyncQuery Object which will be updated\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    private AsyncQuery updateAsyncQuery(AsyncQuery asyncQuery, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQuery\");\n         AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            updateFunction.update(query);\n-            tx.save(query, scope);\n-            return query;\n+            updateFunction.update(asyncQuery);\n+            tx.save(asyncQuery, scope);\n+            return asyncQuery;\n         });\n         return queryObj;\n     }\n \n     @Override\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction) {\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status) {\n+        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n+            asyncQuery.setStatus(status);\n+            });\n+    }\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return query object list updated\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+            UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                updateFunction.update(asyncQuery);\n-                tx.save(asyncQuery, scope);\n-            }\n-            return asyncQueryList;\n-        });\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                        (tx, scope) -> {\n+                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                         .type(AsyncQuery.class)\n+                         .filterExpression(filter)\n+                         .build();\n+\n+                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                 Iterator<Object> itr = loaded.iterator();\n+\n+                 while (itr.hasNext()) {\n+                     AsyncQuery query = (AsyncQuery) itr.next();\n+                     updateFunction.update(query);\n+                     tx.save(query, scope);\n+                 }\n+                 return itr;\n+             });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n         return asyncQueryList;\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<Object> itr = asyncQueryList.iterator();\n-\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+            executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while (itr.hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) itr.next();\n+                    if (query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n-            }\n-\n-            return asyncQueryList;\n-        });\n-        return asyncQueryList;\n+                return null;\n+            });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n+        return null;\n     }\n \n     @Override\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n+            AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1d928df8c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,17 +154,17 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                         tx.delete(query, scope);\n                     }\n                 }\n-                return null;\n+                return loaded;\n             });\n         } catch (ParseException e) {\n             log.error(\"Exception: {}\", e);\n         }\n-        return null;\n+        return asyncQueryList;\n     }\n \n     @Override\n     public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+            AsyncQuery asyncQuery, String asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1d928df8c..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,22 +154,20 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, String asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            query.setStatus(QueryStatus.COMPLETE);\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,7 +141,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                     .build();\n             AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n             query.setResult(asyncQueryResult);\n-            query.setStatus(QueryStatus.COMPLETE);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n             tx.save(query, scope);\n             return query;\n         });\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExMTY0Ng==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391111646", "body": "Add a function (see later comments):\r\n```Collection<AsyncQuery> loadQueries(FilterExpression filter)```", "bodyText": "Add a function (see later comments):\nCollection<AsyncQuery> loadQueries(FilterExpression filter)", "bodyHTML": "<p dir=\"auto\">Add a function (see later comments):<br>\n<code>Collection&lt;AsyncQuery&gt; loadQueries(FilterExpression filter)</code></p>", "author": "aklish", "createdAt": "2020-03-11T16:44:51Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.AsyncQueryResult;\n+import com.yahoo.elide.core.DataStore;\n+\n+/**\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n+ */\n+public interface AsyncQueryDAO {\n+\n+    /**\n+     * Set elide object\n+     * @param elide Elide Object.\n+     */\n+    public void setElide(Elide elide);\n+\n+    /**\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n+     */\n+    public void setDataStore(DataStore dataStore);\n+", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -19,40 +19,20 @@ import com.yahoo.elide.core.DataStore;\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setElide(Elide elide);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method uses the filter expression to evaluate a list of filtered results based on the expression\n+     * and returns a collection of filtered AsyncQuery objects.\n+     * @param filterExpression filter expression for filtering from datastore\n+     * @return filtered results\n      */\n-    public void setDataStore(DataStore dataStore);\n-\n-    /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n+    public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n      * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 39a5aa51b..5fef60d27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -35,14 +34,15 @@ public interface AsyncQueryDAO {\n     public Collection<AsyncQuery> loadQueries(String filterExpression);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 5fef60d27..fe223aa73 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,61 +5,72 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import java.util.UUID;\n+\n+import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-\n-import java.util.Collection;\n-import java.util.UUID;\n+import com.yahoo.elide.core.DataStore;\n \n /**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n+ * Utility interface which uses the elide datastore to modify, update and create\n+ * AsyncQuery and AsyncQueryResult Objects\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQuery The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n+     * Set elide object\n+     * @param elide Elide Object.\n      */\n-    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n+    public void setElide(Elide elide);\n \n     /**\n-     * This method uses the filter expression to evaluate a list of filtered results based on the expression.\n-     * and returns a collection of filtered AsyncQuery objects.\n-     * @param filterExpression filter expression for filtering from datastore\n-     * @return filtered results\n+     * Set data store object\n+     * @param dataStore Datastore Object from Elide.\n      */\n-    public Collection<AsyncQuery> loadQueries(String filterExpression);\n+    public void setDataStore(DataStore dataStore);\n \n     /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param status ElideResponse status from AsyncQuery\n-     * @param responseBody ElideResponse responseBody from AsyncQuery\n-     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n-     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n-     * @return AsyncQueryResult Object\n+     * This method updates the model for AsyncQuery with passed value.\n+     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @return AsyncQuery Object\n+     */\n+    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n+\n+    /**\n+     * This method updates a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n-            UUID asyncQueryId);\n+    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n \n     /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n \n     /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * @param status ElideResponse status from AsyncQuery\n+     * @param responseBody ElideResponse responseBody from AsyncQuery\n+     * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n+     * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n+     * @return AsyncQueryResult Object\n+     */\n+    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method creates a transaction from the datastore, performs the DB action using\n+     * a generic functional interface and closes the transaction.\n+     * @param dataStore Elide datastore retrieved from Elide object\n+     * @param action Functional interface to perform DB action\n+     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n-            QueryStatus status);\n+    public Object executeInTransaction(DataStore dataStore, Transactional action);\n \n }\n", "next_change": {"commit": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..f68a06e2e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -62,15 +42,22 @@ public interface AsyncQueryDAO {\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+\n+    /**\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n \n }\n", "next_change": {"commit": "26f83caac1e5f9d314fb5df562de880925cb4147", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex f68a06e2e..39a5aa51b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -47,15 +47,16 @@ public interface AsyncQueryDAO {\n     /**\n      * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n      * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n      * @return query object list deleted\n      */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList);\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n \n     /**\n      * This method updates the status for a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n      * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param status status to be updated\n      * @return query object list updated\n      */\n     public Collection<AsyncQuery> updateStatusAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, QueryStatus status);\n", "next_change": null}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex fe223aa73..3dd4c0cc6 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -5,72 +5,53 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import java.util.UUID;\n-\n-import com.yahoo.elide.Elide;\n import com.yahoo.elide.async.models.AsyncQuery;\n import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.core.DataStore;\n+import com.yahoo.elide.async.models.QueryStatus;\n+\n+import java.util.Collection;\n+import java.util.UUID;\n \n /**\n- * Utility interface which uses the elide datastore to modify, update and create\n- * AsyncQuery and AsyncQueryResult Objects\n+ * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n  */\n public interface AsyncQueryDAO {\n \n     /**\n-     * Set elide object\n-     * @param elide Elide Object.\n-     */\n-    public void setElide(Elide elide);\n-\n-    /**\n-     * Set data store object\n-     * @param dataStore Datastore Object from Elide.\n+     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n+     * @param asyncQuery The AsyncQuery Object to be updated\n+     * @param status Status from Enum QueryStatus\n+     * @return AsyncQuery Updated AsyncQuery Object\n      */\n-    public void setDataStore(DataStore dataStore);\n+    public AsyncQuery updateStatus(AsyncQuery asyncQuery, QueryStatus status);\n \n     /**\n-     * This method updates the model for AsyncQuery with passed value.\n-     * @param asyncQueryId Unique UUID for the AsyncQuery Object\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n-     * @return query object list updated\n-     */\n-    public Iterable<Object> updateAsyncQueryCollection(Iterable<Object> asyncQueryList, UpdateQuery updateFunction);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be deleted\n-     * @return query object list deleted\n-     */\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship\n+     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n      * @param status ElideResponse status from AsyncQuery\n      * @param responseBody ElideResponse responseBody from AsyncQuery\n      * @param asyncQuery AsyncQuery object to be associated with the AsyncQueryResult object\n      * @param asyncQueryId UUID of the AsyncQuery to be associated with the AsyncQueryResult object\n      * @return AsyncQueryResult Object\n      */\n-    public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId);\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery,\n+            UUID asyncQueryId);\n \n     /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n+     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n+     * returns the objects deleted.\n+     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n+     * @return query object list deleted\n+     */\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression);\n+\n+    /**\n+     * This method updates the status for a collection of AsyncQuery objects from database and\n+     * returns the objects updated.\n+     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n+     * @param status status to be updated\n+     * @return query object list updated\n      */\n-    public Object executeInTransaction(DataStore dataStore, Transactional action);\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+            QueryStatus status);\n \n }\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\nindex 3dd4c0cc6..8a09538f2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n", "chunk": "@@ -51,7 +49,13 @@ public interface AsyncQueryDAO {\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n-\n+    /**\n+     * This method gets a collection of AsyncQuery objects from database and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\ndeleted file mode 100644\nindex 8a09538f2..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,61 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-\n-import java.util.Collection;\n-\n-/**\n- * Utility interface which uses the elide datastore to modify and create AsyncQuery and AsyncQueryResult Objects.\n- */\n-public interface AsyncQueryDAO {\n-\n-    /**\n-     * This method updates the QueryStatus for AsyncQuery for given QueryStatus.\n-     * @param asyncQueryId The AsyncQuery Object to be updated\n-     * @param status Status from Enum QueryStatus\n-     * @return AsyncQuery Updated AsyncQuery Object\n-     */\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status);\n-\n-    /**\n-     * This method persists the model for AsyncQueryResult, AsyncQuery object and establishes the relationship.\n-     * @param asyncQueryResult AsyncQueryResult to be associated with the AsyncQuery object\n-     * @param asyncQueryId String\n-     * @return AsyncQuery Object\n-     */\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId);\n-\n-    /**\n-     * This method deletes a collection of AsyncQuery and its associated AsyncQueryResult objects from database and\n-     * returns the objects deleted.\n-     * @param filterExpression filter expression to delete AsyncQuery Objects based on\n-     * @return query object list deleted\n-     */\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression);\n-\n-    /**\n-     * This method updates the status for a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param  filterExpression filter expression to update AsyncQuery Objects based on\n-     * @param status status to be updated\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status);\n-    /**\n-     * This method gets a collection of AsyncQuery objects from database and\n-     * returns the objects.\n-     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n-     * @return query object list updated\n-     */\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression);\n-}\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391114170", "body": "We are logging the response above before we check for null here.", "bodyText": "We are logging the response above before we check for null here.", "bodyHTML": "<p dir=\"auto\">We are logging the response above before we check for null here.</p>", "author": "aklish", "createdAt": "2020-03-11T16:48:38Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.net.URISyntaxException;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URIBuilder;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideResponse;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.async.models.QueryType;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for executing the query provided in Async Query.\n+ * It will also update the query status and result object at different\n+ * stages of execution.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryThread implements Runnable {\n+\n+    private AsyncQuery queryObj;\n+    private User user;\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        processQuery();\n+    }\n+\n+    /**\n+     * This is the main method which processes the Async Query request, executes the query and updates\n+     * values for AsyncQuery and AsyncQueryResult models accordingly.\n+     */\n+    protected void processQuery() {\n+        try {\n+            // Change async query to processing\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n+            ElideResponse response = null;\n+            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n+            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n+                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n+                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+                response = runner.run(queryObj.getQuery(), user);\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+            }\n+            if (response != null){", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDkzOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391114939", "bodyText": "Technically, I don't think this ever returns null.  I think it either returns non-null or throws an exception.", "author": "aklish", "createdAt": "2020-03-11T16:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNTM5NQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391115395", "bodyText": "Instead of checking for null, we can just add an assert here that will throw an exception if response is null.", "author": "aklish", "createdAt": "2020-03-11T16:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNDE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 9b205d0c8..abf73e908 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -68,27 +67,27 @@ public class AsyncQueryThread implements Runnable {\n                 response = runner.run(queryObj.getQuery(), user);\n                 log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response != null){\n-                // If we receive a response update Query Status to complete\n-                queryObj.setStatus(QueryStatus.COMPLETE);\n+            if (response == null){\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            }\n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n-                asyncQueryDao.setAsyncQueryAndResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex abf73e908..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -92,8 +97,8 @@ public class AsyncQueryThread implements Runnable {\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..b80f6ac05 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -50,55 +49,47 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n+     */\n     protected void processQuery() {\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n+                asyncQuery.setStatus(QueryStatus.PROCESSING);\n+                });\n             ElideResponse response = null;\n             log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n             if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n                 MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n                 log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n                 response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n             else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n                 response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n             }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n+            if (response == null){\n+                throw new NullPointerException(\"Response for request returned as null\");\n             }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n             // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+            queryObj.setStatus(QueryStatus.COMPLETE);\n+\n+            // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n+            asyncQueryDao.setAsyncQueryAndResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n \n         } catch (Exception e) {\n             log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+            // If an Exception is encountered we set the QueryStatus to FAILURE\n+            //No AsyncQueryResult will be set for this case\n+            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n+                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n+            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params.\n-     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n+     * to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 9b205d0c8..13c26da5a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -49,52 +50,55 @@ public class AsyncQueryThread implements Runnable {\n     /**\n      * This is the main method which processes the Async Query request, executes the query and updates\n      * values for AsyncQuery and AsyncQueryResult models accordingly.\n-     */\n+    */\n     protected void processQuery() {\n         try {\n             // Change async query to processing\n-            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQuery) -> {\n-                asyncQuery.setStatus(QueryStatus.PROCESSING);\n-                });\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n             ElideResponse response = null;\n             log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n             if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n                 MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n                 log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n                 response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n             }\n             else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n                 response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\", response.getResponseCode(), response.getBody());\n+                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n+                        response.getResponseCode(), response.getBody());\n+            }\n+            if (response == null) {\n+                throw new NoHttpResponseException(\"Response for request returned as null\");\n             }\n-            if (response != null){\n-                // If we receive a response update Query Status to complete\n-                queryObj.setStatus(QueryStatus.COMPLETE);\n \n-                // Create AsyncQueryResult entry for AsyncQuery and add queryResult object to query object\n-                asyncQueryDao.setAsyncQueryAndResult(response.getResponseCode(), response.getBody(), queryObj, queryObj.getId());\n+            // Create AsyncQueryResult entry for AsyncQuery and\n+            // add queryResult object to query object\n+            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n+                    queryObj, queryObj.getId());\n \n+            // If we receive a response update Query Status to complete\n+            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n+\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            if (e.getClass().equals(InterruptedException.class)) {\n+                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n+                // We set the QueryStatus to TIMEDOUT\n+                // No AsyncQueryResult will be set for this case\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n             } else {\n-                // If no response is returned on AsyncQuery request we set the QueryStatus to FAILURE\n+                // If an Exception is encountered we set the QueryStatus to FAILURE\n                 // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-                    asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-                 });\n+                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n             }\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            // If an Exception is encountered we set the QueryStatus to FAILURE\n-            //No AsyncQueryResult will be set for this case\n-            asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-                asyncQueryObj.setStatus(QueryStatus.FAILURE);\n-            });\n         }\n     }\n \n     /**\n-     * This method parses the url and gets the query params and adds them into a MultivaluedMap\n-     * to be used by underlying Elide.get method\n+     * This method parses the url and gets the query params.\n+     * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n      * @param query query from the Async request\n      * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n      * @return MultivaluedMap with query parameters\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\nindex 13c26da5a..d5c2b89c7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryThread.java\n", "chunk": "@@ -17,95 +18,63 @@ import org.apache.http.NameValuePair;\n import org.apache.http.NoHttpResponseException;\n import org.apache.http.client.utils.URIBuilder;\n \n-import lombok.AllArgsConstructor;\n-import lombok.Data;\n import lombok.extern.slf4j.Slf4j;\n \n import java.net.URISyntaxException;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.Callable;\n \n import javax.ws.rs.core.MultivaluedHashMap;\n import javax.ws.rs.core.MultivaluedMap;\n \n /**\n- * Runnable thread for executing the query provided in Async Query.\n- * It will also update the query status and result object at different\n- * stages of execution.\n+ * AsyncQuery implementation of Callable for executing the query provided in AsyncQuery.\n+ * It will also update the query status and result object at different stages of execution.\n  */\n @Slf4j\n-@Data\n-@AllArgsConstructor\n-public class AsyncQueryThread implements Runnable {\n-\n-    private AsyncQuery queryObj;\n+public class AsyncQueryThread implements Callable<AsyncAPIResult> {\n+    private AsyncAPI queryObj;\n     private User user;\n-    private Elide elide;\n-    private QueryRunner runner;\n-    private AsyncQueryDAO asyncQueryDao;\n+    private AsyncExecutorService service;\n+    private String apiVersion;\n \n-    @Override\n-    public void run() {\n-        processQuery();\n+    public AsyncQueryThread(AsyncAPI queryObj, User user, AsyncExecutorService service, String apiVersion) {\n+        this.queryObj = queryObj;\n+        this.user = user;\n+        this.service = service;\n+        this.apiVersion = apiVersion;\n     }\n \n-    /**\n-     * This is the main method which processes the Async Query request, executes the query and updates\n-     * values for AsyncQuery and AsyncQueryResult models accordingly.\n-    */\n-    protected void processQuery() {\n-        try {\n-            // Change async query to processing\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.PROCESSING);\n-            ElideResponse response = null;\n-            log.debug(\"AsyncQuery Object from request: {}\", queryObj);\n-            if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n-                MultivaluedMap<String, String> queryParams = getQueryParams(queryObj.getQuery());\n-                log.debug(\"Extracted QueryParams from AsyncQuery Object: {}\", queryParams);\n-                response = elide.get(getPath(queryObj.getQuery()), queryParams, user);\n-                log.debug(\"JSONAPI_V1_0 getResponseCode: {}, JSONAPI_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n-                response = runner.run(queryObj.getQuery(), user);\n-                log.debug(\"GRAPHQL_V1_0 getResponseCode: {}, GRAPHQL_V1_0 getBody: {}\",\n-                        response.getResponseCode(), response.getBody());\n-            }\n-            if (response == null) {\n-                throw new NoHttpResponseException(\"Response for request returned as null\");\n-            }\n-\n-            // Create AsyncQueryResult entry for AsyncQuery and\n-            // add queryResult object to query object\n-            asyncQueryDao.createAsyncQueryResult(response.getResponseCode(), response.getBody(),\n-                    queryObj, queryObj.getId());\n-\n-            // If we receive a response update Query Status to complete\n-            asyncQueryDao.updateStatus(queryObj, QueryStatus.COMPLETE);\n-\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            if (e.getClass().equals(InterruptedException.class)) {\n-                // An InterruptedException is encountered when we interrupt the query when it goes beyond max run time\n-                // We set the QueryStatus to TIMEDOUT\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.TIMEDOUT);\n-            } else {\n-                // If an Exception is encountered we set the QueryStatus to FAILURE\n-                // No AsyncQueryResult will be set for this case\n-                asyncQueryDao.updateStatus(queryObj, QueryStatus.FAILURE);\n-            }\n+    @Override\n+    public AsyncAPIResult call() throws URISyntaxException, NoHttpResponseException {\n+        ElideResponse response = null;\n+        log.debug(\"AsyncQuery Object from request: {}\", this);\n+        UUID requestUUID = UUID.fromString(queryObj.getRequestId());\n+        if (queryObj.getQueryType().equals(QueryType.JSONAPI_V1_0)) {\n+            response = executeJsonApiRequest(service.getElide(), user, apiVersion, requestUUID);\n+        } else if (queryObj.getQueryType().equals(QueryType.GRAPHQL_V1_0)) {\n+            response = executeGraphqlRequest(service.getRunners(), user, apiVersion, requestUUID);\n         }\n+        nullResponseCheck(response);\n+\n+        AsyncQueryResult queryResult = new AsyncQueryResult();\n+        queryResult.setHttpStatus(response.getResponseCode());\n+        queryResult.setCompletedOn(new Date());\n+        queryResult.setResponseBody(response.getBody());\n+        queryResult.setContentLength(response.getBody().length());\n+        //TODO Add recordcount to queryResultObj\n+        return queryResult;\n     }\n \n     /**\n      * This method parses the url and gets the query params.\n      * And adds them into a MultivaluedMap to be used by underlying Elide.get method\n-     * @param query query from the Async request\n-     * @throws URISyntaxException URISyntaxException from malformed or incorrect URI\n+     * @param uri URIBuilder instance\n      * @return MultivaluedMap with query parameters\n      */\n-    protected MultivaluedMap<String, String> getQueryParams(String query) throws URISyntaxException {\n-        URIBuilder uri;\n-        uri = new URIBuilder(query);\n+    private MultivaluedMap<String, String> getQueryParams(URIBuilder uri) {\n         MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n         for (NameValuePair queryParam : uri.getQueryParams()) {\n             queryParams.add(queryParam.getName(), queryParam.getValue());\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "0ce21e5e6020cd53bdfeb5e6108c83d6aa269ed3", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data Export - Model Changes (#1524)"}, {"oid": "b2a4b372aaf9ac9ef1c3ce181ff4d02dfec467df", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Result Storage Engine Implementation (#1526)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "2f0799a0034c4cf0a7cb2bc6990b0b860c87d5bf", "committedDate": "2021-01-05 14:51:58 -0600", "message": "Initial Table Export Models"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExNzc1Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391117753", "body": "There is some duplicate code here with the prior function.   We should write a utility function to consolidate it.", "bodyText": "There is some duplicate code here with the prior function.   We should write a utility function to consolidate it.", "bodyHTML": "<p dir=\"auto\">There is some duplicate code here with the prior function.   We should write a utility function to consolidate it.</p>", "author": "aklish", "createdAt": "2020-03-11T16:53:50Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -74,45 +62,29 @@ public class AsyncQueryCleanerThread implements Runnable {\n \t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n-        //Calculate date to filter for clean up\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n         String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n                 + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n \n-        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n-            asyncQuery.setStatus(QueryStatus.PROCESSING);\n-            });\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n \n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n \t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -80,6 +121,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n-    }\n-}\n+\t\treturn filterDateFormatted;\n+\t}\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -44,75 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n \n-        //Calculate date to clean up\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(Calendar.DATE, -(queryCleanupDays));\n-        Date cleanupDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n         String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n-        //Calculate date to filter for clean up\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n-        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        cal.add(calendarUnit, -(amount));\n         Date filterDate = cal.getTime();\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n-\n-        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n-            asyncQuery.setStatus(QueryStatus.PROCESSING);\n-            });\n+        return filterDateFormatted;\n     }\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-\t}\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExODAxNg==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391118016", "body": "Shouldn't this be TIMEDOUT instead of PROCESSING?", "bodyText": "Shouldn't this be TIMEDOUT instead of PROCESSING?", "bodyHTML": "<p dir=\"auto\">Shouldn't this be TIMEDOUT instead of PROCESSING?</p>", "author": "aklish", "createdAt": "2020-03-11T16:54:15Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.request.EntityProjection;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Runnable thread for updating AsyncQueryThread status\n+ * beyond the max run time and if not terminated by interrupt process\n+ * due to app/host crash or restart.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCleanerThread implements Runnable {\n+\n+    private int maxRunTimeMinutes;\n+    private Elide elide;\n+    private int queryCleanupDays;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        deleteAsyncQuery();\n+        timeoutAsyncQuery();\n+    }\n+\n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+    @SuppressWarnings(\"unchecked\")\n+    private void deleteAsyncQuery() {\n+\n+        //Calculate date to clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.DATE, -(queryCleanupDays));\n+        Date cleanupDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n+        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+\n+        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+\n+    }\n+    \n+    /**\n+     * This method updates the status of long running async query which\n+     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * */\n+\t@SuppressWarnings(\"unchecked\")\n+    private void timeoutAsyncQuery() {\n+\n+        //Calculate date to filter for clean up\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+\n+        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n+            asyncQuery.setStatus(QueryStatus.PROCESSING);", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..9bbe7c2f9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -74,45 +62,29 @@ public class AsyncQueryCleanerThread implements Runnable {\n \t@SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n-        //Calculate date to filter for clean up\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n         String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n                 + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n \n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n+        Collection<AsyncQuery> loaded = asyncQueryDao.loadQueries(filterExpression);\n \n-        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n-            asyncQuery.setStatus(QueryStatus.PROCESSING);\n-            });\n+        asyncQueryDao.updateStatusAsyncQueryCollection(loaded, QueryStatus.TIMEDOUT);\n     }\n \n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+\tprivate String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(new Date());\n+        cal.add(calendarUnit, -(amount));\n+        Date filterDate = cal.getTime();\n+        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n+        String filterDateFormatted = dateFormat.format(filterDate);\n+        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n+\t\treturn filterDateFormatted;\n \t}\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex 9bbe7c2f9..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -85,6 +80,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-\t\treturn filterDateFormatted;\n-\t}\n-}\n\\ No newline at end of file\n+        return filterDateFormatted;\n+    }\n+}\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..79e9d8a76 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -80,6 +121,6 @@ public class AsyncQueryCleanerThread implements Runnable {\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n-    }\n-}\n+\t\treturn filterDateFormatted;\n+\t}\n+}\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex c36073e74..ec07a6fd7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -44,75 +39,47 @@ public class AsyncQueryCleanerThread implements Runnable {\n     }\n \n     /**\n-     * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * This method deletes the historical queries based on threshold.\n      * */\n     @SuppressWarnings(\"unchecked\")\n     private void deleteAsyncQuery() {\n \n-        //Calculate date to clean up\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(Calendar.DATE, -(queryCleanupDays));\n-        Date cleanupDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String cleanupDateFormatted = dateFormat.format(cleanupDate);\n-        log.debug(\"cleanupDateFormatted = {}\", cleanupDateFormatted);\n+        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n \n         String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n \n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(loaded);\n+        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n \n     }\n-    \n+\n     /**\n      * This method updates the status of long running async query which\n-     * were not interrupted due to host crash/app shutdown to TIMEDOUT.\n+     * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-\t@SuppressWarnings(\"unchecked\")\n+    @SuppressWarnings(\"unchecked\")\n     private void timeoutAsyncQuery() {\n \n-        //Calculate date to filter for clean up\n+        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n+\n+        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n+    }\n+\n+    /**\n+     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return formatted filter date\n+     */\n+     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n         Calendar cal = Calendar.getInstance();\n         cal.setTime(new Date());\n-        cal.add(Calendar.MINUTE, -(maxRunTimeMinutes));\n+        cal.add(calendarUnit, -(amount));\n         Date filterDate = cal.getTime();\n         Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n         String filterDateFormatted = dateFormat.format(filterDate);\n         log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        Iterable<Object> loaded = getFilteredResults(filterExpression);\n-\n-        asyncQueryDao.updateAsyncQueryCollection(loaded, (asyncQuery) -> {\n-            asyncQuery.setStatus(QueryStatus.PROCESSING);\n-            });\n+        return filterDateFormatted;\n     }\n-\n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate Iterable<Object> getFilteredResults(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Iterable<Object> loaded = (Iterable<Object>) asyncQueryDao.executeInTransaction(elide.getDataStore(), (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-\t}\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nindex ec07a6fd7..ed30834a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n", "chunk": "@@ -41,45 +50,37 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method deletes the historical queries based on threshold.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void deleteAsyncQuery() {\n-\n-        String cleanupDateFormatted = evaluateFormattedFilterDate(Calendar.DATE, queryCleanupDays);\n-\n-        String filterExpression = \"createdOn=le='\" + cleanupDateFormatted + \"'\";\n-\n-        asyncQueryDao.deleteAsyncQueryAndResultCollection(filterExpression);\n+    protected void deleteAsyncQuery() {\n \n+        try {\n+            Date cleanupDate = dateUtil.calculateFilterDate(Calendar.DATE, queryCleanupDays);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            FilterExpression fltDeleteExp = new LEPredicate(createdOnPathElement, cleanupDate);\n+            asyncQueryDao.deleteAsyncQueryAndResultCollection(fltDeleteExp);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n \n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n      * */\n-    @SuppressWarnings(\"unchecked\")\n-    private void timeoutAsyncQuery() {\n+    protected void timeoutAsyncQuery() {\n \n-        String filterDateFormatted = evaluateFormattedFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-        String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"\n-                + QueryStatus.QUEUED.toString() + \");createdOn=le='\" + filterDateFormatted + \"'\";\n-\n-        asyncQueryDao.updateStatusAsyncQueryCollection(filterExpression, QueryStatus.TIMEDOUT);\n-    }\n-\n-    /**\n-     * Evaluates and subtracts the amount based on the calendar unit and amount from current date.\n-     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n-     * @param amount Amount of days to be subtracted from current time\n-     * @return formatted filter date\n-     */\n-     private String evaluateFormattedFilterDate(int calendarUnit, int amount) {\n-        Calendar cal = Calendar.getInstance();\n-        cal.setTime(new Date());\n-        cal.add(calendarUnit, -(amount));\n-        Date filterDate = cal.getTime();\n-        Format dateFormat = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\");\n-        String filterDateFormatted = dateFormat.format(filterDate);\n-        log.debug(\"FilterDateFormatted = {}\", filterDateFormatted);\n-        return filterDateFormatted;\n+        try {\n+            Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n+            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n+            FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n+            AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n+            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+        } catch (Exception e) {\n+            log.error(\"Exception in scheduled cleanup: {}\", e);\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nsimilarity index 70%\nrename from elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\nrename to elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\nindex ed30834a9..712d3405a 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCleanerThread.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncAPICleanerThread.java\n", "chunk": "@@ -65,20 +67,21 @@ public class AsyncQueryCleanerThread implements Runnable {\n     /**\n      * This method updates the status of long running async query which\n      * were interrupted due to host crash/app shutdown to TIMEDOUT.\n-     * */\n-    protected void timeoutAsyncQuery() {\n+     * @param type AsyncAPI Type Implementation.\n+     */\n+    protected <T extends AsyncAPI> void timeoutAsyncAPI(Class<T> type) {\n \n         try {\n             Date filterDate = dateUtil.calculateFilterDate(Calendar.MINUTE, maxRunTimeMinutes);\n-            PathElement createdOnPathElement = new PathElement(AsyncQuery.class, Long.class, \"createdOn\");\n-            PathElement statusPathElement = new PathElement(AsyncQuery.class, String.class, \"status\");\n+            PathElement createdOnPathElement = new PathElement(type, Long.class, \"createdOn\");\n+            PathElement statusPathElement = new PathElement(type, String.class, \"status\");\n             List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n             statusList.add(QueryStatus.PROCESSING);\n             statusList.add(QueryStatus.QUEUED);\n             FilterPredicate inPredicate = new InPredicate(statusPathElement, statusList);\n             FilterPredicate lePredicate = new LEPredicate(createdOnPathElement, filterDate);\n             AndFilterExpression fltTimeoutExp = new AndFilterExpression(inPredicate, lePredicate);\n-            asyncQueryDao.updateStatusAsyncQueryCollection(fltTimeoutExp, QueryStatus.TIMEDOUT);\n+            asyncAPIDao.updateStatusAsyncAPICollection(fltTimeoutExp, QueryStatus.TIMEDOUT, type);\n         } catch (Exception e) {\n             log.error(\"Exception in scheduled cleanup: {}\", e);\n         }\n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMDEyOA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391120128", "body": "This doesn't look right to me.  I don't think a Constructor should be calling the a factory method for itself (the singleton).", "bodyText": "This doesn't look right to me.  I don't think a Constructor should be calling the a factory method for itself (the singleton).", "bodyHTML": "<p dir=\"auto\">This doesn't look right to me.  I don't think a Constructor should be calling the a factory method for itself (the singleton).</p>", "author": "aklish", "createdAt": "2020-03-11T16:57:26Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n+    \t\n+        // Setting up query cleaner that marks long running query as TIMEDOUT.\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..507b25eb3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -23,23 +22,21 @@ import lombok.extern.slf4j.Slf4j;\n  * orphan query statuses after host/app crash or restart.\n  */\n @Slf4j\n-@Singleton\n public class AsyncCleanerService {\n \n     private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n     private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n \n-    private static AsyncCleanerService asyncCleanerService;\n-    private ScheduledExecutorService cleanerService;\n+    private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+        //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+        int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n-    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n-    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n-    \t\n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n         AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 507b25eb3..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -12,61 +16,67 @@ import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n \n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses\n+ * after host/app crash or restart.\n  */\n @Slf4j\n public class AsyncCleanerService {\n \n-    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n-    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+    private final int defaultCleanupDelayMinutes = 360;\n+    private final int maxCleanupInitialDelayMinutes = 100;\n \n     private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n \n         //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n         int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n         ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n+                queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n+        //interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n+                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n     /**\n-     * Initialize the singleton AsyncCleanerService object\n+     * Initialize the singleton AsyncCleanerService object.\n+     * If already initialized earlier, no new object is created.\n      * @param elide Elide Instance\n      * @param maxRunTimeMinutes max run times in minutes\n      * @param queryCleanupDays Async Query Clean up days\n      * @param asyncQueryDao DAO Object\n      */\n-    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n-        if(asyncCleanerService == null) {\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n+        if (asyncCleanerService == null) {\n             asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n         } else {\n             log.debug(\"asyncCleanerService is already initialized.\");\n         }\n     }\n \n-    public static AsyncCleanerService getInstance() {\n+    /**\n+     * Get instance of AsyncCleanerService.\n+     * @return AsyncCleanerService Object\n+     */\n+    public synchronized static AsyncCleanerService getInstance() {\n         return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 665eff893..7d765766e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,78 +5,69 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries.\n- * It will schedule task to track long running queries and kills them.\n- * It will also schedule task to update orphan query statuses\n- * after host/app crash or restart.\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n  */\n @Slf4j\n+@Singleton\n public class AsyncCleanerService {\n \n-    private final int defaultCleanupDelayMinutes = 360;\n-    private final int maxCleanupInitialDelayMinutes = 100;\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n \n-    private static AsyncCleanerService asyncCleanerService = null;\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n \n     @Inject\n-    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n \n         //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n         int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n-                queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n-        //interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n-                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    /**\n-     * Initialize the singleton AsyncCleanerService object.\n-     * If already initialized earlier, no new object is created.\n-     * @param elide Elide Instance\n-     * @param maxRunTimeMinutes max run times in minutes\n-     * @param queryCleanupDays Async Query Clean up days\n-     * @param asyncQueryDao DAO Object\n-     */\n-    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    private static AsyncCleanerService getInstance() {\n         if (asyncCleanerService == null) {\n-            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n-        } else {\n-            log.debug(\"asyncCleanerService is already initialized.\");\n+          synchronized (AsyncCleanerService.class) {\n+        \t  asyncCleanerService = new AsyncCleanerService();\n+          }\n         }\n+        return asyncCleanerService;\n     }\n \n-    /**\n-     * Get instance of AsyncCleanerService.\n-     * @return AsyncCleanerService Object\n-     */\n-    public synchronized static AsyncCleanerService getInstance() {\n-        return asyncCleanerService;\n+    private AsyncCleanerService() {\n+      cleanerService = Executors.newSingleThreadScheduledExecutor();\n     }\n-}\n+\n+    private ScheduledExecutorService getExecutorService() {\n+      return cleanerService;\n+    }\n+\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d765766e..2a662976b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -53,21 +48,4 @@ public class AsyncCleanerService {\n         cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n-        if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n-        }\n-        return asyncCleanerService;\n-    }\n-\n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,69 +5,78 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses\n+ * after host/app crash or restart.\n  */\n @Slf4j\n-@Singleton\n public class AsyncCleanerService {\n \n-    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n-    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+    private final int defaultCleanupDelayMinutes = 360;\n+    private final int maxCleanupInitialDelayMinutes = 100;\n \n-    private static AsyncCleanerService asyncCleanerService;\n-    private ScheduledExecutorService cleanerService;\n+    private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n+\n+        //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+        int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n-    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n-    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n-    \t\n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n+                queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n+        //interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n+                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n+    /**\n+     * Initialize the singleton AsyncCleanerService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param maxRunTimeMinutes max run times in minutes\n+     * @param queryCleanupDays Async Query Clean up days\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n         if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n+            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncCleanerService is already initialized.\");\n         }\n-        return asyncCleanerService;\n     }\n \n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n+    /**\n+     * Get instance of AsyncCleanerService.\n+     * @return AsyncCleanerService Object\n+     */\n+    public synchronized static AsyncCleanerService getInstance() {\n+        return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "1c0cc338c4b7a05336dba95c781203a80d157cd5", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Tweak Cleaner Thread Delays (#1674)"}, {"oid": "1d04e914c89ad894560fe36d8d11e96fb2774981", "committedDate": "2021-01-27 17:29:45 -0500", "message": "Async Refactor: Part 1 (#1777)"}, {"oid": "98f612f023448a93324aaed11e00d6d4fa730c74", "committedDate": "2021-04-08 22:39:32 -0400", "message": "Issue 1929 - Clean up code quality (#1964)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "30816cbe1496c349c05a778b105efa87ec51a7c2", "committedDate": "2023-05-29 20:07:44 -0500", "message": "Refactor configuration (#2997)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMDYzOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391120639", "body": "Why do we have the two constructors?", "bodyText": "Why do we have the two constructors?", "bodyHTML": "<p dir=\"auto\">Why do we have the two constructors?</p>", "author": "aklish", "createdAt": "2020-03-11T16:58:09Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Random;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Slf4j\n+@Singleton\n+public class AsyncCleanerService {\n+\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n+\n+    @Inject\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+\n+    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n+    \t\n+        // Setting up query cleaner that marks long running query as TIMEDOUT.\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+\n+        // Since there will be multiple hosts running the elide service,\n+        // setting up random delays to avoid all of them trying to cleanup at the same time.\n+        Random random = new Random();\n+        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n+\n+        //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+    }\n+\n+    private static AsyncCleanerService getInstance() {\n+        if (asyncCleanerService == null) {\n+          synchronized (AsyncCleanerService.class) {\n+        \t  asyncCleanerService = new AsyncCleanerService();\n+          }\n+        }\n+        return asyncCleanerService;\n+    }\n+\n+    private AsyncCleanerService() {", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..507b25eb3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -53,21 +50,23 @@ public class AsyncCleanerService {\n         cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n-        if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n+    /**\n+     * Initialize the singleton AsyncCleanerService object\n+     * @param elide Elide Instance\n+     * @param maxRunTimeMinutes max run times in minutes\n+     * @param queryCleanupDays Async Query Clean up days\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+        if(asyncCleanerService == null) {\n+            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncCleanerService is already initialized.\");\n         }\n-        return asyncCleanerService;\n     }\n \n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n+    public static AsyncCleanerService getInstance() {\n+        return asyncCleanerService;\n     }\n \n }\n\\ No newline at end of file\n", "next_change": {"commit": "0031731c426fff44ad21eaae4e30f890864f68da", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 507b25eb3..c30dd2c8b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -65,7 +65,7 @@ public class AsyncCleanerService {\n         }\n     }\n \n-    public static AsyncCleanerService getInstance() {\n+    public synchronized static AsyncCleanerService getInstance() {\n         return asyncCleanerService;\n     }\n \n", "next_change": {"commit": "09f137109e11ee682a14db111dcd3392069d80d8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex c30dd2c8b..1e72aeb6b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -65,6 +66,10 @@ public class AsyncCleanerService {\n         }\n     }\n \n+    /**\n+     * Get instance of AsyncCleanerService\n+     * @return AsyncCleanerService Object\n+     */\n     public synchronized static AsyncCleanerService getInstance() {\n         return asyncCleanerService;\n     }\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 1e72aeb6b..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -67,11 +73,10 @@ public class AsyncCleanerService {\n     }\n \n     /**\n-     * Get instance of AsyncCleanerService\n+     * Get instance of AsyncCleanerService.\n      * @return AsyncCleanerService Object\n      */\n     public synchronized static AsyncCleanerService getInstance() {\n         return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 665eff893..7d765766e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,78 +5,69 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries.\n- * It will schedule task to track long running queries and kills them.\n- * It will also schedule task to update orphan query statuses\n- * after host/app crash or restart.\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n  */\n @Slf4j\n+@Singleton\n public class AsyncCleanerService {\n \n-    private final int defaultCleanupDelayMinutes = 360;\n-    private final int maxCleanupInitialDelayMinutes = 100;\n+    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n+    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n \n-    private static AsyncCleanerService asyncCleanerService = null;\n+    private static AsyncCleanerService asyncCleanerService;\n+    private ScheduledExecutorService cleanerService;\n \n     @Inject\n-    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n \n         //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n         int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n-                queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n-        //interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n-                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    /**\n-     * Initialize the singleton AsyncCleanerService object.\n-     * If already initialized earlier, no new object is created.\n-     * @param elide Elide Instance\n-     * @param maxRunTimeMinutes max run times in minutes\n-     * @param queryCleanupDays Async Query Clean up days\n-     * @param asyncQueryDao DAO Object\n-     */\n-    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n-            AsyncQueryDAO asyncQueryDao) {\n+    private static AsyncCleanerService getInstance() {\n         if (asyncCleanerService == null) {\n-            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n-        } else {\n-            log.debug(\"asyncCleanerService is already initialized.\");\n+          synchronized (AsyncCleanerService.class) {\n+        \t  asyncCleanerService = new AsyncCleanerService();\n+          }\n         }\n+        return asyncCleanerService;\n     }\n \n-    /**\n-     * Get instance of AsyncCleanerService.\n-     * @return AsyncCleanerService Object\n-     */\n-    public synchronized static AsyncCleanerService getInstance() {\n-        return asyncCleanerService;\n+    private AsyncCleanerService() {\n+      cleanerService = Executors.newSingleThreadScheduledExecutor();\n     }\n-}\n+\n+    private ScheduledExecutorService getExecutorService() {\n+      return cleanerService;\n+    }\n+\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d765766e..2a662976b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -53,21 +48,4 @@ public class AsyncCleanerService {\n         cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n-        if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n-        }\n-        return asyncCleanerService;\n-    }\n-\n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n-    }\n-\n }\n\\ No newline at end of file\n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\nindex 7d4886f22..665eff893 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java\n", "chunk": "@@ -5,69 +5,78 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import com.yahoo.elide.Elide;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n import java.util.Random;\n import java.util.concurrent.Executors;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import javax.inject.Inject;\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-\n-import lombok.extern.slf4j.Slf4j;\n \n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses\n+ * after host/app crash or restart.\n  */\n @Slf4j\n-@Singleton\n public class AsyncCleanerService {\n \n-    private final int DEFAULT_CLEANUP_DELAY_MINUTES = 360;\n-    private final int MAX_CLEANUP_INTIAL_DELAY_MINUTES = 100;\n+    private final int defaultCleanupDelayMinutes = 360;\n+    private final int maxCleanupInitialDelayMinutes = 100;\n \n-    private static AsyncCleanerService asyncCleanerService;\n-    private ScheduledExecutorService cleanerService;\n+    private static AsyncCleanerService asyncCleanerService = null;\n \n     @Inject\n-    public AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n+\n+        //If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n+        int queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n \n-    \t//If query is still running for twice than maxRunTime, then interrupt did not work due to host/app crash.\n-    \tint queryRunTimeThresholdMinutes = maxRunTimeMinutes * 2;\n-    \t\n         // Setting up query cleaner that marks long running query as TIMEDOUT.\n-        ScheduledExecutorService cleaner = AsyncCleanerService.getInstance().getExecutorService();\n-        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide, queryCleanupDays, asyncQueryDao);\n+        ScheduledExecutorService cleaner = Executors.newSingleThreadScheduledExecutor();\n+        AsyncQueryCleanerThread cleanUpTask = new AsyncQueryCleanerThread(queryRunTimeThresholdMinutes, elide,\n+                queryCleanupDays, asyncQueryDao);\n \n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, MAX_CLEANUP_INTIAL_DELAY_MINUTES).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n         log.debug(\"Initial Delay for cleaner service is {}\", initialDelayMinutes);\n \n         //Having a delay of at least DEFAULT_CLEANUP_DELAY between two cleanup attempts.\n-        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query interrupt process.\n-        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(DEFAULT_CLEANUP_DELAY_MINUTES, queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n+        //Or maxRunTimeMinutes * 2 so that this process does not coincides with query\n+        //interrupt process.\n+        cleaner.scheduleWithFixedDelay(cleanUpTask, initialDelayMinutes, Math.max(defaultCleanupDelayMinutes,\n+                queryRunTimeThresholdMinutes), TimeUnit.MINUTES);\n     }\n \n-    private static AsyncCleanerService getInstance() {\n+    /**\n+     * Initialize the singleton AsyncCleanerService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param maxRunTimeMinutes max run times in minutes\n+     * @param queryCleanupDays Async Query Clean up days\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer maxRunTimeMinutes, Integer queryCleanupDays,\n+            AsyncQueryDAO asyncQueryDao) {\n         if (asyncCleanerService == null) {\n-          synchronized (AsyncCleanerService.class) {\n-        \t  asyncCleanerService = new AsyncCleanerService();\n-          }\n+            asyncCleanerService = new AsyncCleanerService(elide, maxRunTimeMinutes, queryCleanupDays, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncCleanerService is already initialized.\");\n         }\n-        return asyncCleanerService;\n     }\n \n-    private AsyncCleanerService() {\n-      cleanerService = Executors.newSingleThreadScheduledExecutor();\n-    }\n-\n-    private ScheduledExecutorService getExecutorService() {\n-      return cleanerService;\n+    /**\n+     * Get instance of AsyncCleanerService.\n+     * @return AsyncCleanerService Object\n+     */\n+    public synchronized static AsyncCleanerService getInstance() {\n+        return asyncCleanerService;\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": null}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "1c0cc338c4b7a05336dba95c781203a80d157cd5", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Tweak Cleaner Thread Delays (#1674)"}, {"oid": "1d04e914c89ad894560fe36d8d11e96fb2774981", "committedDate": "2021-01-27 17:29:45 -0500", "message": "Async Refactor: Part 1 (#1777)"}, {"oid": "98f612f023448a93324aaed11e00d6d4fa730c74", "committedDate": "2021-04-08 22:39:32 -0400", "message": "Issue 1929 - Clean up code quality (#1964)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "30816cbe1496c349c05a778b105efa87ec51a7c2", "committedDate": "2023-05-29 20:07:44 -0500", "message": "Refactor configuration (#2997)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTAzOQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391121039", "body": "Why do we need these two constructors?", "bodyText": "Why do we need these two constructors?", "bodyHTML": "<p dir=\"auto\">Why do we need these two constructors?</p>", "author": "aklish", "createdAt": "2020-03-11T16:58:42Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Date;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Singleton\n+public class AsyncExecutorService {\n+\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private ExecutorService executor;\n+    private ExecutorService interruptor;\n+    private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n+    private AsyncQueryDAO asyncQueryDao;\n+    \n+\n+    @Inject\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        this.elide = elide;\n+        this.runner = new QueryRunner(elide);\n+        this.maxRunTime = maxRunTime;\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n+        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        this.asyncQueryDao = asyncQueryDao;\n+    }\n+\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+        // Change async query in Datastore to queued\n+        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n+            });\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n+                maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n+    }\n+\n+    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+        if (asyncExecutorService == null) {\n+          synchronized (AsyncExecutorService.class) {\n+        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n+            }\n+          }\n+        return asyncExecutorService;\n+    }\n+\n+    private AsyncExecutorService(int threadPoolSize) {", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..ab858b2ef 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -42,41 +39,18 @@ public class AsyncExecutorService {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n+        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n+               maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n-        if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n-    }\n-\n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n-\n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex ab858b2ef..7393afac2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -32,25 +36,53 @@ public class AsyncExecutorService {\n     private ExecutorService interruptor;\n     private int maxRunTime;\n     private AsyncQueryDAO asyncQueryDao;\n-    \n+    private static AsyncExecutorService asyncExecutorService = null;\n \n     @Inject\n-    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n-        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n+    /**\n+     * Initialize the singleton AsyncExecutorService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param threadPoolSize thred pool size\n+     * @param maxRunTime max run times in minutes\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        if (asyncExecutorService == null) {\n+            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncExecutorService is already initialized.\");\n+        }\n+    }\n+\n+    /**\n+     * Get instance of AsyncExecutorService.\n+     * @return AsyncExecutorService Object\n+     */\n+    public synchronized static AsyncExecutorService getInstance() {\n+        return asyncExecutorService;\n+    }\n+\n+    /**\n+     * Execute Query asynchronously.\n+     * @param queryObj Query Object\n+     * @param user User\n+     */\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n         asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n-               maxRunTime, asyncQueryDao);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n+               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "23ec6e16bf492e6054c6e04c360fed32acc034c2", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 7393afac2..e66e35d0d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -79,8 +79,7 @@ public class AsyncExecutorService {\n      */\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n-        // Change async query in Datastore to queued\n-        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+\n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n                executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex e66e35d0d..aa456982e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -5,83 +5,78 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n import java.util.Date;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n \n /**\n- * Service to execute Async queries.\n- * It will schedule task to track long running queries and kills them.\n- * It will also schedule task to update orphan query statuses after\n- * host/app crash or restart.\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n  */\n-@Slf4j\n+@Singleton\n public class AsyncExecutorService {\n \n-    private final int defaultThreadpoolSize = 6;\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n \n     private Elide elide;\n     private QueryRunner runner;\n     private ExecutorService executor;\n     private ExecutorService interruptor;\n     private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n     private AsyncQueryDAO asyncQueryDao;\n-    private static AsyncExecutorService asyncExecutorService = null;\n+    \n \n     @Inject\n-    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n-        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n+        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n-    /**\n-     * Initialize the singleton AsyncExecutorService object.\n-     * If already initialized earlier, no new object is created.\n-     * @param elide Elide Instance\n-     * @param threadPoolSize thred pool size\n-     * @param maxRunTime max run times in minutes\n-     * @param asyncQueryDao DAO Object\n-     */\n-    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n-        if (asyncExecutorService == null) {\n-            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n-        } else {\n-            log.debug(\"asyncExecutorService is already initialized.\");\n-        }\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+        // Change async query in Datastore to queued\n+        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n+            });\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n+                maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n     }\n \n-    /**\n-     * Get instance of AsyncExecutorService.\n-     * @return AsyncExecutorService Object\n-     */\n-    public synchronized static AsyncExecutorService getInstance() {\n+    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+        if (asyncExecutorService == null) {\n+          synchronized (AsyncExecutorService.class) {\n+        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n+            }\n+          }\n         return asyncExecutorService;\n     }\n \n-    /**\n-     * Execute Query asynchronously.\n-     * @param queryObj Query Object\n-     * @param user User\n-     */\n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+    private AsyncExecutorService(int threadPoolSize) {\n+    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n+    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n+    }\n \n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n-               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n+    private ExecutorService getExecutorService() {\n+        return executor;\n+    }\n+\n+    private ExecutorService getInterruptorService() {\n+        return interruptor;\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..944ce0f27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -42,41 +39,18 @@ public class AsyncExecutorService {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n+        asyncQueryDao.updateStatus(queryObj.getId(), QueryStatus.QUEUED);\n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n                 maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n-        if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n-    }\n-\n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n-\n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 944ce0f27..ab858b2ef 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -47,9 +47,9 @@ public class AsyncExecutorService {\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateStatus(queryObj.getId(), QueryStatus.QUEUED);\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n+        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n+               maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..1a1b1b6c2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -5,78 +5,82 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n import java.util.Date;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n import javax.inject.Inject;\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n \n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses after\n+ * host/app crash or restart.\n  */\n-@Singleton\n+@Slf4j\n public class AsyncExecutorService {\n \n-    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+    private final int defaultThreadpoolSize = 6;\n \n     private Elide elide;\n     private QueryRunner runner;\n     private ExecutorService executor;\n     private ExecutorService interruptor;\n     private int maxRunTime;\n-    private static AsyncExecutorService asyncExecutorService;\n     private AsyncQueryDAO asyncQueryDao;\n-    \n+    private static AsyncExecutorService asyncExecutorService = null;\n \n     @Inject\n-    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n-        // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n-    }\n-\n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+    /**\n+     * Initialize the singleton AsyncExecutorService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param threadPoolSize thred pool size\n+     * @param maxRunTime max run times in minutes\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n+            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncExecutorService is already initialized.\");\n+        }\n     }\n \n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n+    /**\n+     * Get instance of AsyncExecutorService.\n+     * @return AsyncExecutorService Object\n+     */\n+    public synchronized static AsyncExecutorService getInstance() {\n+        return asyncExecutorService;\n     }\n \n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n+    /**\n+     * Execute Query asynchronously.\n+     * @param queryObj Query Object\n+     * @param user User\n+     */\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n \n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n+               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 1a1b1b6c2..a4a0f56f5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -76,8 +86,13 @@ public class AsyncExecutorService {\n      * @param queryObj Query Object\n      * @param user User\n      */\n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+    public void executeQuery(AsyncQuery queryObj, User user, String apiVersion) {\n+        QueryRunner runner = runners.get(apiVersion);\n+        if (runner == null) {\n+            throw new InvalidOperationException(\"Invalid API Version\");\n+        }\n+\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao, apiVersion);\n \n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n                executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex a4a0f56f5..f6802bf7b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -85,17 +89,48 @@ public class AsyncExecutorService {\n      * Execute Query asynchronously.\n      * @param queryObj Query Object\n      * @param user User\n+     * @param apiVersion api version\n      */\n     public void executeQuery(AsyncQuery queryObj, User user, String apiVersion) {\n+\n         QueryRunner runner = runners.get(apiVersion);\n         if (runner == null) {\n             throw new InvalidOperationException(\"Invalid API Version\");\n         }\n-\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao, apiVersion);\n+        Future<AsyncQueryResult> task = executor.submit(queryWorker);\n+        try {\n+            queryObj.setStatus(QueryStatus.PROCESSING);\n+            AsyncQueryResult queryResultObj = task.get(queryObj.getAsyncAfterSeconds(), TimeUnit.SECONDS);\n+            queryObj.setResult(queryResultObj);\n+            queryObj.setStatus(QueryStatus.COMPLETE);\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        } catch (ExecutionException e) {\n+            log.error(\"ExecutionException: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            queryObj.setQueryUpdateWorker(new AsyncQueryUpdateThread(elide, task, queryObj, asyncQueryDao));\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        }\n \n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n-               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n+    }\n+    /**\n+     * Complete Query asynchronously.\n+     * @param query AsyncQuery\n+     * @param user User\n+     * @param apiVersion API Version\n+     */\n+    public void completeQuery(AsyncQuery query, User user, String apiVersion) {\n+        if (query.getQueryUpdateWorker() != null) {\n+            log.debug(\"Task has not completed\");\n+            updater.execute(query.getQueryUpdateWorker());\n+        } else {\n+            log.debug(\"Task has completed\");\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex f6802bf7b..7740a54b7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -125,10 +141,13 @@ public class AsyncExecutorService {\n      * @param user User\n      * @param apiVersion API Version\n      */\n-    public void completeQuery(AsyncQuery query, User user, String apiVersion) {\n-        if (query.getQueryUpdateWorker() != null) {\n+    public void completeQuery(AsyncAPI query, User user, String apiVersion) {\n+        AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n+        if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(query.getQueryUpdateWorker());\n+            updater.execute(new AsyncAPIUpdateThread(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+                    asyncAPIDao));\n+            asyncResultFutureThreadLocal.remove();\n         } else {\n             log.debug(\"Task has completed\");\n         }\n", "next_change": {"commit": "1d04e914c89ad894560fe36d8d11e96fb2774981", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 7740a54b7..78c2ef05f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -145,7 +143,7 @@ public class AsyncExecutorService {\n         AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n         if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(new AsyncAPIUpdateThread(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+            updater.execute(new AsyncAPIUpdateRunnable(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n                     asyncAPIDao));\n             asyncResultFutureThreadLocal.remove();\n         } else {\n", "next_change": {"commit": "dd69d567f445b9a62dda30b9ff8093ea4455c08b", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 78c2ef05f..f53db7683 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -143,7 +143,7 @@ public class AsyncExecutorService {\n         AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n         if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(new AsyncAPIUpdateRunnable(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+            updater.execute(new AsyncAPIUpdateOperation(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n                     asyncAPIDao));\n             asyncResultFutureThreadLocal.remove();\n         } else {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "632b7bb81c2ee3413546997718d86afddee47e91", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Fixes - Honor Doc Version in SwaggerController and Use ISO8601Dates Serde Format in Date Formatting  (#1336)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "b735f9b19d4d1a13a530f06f335d02eec4cdae1b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1664)"}, {"oid": "1d04e914c89ad894560fe36d8d11e96fb2774981", "committedDate": "2021-01-27 17:29:45 -0500", "message": "Async Refactor: Part 1 (#1777)"}, {"oid": "dd69d567f445b9a62dda30b9ff8093ea4455c08b", "committedDate": "2021-02-01 17:03:04 -0500", "message": "Async Refactor Cleanup (#1804)"}, {"oid": "106bb161fbeb937b15a19dd40f4ab9d17037ed6d", "committedDate": "2021-02-10 15:23:17 -0600", "message": "Export : Standalone API Resource (#1817)"}, {"oid": "5283569e556181cdc145f0090eac74ee6a9d3e1c", "committedDate": "2021-02-11 11:27:08 -0600", "message": "Issue#1798 Remove Singleton Pattern for Async Service Classes (#1831)"}, {"oid": "36fb16341927b92f9b134e4bde1915e7b33f5e65", "committedDate": "2021-03-10 14:14:33 -0600", "message": "Correct exception logging (#1882)"}, {"oid": "6143d108eb7b1a2250370409d5362c6722c95b23", "committedDate": "2021-04-26 16:28:58 -0500", "message": "Cleanup (#2026)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "119ea75d9ad68b27361326e9837ef1627afd3169", "committedDate": "2023-03-20 18:16:04 -0500", "message": "Fixes #2912 (#2931)"}, {"oid": "fd6f86b4529245b6291cdc9f50f04972b9abae54", "committedDate": "2023-04-30 15:20:02 -0500", "message": "Fix setting `DataFetcherExceptionHandler` (#2964)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEyMTM5Nw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r391121397", "body": "This looks wrong to me.  A constructor should not call a factory method on itself.  Maybe we should just eliminate all the singletons?  ", "bodyText": "This looks wrong to me.  A constructor should not call a factory method on itself.  Maybe we should just eliminate all the singletons?", "bodyHTML": "<p dir=\"auto\">This looks wrong to me.  A constructor should not call a factory method on itself.  Maybe we should just eliminate all the singletons?</p>", "author": "aklish", "createdAt": "2020-03-11T16:59:16Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import java.util.Date;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+/**\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n+ */\n+@Singleton\n+public class AsyncExecutorService {\n+\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+\n+    private Elide elide;\n+    private QueryRunner runner;\n+    private ExecutorService executor;\n+    private ExecutorService interruptor;\n+    private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n+    private AsyncQueryDAO asyncQueryDao;\n+    \n+\n+    @Inject\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        this.elide = elide;\n+        this.runner = new QueryRunner(elide);\n+        this.maxRunTime = maxRunTime;\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();", "originalCommit": "7b16cb4c979d3ffc9b47a8634fc2aa8a39a89a7a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..ab858b2ef 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -42,41 +39,18 @@ public class AsyncExecutorService {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n+        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n+               maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n-        if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n-    }\n-\n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n-\n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex ab858b2ef..7393afac2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -32,25 +36,53 @@ public class AsyncExecutorService {\n     private ExecutorService interruptor;\n     private int maxRunTime;\n     private AsyncQueryDAO asyncQueryDao;\n-    \n+    private static AsyncExecutorService asyncExecutorService = null;\n \n     @Inject\n-    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n-        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n+    /**\n+     * Initialize the singleton AsyncExecutorService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param threadPoolSize thred pool size\n+     * @param maxRunTime max run times in minutes\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+        if (asyncExecutorService == null) {\n+            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncExecutorService is already initialized.\");\n+        }\n+    }\n+\n+    /**\n+     * Get instance of AsyncExecutorService.\n+     * @return AsyncExecutorService Object\n+     */\n+    public synchronized static AsyncExecutorService getInstance() {\n+        return asyncExecutorService;\n+    }\n+\n+    /**\n+     * Execute Query asynchronously.\n+     * @param queryObj Query Object\n+     * @param user User\n+     */\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n         asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n-               maxRunTime, asyncQueryDao);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n+               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n-\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "23ec6e16bf492e6054c6e04c360fed32acc034c2", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 7393afac2..e66e35d0d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -79,8 +79,7 @@ public class AsyncExecutorService {\n      */\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n-        // Change async query in Datastore to queued\n-        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+\n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n                executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n", "next_change": {"commit": "e222f31ab23061016e4a67116e65e75ce13ff71a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex e66e35d0d..aa456982e 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -5,83 +5,78 @@\n  */\n package com.yahoo.elide.async.service;\n \n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n-\n-import lombok.extern.slf4j.Slf4j;\n-\n import java.util.Date;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n import javax.inject.Inject;\n+import javax.inject.Singleton;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n \n /**\n- * Service to execute Async queries.\n- * It will schedule task to track long running queries and kills them.\n- * It will also schedule task to update orphan query statuses after\n- * host/app crash or restart.\n+ * Service to execute Async queries. It will schedule task to track long\n+ * running queries and kills them. It will also schedule task to update\n+ * orphan query statuses after host/app crash or restart.\n  */\n-@Slf4j\n+@Singleton\n public class AsyncExecutorService {\n \n-    private final int defaultThreadpoolSize = 6;\n+    private final int DEFAULT_THREADPOOL_SIZE = 6;\n \n     private Elide elide;\n     private QueryRunner runner;\n     private ExecutorService executor;\n     private ExecutorService interruptor;\n     private int maxRunTime;\n+    private static AsyncExecutorService asyncExecutorService;\n     private AsyncQueryDAO asyncQueryDao;\n-    private static AsyncExecutorService asyncExecutorService = null;\n+    \n \n     @Inject\n-    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n-        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n+        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n-    /**\n-     * Initialize the singleton AsyncExecutorService object.\n-     * If already initialized earlier, no new object is created.\n-     * @param elide Elide Instance\n-     * @param threadPoolSize thred pool size\n-     * @param maxRunTime max run times in minutes\n-     * @param asyncQueryDao DAO Object\n-     */\n-    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n-        if (asyncExecutorService == null) {\n-            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n-        } else {\n-            log.debug(\"asyncExecutorService is already initialized.\");\n-        }\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+        // Change async query in Datastore to queued\n+        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n+            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n+            });\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n+                maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n     }\n \n-    /**\n-     * Get instance of AsyncExecutorService.\n-     * @return AsyncExecutorService Object\n-     */\n-    public synchronized static AsyncExecutorService getInstance() {\n+    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+        if (asyncExecutorService == null) {\n+          synchronized (AsyncExecutorService.class) {\n+        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n+            }\n+          }\n         return asyncExecutorService;\n     }\n \n-    /**\n-     * Execute Query asynchronously.\n-     * @param queryObj Query Object\n-     * @param user User\n-     */\n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+    private AsyncExecutorService(int threadPoolSize) {\n+    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n+    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n+    }\n \n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n-               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n+    private ExecutorService getExecutorService() {\n+        return executor;\n+    }\n+\n+    private ExecutorService getInterruptorService() {\n+        return interruptor;\n     }\n-}\n+}\n\\ No newline at end of file\n", "next_change": {"commit": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..944ce0f27 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -42,41 +39,18 @@ public class AsyncExecutorService {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n+        asyncQueryDao.updateStatus(queryObj.getId(), QueryStatus.QUEUED);\n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n                 maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n-        if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n-    }\n-\n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n-    }\n-\n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n-\n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n-    }\n }\n\\ No newline at end of file\n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 944ce0f27..ab858b2ef 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -47,9 +47,9 @@ public class AsyncExecutorService {\n     public void executeQuery(AsyncQuery queryObj, User user) {\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n         // Change async query in Datastore to queued\n-        asyncQueryDao.updateStatus(queryObj.getId(), QueryStatus.QUEUED);\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n+        asyncQueryDao.updateStatus(queryObj, QueryStatus.QUEUED);\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj, new Date(),\n+               maxRunTime, asyncQueryDao);\n         interruptor.execute(queryInterruptWorker);\n     }\n \n", "next_change": null}]}}]}}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex aa456982e..1a1b1b6c2 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -5,78 +5,82 @@\n  */\n package com.yahoo.elide.async.service;\n \n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.graphql.QueryRunner;\n+import com.yahoo.elide.security.User;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n import java.util.Date;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n \n import javax.inject.Inject;\n-import javax.inject.Singleton;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.graphql.QueryRunner;\n-import com.yahoo.elide.security.User;\n \n /**\n- * Service to execute Async queries. It will schedule task to track long\n- * running queries and kills them. It will also schedule task to update\n- * orphan query statuses after host/app crash or restart.\n+ * Service to execute Async queries.\n+ * It will schedule task to track long running queries and kills them.\n+ * It will also schedule task to update orphan query statuses after\n+ * host/app crash or restart.\n  */\n-@Singleton\n+@Slf4j\n public class AsyncExecutorService {\n \n-    private final int DEFAULT_THREADPOOL_SIZE = 6;\n+    private final int defaultThreadpoolSize = 6;\n \n     private Elide elide;\n     private QueryRunner runner;\n     private ExecutorService executor;\n     private ExecutorService interruptor;\n     private int maxRunTime;\n-    private static AsyncExecutorService asyncExecutorService;\n     private AsyncQueryDAO asyncQueryDao;\n-    \n+    private static AsyncExecutorService asyncExecutorService = null;\n \n     @Inject\n-    public AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n+    private AsyncExecutorService(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         this.elide = elide;\n         this.runner = new QueryRunner(elide);\n         this.maxRunTime = maxRunTime;\n-        executor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getExecutorService();\n-        interruptor = AsyncExecutorService.getInstance(threadPoolSize == null ? DEFAULT_THREADPOOL_SIZE : threadPoolSize).getInterruptorService();\n+        executor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n+        interruptor = Executors.newFixedThreadPool(threadPoolSize == null ? defaultThreadpoolSize : threadPoolSize);\n         this.asyncQueryDao = asyncQueryDao;\n     }\n \n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n-        // Change async query in Datastore to queued\n-        asyncQueryDao.updateAsyncQuery(queryObj.getId(), (asyncQueryObj) -> {\n-            asyncQueryObj.setStatus(QueryStatus.QUEUED);\n-            });\n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide, executor.submit(queryWorker), queryObj.getId(), new Date(), \n-                maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n-    }\n-\n-    private static AsyncExecutorService getInstance(int threadPoolSize) {\n+    /**\n+     * Initialize the singleton AsyncExecutorService object.\n+     * If already initialized earlier, no new object is created.\n+     * @param elide Elide Instance\n+     * @param threadPoolSize thred pool size\n+     * @param maxRunTime max run times in minutes\n+     * @param asyncQueryDao DAO Object\n+     */\n+    public static void init(Elide elide, Integer threadPoolSize, Integer maxRunTime, AsyncQueryDAO asyncQueryDao) {\n         if (asyncExecutorService == null) {\n-          synchronized (AsyncExecutorService.class) {\n-        \t  asyncExecutorService = new AsyncExecutorService(threadPoolSize);\n-            }\n-          }\n-        return asyncExecutorService;\n+            asyncExecutorService = new AsyncExecutorService(elide, threadPoolSize, maxRunTime, asyncQueryDao);\n+        } else {\n+            log.debug(\"asyncExecutorService is already initialized.\");\n+        }\n     }\n \n-    private AsyncExecutorService(int threadPoolSize) {\n-    \texecutor = Executors.newFixedThreadPool(threadPoolSize);\n-    \tinterruptor = Executors.newFixedThreadPool(threadPoolSize);\n+    /**\n+     * Get instance of AsyncExecutorService.\n+     * @return AsyncExecutorService Object\n+     */\n+    public synchronized static AsyncExecutorService getInstance() {\n+        return asyncExecutorService;\n     }\n \n-    private ExecutorService getExecutorService() {\n-        return executor;\n-    }\n+    /**\n+     * Execute Query asynchronously.\n+     * @param queryObj Query Object\n+     * @param user User\n+     */\n+    public void executeQuery(AsyncQuery queryObj, User user) {\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n \n-    private ExecutorService getInterruptorService() {\n-        return interruptor;\n+        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n+               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n+        interruptor.execute(queryInterruptWorker);\n     }\n-}\n\\ No newline at end of file\n+}\n", "next_change": {"commit": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 1a1b1b6c2..a4a0f56f5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -76,8 +86,13 @@ public class AsyncExecutorService {\n      * @param queryObj Query Object\n      * @param user User\n      */\n-    public void executeQuery(AsyncQuery queryObj, User user) {\n-        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao);\n+    public void executeQuery(AsyncQuery queryObj, User user, String apiVersion) {\n+        QueryRunner runner = runners.get(apiVersion);\n+        if (runner == null) {\n+            throw new InvalidOperationException(\"Invalid API Version\");\n+        }\n+\n+        AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao, apiVersion);\n \n         AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n                executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex a4a0f56f5..f6802bf7b 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -85,17 +89,48 @@ public class AsyncExecutorService {\n      * Execute Query asynchronously.\n      * @param queryObj Query Object\n      * @param user User\n+     * @param apiVersion api version\n      */\n     public void executeQuery(AsyncQuery queryObj, User user, String apiVersion) {\n+\n         QueryRunner runner = runners.get(apiVersion);\n         if (runner == null) {\n             throw new InvalidOperationException(\"Invalid API Version\");\n         }\n-\n         AsyncQueryThread queryWorker = new AsyncQueryThread(queryObj, user, elide, runner, asyncQueryDao, apiVersion);\n+        Future<AsyncQueryResult> task = executor.submit(queryWorker);\n+        try {\n+            queryObj.setStatus(QueryStatus.PROCESSING);\n+            AsyncQueryResult queryResultObj = task.get(queryObj.getAsyncAfterSeconds(), TimeUnit.SECONDS);\n+            queryObj.setResult(queryResultObj);\n+            queryObj.setStatus(QueryStatus.COMPLETE);\n+        } catch (InterruptedException e) {\n+            log.error(\"InterruptedException: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        } catch (ExecutionException e) {\n+            log.error(\"ExecutionException: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        } catch (TimeoutException e) {\n+            log.error(\"TimeoutException: {}\", e);\n+            queryObj.setQueryUpdateWorker(new AsyncQueryUpdateThread(elide, task, queryObj, asyncQueryDao));\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);\n+            queryObj.setStatus(QueryStatus.FAILURE);\n+        }\n \n-        AsyncQueryInterruptThread queryInterruptWorker = new AsyncQueryInterruptThread(elide,\n-               executor.submit(queryWorker), queryObj, new Date(), maxRunTime, asyncQueryDao);\n-        interruptor.execute(queryInterruptWorker);\n+    }\n+    /**\n+     * Complete Query asynchronously.\n+     * @param query AsyncQuery\n+     * @param user User\n+     * @param apiVersion API Version\n+     */\n+    public void completeQuery(AsyncQuery query, User user, String apiVersion) {\n+        if (query.getQueryUpdateWorker() != null) {\n+            log.debug(\"Task has not completed\");\n+            updater.execute(query.getQueryUpdateWorker());\n+        } else {\n+            log.debug(\"Task has completed\");\n+        }\n     }\n }\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex f6802bf7b..7740a54b7 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -125,10 +141,13 @@ public class AsyncExecutorService {\n      * @param user User\n      * @param apiVersion API Version\n      */\n-    public void completeQuery(AsyncQuery query, User user, String apiVersion) {\n-        if (query.getQueryUpdateWorker() != null) {\n+    public void completeQuery(AsyncAPI query, User user, String apiVersion) {\n+        AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n+        if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(query.getQueryUpdateWorker());\n+            updater.execute(new AsyncAPIUpdateThread(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+                    asyncAPIDao));\n+            asyncResultFutureThreadLocal.remove();\n         } else {\n             log.debug(\"Task has completed\");\n         }\n", "next_change": {"commit": "1d04e914c89ad894560fe36d8d11e96fb2774981", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 7740a54b7..78c2ef05f 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -145,7 +143,7 @@ public class AsyncExecutorService {\n         AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n         if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(new AsyncAPIUpdateThread(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+            updater.execute(new AsyncAPIUpdateRunnable(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n                     asyncAPIDao));\n             asyncResultFutureThreadLocal.remove();\n         } else {\n", "next_change": {"commit": "dd69d567f445b9a62dda30b9ff8093ea4455c08b", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\nindex 78c2ef05f..f53db7683 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/AsyncExecutorService.java\n", "chunk": "@@ -143,7 +143,7 @@ public class AsyncExecutorService {\n         AsyncAPIResultFuture asyncAPIResultFuture = asyncResultFutureThreadLocal.get();\n         if (asyncAPIResultFuture.isSynchronousTimeout()) {\n             log.debug(\"Task has not completed\");\n-            updater.execute(new AsyncAPIUpdateRunnable(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n+            updater.execute(new AsyncAPIUpdateOperation(elide, asyncAPIResultFuture.getAsyncFuture(), query,\n                     asyncAPIDao));\n             asyncResultFutureThreadLocal.remove();\n         } else {\n", "next_change": null}]}}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "632b7bb81c2ee3413546997718d86afddee47e91", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Fixes - Honor Doc Version in SwaggerController and Use ISO8601Dates Serde Format in Date Formatting  (#1336)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}, {"oid": "827440dac8d3c807860351ac81fc54905e4af007", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Restructuring the packages for Async (#1612)"}, {"oid": "49e61867e840d9818993879436d5db1aad964c9a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Move data store interfaces (#1671)"}, {"oid": "911d29408bdeeb4ff8d78f2beea2417be4e7c673", "committedDate": "2020-12-11 16:20:28 -0600", "message": "cleaned up package hierarchy for elide-core (#1672)"}, {"oid": "b735f9b19d4d1a13a530f06f335d02eec4cdae1b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Initial commit (#1664)"}, {"oid": "1d04e914c89ad894560fe36d8d11e96fb2774981", "committedDate": "2021-01-27 17:29:45 -0500", "message": "Async Refactor: Part 1 (#1777)"}, {"oid": "dd69d567f445b9a62dda30b9ff8093ea4455c08b", "committedDate": "2021-02-01 17:03:04 -0500", "message": "Async Refactor Cleanup (#1804)"}, {"oid": "106bb161fbeb937b15a19dd40f4ab9d17037ed6d", "committedDate": "2021-02-10 15:23:17 -0600", "message": "Export : Standalone API Resource (#1817)"}, {"oid": "5283569e556181cdc145f0090eac74ee6a9d3e1c", "committedDate": "2021-02-11 11:27:08 -0600", "message": "Issue#1798 Remove Singleton Pattern for Async Service Classes (#1831)"}, {"oid": "36fb16341927b92f9b134e4bde1915e7b33f5e65", "committedDate": "2021-03-10 14:14:33 -0600", "message": "Correct exception logging (#1882)"}, {"oid": "6143d108eb7b1a2250370409d5362c6722c95b23", "committedDate": "2021-04-26 16:28:58 -0500", "message": "Cleanup (#2026)"}, {"oid": "f21f35950fe465cfbf135d06cc8ae2321a29513a", "committedDate": "2023-02-04 15:34:06 -0600", "message": "Elide 7.x (#2876)"}, {"oid": "119ea75d9ad68b27361326e9837ef1627afd3169", "committedDate": "2023-03-20 18:16:04 -0500", "message": "Fixes #2912 (#2931)"}, {"oid": "fd6f86b4529245b6291cdc9f50f04972b9abae54", "committedDate": "2023-04-30 15:20:02 -0500", "message": "Fix setting `DataFetcherExceptionHandler` (#2964)"}]}, {"oid": "e222f31ab23061016e4a67116e65e75ce13ff71a", "url": "https://github.com/yahoo/elide/commit/e222f31ab23061016e4a67116e65e75ce13ff71a", "message": "Resolve some review comments\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-12T18:33:33Z", "type": "commit"}, {"oid": "05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "url": "https://github.com/yahoo/elide/commit/05c496e7c62ad6fe6ffd77af34c926ceef8009a7", "message": "Changing the DAO contract and updating references to DAO\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-13T17:53:51Z", "type": "commit"}, {"oid": "46f20fb0f933d6a931c315d424055f0b0e7dc7de", "url": "https://github.com/yahoo/elide/commit/46f20fb0f933d6a931c315d424055f0b0e7dc7de", "message": "Removing singletons and extra constructors, simplyfing logic\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-15T20:55:19Z", "type": "commit"}, {"oid": "71c902eb201c824953109bad119d84b544599bfc", "url": "https://github.com/yahoo/elide/commit/71c902eb201c824953109bad119d84b544599bfc", "message": "Adding default constructor and setters for DefaultDAO\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-15T21:47:08Z", "type": "commit"}, {"oid": "78dd5dfd30c7ba3b6861bd94d4bf1adb02c9ae77", "url": "https://github.com/yahoo/elide/commit/78dd5dfd30c7ba3b6861bd94d4bf1adb02c9ae77", "message": "Fixing codacy error\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-16T14:47:36Z", "type": "commit"}, {"oid": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "url": "https://github.com/yahoo/elide/commit/fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "message": "Changing Base to use correct obj\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-20T23:45:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQzNzg3MA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397437870", "body": "let's check that the object classes are also equal.", "bodyText": "let's check that the object classes are also equal.", "bodyHTML": "<p dir=\"auto\">let's check that the object classes are also equal.</p>", "author": "aklish", "createdAt": "2020-03-24T20:24:45Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.yahoo.elide.async.models;\n+\n+import java.util.Date;\n+import java.util.UUID;\n+\n+import javax.persistence.MappedSuperclass;\n+import javax.persistence.PrePersist;\n+import javax.persistence.PreUpdate;\n+\n+import com.yahoo.elide.annotation.Exclude;\n+\n+import lombok.Getter;\n+\n+@MappedSuperclass\n+public abstract class AsyncBase {\n+\n+    @Getter private Date createdOn;\n+\n+    @Getter private Date updatedOn;\n+\n+    @Exclude\n+    protected String naturalKey = UUID.randomUUID().toString();\n+\n+    @PrePersist\n+    public void prePersist() {\n+        createdOn = updatedOn = new Date();\n+    }\n+\n+    @PreUpdate\n+    public void preUpdate() {\n+        this.updatedOn = new Date();\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return naturalKey.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj == null || !(obj instanceof AsyncBase)) {", "originalCommit": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex 901df35e1..a8cf25861 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -38,7 +38,7 @@ public abstract class AsyncBase {\n \n     @Override\n     public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase)) {\n+        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n             return false;\n         }\n \n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex a8cf25861..9350558a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -38,7 +38,7 @@ public abstract class AsyncBase {\n \n     @Override\n     public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n+        if (obj == null || !(obj instanceof AsyncBase) || !(this.getClass() == obj.getClass())) {\n             return false;\n         }\n \n", "next_change": {"commit": "681ee7603c4c3f56341124af0f0904e2022e33a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex 9350558a9..a8cf25861 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -38,7 +38,7 @@ public abstract class AsyncBase {\n \n     @Override\n     public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase) || !(this.getClass() == obj.getClass())) {\n+        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n             return false;\n         }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\nindex 901df35e1..b58e05fdc 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n", "chunk": "@@ -38,7 +43,7 @@ public abstract class AsyncBase {\n \n     @Override\n     public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase)) {\n+        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n             return false;\n         }\n \n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java b/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\ndeleted file mode 100644\nindex b58e05fdc..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/models/AsyncBase.java\n+++ /dev/null\n", "chunk": "@@ -1,52 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.models;\n-\n-import com.yahoo.elide.annotation.Exclude;\n-\n-import lombok.Getter;\n-\n-import java.util.Date;\n-import java.util.UUID;\n-\n-import javax.persistence.MappedSuperclass;\n-import javax.persistence.PrePersist;\n-import javax.persistence.PreUpdate;\n-\n-@MappedSuperclass\n-public abstract class AsyncBase {\n-\n-    @Getter private Date createdOn;\n-\n-    @Getter private Date updatedOn;\n-\n-    @Exclude\n-    protected String naturalKey = UUID.randomUUID().toString();\n-\n-    @PrePersist\n-    public void prePersist() {\n-        createdOn = updatedOn = new Date();\n-    }\n-\n-    @PreUpdate\n-    public void preUpdate() {\n-        this.updatedOn = new Date();\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return naturalKey.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (obj == null || !(obj instanceof AsyncBase) || this.getClass() != obj.getClass()) {\n-            return false;\n-        }\n-\n-        return ((AsyncBase) obj).naturalKey.equals(naturalKey);\n-    }\n-}\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "1c3963ab4743d71cc6ecadea40c900c5e6696184", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async change to use onReadPreSecurity Hook (#1409)"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397464251", "body": "This one line can be moved outside the transaction.", "bodyText": "This one line can be moved outside the transaction.", "bodyHTML": "<p dir=\"auto\">This one line can be moved outside the transaction.</p>", "author": "aklish", "createdAt": "2020-03-24T21:12:42Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);", "originalCommit": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0NjEwNA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397546104", "bodyText": "If we move this line outside the anonymous function - we would have to put it in a try catch block and move the filter variable as a class level variable else we get: Local variable filter defined in an enclosing scope must be final or effectively final. Do you want this variable to be a class level variable?", "author": "Abhino", "createdAt": "2020-03-25T00:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4NDk1Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r411684953", "bodyText": "You can make filter final inside the loadQueries function.  Then you can move outside the try/catch block.", "author": "aklish", "createdAt": "2020-04-20T20:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDI1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..df24fd5e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,30 +180,6 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-    }\n-\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex df24fd5e5..0d68a6670 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -180,6 +145,30 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+    }\n+\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": null}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,30 +176,6 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-    }\n-\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,31 +145,29 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                         tx.delete(query, scope);\n                     }\n                 }\n-                return null;\n+                return loaded;\n             });\n         } catch (ParseException e) {\n             log.error(\"Exception: {}\", e);\n         }\n-        return null;\n+        return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            query.setStatus(QueryStatus.COMPLETE);\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,7 +141,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                     .build();\n             AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n             query.setResult(asyncQueryResult);\n-            query.setStatus(QueryStatus.COMPLETE);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n             tx.save(query, scope);\n             return query;\n         });\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NDc5Mw==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397464793", "body": "I wonder if this will swallow exceptions that would have been caught and handled by the outer transaction function.  Would it be better to let that function handle the exceptions?", "bodyText": "I wonder if this will swallow exceptions that would have been caught and handled by the outer transaction function.  Would it be better to let that function handle the exceptions?", "bodyHTML": "<p dir=\"auto\">I wonder if this will swallow exceptions that would have been caught and handled by the outer transaction function.  Would it be better to let that function handle the exceptions?</p>", "author": "aklish", "createdAt": "2020-03-24T21:13:45Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -127,8 +149,38 @@ public AsyncQueryResult setAsyncQueryAndResult(Integer status, String responseBo\n         return queryResultObj;\n     }\n \n-    @Override\n-    public Object executeInTransaction(DataStore dataStore, Transactional action) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {", "originalCommit": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -165,7 +167,7 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n \n                 Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n                 return loadedObj;\n-            } catch (Exception e) {\n+            } catch (ParseException e) {\n                 log.error(\"Exception: {}\", e);\n             }\n             return null;\n", "next_change": {"commit": "2adebc4ad0f35f66c33d3f919030fe2e9471b2a8", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..df24fd5e5 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -151,30 +180,6 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (ParseException e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-    }\n-\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex df24fd5e5..0d68a6670 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -180,6 +145,30 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n+                return loadedObj;\n+            } catch (Exception e) {\n+                log.error(\"Exception: {}\", e);\n+            }\n+            return null;\n+        });\n+        return loaded;\n+    }\n+\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,30 +176,6 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n         return queryResultObj;\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadQueries(String filterExpression) {\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> loaded = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loadedObj = tx.loadObjects(asyncQueryCollection, scope);\n-                return loadedObj;\n-            } catch (Exception e) {\n-                log.error(\"Exception: {}\", e);\n-            }\n-            return null;\n-        });\n-        return loaded;\n-    }\n-\n     /**\n      * This method creates a transaction from the datastore, performs the DB action using\n      * a generic functional interface and closes the transaction.\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,31 +145,29 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                         tx.delete(query, scope);\n                     }\n                 }\n-                return null;\n+                return loaded;\n             });\n         } catch (ParseException e) {\n             log.error(\"Exception: {}\", e);\n         }\n-        return null;\n+        return asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            query.setStatus(QueryStatus.COMPLETE);\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,7 +141,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                     .build();\n             AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n             query.setResult(asyncQueryResult);\n-            query.setStatus(QueryStatus.COMPLETE);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n             tx.save(query, scope);\n             return query;\n         });\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2ODg4OA==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397468888", "body": "Same comment about the load below.  The objects can be assumed to have already been loaded.  This function can just call tx.delete.", "bodyText": "Same comment about the load below.  The objects can be assumed to have already been loaded.  This function can just call tx.delete.", "bodyHTML": "<p dir=\"auto\">Same comment about the load below.  The objects can be assumed to have already been loaded.  This function can just call tx.delete.</p>", "author": "aklish", "createdAt": "2020-03-24T21:21:56Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -87,14 +109,14 @@ public AsyncQuery updateAsyncQuery(UUID asyncQueryId, UpdateQuery updateFunction\n     }\n \n     @Override\n-    public Iterable<Object> deleteAsyncQueryAndResultCollection(Iterable<Object> asyncQueryList) {\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n         executeInTransaction(dataStore, (tx, scope) -> {\n             EntityProjection asyncQueryCollection = EntityProjection.builder()\n                     .type(AsyncQuery.class)\n                     .build();\n \n-            Iterator<Object> itr = asyncQueryList.iterator();\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();", "originalCommit": "fe6f5300333ba380eb0cdfb19138a35eb925ec7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3NDM1OQ==", "url": "https://github.com/yahoo/elide/pull/1203#discussion_r397574359", "bodyText": "We are able to remove the load object logic for the update, but does not work with delete. Even calling save before delete does not work. It throws TransactionException trying to remove a detached entity.", "author": "moizarafat", "createdAt": "2020-03-25T02:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2ODg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "58d1f0feb452839cbbb06efc9460b3410a79a88c", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..c501312a9 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -109,26 +101,36 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while(itr.hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) itr.next();\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return null;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        return asyncQueryList;\n     }\n \n     @Override\n", "next_change": {"commit": "8f118c6ed355db72cdad6ef8e1bc65d52d504128", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex c501312a9..4db49e6d3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -134,7 +158,8 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n+            AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "fac0a26ebb73a28517694dbf6eca0588739f1154", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 4db49e6d3..0d68a6670 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -84,82 +82,53 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     /**\n      * This method updates a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n+     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n      * @return query object list updated\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n-            UpdateQuery updateFunction) {\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                   AsyncQuery query = (AsyncQuery) itr.next();\n-                   updateFunction.update(query);\n-                   tx.save(query, scope);\n-                }\n-                return null;\n-                } catch (ParseException e) {\n-                    log.error(\"Exception: {}\", e);\n-                }\n-            return null;\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                updateFunction.update(asyncQuery);\n+                tx.save(asyncQuery, scope);\n+            }\n+            return asyncQueryList;\n         });\n         return asyncQueryList;\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n-        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n-\n-        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                (tx, scope) -> {\n-            try {\n-                FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n-                        AsyncQuery.class, false);\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filter)\n-                        .build();\n-\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                Iterator<Object> itr = loaded.iterator();\n-\n-                while (itr.hasNext()) {\n-                    AsyncQuery query = (AsyncQuery) itr.next();\n-                    if (query != null) {\n-                        tx.delete(query, scope);\n-                    }\n+        executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+\n+            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+\n+            while(itr.hasNext()) {\n+                AsyncQuery query = (AsyncQuery) itr.next();\n+                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                if(asyncQuery != null) {\n+                    tx.delete(asyncQuery, scope);\n                 }\n-                return null;\n-            } catch (ParseException e) {\n-                log.error(\"Exception: {}\", e);\n             }\n-            return null;\n+\n+            return asyncQueryList;\n         });\n-        return asyncQueryList;\n+        return (Collection<AsyncQuery>) asyncQueryList;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "681ee7603c4c3f56341124af0f0904e2022e33a7", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 0d68a6670..1fc29d344 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -105,26 +101,36 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n+        Collection<AsyncQuery> asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+            try {\n+                FilterExpression filter = filterParser.parseFilterExpression(filterExpression, AsyncQuery.class, false);\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n \n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n+                Iterable<Object> itr = tx.loadObjects(asyncQueryCollection, scope);\n+\n+                while(((Iterator<AsyncQuery>) itr).hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) ((Iterator<AsyncQuery>) itr).next();\n+                    //asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n+                    if(query != null) {\n+                        tx.delete(query, scope);\n+                    }\n                 }\n+                return itr;\n+            } catch (ParseException e) {\n+                log.error(\"Exception: {}\", e);\n             }\n-\n-            return asyncQueryList;\n+            return null;\n         });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        return asyncQueryList;\n     }\n \n     @Override\n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex fe3b4fb70..59b9a8703 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -86,53 +84,82 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     /**\n      * This method updates a collection of AsyncQuery objects from database and\n      * returns the objects updated.\n-     * @param asyncQueryList Iterable list of AsyncQuery objects to be updated\n+     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n+     * @param updateFunction Functional interface for updating AsyncQuery Object\n      * @return query object list updated\n      */\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(Collection<AsyncQuery> asyncQueryList, UpdateQuery updateFunction) {\n+    @SuppressWarnings(\"unchecked\")\n+    private Collection<AsyncQuery> updateAsyncQueryCollection(String filterExpression,\n+            UpdateQuery updateFunction) {\n         log.debug(\"updateAsyncQueryCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                updateFunction.update(asyncQuery);\n-                tx.save(asyncQuery, scope);\n-            }\n-            return asyncQueryList;\n-        });\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n+\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        try {\n+             FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+             asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n+                        (tx, scope) -> {\n+                 EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                         .type(AsyncQuery.class)\n+                         .filterExpression(filter)\n+                         .build();\n+\n+                 Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                 Iterator<Object> itr = loaded.iterator();\n+\n+                 while (itr.hasNext()) {\n+                     AsyncQuery query = (AsyncQuery) itr.next();\n+                     updateFunction.update(query);\n+                     tx.save(query, scope);\n+                 }\n+                 return itr;\n+             });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n         return asyncQueryList;\n     }\n \n     @Override\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(Collection<AsyncQuery> asyncQueryList) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(String filterExpression) {\n         log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-\n-            Iterator<AsyncQuery> itr = asyncQueryList.iterator();\n-\n-            while(itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                AsyncQuery asyncQuery = (AsyncQuery) tx.loadObject(asyncQueryCollection, query.getId(), scope);\n-                if(asyncQuery != null) {\n-                    tx.delete(asyncQuery, scope);\n-                }\n-            }\n+        EntityDictionary dictionary = elide.getElideSettings().getDictionary();\n+        RSQLFilterDialect filterParser = new RSQLFilterDialect(dictionary);\n \n-            return asyncQueryList;\n-        });\n-        return (Collection<AsyncQuery>) asyncQueryList;\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                    AsyncQuery.class, false);\n+            executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                Iterator<Object> itr = loaded.iterator();\n+\n+                while (itr.hasNext()) {\n+                    AsyncQuery query = (AsyncQuery) itr.next();\n+                    if (query != null) {\n+                        tx.delete(query, scope);\n+                    }\n+                }\n+                return null;\n+            });\n+        } catch (ParseException e) {\n+            log.error(\"Exception: {}\", e);\n+        }\n+        return null;\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody, AsyncQuery asyncQuery, UUID asyncQueryId) {\n+    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n+            AsyncQuery asyncQuery, UUID asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "b55b769236519aa81a171321c14ee0ac8315908f", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 59b9a8703..1d928df8c 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -149,17 +154,17 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                         tx.delete(query, scope);\n                     }\n                 }\n-                return null;\n+                return loaded;\n             });\n         } catch (ParseException e) {\n             log.error(\"Exception: {}\", e);\n         }\n-        return null;\n+        return asyncQueryList;\n     }\n \n     @Override\n     public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, UUID asyncQueryId) {\n+            AsyncQuery asyncQuery, String asyncQueryId) {\n         log.debug(\"createAsyncQueryResult\");\n         AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n             AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n", "next_change": {"commit": "78619ef065965a1ee0d9fcd90192d70382467c90", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 1d928df8c..9e46d6e8d 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,22 +154,20 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n     }\n \n     @Override\n-    public AsyncQueryResult createAsyncQueryResult(Integer status, String responseBody,\n-            AsyncQuery asyncQuery, String asyncQueryId) {\n-        log.debug(\"createAsyncQueryResult\");\n-        AsyncQueryResult queryResultObj = (AsyncQueryResult) executeInTransaction(dataStore, (tx, scope) -> {\n-            AsyncQueryResult asyncQueryResult = new AsyncQueryResult();\n-            asyncQueryResult.setStatus(status);\n-            asyncQueryResult.setResponseBody(responseBody);\n-            asyncQueryResult.setContentLength(responseBody.length());\n-            asyncQueryResult.setQuery(asyncQuery);\n-            asyncQueryResult.setId(asyncQueryId);\n-            asyncQuery.setResult(asyncQueryResult);\n-            tx.createObject(asyncQueryResult, scope);\n-            tx.save(asyncQuery, scope);\n-            return asyncQueryResult;\n+    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n+            String asyncQueryId) {\n+        log.debug(\"updateAsyncQueryResult\");\n+        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n+            EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                    .type(AsyncQuery.class)\n+                    .build();\n+            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n+            query.setResult(asyncQueryResult);\n+            query.setStatus(QueryStatus.COMPLETE);\n+            tx.save(query, scope);\n+            return query;\n         });\n-        return queryResultObj;\n+        return queryObj;\n     }\n \n     /**\n", "next_change": {"commit": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\nindex 9e46d6e8d..edaf24af3 100644\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n", "chunk": "@@ -163,7 +141,11 @@ public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n                     .build();\n             AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n             query.setResult(asyncQueryResult);\n-            query.setStatus(QueryStatus.COMPLETE);\n+            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n+                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n+            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n+                query.setStatus(QueryStatus.COMPLETE);\n+            }\n             tx.save(query, scope);\n             return query;\n         });\n", "next_change": {"commit": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "changed_code": [{"header": "diff --git a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java b/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\ndeleted file mode 100644\nindex edaf24af3..000000000\n--- a/elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java\n+++ /dev/null\n", "chunk": "@@ -1,201 +0,0 @@\n-/*\n- * Copyright 2020, Yahoo Inc.\n- * Licensed under the Apache License, Version 2.0\n- * See LICENSE file in project root for terms.\n- */\n-package com.yahoo.elide.async.service;\n-\n-import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n-\n-import com.yahoo.elide.Elide;\n-import com.yahoo.elide.async.models.AsyncQuery;\n-import com.yahoo.elide.async.models.AsyncQueryResult;\n-import com.yahoo.elide.async.models.QueryStatus;\n-import com.yahoo.elide.core.DataStore;\n-import com.yahoo.elide.core.DataStoreTransaction;\n-import com.yahoo.elide.core.RequestScope;\n-import com.yahoo.elide.core.filter.expression.FilterExpression;\n-import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n-import com.yahoo.elide.request.EntityProjection;\n-\n-import lombok.Getter;\n-import lombok.Setter;\n-import lombok.extern.slf4j.Slf4j;\n-\n-import java.io.IOException;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.UUID;\n-\n-import javax.inject.Singleton;\n-import javax.ws.rs.core.MultivaluedHashMap;\n-import javax.ws.rs.core.MultivaluedMap;\n-\n-/**\n- * Utility class which implements AsyncQueryDAO.\n- */\n-@Singleton\n-@Slf4j\n-@Getter\n-public class DefaultAsyncQueryDAO implements AsyncQueryDAO {\n-\n-    @Setter private Elide elide;\n-    @Setter private DataStore dataStore;\n-\n-    // Default constructor is needed for standalone implementation for override in getAsyncQueryDao\n-    public DefaultAsyncQueryDAO() {\n-    }\n-\n-    public DefaultAsyncQueryDAO(Elide elide, DataStore dataStore) {\n-        this.elide = elide;\n-        this.dataStore = dataStore;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setStatus(status);\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    @Override\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n-            QueryStatus status) {\n-        return updateAsyncQueryCollection(filterExpression, (asyncQuery) -> {\n-            asyncQuery.setStatus(status);\n-            });\n-    }\n-\n-    /**\n-     * This method updates a collection of AsyncQuery objects from database and\n-     * returns the objects updated.\n-     * @param filterExpression Filter expression to update AsyncQuery Objects based on\n-     * @param updateFunction Functional interface for updating AsyncQuery Object\n-     * @return query object list updated\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    private Collection<AsyncQuery> updateAsyncQueryCollection(FilterExpression filterExpression,\n-            UpdateQuery updateFunction) {\n-        log.debug(\"updateAsyncQueryCollection\");\n-\n-        Collection<AsyncQuery> asyncQueryList = null;\n-         asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore,\n-                    (tx, scope) -> {\n-             EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                     .type(AsyncQuery.class)\n-                     .filterExpression(filterExpression)\n-                     .build();\n-\n-             Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-             Iterator<Object> itr = loaded.iterator();\n-\n-             while (itr.hasNext()) {\n-                 AsyncQuery query = (AsyncQuery) itr.next();\n-                 updateFunction.update(query);\n-                 tx.save(query, scope);\n-             }\n-             return loaded;\n-         });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> deleteAsyncQueryAndResultCollection(FilterExpression filterExpression) {\n-        log.debug(\"deleteAsyncQueryAndResultCollection\");\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .filterExpression(filterExpression)\n-                    .build();\n-\n-            Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-            Iterator<Object> itr = loaded.iterator();\n-\n-            while (itr.hasNext()) {\n-                AsyncQuery query = (AsyncQuery) itr.next();\n-                if (query != null) {\n-                    tx.delete(query, scope);\n-                }\n-            }\n-            return loaded;\n-        });\n-        return asyncQueryList;\n-    }\n-\n-    @Override\n-    public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n-            String asyncQueryId) {\n-        log.debug(\"updateAsyncQueryResult\");\n-        AsyncQuery queryObj = (AsyncQuery) executeInTransaction(dataStore, (tx, scope) -> {\n-            EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                    .type(AsyncQuery.class)\n-                    .build();\n-            AsyncQuery query = (AsyncQuery) tx.loadObject(asyncQueryCollection, asyncQueryId, scope);\n-            query.setResult(asyncQueryResult);\n-            if (query.getStatus().equals(QueryStatus.CANCELLED)) {\n-                query.setStatus(QueryStatus.CANCEL_COMPLETE);\n-            } else if (!(query.getStatus().equals(QueryStatus.CANCEL_COMPLETE))) {\n-                query.setStatus(QueryStatus.COMPLETE);\n-            }\n-            tx.save(query, scope);\n-            return query;\n-        });\n-        return queryObj;\n-    }\n-\n-    /**\n-     * This method creates a transaction from the datastore, performs the DB action using\n-     * a generic functional interface and closes the transaction.\n-     * @param dataStore Elide datastore retrieved from Elide object\n-     * @param action Functional interface to perform DB action\n-     * @return Object Returns Entity Object (AsyncQueryResult or AsyncResult)\n-     */\n-    protected Object executeInTransaction(DataStore dataStore, Transactional action) {\n-        log.debug(\"executeInTransaction\");\n-        Object result = null;\n-        try (DataStoreTransaction tx = dataStore.beginTransaction()) {\n-            JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-            MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-            RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n-                    tx, null, queryParams, UUID.randomUUID(), elide.getElideSettings());\n-            result = action.execute(tx, scope);\n-            tx.flush(scope);\n-            tx.commit(scope);\n-        } catch (IOException e) {\n-            log.error(\"IOException: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public Collection<AsyncQuery> loadAsyncQueryCollection(FilterExpression filterExpression) {\n-        Collection<AsyncQuery> asyncQueryList = null;\n-        log.debug(\"loadAsyncQueryCollection\");\n-        try {\n-            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n-\n-                EntityProjection asyncQueryCollection = EntityProjection.builder()\n-                        .type(AsyncQuery.class)\n-                        .filterExpression(filterExpression)\n-                        .build();\n-                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n-                return loaded;\n-            });\n-        } catch (Exception e) {\n-            log.error(\"Exception: {}\", e);\n-            throw new IllegalStateException(e);\n-        }\n-        return asyncQueryList;\n-    }\n-}\n", "next_change": null}]}}]}}]}}]}}]}, "commits_in_main": [{"oid": "6781c4bef3bcfbd81cf564d33a43214dd2c5c015", "message": "Merge commit", "committedDate": null}, {"oid": "9bda0185f0c316cea05c245c9003c1ada5b5911a", "committedDate": "2020-12-11 16:20:28 -0600", "message": "parent a14ccfbb7b558d27799b4e7b1916850519639708 author Jack (\uc815\ud658) <QubitPi@users.noreply.github.com> 1559678988 -0700 committer Aaron Klish <klish@verizonmedia.com> 1589583449 -0500"}, {"oid": "b55b769236519aa81a171321c14ee0ac8315908f", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async ID change from UUID to String and Dynamic Config FIx (#1325)"}, {"oid": "90a083d3c16c9c12fea7989652c63c37d5c75191", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Miscellanous fix (#1371)"}, {"oid": "78619ef065965a1ee0d9fcd90192d70382467c90", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Carbon 167 Async Enhancements Embeddable (#1353)"}, {"oid": "c823f5a24efd81298d5fdd0ffc1657be7572b2b4", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Elide 5- Unify request ids (#1423)"}, {"oid": "916e829f86ef08fbc7d2d05e6d88afe5c568504b", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Finished rebase"}, {"oid": "80c38a134a938bfb74583d9efb6d0c2b80c39e61", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Cancel long running or cancelled async queries (#1447)"}, {"oid": "5c065ad65fcda862269b5e31a8b6dc5d8c828aaa", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Data export - Refactoring and Prep for using ResultStorageEngine (#1527)"}, {"oid": "6227ce4839efe4607e3604f9abf85e031b44cdc9", "committedDate": "2020-12-11 16:20:28 -0600", "message": "Async model Spec Changes  (#1584)"}]}, {"oid": "fac0a26ebb73a28517694dbf6eca0588739f1154", "url": "https://github.com/yahoo/elide/commit/fac0a26ebb73a28517694dbf6eca0588739f1154", "message": "Fixing review comments\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-25T07:27:33Z", "type": "commit"}, {"oid": "681ee7603c4c3f56341124af0f0904e2022e33a7", "url": "https://github.com/yahoo/elide/commit/681ee7603c4c3f56341124af0f0904e2022e33a7", "message": "Resolving review comments\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-25T16:34:40Z", "type": "commit"}, {"oid": "26f83caac1e5f9d314fb5df562de880925cb4147", "url": "https://github.com/yahoo/elide/commit/26f83caac1e5f9d314fb5df562de880925cb4147", "message": "Review comments\n\nCo-authored-by: Abhino <Abhino@gmail.com>", "committedDate": "2020-03-25T21:02:49Z", "type": "commit"}, {"oid": "5a2325c7c1daf0919a4256bcb82784b5bab8d284", "url": "https://github.com/yahoo/elide/commit/5a2325c7c1daf0919a4256bcb82784b5bab8d284", "message": "Merge branch 'elide-5.x' into elide-5.x-async", "committedDate": "2020-03-26T16:58:47Z", "type": "commit"}, {"oid": "70038d5a065c54556906c736ca9125784be81e76", "url": "https://github.com/yahoo/elide/commit/70038d5a065c54556906c736ca9125784be81e76", "message": "Elide 5.x elide-async integration in elide-standalone (#1205)\n\n* Integrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Integrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Resolving review comments.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Resolving review comments.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Removing unwanted params.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Binding Cleaner service.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\nBinding Cleaner service.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Adding query result retention.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Integrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Default enableAsync to False.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Integrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Resolving review comments.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Resolving review comments.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Removing unwanted params.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Binding Cleaner service.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\nBinding Cleaner service.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Adding query result retention.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Making AsyncQueryDAO configurable\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Making AsyncQueryDAO configurable\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Review comments\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Review comments\r\n\r\nCo-authored-by: abhino <abhino@gmail.com>\r\n\r\n* Changing call to DefaultAsyncQueryDAO\r\n\r\n* Review comments\r\n\r\nCo-authored-by: Abhino <Abhino@gmail.com>\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-26T19:24:04Z", "type": "commit"}, {"oid": "98c5c3ce85b133dd7c8962a94e6b788e6dfbe205", "url": "https://github.com/yahoo/elide/commit/98c5c3ce85b133dd7c8962a94e6b788e6dfbe205", "message": "Elide 5.x elide-async integration in elide-spring (#1204)\n\n* Integrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\nIntegrating elide-async.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Removing unwanted params.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Binding Cleaner service.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Adding query result retention.\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Adding DAO configuration\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Checkstyle error\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Review comments\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Review comments\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>\r\n\r\n* Review comments\r\n\r\nCo-authored-by: Abhino <abhino@gmail.com>", "committedDate": "2020-03-26T19:37:23Z", "type": "commit"}, {"oid": "517697dfd9864fa1387a69c3f36e801cc6bf4360", "url": "https://github.com/yahoo/elide/commit/517697dfd9864fa1387a69c3f36e801cc6bf4360", "message": "Codacy Error\n\nCo-authored-by: Abhino <Abhino@gmail.com>", "committedDate": "2020-03-26T19:56:50Z", "type": "commit"}, {"oid": "26ff9607c3d38d6c02b87ac8bc3b4fc92f8bd384", "url": "https://github.com/yahoo/elide/commit/26ff9607c3d38d6c02b87ac8bc3b4fc92f8bd384", "message": "Changing include type to asyncQuery to avoid conflict\n\nCo-authored-by: moizarafat <moiz.arafat@gmail.com>", "committedDate": "2020-03-26T21:23:41Z", "type": "commit"}, {"oid": "9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "url": "https://github.com/yahoo/elide/commit/9232b3f2b1dbfb35a8b488bd9a91b81adf1006cd", "message": "Sync\n\nCo-authored-by: Abhino <Abhino@gmail.com>", "committedDate": "2020-03-26T22:13:05Z", "type": "commit"}]}