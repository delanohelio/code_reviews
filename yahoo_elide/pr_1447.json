{"pr_number": 1447, "pr_title": "Cancel long running or cancelled async queries", "pr_author": "ayeswarya", "pr_createdAt": "2020-07-17T19:50:43Z", "pr_url": "https://github.com/yahoo/elide/pull/1447", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjkyMA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456672920", "body": "we should expand this where clause to pull records based on create_time also as after sometime CANCELLED query list will expand. Something like create_time after current-date minus maxRunTimeSeconds;", "bodyText": "we should expand this where clause to pull records based on create_time also as after sometime CANCELLED query list will expand. Something like create_time after current-date minus maxRunTimeSeconds;", "bodyHTML": "<p dir=\"auto\">we should expand this where clause to pull records based on create_time also as after sometime CANCELLED query list will expand. Something like create_time after current-date minus maxRunTimeSeconds;</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:02:24Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        log.debug(\"getActiveAsyncQueryCollection\");\n+        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NTkyMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456675923", "bodyText": "Also the FilterExpression should be the method argument as elide will be controlling the Filter, where as users can provide their implementation of getActiveAsyncQueryCollection method.", "author": "moizarafat", "createdAt": "2020-07-17T21:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MjkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzEwNw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456673107", "body": "throw the exception as IllegalStateException.", "bodyText": "throw the exception as IllegalStateException.", "bodyHTML": "<p dir=\"auto\">throw the exception as IllegalStateException.</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:02:55Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {\n+        Collection<AsyncQuery> asyncQueryList = null;\n+\n+        log.debug(\"getActiveAsyncQueryCollection\");\n+        String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                + QueryStatus.PROCESSING.toString() + \",\"\n+                + QueryStatus.QUEUED.toString() + \")\";\n+\n+        try {\n+            FilterExpression filter = filterParser.parseFilterExpression(filterExpression,\n+                     AsyncQuery.class, false);\n+            asyncQueryList = (Collection<AsyncQuery>) executeInTransaction(dataStore, (tx, scope) -> {\n+\n+                EntityProjection asyncQueryCollection = EntityProjection.builder()\n+                        .type(AsyncQuery.class)\n+                        .filterExpression(filter)\n+                        .build();\n+                Iterable<Object> loaded = tx.loadObjects(asyncQueryCollection, scope);\n+                return loaded;\n+            });\n+        } catch (Exception e) {\n+            log.error(\"Exception: {}\", e);", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3MzgxNQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456673815", "body": "we should update the getRunningTransactions method to get this and we can remove the getter method on TransactionMap as its not used anyplace else.", "bodyText": "we should update the getRunningTransactions method to get this and we can remove the getter method on TransactionMap as its not used anyplace else.", "bodyHTML": "<p dir=\"auto\">we should update the getRunningTransactions method to get this and we can remove the getter method on TransactionMap as its not used anyplace else.</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:04:48Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3NzIyNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456677226", "body": "we can combine these two if statements with an OR", "bodyText": "we can combine these two if statements with an OR", "bodyHTML": "<p dir=\"auto\">we can combine these two if statements with an OR</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:13:41Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {\n+                for (AsyncQuery obj : asyncQueryCollection) {\n+                    if (obj.getRequestId().trim().equals(entry.getKey().toString().trim())) {\n+                        Date currentDate = new Date(System.currentTimeMillis());\n+                        long diffInMillies = Math.abs(obj.getUpdatedOn().getTime() - currentDate.getTime());\n+                        long diffInSecs = TimeUnit.SECONDS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n+                        if (obj.getStatus().equals(QueryStatus.CANCELLED)) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        } else if (diffInSecs > maxRunTimeSeconds) {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MTg2Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456681863", "body": "a couple of things we can probably do to improve the performance here: \r\ni) When the match occurs in if clause, after processing the if block we should break the inner loop\r\nii) we should remove the object from asyncQueryCollection when a match happens so that the size keeps reducing as the transaction loop move on.", "bodyText": "a couple of things we can probably do to improve the performance here:\ni) When the match occurs in if clause, after processing the if block we should break the inner loop\nii) we should remove the object from asyncQueryCollection when a match happens so that the size keeps reducing as the transaction loop move on.", "bodyHTML": "<p dir=\"auto\">a couple of things we can probably do to improve the performance here:<br>\ni) When the match occurs in if clause, after processing the if block we should break the inner loop<br>\nii) we should remove the object from asyncQueryCollection when a match happens so that the size keeps reducing as the transaction loop move on.</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:27:29Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {\n+                for (AsyncQuery obj : asyncQueryCollection) {\n+                    if (obj.getRequestId().trim().equals(entry.getKey().toString().trim())) {\n+                        Date currentDate = new Date(System.currentTimeMillis());\n+                        long diffInMillies = Math.abs(obj.getUpdatedOn().getTime() - currentDate.getTime());\n+                        long diffInSecs = TimeUnit.SECONDS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n+                        if (obj.getStatus().equals(QueryStatus.CANCELLED)) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        } else if (diffInSecs > maxRunTimeSeconds) {\n+                            log.debug(\"Async Query Cancelled: \" + obj.getId());\n+                            entry.getValue().cancel();\n+                        }", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4Mjk2Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456682966", "body": "i think getAsyncQueryCancelIntervalSeconds sounds better as Delay could be taken as differently.", "bodyText": "i think getAsyncQueryCancelIntervalSeconds sounds better as Delay could be taken as differently.", "bodyHTML": "<p dir=\"auto\">i think getAsyncQueryCancelIntervalSeconds sounds better as Delay could be taken as differently.</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:31:15Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -234,6 +234,15 @@ default Integer getAsyncQueryCleanupDays() {\n         return 7;\n     }\n \n+    /**\n+     * Number of seconds  between async query cancellation checks.\n+     *\n+     * @return Default: 300\n+     */\n+    default Integer getAsyncQueryCancelDelaySeconds() {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MzA2Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456683063", "body": "queryCancellationIntervalSeconds", "bodyText": "queryCancellationIntervalSeconds", "bodyHTML": "<p dir=\"auto\">queryCancellationIntervalSeconds</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:31:39Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,11 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default cancel interval of async query.\n+     */\n+    private int queryCancellationSeconds = 300;", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzUxNDE0NA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r457514144", "bodyText": "I want to keep it similar to cleanup. cleanup  is called queryCleanupDays. So queryCancellationSeconds sounds correct to me.", "author": "ayeswarya", "createdAt": "2020-07-20T15:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NTMyMA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456685320", "body": "This is a bit of pseudocode, but I think the code is more readable with functional style and breaking this into sets:\r\n\r\n```java\r\n\r\nSet<UUID> runningQueries = runningTransctionMap.keySet();\r\n\r\nSet<UUID> cancellingQueries = asyncQueryCollection.stream()\r\n     .filter(query -> query.getStatus == QueryStatus.CANCELED)\r\n     .map (AsyncQuery::getRequestId)\r\n      .collect(Collectors.toSet());\r\n\r\nSet<UUID> queriesToKill = Sets.intersection(runningQueries, cancellingQueries);\r\n\r\nqueriesToKill.stream().\r\n   .map(transactionRegistry.getRunningTransaction)\r\n   .forEach((tx) -> {\r\n      tx.cancel();\r\n   });\r\n\r\n```", "bodyText": "This is a bit of pseudocode, but I think the code is more readable with functional style and breaking this into sets:\nSet<UUID> runningQueries = runningTransctionMap.keySet();\n\nSet<UUID> cancellingQueries = asyncQueryCollection.stream()\n     .filter(query -> query.getStatus == QueryStatus.CANCELED)\n     .map (AsyncQuery::getRequestId)\n      .collect(Collectors.toSet());\n\nSet<UUID> queriesToKill = Sets.intersection(runningQueries, cancellingQueries);\n\nqueriesToKill.stream().\n   .map(transactionRegistry.getRunningTransaction)\n   .forEach((tx) -> {\n      tx.cancel();\n   });", "bodyHTML": "<p dir=\"auto\">This is a bit of pseudocode, but I think the code is more readable with functional style and breaking this into sets:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\nSet&lt;UUID&gt; runningQueries = runningTransctionMap.keySet();\n\nSet&lt;UUID&gt; cancellingQueries = asyncQueryCollection.stream()\n     .filter(query -&gt; query.getStatus == QueryStatus.CANCELED)\n     .map (AsyncQuery::getRequestId)\n      .collect(Collectors.toSet());\n\nSet&lt;UUID&gt; queriesToKill = Sets.intersection(runningQueries, cancellingQueries);\n\nqueriesToKill.stream().\n   .map(transactionRegistry.getRunningTransaction)\n   .forEach((tx) -&gt; {\n      tx.cancel();\n   });\n\n\"><pre><span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">UUID</span>&gt;</span> runningQueries <span class=\"pl-k\">=</span> runningTransctionMap<span class=\"pl-k\">.</span>keySet();\n\n<span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">UUID</span>&gt;</span> cancellingQueries <span class=\"pl-k\">=</span> asyncQueryCollection<span class=\"pl-k\">.</span>stream()\n     .filter(query <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> query<span class=\"pl-k\">.</span>getStatus <span class=\"pl-k\">==</span> <span class=\"pl-smi\">QueryStatus</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>CANCELED</span>)\n     .map (<span class=\"pl-smi\">AsyncQuery</span><span class=\"pl-k\">::</span>getRequestId)\n      .collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span>toSet());\n\n<span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">UUID</span>&gt;</span> queriesToKill <span class=\"pl-k\">=</span> <span class=\"pl-smi\">Sets</span><span class=\"pl-k\">.</span>intersection(runningQueries, cancellingQueries);\n\nqueriesToKill<span class=\"pl-k\">.</span>stream()<span class=\"pl-c1\">.</span>\n   .map(transactionRegistry<span class=\"pl-k\">.</span>getRunningTransaction)\n   .forEach((tx) <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> {\n      tx<span class=\"pl-k\">.</span>cancel();\n   });\n</pre></div>", "author": "aklish", "createdAt": "2020-07-17T21:38:50Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.TransactionRegistry;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getTransactionMap();\n+            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection();\n+\n+            for (Map.Entry<UUID, DataStoreTransaction> entry : runningTransactionMap.entrySet()) {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NjI3Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456686276", "body": "plz remove commented code", "bodyText": "plz remove commented code", "bodyHTML": "<p dir=\"auto\">plz remove commented code</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:41:33Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        transactionRegistry = mock(TransactionRegistry.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testCancelAsyncQuery() {\n+        cancelThread.cancelAsyncQuery();\n+        verify(asyncQueryDao, times(1)).getActiveAsyncQueryCollection();\n+        //verify(transactionRegistry, times(1)).getTransactionMap();", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NzYzMg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r456687632", "body": "please include a test case in DefaultAsyncQueryDAOTest.java for this method.", "bodyText": "please include a test case in DefaultAsyncQueryDAOTest.java for this method.", "bodyHTML": "<p dir=\"auto\">please include a test case in DefaultAsyncQueryDAOTest.java for this method.</p>", "author": "moizarafat", "createdAt": "2020-07-17T21:45:47Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,32 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection() {", "originalCommit": "a7dbe18ab0016b3c6af5f7a60f0ee92f0692cbb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc4NzYwNQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461787605", "body": "I'm not sure this is correct.  This filter will look for any query that is canceled, queued, or processing that is more recent than now minus max runtime.  Later, we filter this collection by queries that are canceled or having ran longer than max runtime.\r\n\r\nI think there are two problems:\r\n1. I don't believe the second condition will ever evaluate.  Those queries have already been removed by the DAO filter.\r\n2. I think it is possible to miss queries that are canceled but have run longer (for whatever reason) than  the max runtime.", "bodyText": "I'm not sure this is correct.  This filter will look for any query that is canceled, queued, or processing that is more recent than now minus max runtime.  Later, we filter this collection by queries that are canceled or having ran longer than max runtime.\nI think there are two problems:\n\nI don't believe the second condition will ever evaluate.  Those queries have already been removed by the DAO filter.\nI think it is possible to miss queries that are canceled but have run longer (for whatever reason) than  the max runtime.", "bodyHTML": "<p dir=\"auto\">I'm not sure this is correct.  This filter will look for any query that is canceled, queued, or processing that is more recent than now minus max runtime.  Later, we filter this collection by queries that are canceled or having ran longer than max runtime.</p>\n<p dir=\"auto\">I think there are two problems:</p>\n<ol dir=\"auto\">\n<li>I don't believe the second condition will ever evaluate.  Those queries have already been removed by the DAO filter.</li>\n<li>I think it is possible to miss queries that are canceled but have run longer (for whatever reason) than  the max runtime.</li>\n</ol>", "author": "aklish", "createdAt": "2020-07-28T18:31:03Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.text.Format;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+\n+            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, maxRunTimeSeconds);\n+            String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MDE5OA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461850198", "body": "The interface contract for the AsyncQueryDAO would be cleaner if the filterExpression for this method and others was an actual FilterExpression object instead of a String.  ", "bodyText": "The interface contract for the AsyncQueryDAO would be cleaner if the filterExpression for this method and others was an actual FilterExpression object instead of a String.", "bodyHTML": "<p dir=\"auto\">The interface contract for the AsyncQueryDAO would be cleaner if the filterExpression for this method and others was an actual FilterExpression object instead of a String.</p>", "author": "aklish", "createdAt": "2020-07-28T20:14:27Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +199,30 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(String filterExpression) {", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MDcwOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461850709", "body": "Should we change this to UUID.fromString(id)?", "bodyText": "Should we change this to UUID.fromString(id)?", "bodyHTML": "<p dir=\"auto\">Should we change this to UUID.fromString(id)?</p>", "author": "aklish", "createdAt": "2020-07-28T20:15:04Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncExecutorServiceTest.java", "diffHunk": "@@ -85,9 +86,10 @@ public void testExecuteQueryComplete() throws InterruptedException {\n         AsyncQuery queryObj = mock(AsyncQuery.class);\n         String query = \"/group?sort=commonName&fields%5Bgroup%5D=commonName,description\";\n         String id = \"edc4a871-dff2-4054-804e-d80075cf827d\";\n+        UUID uuid = UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\");", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461853119", "body": "I wonder if this would read better with a more descriptive name (although longer):\r\ngetAsyncQueryCancelCheckIntervalSeconds", "bodyText": "I wonder if this would read better with a more descriptive name (although longer):\ngetAsyncQueryCancelCheckIntervalSeconds", "bodyHTML": "<p dir=\"auto\">I wonder if this would read better with a more descriptive name (although longer):<br>\ngetAsyncQueryCancelCheckIntervalSeconds</p>", "author": "aklish", "createdAt": "2020-07-28T20:18:21Z", "path": "elide-standalone/src/main/java/com/yahoo/elide/standalone/config/ElideStandaloneSettings.java", "diffHunk": "@@ -235,6 +235,15 @@ default Integer getAsyncQueryCleanupDays() {\n         return 7;\n     }\n \n+    /**\n+     * Number of seconds  between async query cancellation checks.\n+     *\n+     * @return Default: 300\n+     */\n+    default Integer getAsyncQueryCancelSeconds() {", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1Mzc3MA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461853770", "bodyText": "Maybe a better approach is to move all of the async query settings into a struct of some kind to namespace them (so they aren't so long)", "author": "aklish", "createdAt": "2020-07-28T20:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NTU0Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471055543", "bodyText": "we can take care of this in the download pr", "author": "moizarafat", "createdAt": "2020-08-16T02:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1MzExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg1NDM2NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r461854365", "body": "I think the definition of this is vague.  What is this interval for?  Let's get a more descriptive name and a better description of its intended use.", "bodyText": "I think the definition of this is vague.  What is this interval for?  Let's get a more descriptive name and a better description of its intended use.", "bodyHTML": "<p dir=\"auto\">I think the definition of this is vague.  What is this interval for?  Let's get a more descriptive name and a better description of its intended use.</p>", "author": "aklish", "createdAt": "2020-07-28T20:20:35Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,11 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default cancel interval of async query.\n+     */\n+    private int queryCancellationSeconds = 300;", "originalCommit": "12ba32589643f99638e66024251451bb425e0056", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODU4MQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463818581", "body": "This is too broad and is swallowing exceptions that need to be propagated.   ", "bodyText": "This is too broad and is swallowing exceptions that need to be propagated.", "bodyHTML": "<p dir=\"auto\">This is too broad and is swallowing exceptions that need to be propagated.</p>", "author": "aklish", "createdAt": "2020-07-31T20:24:38Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -114,27 +106,26 @@ public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n                  }\n                  return loaded;\n              });\n-        } catch (ParseException e) {\n+        } catch (Exception e) {", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxOTI1Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463819256", "body": "The DAO should not swallow exceptions.  Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).", "bodyText": "The DAO should not swallow exceptions.  Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).", "bodyHTML": "<p dir=\"auto\">The DAO should not swallow exceptions.  Utilities need to propagate exceptions and let the calling code handle them (or the utility will have limited reuse and can only be used in limited contexts).</p>", "author": "aklish", "createdAt": "2020-07-31T20:26:09Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -148,7 +139,7 @@ public AsyncQuery updateStatus(String asyncQueryId, QueryStatus status) {\n                 }\n                 return loaded;\n             });\n-        } catch (ParseException e) {\n+        } catch (Exception e) {", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxOTgyNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r463819826", "body": "Relying on time to find the queries that need to be canceled has some race conditions and other issues with configuration that can cause problems.\r\n\r\nInstead of filtering on time, I think we need to introduce another state - CANCEL_COMPLETE or something along those lines that marks which queries have been successfully canceled.", "bodyText": "Relying on time to find the queries that need to be canceled has some race conditions and other issues with configuration that can cause problems.\nInstead of filtering on time, I think we need to introduce another state - CANCEL_COMPLETE or something along those lines that marks which queries have been successfully canceled.", "bodyHTML": "<p dir=\"auto\">Relying on time to find the queries that need to be canceled has some race conditions and other issues with configuration that can cause problems.</p>\n<p dir=\"auto\">Instead of filtering on time, I think we need to introduce another state - CANCEL_COMPLETE or something along those lines that marks which queries have been successfully canceled.</p>", "author": "aklish", "createdAt": "2020-07-31T20:27:37Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -61,13 +66,13 @@ protected void cancelAsyncQuery() {\n \n             TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n             Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n-\n-            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, maxRunTimeSeconds);\n-            String filterExpression = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n-                    + QueryStatus.PROCESSING.toString() + \",\"\n-                    + QueryStatus.QUEUED.toString() + \");createdOn=ge='\" + filterDateFormatted + \"'\";\n-\n-            Collection<AsyncQuery> asyncQueryCollection = asyncQueryDao.getActiveAsyncQueryCollection(filterExpression);\n+            String filterDateFormatted = evaluateFormattedFilterDate(Calendar.SECOND, 2 * maxRunTimeSeconds);\n+            String filterExpression = \"status=in=(\" + QueryStatus.PROCESSING.toString() + \",\"", "originalCommit": "72fb16f0c8ef4a31cf175f1b9ff27321fb9aac32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgzMTIxMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r465831213", "body": "It will be more efficient to call asyncQueryDao.updateAsyncQueryCollection which can do a bulk update", "bodyText": "It will be more efficient to call asyncQueryDao.updateAsyncQueryCollection which can do a bulk update", "bodyHTML": "<p dir=\"auto\">It will be more efficient to call asyncQueryDao.updateAsyncQueryCollection which can do a bulk update</p>", "author": "aklish", "createdAt": "2020-08-05T15:56:18Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -87,33 +85,20 @@ protected void cancelAsyncQuery() {\n \n             queriesToCancel.stream()\n                .forEach((tx) -> {\n-                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n-                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n-                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n-                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n-                           tx, elide.getElideSettings());\n-                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                       JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                       MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                       RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                               transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                               tx, elide.getElideSettings());\n+                       transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                       List<AsyncQuery> asyncQueryList = asyncQueryCollection.stream()\n+                               .filter(query -> query.getRequestId().equals(tx)).collect(Collectors.toList());\n+                       asyncQueryList.forEach(asyncQuery -> asyncQueryDao.updateStatus(asyncQuery.getId(),", "originalCommit": "685573ccd9d97ee5c2d497004fcdb13eee2df915", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwODI3NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467208275", "body": "Shouldn't this calculation be:\r\nNOW - query.getCreatedOn().getTime() > maxRunTimeSeconds\r\n\r\nSo two changes - createdOn instead of updatedOn and invert the subtraction  operands (we can keep the absolute value though).", "bodyText": "Shouldn't this calculation be:\nNOW - query.getCreatedOn().getTime() > maxRunTimeSeconds\nSo two changes - createdOn instead of updatedOn and invert the subtraction  operands (we can keep the absolute value though).", "bodyHTML": "<p dir=\"auto\">Shouldn't this calculation be:<br>\nNOW - query.getCreatedOn().getTime() &gt; maxRunTimeSeconds</p>\n<p dir=\"auto\">So two changes - createdOn instead of updatedOn and invert the subtraction  operands (we can keep the absolute value though).</p>", "author": "aklish", "createdAt": "2020-08-07T18:40:46Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467209997", "body": "Another thing (I'm probably going back on prior comments here), but I think tx.cancel can throw an exception.  If this thread is terminated by an exception, will the executor schedule another?", "bodyText": "Another thing (I'm probably going back on prior comments here), but I think tx.cancel can throw an exception.  If this thread is terminated by an exception, will the executor schedule another?", "bodyHTML": "<p dir=\"auto\">Another thing (I'm probably going back on prior comments here), but I think tx.cancel can throw an exception.  If this thread is terminated by an exception, will the executor schedule another?</p>", "author": "aklish", "createdAt": "2020-08-07T18:44:37Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(AsyncQuery::getRequestId)\n+            .collect(Collectors.toSet());\n+\n+            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n+\n+            List<String> asyncQueryList = new ArrayList<String>();\n+            queriesToCancel.stream()\n+               .forEach((tx) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                           tx, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                   List<String> cancelledQuery = asyncQueryCollection.stream().filter(query\n+                           -> query.getRequestId().equals(tx)).map(AsyncQuery::getId).collect(Collectors.toList());\n+                   asyncQueryList.addAll(cancelledQuery);\n+               });\n+            if (!queriesToCancel.isEmpty()) {\n+                String cancelledQueryStr = String.join(\",\", asyncQueryList);\n+                String filterById = \"id=in=(\" + cancelledQueryStr + \")\";\n+                FilterExpression fltIdExpression = filterParser.parseFilterExpression\n+                        (filterById, AsyncQuery.class, false);\n+                asyncQueryDao.updateStatusAsyncQueryCollection(fltIdExpression, QueryStatus.CANCEL_COMPLETE);\n+            }\n+        } catch (ParseException e) {", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjc2Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467216767", "bodyText": "We probably want to invert the order of canceling the transaction and marking the status to complete.  If canceling throws an exception, it will leave a query in the canceling state with nothing to clean it up.", "author": "aklish", "createdAt": "2020-08-07T18:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY3MjE2OQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467672169", "bodyText": "The way the code is now, cancellation happens before we mark the status of the query as CANCEL_COMPLETE. So if there were to be an exception, the query status will not change, so it can be picked up for cancellation in the next run of the cancel thread...", "author": "ayeswarya", "createdAt": "2020-08-10T03:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDEyNDUyOA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r470124528", "bodyText": "I was testing the code in example application and discovered that the executor does not schedule another thread if it encounters an exception. Can I catch exceptions, log them?", "author": "ayeswarya", "createdAt": "2020-08-13T17:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIwOTk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1NzU3Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467257576", "body": "A couple of improvements on this code.  I think we should rename some of the local variables for clarity.  When dealing with ids, we shouldn't call them queries or transactions but rather identifiers - so we can distinguish the collections from each other.\r\n\r\nSecond, I'm not sure how much of an improvement this is, but I would probably have written the mapping from UUIDs to kill to queries to kill as follows:\r\n\r\n```java\r\nSet<Query> queriesToCancel = queryIdsToCancel.stream()\r\n        .map(uuid -> { \r\n            asyncQueryCollection.stream()\r\n               .filter(query -> query.getRequestId().equals(uuid))\r\n               .findFirst().orElseThrow(IllegalStateException::new)\r\n         })\r\n         .collect(Collectors.toSet());\r\n```\r\n\r\nBecause naming is hard, it is sometimes more readable to collapse the mapping into a single logical block without intermediate state.  Alternatively, we could write a separate function to do the same thing.", "bodyText": "A couple of improvements on this code.  I think we should rename some of the local variables for clarity.  When dealing with ids, we shouldn't call them queries or transactions but rather identifiers - so we can distinguish the collections from each other.\nSecond, I'm not sure how much of an improvement this is, but I would probably have written the mapping from UUIDs to kill to queries to kill as follows:\nSet<Query> queriesToCancel = queryIdsToCancel.stream()\n        .map(uuid -> { \n            asyncQueryCollection.stream()\n               .filter(query -> query.getRequestId().equals(uuid))\n               .findFirst().orElseThrow(IllegalStateException::new)\n         })\n         .collect(Collectors.toSet());\nBecause naming is hard, it is sometimes more readable to collapse the mapping into a single logical block without intermediate state.  Alternatively, we could write a separate function to do the same thing.", "bodyHTML": "<p dir=\"auto\">A couple of improvements on this code.  I think we should rename some of the local variables for clarity.  When dealing with ids, we shouldn't call them queries or transactions but rather identifiers - so we can distinguish the collections from each other.</p>\n<p dir=\"auto\">Second, I'm not sure how much of an improvement this is, but I would probably have written the mapping from UUIDs to kill to queries to kill as follows:</p>\n<div class=\"highlight highlight-source-java position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"Set&lt;Query&gt; queriesToCancel = queryIdsToCancel.stream()\n        .map(uuid -&gt; { \n            asyncQueryCollection.stream()\n               .filter(query -&gt; query.getRequestId().equals(uuid))\n               .findFirst().orElseThrow(IllegalStateException::new)\n         })\n         .collect(Collectors.toSet());\"><pre><span class=\"pl-k\">Set&lt;<span class=\"pl-smi\">Query</span>&gt;</span> queriesToCancel <span class=\"pl-k\">=</span> queryIdsToCancel<span class=\"pl-k\">.</span>stream()\n        .map(uuid <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> { \n            asyncQueryCollection<span class=\"pl-k\">.</span>stream()\n               .filter(query <span class=\"pl-k\">-</span><span class=\"pl-k\">&gt;</span> query<span class=\"pl-k\">.</span>getRequestId()<span class=\"pl-k\">.</span>equals(uuid))\n               .findFirst()<span class=\"pl-k\">.</span>orElseThrow(<span class=\"pl-smi\">IllegalStateException</span><span class=\"pl-k\">::</span><span class=\"pl-k\">new</span>)\n         })\n         .collect(<span class=\"pl-smi\">Collectors</span><span class=\"pl-k\">.</span>toSet());</pre></div>\n<p dir=\"auto\">Because naming is hard, it is sometimes more readable to collapse the mapping into a single logical block without intermediate state.  Alternatively, we could write a separate function to do the same thing.</p>", "author": "aklish", "createdAt": "2020-08-07T20:37:20Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private EntityDictionary dictionary;\n+    private RSQLFilterDialect filterParser;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+            String filterByStatus = \"status=in=(\" + QueryStatus.CANCELLED.toString() + \",\"\n+                    + QueryStatus.PROCESSING.toString() + \",\"\n+                    + QueryStatus.QUEUED.toString() + \")\";\n+            FilterExpression fltStatusExpression = filterParser.parseFilterExpression(filterByStatus,\n+                    AsyncQuery.class, false);\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.getActiveAsyncQueryCollection(fltStatusExpression);\n+\n+            Set<UUID> runningTransactions = runningTransactionMap.keySet();\n+\n+            Set<UUID> asyncTransactions = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(query.getUpdatedOn().getTime()\n+                    - new Date(System.currentTimeMillis()).getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(AsyncQuery::getRequestId)\n+            .collect(Collectors.toSet());\n+\n+            Set<UUID> queriesToCancel = Sets.intersection(runningTransactions, asyncTransactions);\n+\n+            List<String> asyncQueryList = new ArrayList<String>();\n+            queriesToCancel.stream()\n+               .forEach((tx) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(tx), null, queryParams,\n+                           tx, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(tx).cancel(scope);\n+                   List<String> cancelledQuery = asyncQueryCollection.stream().filter(query", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1OTA3Nw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467259077", "body": "The DAO will be more usable if we don't tie down the contract with constraints like limiting the status to QUEUED, PROCESSING, etc.\r\n\r\nThis can just be a load method that takes a filter expression.  Let the calling code determine what states or other bits to filter on.", "bodyText": "The DAO will be more usable if we don't tie down the contract with constraints like limiting the status to QUEUED, PROCESSING, etc.\nThis can just be a load method that takes a filter expression.  Let the calling code determine what states or other bits to filter on.", "bodyHTML": "<p dir=\"auto\">The DAO will be more usable if we don't tie down the contract with constraints like limiting the status to QUEUED, PROCESSING, etc.</p>\n<p dir=\"auto\">This can just be a load method that takes a filter expression.  Let the calling code determine what states or other bits to filter on.</p>", "author": "aklish", "createdAt": "2020-08-07T20:41:03Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryDAO.java", "diffHunk": "@@ -48,7 +49,14 @@ public AsyncQuery updateAsyncQueryResult(AsyncQueryResult asyncQueryResult,\n      * @param status status to be updated\n      * @return query object list updated\n      */\n-    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(String filterExpression,\n+    public Collection<AsyncQuery> updateStatusAsyncQueryCollection(FilterExpression filterExpression,\n             QueryStatus status);\n+    /**\n+     * This method gets a collection of AsyncQuery and objects from database with status QUEUED/PROCESSING/CANCELLED and\n+     * returns the objects.\n+     * @param filterExpression filter expression to cancel AsyncQuery Objects based on\n+     * @return query object list updated\n+     */\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression);", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI1OTQ0Mw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467259443", "body": "Change the name to reflect this is a simple loadQueries or something.", "bodyText": "Change the name to reflect this is a simple loadQueries or something.", "bodyHTML": "<p dir=\"auto\">Change the name to reflect this is a simple loadQueries or something.</p>", "author": "aklish", "createdAt": "2020-08-07T20:42:05Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DefaultAsyncQueryDAO.java", "diffHunk": "@@ -195,4 +183,29 @@ protected Object executeInTransaction(DataStore dataStore, Transactional action)\n         }\n         return result;\n     }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<AsyncQuery> getActiveAsyncQueryCollection(FilterExpression filterExpression) {", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MzExNA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467263114", "body": "I feel like these tests don't test too much of the code that was added.\r\n\r\nWe have all this set interaction between running transactions and transactions that exist in the database.  We ought to be testing (with unit tests):\r\n\r\n1. Async queries in the database that are COMPLETE, CANCEL_COMPLETE are skipped.\r\n2. Only the async queries that reflect running queries in the transaction registry are canceled.\r\n3. Queries that exceed their runtime are canceled (but only if they are in the transaction registry).\r\n4. Queries that didn't exceed their runtime are not canceled.\r\n\r\nThat's not an exhaustive test - but that will verify the functionality works as we expect.  \r\n\r\n1. ", "bodyText": "I feel like these tests don't test too much of the code that was added.\nWe have all this set interaction between running transactions and transactions that exist in the database.  We ought to be testing (with unit tests):\n\nAsync queries in the database that are COMPLETE, CANCEL_COMPLETE are skipped.\nOnly the async queries that reflect running queries in the transaction registry are canceled.\nQueries that exceed their runtime are canceled (but only if they are in the transaction registry).\nQueries that didn't exceed their runtime are not canceled.\n\nThat's not an exhaustive test - but that will verify the functionality works as we expect.", "bodyHTML": "<p dir=\"auto\">I feel like these tests don't test too much of the code that was added.</p>\n<p dir=\"auto\">We have all this set interaction between running transactions and transactions that exist in the database.  We ought to be testing (with unit tests):</p>\n<ol dir=\"auto\">\n<li>Async queries in the database that are COMPLETE, CANCEL_COMPLETE are skipped.</li>\n<li>Only the async queries that reflect running queries in the transaction registry are canceled.</li>\n<li>Queries that exceed their runtime are canceled (but only if they are in the transaction registry).</li>\n<li>Queries that didn't exceed their runtime are not canceled.</li>\n</ol>\n<p dir=\"auto\">That's not an exhaustive test - but that will verify the functionality works as we expect.</p>\n<ol dir=\"auto\">\n<li></li>\n</ol>", "author": "aklish", "createdAt": "2020-08-07T20:51:42Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.RSQLFilterDialect;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        EntityDictionary dictionary = mock(EntityDictionary.class);\n+        RSQLFilterDialect filterParser = mock(RSQLFilterDialect.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao, dictionary, filterParser);\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testCancelAsyncQuery() {\n+        cancelThread.cancelAsyncQuery();\n+        verify(asyncQueryDao, times(1)).getActiveAsyncQueryCollection(any());", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2MzkxMw==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r467263913", "body": "Similar to my above comment - stronger tests would have a list of mock queries with different conditions of staleness - and we verify that:\r\n\r\n1. the ones we expect to be canceled are canceled\r\n2. the ones that we expect to be deleted are deleted\r\n3. the ones we expect to be ignored are ignored.", "bodyText": "Similar to my above comment - stronger tests would have a list of mock queries with different conditions of staleness - and we verify that:\n\nthe ones we expect to be canceled are canceled\nthe ones that we expect to be deleted are deleted\nthe ones we expect to be ignored are ignored.", "bodyHTML": "<p dir=\"auto\">Similar to my above comment - stronger tests would have a list of mock queries with different conditions of staleness - and we verify that:</p>\n<ol dir=\"auto\">\n<li>the ones we expect to be canceled are canceled</li>\n<li>the ones that we expect to be deleted are deleted</li>\n<li>the ones we expect to be ignored are ignored.</li>\n</ol>", "author": "aklish", "createdAt": "2020-08-07T20:53:39Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -59,14 +62,12 @@ public void testAsyncQueryCleanerThreadSet() {\n     @Test\n     public void testDeleteAsyncQuery() {\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(any());", "originalCommit": "16b3a1ca2610c51646fcccd4f77efb0f007ebd91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "url": "https://github.com/yahoo/elide/commit/bf389d9adc585b3dab7f42b19b253eeea50f2ea5", "message": "cherry pick from CARBON-100 branch", "committedDate": "2020-08-14T04:41:43Z", "type": "commit"}, {"oid": "97133d3528bd57fedab66cdccd54df59bcf805d3", "url": "https://github.com/yahoo/elide/commit/97133d3528bd57fedab66cdccd54df59bcf805d3", "message": "Merge branch 'elide-5.x' of github.com:yahoo/elide into cancel_async", "committedDate": "2020-08-14T15:33:16Z", "type": "commit"}, {"oid": "663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "url": "https://github.com/yahoo/elide/commit/663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "message": "tested in example app", "committedDate": "2020-08-14T18:15:34Z", "type": "commit"}, {"oid": "663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "url": "https://github.com/yahoo/elide/commit/663dd9e68e2a935c53a30cf2118d0d44cef6ff0e", "message": "tested in example app", "committedDate": "2020-08-14T18:15:34Z", "type": "forcePushed"}, {"oid": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "url": "https://github.com/yahoo/elide/commit/f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "message": "codacy", "committedDate": "2020-08-14T19:01:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NTQxNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471055416", "body": "This variable is not used any more, can be removed. ", "bodyText": "This variable is not used any more, can be removed.", "bodyHTML": "<p dir=\"auto\">This variable is not used any more, can be removed.</p>", "author": "moizarafat", "createdAt": "2020-08-16T02:25:16Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncCleanerService.java", "diffHunk": "@@ -44,28 +43,38 @@ private AsyncCleanerService(Elide elide, Integer maxRunTimeMinutes, Integer quer\n         // Since there will be multiple hosts running the elide service,\n         // setting up random delays to avoid all of them trying to cleanup at the same time.\n         Random random = new Random();\n-        int initialDelayMinutes = random.ints(0, maxCleanupInitialDelayMinutes).limit(1).findFirst().getAsInt();\n+        int initialDelayMinutes = random.ints(0, maxInitialDelayMinutes).limit(1).findFirst().getAsInt();", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA1NjI1Mg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471056252", "body": "may be we should store transactionRegistry.getRunningTransaction(uuid) in a variable and check for null before calling cancel. ", "bodyText": "may be we should store transactionRegistry.getRunningTransaction(uuid) in a variable and check for null before calling cancel.", "bodyHTML": "<p dir=\"auto\">may be we should store transactionRegistry.getRunningTransaction(uuid) in a variable and check for null before calling cancel.</p>", "author": "moizarafat", "createdAt": "2020-08-16T02:37:35Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/AsyncQueryCancelThread.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static com.yahoo.elide.core.EntityDictionary.NO_VERSION;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.Path.PathElement;\n+import com.yahoo.elide.core.RequestScope;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.filter.InPredicate;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.jsonapi.models.JsonApiDocument;\n+\n+import com.google.common.collect.Sets;\n+\n+import lombok.AllArgsConstructor;\n+import lombok.Data;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedHashMap;\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+/**\n+ * Runnable thread for cancelling AsyncQuery transactions\n+ * beyond the max run time or if it has status CANCELLED.\n+ */\n+@Slf4j\n+@Data\n+@AllArgsConstructor\n+public class AsyncQueryCancelThread implements Runnable {\n+\n+    private int maxRunTimeSeconds;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+\n+    @Override\n+    public void run() {\n+        cancelAsyncQuery();\n+    }\n+\n+    /**\n+     * This method cancels queries based on threshold.\n+     */\n+    protected void cancelAsyncQuery() {\n+\n+        try {\n+            TransactionRegistry transactionRegistry = elide.getTransactionRegistry();\n+\n+            Map<UUID, DataStoreTransaction> runningTransactionMap = transactionRegistry.getRunningTransactions();\n+\n+            //Running transaction UUIDs\n+            Set<UUID> runningTransactionUUIDs = runningTransactionMap.keySet();\n+\n+            //Construct filter expression\n+            PathElement statusPathElement = new PathElement(AsyncQuery.class, QueryStatus.class, \"status\");\n+            List<QueryStatus> statusList = new ArrayList<QueryStatus>();\n+            statusList.add(QueryStatus.CANCELLED);\n+            statusList.add(QueryStatus.PROCESSING);\n+            statusList.add(QueryStatus.QUEUED);\n+            FilterExpression fltStatusExpression =\n+                    new InPredicate(statusPathElement, statusList);\n+\n+            Collection<AsyncQuery> asyncQueryCollection =\n+                    asyncQueryDao.loadAsyncQueryCollection(fltStatusExpression);\n+\n+            //Active AsyncQuery UUIDs\n+            Set<UUID> asyncTransactionUUIDs = asyncQueryCollection.stream()\n+                    .filter(query -> query.getStatus() == QueryStatus.CANCELLED\n+                    || TimeUnit.SECONDS.convert(Math.abs(new Date(System.currentTimeMillis()).getTime()\n+                            - query.getCreatedOn().getTime()), TimeUnit.MILLISECONDS) > maxRunTimeSeconds)\n+                    .map(query -> UUID.fromString(query.getRequestId()))\n+            .collect(Collectors.toSet());\n+\n+            //AsyncQuery UUIDs that have active transactions\n+            Set<UUID> queryUUIDsToCancel = Sets.intersection(runningTransactionUUIDs, asyncTransactionUUIDs);\n+\n+            //AsyncQuery IDs that need to be cancelled\n+            Set<String> queryIDsToCancel = queryUUIDsToCancel.stream()\n+            .map(uuid -> {\n+                return asyncQueryCollection.stream()\n+                .filter(query -> query.getRequestId().equals(uuid.toString()))\n+                .map(AsyncQuery::getId)\n+                .findFirst().orElseThrow(IllegalStateException::new);\n+            })\n+            .collect(Collectors.toSet());\n+\n+            //Cancel Transactions\n+            queryUUIDsToCancel.stream()\n+               .forEach((uuid) -> {\n+                   JsonApiDocument jsonApiDoc = new JsonApiDocument();\n+                   MultivaluedMap<String, String> queryParams = new MultivaluedHashMap<String, String>();\n+                   RequestScope scope = new RequestScope(\"\", \"query\", NO_VERSION, jsonApiDoc,\n+                           transactionRegistry.getRunningTransaction(uuid), null, queryParams,\n+                           uuid, elide.getElideSettings());\n+                   transactionRegistry.getRunningTransaction(uuid).cancel(scope);", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIxMjc0NQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r471212745", "body": "maxRunTimeMinutes is not needed any more", "bodyText": "maxRunTimeMinutes is not needed any more", "bodyHTML": "<p dir=\"auto\">maxRunTimeMinutes is not needed any more</p>", "author": "moizarafat", "createdAt": "2020-08-17T03:23:07Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -18,6 +18,11 @@\n      */\n     private int threadPoolSize = 5;\n \n+    /**\n+     * Default max query run time.\n+     */\n+    private int maxRunTimeSeconds = 3600;\n+\n     /**\n      * Default max query run time.", "originalCommit": "f4a1928e0ab2efc46f327dd2c8b188c2959e0457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "437643db56fb4437b39b2962f90f413f1a9a73df", "url": "https://github.com/yahoo/elide/commit/437643db56fb4437b39b2962f90f413f1a9a73df", "message": "fixes", "committedDate": "2020-08-17T18:54:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MjUzOQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474172539", "body": "Any reason not to make this public?", "bodyText": "Any reason not to make this public?", "bodyHTML": "<p dir=\"auto\">Any reason not to make this public?</p>", "author": "aklish", "createdAt": "2020-08-20T18:00:25Z", "path": "elide-async/src/main/java/com/yahoo/elide/async/service/DateUtil.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+\n+package com.yahoo.elide.async.service;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+/**\n+ * Utility class which implements a static method calculateFilterDate.\n+ */\n+@Slf4j\n+public class DateUtil {\n+\n+    /**\n+     * Calculated and subtracts the amount based on the calendar unit and amount from current date.\n+     * @param calendarUnit Enum such as Calendar.DATE or Calendar.MINUTE\n+     * @param amount Amount of days to be subtracted from current time\n+     * @return filter date\n+     */\n+     protected static Date calculateFilterDate(int calendarUnit, int amount) {", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MTAxOA==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474181018", "body": "You could also verify the status argument here.", "bodyText": "You could also verify the status argument here.", "bodyHTML": "<p dir=\"auto\">You could also verify the status argument here.</p>", "author": "aklish", "createdAt": "2020-08-20T18:16:15Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MzY1Mg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474183652", "body": "Can we verify the load statement as well?", "bodyText": "Can we verify the load statement as well?", "bodyHTML": "<p dir=\"auto\">Can we verify the load statement as well?</p>", "author": "aklish", "createdAt": "2020-08-20T18:21:08Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4MzgxMQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474183811", "body": "Can we verify the updateStatus statement as well?", "bodyText": "Can we verify the updateStatus statement as well?", "bodyHTML": "<p dir=\"auto\">Can we verify the updateStatus statement as well?</p>", "author": "aklish", "createdAt": "2020-08-20T18:21:28Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+    }\n+\n+    @Test\n+    public void testStatusBasedFilter() throws ParseException {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf826d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.CANCEL_COMPLETE);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.CANCELLED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.PROCESSING);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NDE3MQ==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474184171", "body": "Verify the status.", "bodyText": "Verify the status.", "bodyHTML": "<p dir=\"auto\">Verify the status.</p>", "author": "aklish", "createdAt": "2020-08-20T18:22:09Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCancelThreadTest.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020, Yahoo Inc.\n+ * Licensed under the Apache License, Version 2.0\n+ * See LICENSE file in project root for terms.\n+ */\n+package com.yahoo.elide.async.service;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.yahoo.elide.Elide;\n+import com.yahoo.elide.ElideSettingsBuilder;\n+import com.yahoo.elide.async.models.AsyncQuery;\n+import com.yahoo.elide.async.models.QueryStatus;\n+import com.yahoo.elide.core.DataStoreTransaction;\n+import com.yahoo.elide.core.EntityDictionary;\n+import com.yahoo.elide.core.TransactionRegistry;\n+import com.yahoo.elide.core.datastore.inmemory.HashMapDataStore;\n+import com.yahoo.elide.core.filter.dialect.ParseException;\n+import com.yahoo.elide.core.filter.expression.FilterExpression;\n+import com.yahoo.elide.security.checks.Check;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TimeZone;\n+import java.util.UUID;\n+\n+public class AsyncQueryCancelThreadTest {\n+\n+    private AsyncQueryCancelThread cancelThread;\n+    private Elide elide;\n+    private AsyncQueryDAO asyncQueryDao;\n+    private TransactionRegistry transactionRegistry;\n+\n+    @BeforeEach\n+    public void setupMocks() {\n+        HashMapDataStore inMemoryStore = new HashMapDataStore(AsyncQuery.class.getPackage());\n+        Map<String, Class<? extends Check>> checkMappings = new HashMap<>();\n+\n+        elide = new Elide(\n+                new ElideSettingsBuilder(inMemoryStore)\n+                        .withEntityDictionary(new EntityDictionary(checkMappings))\n+                        .withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"))\n+                        .build());\n+\n+        asyncQueryDao = mock(DefaultAsyncQueryDAO.class);\n+        cancelThread = new AsyncQueryCancelThread(7, elide, asyncQueryDao);\n+        transactionRegistry = elide.getTransactionRegistry();\n+\n+    }\n+\n+    @Test\n+    public void testAsyncQueryCancelThreadSet() {\n+        assertEquals(elide, cancelThread.getElide());\n+        assertEquals(asyncQueryDao, cancelThread.getAsyncQueryDao());\n+        assertEquals(7, cancelThread.getMaxRunTimeSeconds());\n+    }\n+\n+    @Test\n+    public void testActiveTransactionCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());\n+        assertEquals(\"asyncQuery.id IN [[edc4a871-dff2-4054-804e-d80075cf828d]]\", filterCaptor.getValue().toString());\n+    }\n+\n+    @Test\n+    public void testStatusBasedFilter() throws ParseException {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf826d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                1577883600000L, QueryStatus.CANCEL_COMPLETE);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.CANCELLED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.PROCESSING);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> fltStatusCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).loadAsyncQueryCollection(fltStatusCaptor.capture());\n+        assertEquals(\"asyncQuery.status IN [[CANCELLED, PROCESSING, QUEUED]]\", fltStatusCaptor.getValue().toString());\n+\n+    }\n+\n+    @Test\n+    public void testTimeBasedCancellation() {\n+        DataStoreTransaction dtx = elide.getDataStore().beginTransaction();\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf828d\"), dtx);\n+        transactionRegistry.addRunningTransaction(UUID.fromString(\"edc4a871-dff2-4054-804e-d80075cf827d\"), dtx);\n+        AsyncQuery asyncQuery1 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf828d\",\n+                System.currentTimeMillis(), QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery2 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf827d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        AsyncQuery asyncQuery3 = createAsyncQueryTestObject(\"edc4a871-dff2-4054-804e-d80075cf826d\",\n+                1577883600000L, QueryStatus.QUEUED);\n+        Collection<AsyncQuery> asyncCollection = new ArrayList<AsyncQuery>();\n+        asyncCollection.add(asyncQuery1);\n+        asyncCollection.add(asyncQuery2);\n+        asyncCollection.add(asyncQuery3);\n+        when(cancelThread.getAsyncQueryDao().loadAsyncQueryCollection(any())).thenReturn(asyncCollection);\n+        cancelThread.cancelAsyncQuery();\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any());", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NTUwNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474185506", "body": "It's possible for this test to fail because of a 1ms gap between when this date is calculated and when the delete filter is generated.   We'll need to find a less brittle approach.", "bodyText": "It's possible for this test to fail because of a 1ms gap between when this date is calculated and when the delete filter is generated.   We'll need to find a less brittle approach.", "bodyHTML": "<p dir=\"auto\">It's possible for this test to fail because of a 1ms gap between when this date is calculated and when the delete filter is generated.   We'll need to find a less brittle approach.</p>", "author": "aklish", "createdAt": "2020-08-20T18:24:38Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -58,15 +59,19 @@ public void testAsyncQueryCleanerThreadSet() {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n+        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE4NTcwNg==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474185706", "body": "Same comment on date.", "bodyText": "Same comment on date.", "bodyHTML": "<p dir=\"auto\">Same comment on date.</p>", "author": "aklish", "createdAt": "2020-08-20T18:25:00Z", "path": "elide-async/src/test/java/com/yahoo/elide/async/service/AsyncQueryCleanerThreadTest.java", "diffHunk": "@@ -58,15 +59,19 @@ public void testAsyncQueryCleanerThreadSet() {\n \n     @Test\n     public void testDeleteAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.deleteAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(anyString());\n+        verify(asyncQueryDao, times(1)).deleteAsyncQueryAndResultCollection(filterCaptor.capture());\n+        Long date = System.currentTimeMillis() - (cleanerThread.getQueryCleanupDays() * 24 * 3600 * 1000);\n+        assertEquals(\"asyncQuery.createdOn LE [\" + new Date(date) + \"]\", filterCaptor.getValue().toString());\n     }\n \n     @Test\n-    public void timeoutAsyncQuery() {\n+    public void testTimeoutAsyncQuery() {\n+        ArgumentCaptor<FilterExpression> filterCaptor = ArgumentCaptor.forClass(FilterExpression.class);\n         cleanerThread.timeoutAsyncQuery();\n-\n-        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(anyString(), any(QueryStatus.class));\n+        verify(asyncQueryDao, times(1)).updateStatusAsyncQueryCollection(filterCaptor.capture(), any(QueryStatus.class));\n+        Long date = System.currentTimeMillis() - (cleanerThread.getMaxRunTimeMinutes() * 60 * 1000);", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5MTc0Ng==", "url": "https://github.com/yahoo/elide/pull/1447#discussion_r474191746", "body": "The other comment for standalone was:\r\n\"Number of seconds between async query cancellation checks.\"\r\n\r\nLet's use the same comment for both standalone and spring and maybe change to:\r\n\"Polling interval to identify async queries that should be canceled.\"\r\n\r\nAlso, 300 seconds is way too long for this interval.  It should probably be somewhere in the 1-10 second range by default.  \r\n", "bodyText": "The other comment for standalone was:\n\"Number of seconds between async query cancellation checks.\"\nLet's use the same comment for both standalone and spring and maybe change to:\n\"Polling interval to identify async queries that should be canceled.\"\nAlso, 300 seconds is way too long for this interval.  It should probably be somewhere in the 1-10 second range by default.", "bodyHTML": "<p dir=\"auto\">The other comment for standalone was:<br>\n\"Number of seconds between async query cancellation checks.\"</p>\n<p dir=\"auto\">Let's use the same comment for both standalone and spring and maybe change to:<br>\n\"Polling interval to identify async queries that should be canceled.\"</p>\n<p dir=\"auto\">Also, 300 seconds is way too long for this interval.  It should probably be somewhere in the 1-10 second range by default.</p>", "author": "aklish", "createdAt": "2020-08-20T18:35:44Z", "path": "elide-spring/elide-spring-boot-autoconfigure/src/main/java/com/yahoo/elide/spring/config/AsyncProperties.java", "diffHunk": "@@ -33,6 +33,12 @@\n      */\n     private int queryCleanupDays = 7;\n \n+    /**\n+     * Default time interval for cancelling async query transactions", "originalCommit": "437643db56fb4437b39b2962f90f413f1a9a73df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "69559cc16e21e5695342be7f6660384aa5eeae9c", "url": "https://github.com/yahoo/elide/commit/69559cc16e21e5695342be7f6660384aa5eeae9c", "message": "mocking date util, and extra verifications for unit tests", "committedDate": "2020-08-20T20:46:07Z", "type": "commit"}]}