{"pr_number": 2568, "pr_title": "6203: Remove status code check in XXE, extract Local File Reflection and Local File Inclusion", "pr_author": "ejayaraman", "pr_createdAt": "2020-10-11T13:44:44Z", "pr_url": "https://github.com/zaproxy/zap-extensions/pull/2568", "merge_commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985622", "body": "Remove, no longer necessary.", "bodyText": "Remove, no longer necessary.", "bodyHTML": "<p dir=\"auto\">Remove, no longer necessary.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:11:10Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDU0OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820548", "bodyText": "Updated.", "author": "ejayaraman", "createdAt": "2020-10-15T20:29:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985643", "body": "Go for it \ud83d\ude00 ", "bodyText": "Go for it \ud83d\ude00", "bodyHTML": "<p dir=\"auto\">Go for it <g-emoji class=\"g-emoji\" alias=\"grinning\" fallback-src=\"https://github.githubassets.com/images/icons/emoji/unicode/1f600.png\">\ud83d\ude00</g-emoji></p>", "author": "kingthorin", "createdAt": "2020-10-12T00:11:26Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDczNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820734", "bodyText": "Doc comments included.", "author": "ejayaraman", "createdAt": "2020-10-15T20:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985735", "body": "The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.", "bodyText": "The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.", "bodyHTML": "<p dir=\"auto\">The blank and comment can be removed, it's in a separate method now, it obviously related to LFI.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:12:09Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzI3Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823272", "bodyText": "This has been updated.", "author": "ejayaraman", "createdAt": "2020-10-15T20:33:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgxNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985817", "body": "These blanks and comment are no longer necessary.", "bodyText": "These blanks and comment are no longer necessary.", "bodyHTML": "<p dir=\"auto\">These blanks and comment are no longer necessary.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:12:52Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985824", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:12:59Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzc0OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505823748", "bodyText": "This is the one I forgot to remove. I can push another commit for this.", "author": "ejayaraman", "createdAt": "2020-10-15T20:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTg4Nw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985887", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Check if the scan has been stopped</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> if yes dispose resources and exit</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:13:33Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -290,16 +274,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             log.warn(\n                     \"XXE Injection vulnerability check failed for payload [\"\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,103 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -290,16 +268,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             log.warn(\n                     \"XXE Injection vulnerability check failed for payload [\"\n", "next_change": {"commit": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..1c6f6e921 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -274,9 +274,8 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 1c6f6e921..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -241,42 +241,44 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     }\n \n     /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     * Local File Reflection Attack initially substitutes every attribute in the original XML\n+     * request with a fake entity which includes a sensitive local file. The attack is repeated for\n+     * every file listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found. If no alert is raised, then\n+     * the process is repeated by replacing one attribute at a time, for a fixed number of\n+     * attributes depending on the strength of the rule.\n      *\n      * @param msg new HttpMessage with the same request as the base. This is used to build the\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTkwNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985905", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">                    </span><span class=\"pl-c\"><span class=\"pl-c x\">//</span><span class=\"x x-last\"> Dispose all resources</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:13:42Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -290,16 +274,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             log.warn(\n                     \"XXE Injection vulnerability check failed for payload [\"\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,103 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -290,16 +268,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             log.warn(\n                     \"XXE Injection vulnerability check failed for payload [\"\n", "next_change": {"commit": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..1c6f6e921 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -274,9 +274,8 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 1c6f6e921..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -241,42 +241,44 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     }\n \n     /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     * Local File Reflection Attack initially substitutes every attribute in the original XML\n+     * request with a fake entity which includes a sensitive local file. The attack is repeated for\n+     * every file listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found. If no alert is raised, then\n+     * the process is repeated by replacing one attribute at a time, for a fixed number of\n+     * attributes depending on the strength of the rule.\n      *\n      * @param msg new HttpMessage with the same request as the base. This is used to build the\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502985962", "body": "Go for it.", "bodyText": "Go for it.", "bodyHTML": "<p dir=\"auto\">Go for it.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:14:00Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDE1NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824155", "bodyText": "Doc comments added.", "author": "ejayaraman", "createdAt": "2020-10-15T20:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NTk2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,27 +287,30 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -312,7 +311,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,29 +281,31 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": null}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986021", "body": "Can be private. Will explain further while commenting on the other class.", "bodyText": "Can be private. Will explain further while commenting on the other class.", "bodyHTML": "<p dir=\"auto\">Can be private. Will explain further while commenting on the other class.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:14:37Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyNDY1OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505824659", "bodyText": "This is private now, as the tests are using the scan() method.", "author": "ejayaraman", "createdAt": "2020-10-15T20:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjAyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -245,42 +235,36 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -266,7 +266,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -229,60 +222,45 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n             localFileReflectionAttack(getNewMsg());\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n             if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n                 return;\n             }\n \n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n+                return;\n+            }\n+\n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n             localFileInclusionAttack(getNewMsg());\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileReflectionAttack(HttpMessage msg) {\n-        Matcher matcher;\n-        String localFile;\n-        String response;\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(requestBody, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..81c41e7dc 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,31 +254,38 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n     private void localFileReflectionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n+            // First replace the values in all the Elements by the Attack Entity\n+            String originalRequestBody = msg.getRequestBody().toString();\n+            String requestBody = createLfrPayload(originalRequestBody);\n+            if (localFileReflectionTest(msg, requestBody, payload)) {\n+                return;\n+            }\n+            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+            // fixed number of Elements, depending on the strength at which the rule is used.\n+\n+            // Remove original xml header\n+            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+            int maxValuesChanged = 0;\n+\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+                maxValuesChanged = Integer.MAX_VALUE;\n+            }\n+            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+                if (localFileReflectionTest(msg, requestBody, payload)) {\n                     return;\n                 }\n             }\n         } catch (IOException ex) {\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 81c41e7dc..b318fadbe 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -252,41 +252,33 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n      *     attack payload.\n      */\n     private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            // First replace the values in all the Elements by the Attack Entity\n-            String originalRequestBody = msg.getRequestBody().toString();\n-            String requestBody = createLfrPayload(originalRequestBody);\n-            if (localFileReflectionTest(msg, requestBody, payload)) {\n-                return;\n-            }\n-            // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n-            // fixed number of Elements, depending on the strength at which the rule is used.\n-\n-            // Remove original xml header\n-            Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n-            String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n-            int maxValuesChanged = 0;\n+        // First replace the values in all the Elements by the Attack Entity\n+        String originalRequestBody = msg.getRequestBody().toString();\n+        String requestBody = createLfrPayload(originalRequestBody);\n+        if (localFileReflectionTest(msg, requestBody)) {\n+            return;\n+        }\n+        // Now if no issue is found yet, then we replace the values one at a time. Do this for a\n+        // fixed number of Elements, depending on the strength at which the rule is used.\n \n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n-                maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n-                maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n-            } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n-                maxValuesChanged = Integer.MAX_VALUE;\n-            }\n-            Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n-            for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n-                requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n-                if (localFileReflectionTest(msg, requestBody, payload)) {\n-                    return;\n-                }\n+        // Remove original xml header\n+        Matcher headerMatcher = xmlHeaderPattern.matcher(originalRequestBody);\n+        String headerlessRequestBody = headerMatcher.replaceAll(\"\");\n+        int maxValuesChanged = 0;\n+\n+        if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            maxValuesChanged = 72 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.HIGH) {\n+            maxValuesChanged = 144 / LOCAL_FILE_TARGETS.length;\n+        } else if (this.getAttackStrength() == AttackStrength.INSANE) {\n+            maxValuesChanged = Integer.MAX_VALUE;\n+        }\n+        Matcher tagMatcher = tagPattern.matcher(headerlessRequestBody);\n+        for (int tagIdx = 1; (tagIdx <= maxValuesChanged) && tagMatcher.find(); tagIdx++) {\n+            requestBody = createTagSpecificLfrPayload(headerlessRequestBody, tagMatcher);\n+            if (localFileReflectionTest(msg, requestBody)) {\n+                return;\n             }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n-                    payload,\n-                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE2Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986166", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // msg = getNewMsg();", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">                </span><span class=\"pl-c\"><span class=\"pl-c x\">//</span><span class=\"x x-last\"> msg = getNewMsg();</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:15:24Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,27 +287,30 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -312,7 +311,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,29 +281,31 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": null}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjE4Mw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986183", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Send message with local file inclusion", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Send message with local file inclusion</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:15:36Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,27 +287,30 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -312,7 +311,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,29 +281,31 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": null}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIxNg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986216", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Parse the result", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Parse the result</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:15:50Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,27 +287,30 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -312,7 +311,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,29 +281,31 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": null}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986227", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:15:57Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODgzMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505828831", "bodyText": "And another one to remove.", "author": "ejayaraman", "createdAt": "2020-10-15T20:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjIyNw=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,27 +287,30 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n \n                     newAlert()\n", "next_change": {"commit": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..f10eda1f8 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -312,7 +311,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 String response = msg.getResponseBody().toString();\n                 Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex f10eda1f8..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,101 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -309,29 +281,31 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    // TODO: Add Doc Comments\n-    protected void localFileInclusionAttack(HttpMessage msg) {\n-        String localFile;\n-        String response;\n-        Matcher matcher;\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n         String payload = null;\n         try {\n             for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                // Prepare the message\n-                localFile = LOCAL_FILE_TARGETS[idx];\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n                 payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                // msg = getNewMsg();\n                 msg.setRequestBody(payload);\n-\n-                // Send message with local file inclusion\n                 sendAndReceive(msg);\n-\n-                // Parse the result\n-\n-                response = msg.getResponseBody().toString();\n-                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n                 if (matcher.find()) {\n-\n                     newAlert()\n                             .setConfidence(Alert.CONFIDENCE_MEDIUM)\n                             .setAttack(payload)\n", "next_change": null}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI3OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986278", "body": "```suggestion\r\n                // Check if the scan has been stopped\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                            // Check if the scan has been stopped\n          \n          \n            \n                            // if yes dispose resources and exit\n          \n          \n            \n                            // Check if the scan has been stopped", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Check if the scan has been stopped</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> if yes dispose resources and exit</span></td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                <span class=\"pl-c\"><span class=\"pl-c\">//</span> Check if the scan has been stopped</span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:16:17Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +320,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,103 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +313,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..1c6f6e921 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -321,9 +320,8 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 1c6f6e921..f73f4b0c6 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -326,66 +366,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    /**\n-     * Notification for a successful rule execution\n-     *\n-     * @param challenge the challenge callback that has been used\n-     * @param targetMessage the original message sent to the target containing the callback\n-     */\n-    @Override\n-    public void notifyCallback(String challenge, HttpMessage targetMessage) {\n-        if (challenge != null) {\n-\n-            String evidence = callbackImplementor.getCallbackUrl(challenge);\n-\n-            newAlert()\n-                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                    .setAttack(getCallbackAttackPayload(challenge))\n-                    .setEvidence(evidence)\n-                    .setMessage(targetMessage)\n-                    .raise();\n-        }\n-    }\n-\n-    private String getCallbackAttackPayload(String challenge) {\n-        String message = ATTACK_HEADER + ATTACK_BODY;\n-        return MessageFormat.format(message, callbackImplementor.getCallbackUrl(challenge));\n-    }\n-\n-    /**\n-     * Get a randomly built string with exactly lenght chars\n-     *\n-     * @param length the number of chars of this string\n-     * @return a string element containing exactly \"lenght\" characters\n-     */\n-    private String randomString(int length) {\n-        SecureRandom rand = new SecureRandom();\n-        StringBuilder result = new StringBuilder(length);\n-        String alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-        for (int i = 0; i < length; i++) {\n-            result.append(alphabet.charAt(rand.nextInt(alphabet.length())));\n-        }\n-\n-        return result.toString();\n-    }\n-\n-    /**\n-     * Only for use in unit tests\n-     *\n-     * @param extCallback\n-     */\n-    protected void setExtensionCallback(ExtensionCallback extCallback) {\n-        ChallengeCallbackImplementor.setExtensionCallback(extCallback);\n-    }\n-\n-    protected static void unload() {\n-        if (ChallengeCallbackImplementor.getExtensionCallback() != null) {\n-            ChallengeCallbackImplementor.getExtensionCallback()\n-                    .removeCallbackImplementor(callbackImplementor);\n-        }\n-    }\n-\n     static String createLfrPayload(String requestBody) {\n         StringBuilder sb = new StringBuilder(ATTACK_HEADER);\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjI4OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986289", "body": "```suggestion\r\n```", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Dispose all resources", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"><span class=\"x x-first\">                    </span><span class=\"pl-c\"><span class=\"pl-c x\">//</span><span class=\"x x-last\"> Dispose all resources</span></span></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:16:26Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +320,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,103 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +313,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..1c6f6e921 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -321,9 +320,8 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 1c6f6e921..f73f4b0c6 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -326,66 +366,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    /**\n-     * Notification for a successful rule execution\n-     *\n-     * @param challenge the challenge callback that has been used\n-     * @param targetMessage the original message sent to the target containing the callback\n-     */\n-    @Override\n-    public void notifyCallback(String challenge, HttpMessage targetMessage) {\n-        if (challenge != null) {\n-\n-            String evidence = callbackImplementor.getCallbackUrl(challenge);\n-\n-            newAlert()\n-                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                    .setAttack(getCallbackAttackPayload(challenge))\n-                    .setEvidence(evidence)\n-                    .setMessage(targetMessage)\n-                    .raise();\n-        }\n-    }\n-\n-    private String getCallbackAttackPayload(String challenge) {\n-        String message = ATTACK_HEADER + ATTACK_BODY;\n-        return MessageFormat.format(message, callbackImplementor.getCallbackUrl(challenge));\n-    }\n-\n-    /**\n-     * Get a randomly built string with exactly lenght chars\n-     *\n-     * @param length the number of chars of this string\n-     * @return a string element containing exactly \"lenght\" characters\n-     */\n-    private String randomString(int length) {\n-        SecureRandom rand = new SecureRandom();\n-        StringBuilder result = new StringBuilder(length);\n-        String alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-        for (int i = 0; i < length; i++) {\n-            result.append(alphabet.charAt(rand.nextInt(alphabet.length())));\n-        }\n-\n-        return result.toString();\n-    }\n-\n-    /**\n-     * Only for use in unit tests\n-     *\n-     * @param extCallback\n-     */\n-    protected void setExtensionCallback(ExtensionCallback extCallback) {\n-        ChallengeCallbackImplementor.setExtensionCallback(extCallback);\n-    }\n-\n-    protected static void unload() {\n-        if (ChallengeCallbackImplementor.getExtensionCallback() != null) {\n-            ChallengeCallbackImplementor.getExtensionCallback()\n-                    .removeCallbackImplementor(callbackImplementor);\n-        }\n-    }\n-\n     static String createLfrPayload(String requestBody) {\n         StringBuilder sb = new StringBuilder(ATTACK_HEADER);\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjMyNA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986324", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:16:46Z", "path": "addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java", "diffHunk": "@@ -304,57 +254,109 @@ public void scan() {\n             // only in case of a bare XML parser which execute the conetnt and then\n             // gives it back almost untouched (maybe because it applies an XSLT or\n             // query it using XPath and give back the result).\n-            msg = getNewMsg();\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n-\n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    // TODO: Add Doc Comments\n+    protected void localFileReflectionAttack(HttpMessage msg) {\n+        Matcher matcher;\n+        String localFile;\n+        String response;\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n                 }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n             }\n+\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n+\n+    // TODO: Add Doc Comments\n+    protected void localFileInclusionAttack(HttpMessage msg) {\n+        String localFile;\n+        String response;\n+        Matcher matcher;\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                // Prepare the message\n+                localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                // msg = getNewMsg();\n+                msg.setRequestBody(payload);\n+\n+                // Send message with local file inclusion\n+                sendAndReceive(msg);\n+\n+                // Parse the result\n+\n+                response = msg.getResponseBody().toString();\n+                matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+\n+                // Check if the scan has been stopped\n+                // if yes dispose resources and exit\n+                if (isStop()) {\n+                    // Dispose all resources\n+                    // Exit the rule\n+                    return;\n+                }\n+            }\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..b1e8fab8f 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +320,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex b1e8fab8f..03d09b13d 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -235,103 +288,66 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                 return;\n             }\n \n-            // Exit if the scan has been stopped\n-            if (isStop()) {\n-                return;\n-            }\n-\n             // Check #3 : XXE Local File Inclusion Attack\n-            localFileInclusionAttack(getNewMsg());\n-        }\n-    }\n+            // ------------------------------------------------------\n+            // This attack is described in\n+            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n+            // trying to include a local file and maybe have the inclusion back in\n+            // the result page. This situation is very uncommon because it works\n+            // only in case of a bare XML parser which execute the conetnt and then\n+            // gives it back almost untouched (maybe because it applies an XSLT or\n+            // query it using XPath and give back the result).\n+            msg = getNewMsg();\n+\n+            try {\n+                String localFile;\n+                String response;\n+                Matcher matcher;\n+\n+                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                    // Prepare the message\n+                    localFile = LOCAL_FILE_TARGETS[idx];\n+                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                    // msg = getNewMsg();\n+                    msg.setRequestBody(payload);\n \n-    /**\n-     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n-     * fake entity which includes a sensitive local file. The attack is repeated for every file\n-     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n-     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileReflectionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(requestBody, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n-        }\n-    }\n+                    // Send message with local file inclusion\n+                    sendAndReceive(msg);\n \n-    /**\n-     * Local File Inclusion Attack is described in\n-     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n-     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n-     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n-     * alert is raised when a match is found.\n-     *\n-     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n-     * execute the content and then returns the content almost untouched (maybe because it applies\n-     * an XSLT or query it using XPath and give back the result)\n-     *\n-     * @param msg new HttpMessage with the same request as the base. This is used to build the\n-     *     attack payload.\n-     */\n-    private void localFileInclusionAttack(HttpMessage msg) {\n-        String payload = null;\n-        try {\n-            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                String localFile = LOCAL_FILE_TARGETS[idx];\n-                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                msg.setRequestBody(payload);\n-                sendAndReceive(msg);\n-                String response = msg.getResponseBody().toString();\n-                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                if (matcher.find()) {\n-\n-                    newAlert()\n-                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                            .setAttack(payload)\n-                            .setEvidence(matcher.group())\n-                            .setMessage(msg)\n-                            .raise();\n-                }\n-                if (isStop()) {\n-                    return;\n+                    // Parse the result\n+                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n+\n+                        response = msg.getResponseBody().toString();\n+                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                        if (matcher.find()) {\n+\n+                            newAlert()\n+                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                                    .setAttack(payload)\n+                                    .setEvidence(matcher.group())\n+                                    .setMessage(msg)\n+                                    .raise();\n+                        }\n+                    }\n+\n+                    // Check if the scan has been stopped\n+                    // if yes dispose resources and exit\n+                    if (isStop()) {\n+                        // Dispose all resources\n+                        // Exit the rule\n+                        return;\n+                    }\n                 }\n+\n+            } catch (IOException ex) {\n+                // Do not try to internationalise this.. we need an error message in any event..\n+                // if it's in English, it's still better than not having it at all.\n+                log.warn(\n+                        \"XXE Injection vulnerability check failed for payload [\"\n+                                + payload\n+                                + \"] due to an I/O error\",\n+                        ex);\n             }\n-        } catch (IOException ex) {\n-            // Do not try to internationalise this.. we need an error message in any event..\n-            // if it's in English, it's still better than not having it at all.\n-            log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n-                    ex);\n         }\n     }\n \n", "next_change": {"commit": "f06a9bb670792320ea21f2536832a87344616516", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 03d09b13d..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -223,131 +222,109 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             }\n \n             // Check #2 : XXE Local File Reflection Attack\n-            // ------------------------------------------------------\n-            // This attack is not described anywhere but the idea is\n-            // very simple: use the original XML request and substitute\n-            // every content and attribute with a fake entity which\n-            // include a sensitive local file. If the page goes in error\n-            // or reflect and manage the sent content you can probably\n-            // have the file included in the HTML page and you can check it\n-            //\n-            msg = getNewMsg();\n-\n-            try {\n-                Matcher matcher;\n-                String localFile;\n-                String response;\n-                String requestBody = createLfrPayload(msg.getRequestBody().toString());\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(requestBody, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileReflectionAttack(getNewMsg());\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n-                }\n-\n-            } catch (IOException ex) {\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+            // Check if we've to do only medium sized analysis\n+            // (only remote and reflected will be done)\n+            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+                return;\n             }\n \n-            // Check if we've to do only medium sized analysis (only remote and reflected will be\n-            // done)...\n-            if (this.getAttackStrength() == AttackStrength.MEDIUM) {\n+            // Exit if the scan has been stopped\n+            if (isStop()) {\n                 return;\n             }\n \n             // Check #3 : XXE Local File Inclusion Attack\n-            // ------------------------------------------------------\n-            // This attack is described in\n-            // https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing\n-            // trying to include a local file and maybe have the inclusion back in\n-            // the result page. This situation is very uncommon because it works\n-            // only in case of a bare XML parser which execute the conetnt and then\n-            // gives it back almost untouched (maybe because it applies an XSLT or\n-            // query it using XPath and give back the result).\n-            msg = getNewMsg();\n-\n-            try {\n-                String localFile;\n-                String response;\n-                Matcher matcher;\n-\n-                for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n-                    // Prepare the message\n-                    localFile = LOCAL_FILE_TARGETS[idx];\n-                    payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n-                    // msg = getNewMsg();\n-                    msg.setRequestBody(payload);\n-\n-                    // Send message with local file inclusion\n-                    sendAndReceive(msg);\n+            localFileInclusionAttack(getNewMsg());\n+        }\n+    }\n \n-                    // Parse the result\n-                    if (msg.getResponseHeader().getStatusCode() == HttpStatusCode.OK) {\n-\n-                        response = msg.getResponseBody().toString();\n-                        matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n-                        if (matcher.find()) {\n-\n-                            newAlert()\n-                                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                                    .setAttack(payload)\n-                                    .setEvidence(matcher.group())\n-                                    .setMessage(msg)\n-                                    .raise();\n-                        }\n-                    }\n-\n-                    // Check if the scan has been stopped\n-                    // if yes dispose resources and exit\n-                    if (isStop()) {\n-                        // Dispose all resources\n-                        // Exit the rule\n-                        return;\n-                    }\n+    /**\n+     * Local File Reflection Attack substitutes every attribute in the original XML request with a\n+     * fake entity which includes a sensitive local file. The attack is repeated for every file\n+     * listed in the LOCAL_FILE_TARGETS. The response returned is pattern matched against\n+     * LOCAL_FILE_PATTERNS. An alert is raised when a match is found.\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileReflectionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            String requestBody = createLfrPayload(msg.getRequestBody().toString());\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(requestBody, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n                 }\n+            }\n+        } catch (IOException ex) {\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n+        }\n+    }\n \n-            } catch (IOException ex) {\n-                // Do not try to internationalise this.. we need an error message in any event..\n-                // if it's in English, it's still better than not having it at all.\n-                log.warn(\n-                        \"XXE Injection vulnerability check failed for payload [\"\n-                                + payload\n-                                + \"] due to an I/O error\",\n-                        ex);\n+    /**\n+     * Local File Inclusion Attack is described in\n+     * https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing. The\n+     * attack builds a payload for every file listed in LOCAL_FILE_TARGETS with the ATTACK_HEADER\n+     * and the ATTACK_BODY. The response returned is pattern matched against LOCAL_FILE_PATTERNS. An\n+     * alert is raised when a match is found.\n+     *\n+     * <p>This situation is very uncommon because it works only in case of a bare XML parser which\n+     * execute the content and then returns the content almost untouched (maybe because it applies\n+     * an XSLT or query it using XPath and give back the result)\n+     *\n+     * @param msg new HttpMessage with the same request as the base. This is used to build the\n+     *     attack payload.\n+     */\n+    private void localFileInclusionAttack(HttpMessage msg) {\n+        String payload = null;\n+        try {\n+            for (int idx = 0; idx < LOCAL_FILE_TARGETS.length; idx++) {\n+                String localFile = LOCAL_FILE_TARGETS[idx];\n+                payload = MessageFormat.format(ATTACK_HEADER + ATTACK_BODY, localFile);\n+                msg.setRequestBody(payload);\n+                sendAndReceive(msg);\n+                String response = msg.getResponseBody().toString();\n+                Matcher matcher = LOCAL_FILE_PATTERNS[idx].matcher(response);\n+                if (matcher.find()) {\n+                    newAlert()\n+                            .setConfidence(Alert.CONFIDENCE_MEDIUM)\n+                            .setAttack(payload)\n+                            .setEvidence(matcher.group())\n+                            .setMessage(msg)\n+                            .raise();\n+                }\n+                if (isStop()) {\n+                    return;\n+                }\n             }\n+        } catch (IOException ex) {\n+            // Do not try to internationalise this.. we need an error message in any event..\n+            // if it's in English, it's still better than not having it at all.\n+            log.warn(\n+                    \"XXE Injection vulnerability check failed for payload [\"\n+                            + payload\n+                            + \"] due to an I/O error\",\n+                    ex);\n         }\n     }\n \n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 3caffad8c..32ed1cb61 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -339,16 +313,10 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n                             .setMessage(msg)\n                             .raise();\n                 }\n-\n-                // Check if the scan has been stopped\n-                // if yes dispose resources and exit\n                 if (isStop()) {\n-                    // Dispose all resources\n-                    // Exit the rule\n                     return;\n                 }\n             }\n-\n         } catch (IOException ex) {\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n", "next_change": {"commit": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 32ed1cb61..1c6f6e921 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -321,9 +320,8 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n             // Do not try to internationalise this.. we need an error message in any event..\n             // if it's in English, it's still better than not having it at all.\n             log.warn(\n-                    \"XXE Injection vulnerability check failed for payload [\"\n-                            + payload\n-                            + \"] due to an I/O error\",\n+                    \"XXE Injection vulnerability check failed for payload [{}] due to an I/O error\",\n+                    payload,\n                     ex);\n         }\n     }\n", "next_change": {"commit": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\nindex 1c6f6e921..f73f4b0c6 100644\n--- a/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n+++ b/addOns/ascanrulesBeta/src/main/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRule.java\n", "chunk": "@@ -326,66 +366,6 @@ public class XxeScanRule extends AbstractAppPlugin implements ChallengeCallbackP\n         }\n     }\n \n-    /**\n-     * Notification for a successful rule execution\n-     *\n-     * @param challenge the challenge callback that has been used\n-     * @param targetMessage the original message sent to the target containing the callback\n-     */\n-    @Override\n-    public void notifyCallback(String challenge, HttpMessage targetMessage) {\n-        if (challenge != null) {\n-\n-            String evidence = callbackImplementor.getCallbackUrl(challenge);\n-\n-            newAlert()\n-                    .setConfidence(Alert.CONFIDENCE_MEDIUM)\n-                    .setAttack(getCallbackAttackPayload(challenge))\n-                    .setEvidence(evidence)\n-                    .setMessage(targetMessage)\n-                    .raise();\n-        }\n-    }\n-\n-    private String getCallbackAttackPayload(String challenge) {\n-        String message = ATTACK_HEADER + ATTACK_BODY;\n-        return MessageFormat.format(message, callbackImplementor.getCallbackUrl(challenge));\n-    }\n-\n-    /**\n-     * Get a randomly built string with exactly lenght chars\n-     *\n-     * @param length the number of chars of this string\n-     * @return a string element containing exactly \"lenght\" characters\n-     */\n-    private String randomString(int length) {\n-        SecureRandom rand = new SecureRandom();\n-        StringBuilder result = new StringBuilder(length);\n-        String alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-        for (int i = 0; i < length; i++) {\n-            result.append(alphabet.charAt(rand.nextInt(alphabet.length())));\n-        }\n-\n-        return result.toString();\n-    }\n-\n-    /**\n-     * Only for use in unit tests\n-     *\n-     * @param extCallback\n-     */\n-    protected void setExtensionCallback(ExtensionCallback extCallback) {\n-        ChallengeCallbackImplementor.setExtensionCallback(extCallback);\n-    }\n-\n-    protected static void unload() {\n-        if (ChallengeCallbackImplementor.getExtensionCallback() != null) {\n-            ChallengeCallbackImplementor.getExtensionCallback()\n-                    .removeCallbackImplementor(callbackImplementor);\n-        }\n-    }\n-\n     static String createLfrPayload(String requestBody) {\n         StringBuilder sb = new StringBuilder(ATTACK_HEADER);\n \n", "next_change": null}]}}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "d07b0adbccba07c2a8bca9026e5e9c2c583a7e90", "committedDate": "2021-03-03 13:27:06 -0500", "message": "ascanrulesBeta: Use Log4j 2.x"}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "2a84d9bfd97bbd5d778a1f04941de6b79bd55a8a", "committedDate": "2021-04-30 11:26:36 -0400", "message": "fix: SAST Items"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "a656d9677902917787569271081fa5d6e74068c0", "committedDate": "2021-12-04 19:14:30 +0530", "message": "ascanrulesBeta: Update XxeScanRule to use OAST payloads"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986478", "body": "This seems to be used over and over again, It may as well be extracted to a local method, such as `createNanoHandler`. Then just used as `this.nano.addHandler(createHandler());`", "bodyText": "This seems to be used over and over again, It may as well be extracted to a local method, such as createNanoHandler. Then just used as this.nano.addHandler(createHandler());", "bodyHTML": "<p dir=\"auto\">This seems to be used over and over again, It may as well be extracted to a local method, such as <code>createNanoHandler</code>. Then just used as <code>this.nano.addHandler(createHandler());</code></p>", "author": "kingthorin", "createdAt": "2020-10-12T00:18:14Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxMzkyMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505813922", "bodyText": "A local method has been created: createNanoHandler", "author": "ejayaraman", "createdAt": "2020-10-15T20:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjQ3OA=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU0NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986545", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:18:57Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU2Mg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986562", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:19:06Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjU4Ng==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986586", "body": "```suggestion\r\n```", "bodyText": "Suggested change", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\"></td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n", "author": "kingthorin", "createdAt": "2020-10-12T00:19:19Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986700", "body": "The blanks leading `// When` and `// Then` throughout can be removed, the comments already delineate things.", "bodyText": "The blanks leading // When and // Then throughout can be removed, the comments already delineate things.", "bodyHTML": "<p dir=\"auto\">The blanks leading <code>// When</code> and <code>// Then</code> throughout can be removed, the comments already delineate things.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:20:06Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDEwMQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814101", "bodyText": "This has been removed now.", "author": "ejayaraman", "createdAt": "2020-10-15T20:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NjcwMA=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502986845", "body": "Is this an intentional mismatch?", "bodyText": "Is this an intentional mismatch?", "bodyHTML": "<p dir=\"auto\">Is this an intentional mismatch?</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:21:25Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDM4OA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814388", "bodyText": "yes, it is. I have added a comment in the test to explain this mismatch.", "author": "ejayaraman", "createdAt": "2020-10-15T20:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4Njg0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987235", "body": "Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.\r\n\r\nHowever, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).", "bodyText": "Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.\nHowever, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).", "bodyHTML": "<p dir=\"auto\">Throughout the new tests the scan method should be used. That ensures none of the payloads are misinterpreted.</p>\n<p dir=\"auto\">However, having the two test methods broken out in the scan rule allows for earlier troubleshooting and maintenance in the future so that was a worthy change (IMHO).</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:24:51Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDYyMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814623", "bodyText": "Tests have been updated to use the scan method.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzIzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987351", "body": "The number of messages sent should already be being tested as part of the generalized Strength tests.\r\n\r\nEdit: So I believe this one can be removed.", "bodyText": "The number of messages sent should already be being tested as part of the generalized Strength tests.\nEdit: So I believe this one can be removed.", "bodyHTML": "<p dir=\"auto\">The number of messages sent should already be being tested as part of the generalized Strength tests.</p>\n<p dir=\"auto\">Edit: So I believe this one can be removed.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:25:38Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDc5NQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814795", "bodyText": "This has been removed.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,157 +121,50 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n-    }\n-\n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileReflectionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n", "next_change": {"commit": "066facf27086e008e3a12b132577937c88073360", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..4f9ceb082 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -171,7 +227,7 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+    void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n             throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502987737", "body": "```suggestion\r\n        Alert alert = alertsRaised.get(0);\r\n        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\r\n        assertThat(\r\n                alert.getAttack(),\r\n                equalTo(\r\n                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\r\n                                + XxeScanRule.ATTACK_BODY));\r\n        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\r\n        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\r\n```\r\n\r\nThis likely applies elsewhere as well.", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alertsRaised.get(0).getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n          \n            \n                    Alert alert = alertsRaised.get(0);\n          \n          \n            \n                    assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                            alert.getAttack(),\n          \n          \n            \n                            equalTo(\n          \n          \n            \n                                    MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n          \n          \n            \n                                            + XxeScanRule.ATTACK_BODY));\n          \n          \n            \n                    assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n          \n          \n            \n                    assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n          \n      \n    \n    \n  \n\nThis likely applies elsewhere as well.", "bodyHTML": "  <div class=\"my-2 border rounded-1 js-suggested-changes-blob diff-view js-check-bidi\" id=\"\">\n    <div class=\"f6 p-2 lh-condensed border-bottom d-flex\">\n      <div class=\"flex-auto flex-items-center color-fg-muted\">\n        Suggested change\n        <span class=\"tooltipped tooltipped-multiline tooltipped-s\" aria-label=\"This code change can be committed by users with write permissions.\">\n          <svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" data-view-component=\"true\" class=\"octicon octicon-info hide-sm\">\n    <path fill-rule=\"evenodd\" d=\"M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm6.5-.25A.75.75 0 017.25 7h1a.75.75 0 01.75.75v2.75h.25a.75.75 0 010 1.5h-2a.75.75 0 010-1.5h.25v-2h-.25a.75.75 0 01-.75-.75zM8 6a1 1 0 100-2 1 1 0 000 2z\"></path>\n</svg>\n        </span>\n      </div>\n    </div>\n    <div itemprop=\"text\" class=\"blob-wrapper data file\" style=\"margin: 0; border: none; overflow-y: visible; overflow-x: auto;\">\n      <table class=\"d-table tab-size mb-0 width-full\" data-paste-markdown-skip=\"\">\n          <tbody><tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        assertThat(alertsRaised<span class=\"pl-k\">.</span>get(<span class=\"pl-c1\">0</span>)<span class=\"pl-k\">.</span>getEvidence(), equalTo(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>root:*:0:0<span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        assertThat(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                alertsRaised<span class=\"pl-k\">.</span>get(<span class=\"pl-c1\">0</span>)<span class=\"pl-k\">.</span>getAttack(),</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                equalTo(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                        <span class=\"pl-smi\">MessageFormat</span><span class=\"pl-k\">.</span>format(<span class=\"pl-smi\">XxeScanRule</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>ATTACK_HEADER</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file:///etc/passwd<span class=\"pl-pds\">\"</span></span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">                                <span class=\"pl-k\">+</span> <span class=\"pl-smi\">XxeScanRule</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>ATTACK_BODY</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        assertThat(alertsRaised<span class=\"pl-k\">.</span>get(<span class=\"pl-c1\">0</span>)<span class=\"pl-k\">.</span>getRisk(), equalTo(<span class=\"pl-smi\">Alert</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>RISK_HIGH</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-deletion text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-deletion js-blob-code-deletion blob-code-marker-deletion\">        assertThat(alertsRaised<span class=\"pl-k\">.</span>get(<span class=\"pl-c1\">0</span>)<span class=\"pl-k\">.</span>getConfidence(), equalTo(<span class=\"pl-smi\">Alert</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>CONFIDENCE_MEDIUM</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        <span class=\"pl-smi\">Alert</span> alert <span class=\"pl-k\">=</span> alertsRaised<span class=\"pl-k\">.</span>get(<span class=\"pl-c1\">0</span>);</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(alert<span class=\"pl-k\">.</span>getEvidence(), equalTo(<span class=\"pl-s\"><span class=\"pl-pds\">\"</span>root:*:0:0<span class=\"pl-pds\">\"</span></span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                alert<span class=\"pl-k\">.</span>getAttack(),</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                equalTo(</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                        <span class=\"pl-smi\">MessageFormat</span><span class=\"pl-k\">.</span>format(<span class=\"pl-smi\">XxeScanRule</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>ATTACK_HEADER</span>, <span class=\"pl-s\"><span class=\"pl-pds\">\"</span>file:///etc/passwd<span class=\"pl-pds\">\"</span></span>)</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">                                <span class=\"pl-k\">+</span> <span class=\"pl-smi\">XxeScanRule</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>ATTACK_BODY</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(alert<span class=\"pl-k\">.</span>getRisk(), equalTo(<span class=\"pl-smi\">Alert</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>RISK_HIGH</span>));</td>\n          </tr>\n          <tr class=\"border-0\">\n            <td class=\"blob-num blob-num-addition text-right border-0 px-2 py-1 lh-default\" data-line-number=\"\"></td>\n            <td class=\"border-0 px-2 py-1 blob-code-inner blob-code-addition js-blob-code-addition blob-code-marker-addition\">        assertThat(alert<span class=\"pl-k\">.</span>getConfidence(), equalTo(<span class=\"pl-smi\">Alert</span><span class=\"pl-c1\"><span class=\"pl-k\">.</span>CONFIDENCE_MEDIUM</span>));</td>\n          </tr>\n      </tbody></table>\n    </div>\n    <div class=\"js-apply-changes\"></div>\n  </div>\n\n<p dir=\"auto\">This likely applies elsewhere as well.</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:28:27Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgxNDk4MQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505814981", "bodyText": "This has been updated as well.", "author": "ejayaraman", "createdAt": "2020-10-15T20:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4NzczNw=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -289,65 +172,48 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..14205e6fa 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -216,4 +343,17 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n         return msg;\n     }\n+\n+    private static String getXmlResource(String fileName) {\n+        try {\n+            String xmlString =\n+                    FileUtils.readFileToString(\n+                            new File(XxeScanRuleUnitTest.class.getResource(fileName).getFile()),\n+                            \"UTF-8\");\n+            return xmlString;\n+        } catch (IOException e) {\n+            System.err.println(\"Failed to read file \" + fileName);\n+            throw new RuntimeException(e);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r502988269", "body": "This test is an interesting idea, however, I'm not sure it'll behave properly if When is `rule.scan` and `parent.stop()` was issued in Given.\r\n@thc202? @psiinon?", "bodyText": "This test is an interesting idea, however, I'm not sure it'll behave properly if When is rule.scan and parent.stop() was issued in Given.\n@thc202? @psiinon?", "bodyHTML": "<p dir=\"auto\">This test is an interesting idea, however, I'm not sure it'll behave properly if When is <code>rule.scan</code> and <code>parent.stop()</code> was issued in Given.<br>\n<a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/thc202/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/thc202\">@thc202</a>? <a class=\"user-mention\" data-hovercard-type=\"user\" data-hovercard-url=\"/users/psiinon/hovercard\" data-octo-click=\"hovercard-link-click\" data-octo-dimensions=\"link_type:self\" href=\"https://github.com/psiinon\">@psiinon</a>?</p>", "author": "kingthorin", "createdAt": "2020-10-12T00:32:56Z", "path": "addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java", "diffHunk": "@@ -121,4 +129,225 @@ public void replaceMultipleElementsAndRemoveHeader() {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.scan();\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + \"<comment><text>&zapxxe;</text></comment>\"));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileReflectionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }\n+\n+    @Test\n+    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(3));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n+                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(alertsRaised.size(), equalTo(1));\n+        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(\n+                alertsRaised.get(0).getAttack(),\n+                equalTo(\n+                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                                + XxeScanRule.ATTACK_BODY));\n+        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @Test\n+    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n+        // Given\n+        String test = \"/test\";\n+        this.nano.addHandler(\n+                new NanoServerHandler(test) {\n+                    @Override\n+                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                        consumeBody(session);\n+                        String response =\n+                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+                        return newFixedLengthResponse(\n+                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n+                    }\n+                });\n+        HttpMessage msg = this.getHttpMessage(test);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        parent.stop();\n+        rule.init(msg, parent);\n+\n+        // When\n+        rule.localFileInclusionAttack(msg);\n+\n+        // Then\n+        assertThat(countMessagesSent, equalTo(1));\n+    }", "originalCommit": "28af3c43d0f33b370234833a162f0cd8827601f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMDIxMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r505820210", "bodyText": "This test did started failing after using rule.scan(), but not sure if it is for the same reason you had in mind. The reason it started failing for me was: since localFileInclusionAttack and localFileReflectionAttack has been moved to its own methods, return, when parent.stop() is true, exits only that method and not the scan itself. So I have added another check within the scan() method between attacks to stop scanning when parent.stop() is invoked. This fixed the test.", "author": "ejayaraman", "createdAt": "2020-10-15T20:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MDQzMw==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510250433", "bodyText": "I'm not sure we should add it as is, if the scanner is already stopped the scan rule would not have been called (it could happen immediately after but it's less likely than when actually running), better to test that the stop is respected by stopping while running (i.e. in the several loops that it might have).", "author": "thc202", "createdAt": "2020-10-22T15:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1MzAxOA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510253018", "bodyText": "This is probably something that can be added as part of the common tests.", "author": "thc202", "createdAt": "2020-10-22T15:25:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI1NTIwMg==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510255202", "bodyText": "For the time being lets just leave the stop testing out for now. It would be nice to get this done/in. Stop testing will require further unrelated changes.", "author": "kingthorin", "createdAt": "2020-10-22T15:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NDUwMA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r510954500", "bodyText": "Sure. Will remove this test.", "author": "ejayaraman", "createdAt": "2020-10-23T15:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MDQ4MA==", "url": "https://github.com/zaproxy/zap-extensions/pull/2568#discussion_r513790480", "bodyText": "This test has been removed.", "author": "ejayaraman", "createdAt": "2020-10-28T22:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4ODI2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..2d6b47f41 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -131,223 +121,111 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n     }\n \n     @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws Exception {\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         rule.init(msg, parent);\n-\n         // When\n         rule.scan();\n-\n         // Then\n         assertThat(countMessagesSent, equalTo(0));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileReflectionRule() throws Exception {\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @ParameterizedTest\n     @EnumSource(\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + \"<comment><text>&zapxxe;</text></comment>\"));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n     @Test\n-    public void shouldStopLocalFileReflectionRuleIfScanIsStopped() throws Exception {\n+    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n         // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        HttpMessage msg = getXmlPostMessage(\"/test\");\n         parent.stop();\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileReflectionAttack(msg);\n-\n+        rule.scan();\n         // Then\n         assertThat(countMessagesSent, equalTo(1));\n     }\n \n-    @Test\n-    public void shouldSendThreeMessagesForLocalFileInclusionRule() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(3));\n+    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n     }\n \n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 2d6b47f41..aa45d8635 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -119,113 +106,4 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n-\n-    @Test\n-    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = this.getHttpMessage(\"/test\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n-        // The mismatch in request body and content-type is intentional.\n-        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n-        // send a message converting the XML body into an attack payload.\n-        // This may not happen, if the request body is not XML.\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(0));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                        + \"<comment><text>&zapxxe;</text></comment>\";\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @ParameterizedTest\n-    @EnumSource(\n-            value = NanoHTTPD.Response.Status.class,\n-            names = {\"OK\", \"BAD_REQUEST\"})\n-    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws HttpMalformedHeaderException {\n-        // Given\n-        String test = \"/test\";\n-        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n-        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n-        HttpMessage msg = getXmlPostMessage(test);\n-        rule.init(msg, parent);\n-        // When\n-        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.scan();\n-        // Then\n-        String localFileInclusionAttackPayload =\n-                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n-                        + XxeScanRule.ATTACK_BODY;\n-        List<Alert> alertList =\n-                alertsRaised.stream()\n-                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n-                        .collect(Collectors.toList());\n-        assertThat(alertList.size(), equalTo(1));\n-        Alert alert = alertList.get(0);\n-        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n-        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n-    }\n-\n-    @Test\n-    public void shouldStopScanIfScanIsStopped() throws HttpMalformedHeaderException {\n-        // Given\n-        HttpMessage msg = getXmlPostMessage(\"/test\");\n-        parent.stop();\n-        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n-        rule.init(msg, parent);\n-        // When\n-        rule.scan();\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n-    }\n-\n-    private NanoServerHandler createNanoHandler(String path, IStatus status, String responseBody) {\n-        return new NanoServerHandler(path) {\n-            @Override\n-            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                consumeBody(session);\n-                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n-            }\n-        };\n-    }\n-\n-    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n-        HttpMessage msg = this.getHttpMessage(path);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        return msg;\n-    }\n }\n", "next_change": {"commit": "380a0995ce8dd79e5596ae680e57849d85e5f447", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex aa45d8635..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -106,4 +119,101 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n                         + \"</comments>\";\n         assertThat(payload, is(expectedPayload));\n     }\n+\n+    @Test\n+    public void shouldScanOnlyIfRequestContentTypeIsXml() throws HttpMalformedHeaderException {\n+        // Given\n+        HttpMessage msg = this.getHttpMessage(\"/test\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/json\");\n+        // The mismatch in request body and content-type is intentional.\n+        // For any reason if the rule fails to check the Content-Type, then createLfrPayload() will\n+        // send a message converting the XML body into an attack payload.\n+        // This may not happen, if the request body is not XML.\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        assertThat(countMessagesSent, equalTo(0));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileReflectedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n+                        + \"<comment><text>&zapxxe;</text></comment>\";\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"root:*:0:0\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    @ParameterizedTest\n+    @EnumSource(\n+            value = NanoHTTPD.Response.Status.class,\n+            names = {\"OK\", \"BAD_REQUEST\"})\n+    public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n+            throws HttpMalformedHeaderException {\n+        // Given\n+        String test = \"/test\";\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n+        rule.init(msg, parent);\n+        // When\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n+        // Then\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+    }\n+\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n+        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n+        msg.getRequestHeader().setMethod(\"POST\");\n+        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        return msg;\n+    }\n }\n", "next_change": null}]}}]}}]}, "revised_code_in_main": {"commit": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex f41bdcfec..18eca0e2c 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -289,65 +172,48 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n             value = NanoHTTPD.Response.Status.class,\n             names = {\"OK\", \"BAD_REQUEST\"})\n     public void shouldAlertWhenLocalFileIncludedInResponse(NanoHTTPD.Response.Status status)\n-            throws Exception {\n+            throws HttpMalformedHeaderException {\n         // Given\n         String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response = \"root:*:0:0:System Administrator:/var/root:/bin/sh\";\n-                        return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n-        msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n-        msg.getRequestHeader().setMethod(\"POST\");\n-        msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n+        String responseBody = \"[drivers]\\n\" + \"wave=mmdrv.dll\";\n+        this.nano.addHandler(createNanoHandler(test, status, responseBody));\n+        HttpMessage msg = getXmlPostMessage(test);\n         rule.init(msg, parent);\n-\n         // When\n-        rule.localFileInclusionAttack(msg);\n-\n+        // Local File Inclusion Attacks is triggered only when AttackStrength is > Medium\n+        rule.setAttackStrength(Plugin.AttackStrength.HIGH);\n+        rule.scan();\n         // Then\n-        assertThat(alertsRaised.size(), equalTo(1));\n-        assertThat(alertsRaised.get(0).getEvidence(), equalTo(\"root:*:0:0\"));\n-        assertThat(\n-                alertsRaised.get(0).getAttack(),\n-                equalTo(\n-                        MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///etc/passwd\")\n-                                + XxeScanRule.ATTACK_BODY));\n-        assertThat(alertsRaised.get(0).getRisk(), equalTo(Alert.RISK_HIGH));\n-        assertThat(alertsRaised.get(0).getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n+        String localFileInclusionAttackPayload =\n+                MessageFormat.format(XxeScanRule.ATTACK_HEADER, \"file:///c:/Windows/system.ini\")\n+                        + XxeScanRule.ATTACK_BODY;\n+        List<Alert> alertList =\n+                alertsRaised.stream()\n+                        .filter(alert -> alert.getAttack().equals(localFileInclusionAttackPayload))\n+                        .collect(Collectors.toList());\n+        assertThat(alertList.size(), equalTo(1));\n+        Alert alert = alertList.get(0);\n+        assertThat(alert.getEvidence(), equalTo(\"[drivers]\"));\n+        assertThat(alert.getRisk(), equalTo(Alert.RISK_HIGH));\n+        assertThat(alert.getConfidence(), equalTo(Alert.CONFIDENCE_MEDIUM));\n     }\n \n-    @Test\n-    public void shouldStopLocalFileInclusionRuleIfScanIsStopped() throws Exception {\n-        // Given\n-        String test = \"/test\";\n-        this.nano.addHandler(\n-                new NanoServerHandler(test) {\n-                    @Override\n-                    protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n-                        consumeBody(session);\n-                        String response =\n-                                \"<foo>root:*:0:0:System Administrator:/var/root:/bin/sh</foo>\";\n-                        return newFixedLengthResponse(\n-                                NanoHTTPD.Response.Status.OK, NanoHTTPD.MIME_PLAINTEXT, response);\n-                    }\n-                });\n-        HttpMessage msg = this.getHttpMessage(test);\n+    private NanoServerHandler createNanoHandler(\n+            String path, NanoHTTPD.Response.IStatus status, String responseBody) {\n+        return new NanoServerHandler(path) {\n+            @Override\n+            protected NanoHTTPD.Response serve(NanoHTTPD.IHTTPSession session) {\n+                consumeBody(session);\n+                return newFixedLengthResponse(status, NanoHTTPD.MIME_PLAINTEXT, responseBody);\n+            }\n+        };\n+    }\n+\n+    private HttpMessage getXmlPostMessage(String path) throws HttpMalformedHeaderException {\n+        HttpMessage msg = this.getHttpMessage(path);\n         msg.setRequestBody(\"<?xml version=\\\"1.0\\\"?><comment><text>test</text></comment>\");\n         msg.getRequestHeader().setMethod(\"POST\");\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n-        parent.stop();\n-        rule.init(msg, parent);\n-\n-        // When\n-        rule.localFileInclusionAttack(msg);\n-\n-        // Then\n-        assertThat(countMessagesSent, equalTo(1));\n+        return msg;\n     }\n }\n", "next_change": {"commit": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "changed_code": [{"header": "diff --git a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\nindex 18eca0e2c..14205e6fa 100644\n--- a/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n+++ b/addOns/ascanrulesBeta/src/test/java/org/zaproxy/zap/extension/ascanrulesBeta/XxeScanRuleUnitTest.java\n", "chunk": "@@ -216,4 +343,17 @@ public class XxeScanRuleUnitTest extends ActiveScannerTest<XxeScanRule> {\n         msg.getRequestHeader().setHeader(\"Content-Type\", \"application/xml\");\n         return msg;\n     }\n+\n+    private static String getXmlResource(String fileName) {\n+        try {\n+            String xmlString =\n+                    FileUtils.readFileToString(\n+                            new File(XxeScanRuleUnitTest.class.getResource(fileName).getFile()),\n+                            \"UTF-8\");\n+            return xmlString;\n+        } catch (IOException e) {\n+            System.err.println(\"Failed to read file \" + fileName);\n+            throw new RuntimeException(e);\n+        }\n+    }\n }\n", "next_change": null}]}}]}, "commits_in_main": [{"oid": "1c5718680a3ed80fba9f83035ca30f3fcaf9f9b5", "message": "Merge commit", "committedDate": null}, {"oid": "fdbbbc45dc8a898f1f53c7623f65a0d09246e0ca", "committedDate": "2021-04-17 03:57:44 +0530", "message": "Improved the XXE Scan Rule,added tests,resource files and updated the Changelog"}, {"oid": "066facf27086e008e3a12b132577937c88073360", "committedDate": "2021-05-03 13:37:35 -0400", "message": "improve: Unit Test related SAST (sonar) findings"}, {"oid": "a80cb14e6e07f15f8c6ae53e61887ffab9ebd05d", "committedDate": "2021-09-23 20:07:22 +0530", "message": "ascanrulesBeta: Use OAST callbacks"}, {"oid": "67f0aaca92268010a832e0b0d6b5388903c409e9", "committedDate": "2021-10-04 10:06:13 -0400", "message": "improve: ascanrulesBeta: Add Top10 Mappings"}, {"oid": "deb8239567a712c10ba69e2ce6193af3be1f5bb9", "committedDate": "2021-12-05 20:17:34 -0500", "message": "feat: ascanrules all (3): Add WSTG v4.2 alert mappings"}, {"oid": "6f8fd93a61851516fced9e4fdf61c55f4bad4bce", "committedDate": "2021-12-07 19:35:32 +0530", "message": "oast, ascanrulesBeta: Remove usages of CallbackImplementor"}, {"oid": "2d90018b480b838ecd5629cdb82b103cd7223697", "committedDate": "2022-10-21 10:59:34 +0200", "message": "ascanrules: Promotions (#4049)"}]}, {"oid": "10de60d241a1143dc4c3717cb7a0e1bb870823be", "url": "https://github.com/zaproxy/zap-extensions/commit/10de60d241a1143dc4c3717cb7a0e1bb870823be", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-15T20:04:24Z", "type": "forcePushed"}, {"oid": "5a73de1287b5c925621671e7553924fc32dd656a", "url": "https://github.com/zaproxy/zap-extensions/commit/5a73de1287b5c925621671e7553924fc32dd656a", "message": "ISSUE-6203: XXE Scan rule updated to parse response irresspective of status code.\nWhen extension callback is not available only XXE Remote file inclusion attack is skipped.\nAdded unit tests\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-15T20:12:07Z", "type": "forcePushed"}, {"oid": "29cf52d5bc300ca0f5729f0bb599771d725ed344", "url": "https://github.com/zaproxy/zap-extensions/commit/29cf52d5bc300ca0f5729f0bb599771d725ed344", "message": "Removed blank lines.\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-17T13:55:08Z", "type": "forcePushed"}, {"oid": "9229f2da87b2eac652396f84f589a4df857495e7", "url": "https://github.com/zaproxy/zap-extensions/commit/9229f2da87b2eac652396f84f589a4df857495e7", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-10-28T21:16:25Z", "type": "forcePushed"}, {"oid": "6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "url": "https://github.com/zaproxy/zap-extensions/commit/6f1cf427f4b223e3659b6e383ad0a4b8ebe2d5ec", "message": "XML External Entity Attack scan rule changed to skip only Remote File Inclusion Attack when Callback extension is not available\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:27:45Z", "type": "commit"}, {"oid": "380a0995ce8dd79e5596ae680e57849d85e5f447", "url": "https://github.com/zaproxy/zap-extensions/commit/380a0995ce8dd79e5596ae680e57849d85e5f447", "message": "XML External Entity Attack scan rule changed to parse response body irrespective of the HTTP response status code\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "commit"}, {"oid": "f06a9bb670792320ea21f2536832a87344616516", "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "commit"}, {"oid": "f06a9bb670792320ea21f2536832a87344616516", "url": "https://github.com/zaproxy/zap-extensions/commit/f06a9bb670792320ea21f2536832a87344616516", "message": "Refactor XXE Scan Rule to extract Local File Reflection and Local File Inclusion\n\nSigned-off-by: ejayaraman <7340261+ejayaraman@users.noreply.github.com>", "committedDate": "2020-11-09T17:28:10Z", "type": "forcePushed"}]}